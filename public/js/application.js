(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
 * Paper.js v0.9.18 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Mon Apr 7 11:24:38 2014 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2013 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = new function(undefined) {

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,

		forEach = [].forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++)
				iter.call(bind, this[i], i, this);
		},

		forIn = function(iter, bind) {
			for (var i in this)
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
		},

		create = Object.create || function(proto) {
			return { __proto__: proto };
		},

		describe = Object.getOwnPropertyDescriptor || function(obj, name) {
			var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
			return get
					? { get: get, set: obj.__lookupSetter__(name),
						enumerable: true, configurable: true }
					: obj.hasOwnProperty(name)
						? { value: obj[name], enumerable: true,
							configurable: true, writable: true }
						: null;
		},

		_define = Object.defineProperty || function(obj, name, desc) {
			if ((desc.get || desc.set) && obj.__defineGetter__) {
				if (desc.get)
					obj.__defineGetter__(name, desc.get);
				if (desc.set)
					obj.__defineSetter__(name, desc.set);
			} else {
				obj[name] = desc.value;
			}
			return obj;
		},

		define = function(obj, name, desc) {
			delete obj[name];
			return _define(obj, name, desc);
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res))
					res = { value: res, writable: true };
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function each(obj, iter, bind) {
		if (obj)
			('length' in obj && !obj.getLength
					&& typeof obj.length === 'number'
				? forEach
				: forIn).call(obj, iter, bind = bind || obj);
		return bind;
	}

	function set(obj, props) {
		for (var i in props)
			if (props.hasOwnProperty(i))
				obj[i] = props[i];
		return obj;
	}

	return inject(function Base() {
		for (var i = 0, l = arguments.length; i < l; i++)
			set(this, arguments[i]);
	}, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, true, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor;
			for (var i = 0, l = arguments.length; i < l; i++)
				if (ctor = arguments[i].initialize)
					break;
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			ctor.prototype = create(this.prototype);
			ctor.base = base;
			define(ctor.prototype, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this, true);
			return arguments.length ? this.inject.apply(ctor, arguments) : ctor;
		}
	}, true).inject({
		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src)
					inject(this, src, src.enumerable, src.beans, src.preserve);
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			each: each,
			create: create,
			define: define,
			describe: describe,
			set: set,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function() {
				for (var i = 0, l = arguments.length; i < l; i++)
					if (arguments[i] !== undefined)
						return arguments[i];
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

if (!Array.isArray) {
	Array.isArray = function(obj) {
		return Object.prototype.toString.call(obj) === '[object Array]';
	};
}

if (!document.head) {
	document.head = document.getElementsByTagName('head')[0];
}

Base.inject({
	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	_set: function(props, exclude) {
		if (props && Base.isPlainObject(props)) {
			var orig = props._filtering || props;
			for (var key in orig) {
				if (key in this && orig.hasOwnProperty(key)
						&& (!exclude || !exclude[key])) {
					var value = props[key];
					if (value !== undefined)
						this[key] = value;
				}
			}
			return true;
		}
	},

	statics: {

		exports: {
			enumerable: true 
		},

		extend: function extend() {
			var res = extend.base.apply(this, arguments),
				name = res.prototype._class;
			if (name && !Base.exports[name])
				Base.exports[name] = res;
			return res;
		},

		equals: function(obj1, obj2) {
			function checkKeys(o1, o2) {
				for (var i in o1)
					if (o1.hasOwnProperty(i) && !o2.hasOwnProperty(i))
						return false;
				return true;
			}
			if (obj1 === obj2)
				return true;
			if (obj1 && obj1.equals)
				return obj1.equals(obj2);
			if (obj2 && obj2.equals)
				return obj2.equals(obj1);
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				if (obj1.length !== obj2.length)
					return false;
				for (var i = 0, l = obj1.length; i < l; i++) {
					if (!Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			if (obj1 && typeof obj1 === 'object'
					&& obj2 && typeof obj2 === 'object') {
				if (!checkKeys(obj1, obj2) || !checkKeys(obj2, obj1))
					return false;
				for (var i in obj1) {
					if (obj1.hasOwnProperty(i)
							&& !Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			return false;
		},

		read: function(list, start, options, length) {
			if (this === Base) {
				var value = this.peek(list, start);
				list.__index++;
				return value;
			}
			var proto = this.prototype,
				readIndex = proto._readIndex,
				index = start || readIndex && list.__index || 0;
			if (!length)
				length = list.length - index;
			var obj = list[index];
			if (obj instanceof this
				|| options && options.readNull && obj == null && length <= 1) {
				if (readIndex)
					list.__index = index + 1;
				return obj && options && options.clone ? obj.clone() : obj;
			}
			obj = Base.create(this.prototype);
			if (readIndex)
				obj.__read = true;
			obj = obj.initialize.apply(obj, index > 0 || length < list.length
				? Array.prototype.slice.call(list, index, index + length)
				: list) || obj;
			if (readIndex) {
				list.__index = index + obj.__read;
				obj.__read = undefined;
			}
			return obj;
		},

		peek: function(list, start) {
			return list[list.__index = start || list.__index || 0];
		},

		remain: function(list) {
			return list.length - (list.__index || 0);
		},

		readAll: function(list, start, options) {
			var res = [],
				entry;
			for (var i = start || 0, l = list.length; i < l; i++) {
				res.push(Array.isArray(entry = list[i])
						? this.read(entry, 0, options)
						: this.read(list, i, options, 1));
			}
			return res;
		},

		readNamed: function(list, name, start, options, length) {
			var value = this.getNamed(list, name),
				hasObject = value !== undefined;
			if (hasObject) {
				var filtered = list._filtered;
				if (!filtered) {
					filtered = list._filtered = Base.create(list[0]);
					filtered._filtering = list[0];
				}
				filtered[name] = undefined;
			}
			return this.read(hasObject ? [value] : list, start, options, length);
		},

		getNamed: function(list, name) {
			var arg = list[0];
			if (list._hasObject === undefined)
				list._hasObject = list.length === 1 && Base.isPlainObject(arg);
			if (list._hasObject)
				return name ? arg[name] : list._filtered || arg;
		},

		hasNamed: function(list, name) {
			return !!this.getNamed(list, name);
		},

		isPlainValue: function(obj) {
			return this.isPlainObject(obj) || Array.isArray(obj);
		},

		serialize: function(obj, options, compact, dictionary) {
			options = options || {};

			var root = !dictionary,
				res;
			if (root) {
				options.formatter = new Formatter(options.precision);
				dictionary = {
					length: 0,
					definitions: {},
					references: {},
					add: function(item, create) {
						var id = '#' + item._id,
							ref = this.references[id];
						if (!ref) {
							this.length++;
							var res = create.call(item),
								name = item._class;
							if (name && res[0] !== name)
								res.unshift(name);
							this.definitions[id] = res;
							ref = this.references[id] = [id];
						}
						return ref;
					}
				};
			}
			if (obj && obj._serialize) {
				res = obj._serialize(options, dictionary);
				var name = obj._class;
				if (name && !compact && !res._compact && res[0] !== name)
					res.unshift(name);
			} else if (Array.isArray(obj)) {
				res = [];
				for (var i = 0, l = obj.length; i < l; i++)
					res[i] = Base.serialize(obj[i], options, compact,
							dictionary);
				if (compact)
					res._compact = true;
			} else if (Base.isPlainObject(obj)) {
				res = {};
				for (var i in obj)
					if (obj.hasOwnProperty(i))
						res[i] = Base.serialize(obj[i], options, compact,
								dictionary);
			} else if (typeof obj === 'number') {
				res = options.formatter.number(obj, options.precision);
			} else {
				res = obj;
			}
			return root && dictionary.length > 0
					? [['dictionary', dictionary.definitions], res]
					: res;
		},

		deserialize: function(json, create, _data) {
			var res = json,
				isRoot = !_data;
			_data = _data || {};
			if (Array.isArray(json)) {
				var type = json[0],
					isDictionary = type === 'dictionary';
				if (!isDictionary) {
					if (_data.dictionary && json.length == 1 && /^#/.test(type))
						return _data.dictionary[type];
					type = Base.exports[type];
				}
				res = [];
				for (var i = type ? 1 : 0, l = json.length; i < l; i++)
					res.push(Base.deserialize(json[i], create, _data));
				if (isDictionary) {
					_data.dictionary = res[0];
				} else if (type) {
					var args = res;
					if (create) {
						res = create(type, args, isRoot);
					} else {
						res = Base.create(type.prototype);
						type.apply(res, args);
					}
				}
			} else if (Base.isPlainObject(json)) {
				res = {};
				for (var key in json)
					res[key] = Base.deserialize(json[key], create, _data);
			}
			return res;
		},

		exportJSON: function(obj, options) {
			var json = Base.serialize(obj, options);
			return options && options.asString === false
					? json
					: JSON.stringify(json);
		},

		importJSON: function(json, target) {
			return Base.deserialize(
					typeof json === 'string' ? JSON.parse(json) : json,
					function(type, args, isRoot) {
						var obj = target && target.constructor === type
								? target
								: Base.create(type.prototype),
							isTarget = obj === target;
						if (!isRoot && args.length === 1 && obj instanceof Item
								&& (!(obj instanceof Layer) || isTarget)) {
							var arg = args[0];
							if (Base.isPlainObject(arg))
								arg.insert = false;
						}
						type.apply(obj, args);
						if (isTarget)
							target = null;
						return obj;
					});
		},

		splice: function(list, items, index, remove) {
			var amount = items && items.length,
				append = index === undefined;
			index = append ? list.length : index;
			if (index > list.length)
				index = list.length;
			for (var i = 0; i < amount; i++)
				items[i]._index = index + i;
			if (append) {
				list.push.apply(list, items);
				return [];
			} else {
				var args = [index, remove];
				if (items)
					args.push.apply(args, items);
				var removed = list.splice.apply(list, args);
				for (var i = 0, l = removed.length; i < l; i++)
					removed[i]._index = undefined;
				for (var i = index + amount, l = list.length; i < l; i++)
					list[i]._index = i;
				return removed;
			}
		},

		capitalize: function(str) {
			return str.replace(/\b[a-z]/g, function(match) {
				return match.toUpperCase();
			});
		},

		camelize: function(str) {
			return str.replace(/-(.)/g, function(all, chr) {
				return chr.toUpperCase();
			});
		},

		hyphenate: function(str) {
			return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}
	}
});

var Callback = {
	attach: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.attach(key, value);
			}, this);
			return;
		}
		var entry = this._eventTypes[type];
		if (entry) {
			var handlers = this._handlers = this._handlers || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) == -1) { 
				handlers.push(func);
				if (entry.install && handlers.length == 1)
					entry.install.call(this, type);
			}
		}
	},

	detach: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.detach(key, value);
			}, this);
			return;
		}
		var entry = this._eventTypes[type],
			handlers = this._handlers && this._handlers[type],
			index;
		if (entry && handlers) {
			if (!func || (index = handlers.indexOf(func)) != -1
					&& handlers.length == 1) {
				if (entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._handlers[type];
			} else if (index != -1) {
				handlers.splice(index, 1);
			}
		}
	},

	once: function(type, func) {
		this.attach(type, function() {
			func.apply(this, arguments);
			this.detach(type, func);
		});
	},

	fire: function(type, event) {
		var handlers = this._handlers && this._handlers[type];
		if (!handlers)
			return false;
		var args = [].slice.call(arguments, 1),
			that = this;
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(that, args) === false
					&& event && event.stop) {
				event.stop();
				break;
			}
		}
		return true;
	},

	responds: function(type) {
		return !!(this._handlers && this._handlers[type]);
	},

	on: '#attach',
	off: '#detach',
	trigger: '#fire',

	_installEvents: function(install) {
		var handlers = this._handlers,
			key = install ? 'install' : 'uninstall';
		for (var type in handlers) {
			if (handlers[type].length > 0) {
				var entry = this._eventTypes[type],
					func = entry[key];
				if (func)
					func.call(this, type);
			}
		}
	},

	statics: {
		inject: function inject() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i],
					events = src._events;
				if (events) {
					var types = {};
					Base.each(events, function(entry, key) {
						var isString = typeof entry === 'string',
							name = isString ? entry : key,
							part = Base.capitalize(name),
							type = name.substring(2).toLowerCase();
						types[type] = isString ? {} : entry;
						name = '_' + name;
						src['get' + part] = function() {
							return this[name];
						};
						src['set' + part] = function(func) {
							var prev = this[name];
							if (prev)
								this.detach(type, prev);
							if (func)
								this.attach(type, func);
							this[name] = func;
						};
					});
					src._eventTypes = types;
				}
				inject.base.call(this, src);
			}
			return this;
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope(script) {
		paper = this;
		this.settings = {
			applyMatrix: true,
			handleSize: 4,
			hitTolerance: 0
		};
		this.project = null;
		this.projects = [];
		this.tools = [];
		this.palettes = [];
		this._id = script && (script.getAttribute('id') || script.src)
				|| ('paperscope-' + (PaperScope._id++));
		if (script)
			script.setAttribute('id', this._id);
		PaperScope._scopes[this._id] = this;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1);
			PaperScope.prototype.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}
	},

	version: '0.9.18',

	getView: function() {
		return this.project && this.project.getView();
	},

	getPaper: function() {
		return this;
	},

	execute: function(code) {
		paper.PaperScript.execute(code, this);
		View.updateFocus();
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(canvas) {
		paper = this;
		this.project = new Project(canvas);
		return this;
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		for (var i = this.projects.length - 1; i >= 0; i--)
			this.projects[i].remove();
		for (var i = this.tools.length - 1; i >= 0; i--)
			this.tools[i].remove();
		for (var i = this.palettes.length - 1; i >= 0; i--)
			this.palettes[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				if (id && id.getAttribute)
					id = id.getAttribute('id');
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Callback, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.fire('deactivate');
		this._scope[this._reference] = this;
		this.fire('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	}
});

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = precision || 5;
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return Math.round(val * this.multiplier) / this.multiplier;
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		cos = Math.cos,
		PI = Math.PI,
		TOLERANCE = 10e-6,
		EPSILON = 10e-12;

	function setupRoots(roots, min, max) {
		var unbound = min === undefined,
			minE = min - EPSILON,
			maxE = max + EPSILON,
			count = 0;
		return function(root) {
			if (unbound || root > minE && root < maxE)
				roots[count++] = root < min ? min : root > max ? max : root;
			return count;
		};
	}

	return {
		TOLERANCE: TOLERANCE,
		EPSILON: EPSILON,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return abs(val) <= EPSILON;
		},

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = 0.5 * (b - a),
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0; 
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance)
					return nx;
				if (fx > 0) {
					b = x;
					x = nx <= a ? 0.5 * (a + b) : nx;
				} else {
					a = x;
					x = nx >= b ? 0.5 * (a + b) : nx;
				}
			}
			return x;
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var add = setupRoots(roots, min, max);

			if (abs(a) < EPSILON) {
				if (abs(b) >= EPSILON)
					return add(-c / b);
				return abs(c) < EPSILON ? -1 : 0; 
			}
			var p = b / (2 * a);
			var q = c / a;
			var p2 = p * p;
			if (p2 < q - EPSILON)
				return 0;
			var s = p2 > q ? sqrt(p2 - q) : 0,
				count = add(s - p);
			if (s > 0)
				count = add(-s - p);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			if (abs(a) < EPSILON)
				return Numerical.solveQuadratic(b, c, d, roots, min, max);

			b /= a;
			c /= a;
			d /= a;
			var add = setupRoots(roots, min, max),
				bb = b * b,
				p = (bb - 3 * c) / 9,
				q = (2 * bb * b - 9 * b * c + 27 * d) / 54,
				ppp = p * p * p,
				D = q * q - ppp;
			b /= 3;
			if (abs(D) < EPSILON) {
				if (abs(q) < EPSILON) 
					return add(-b);
				var sqp = sqrt(p),
					snq = q > 0 ? 1 : -1;
				add(-snq * 2 * sqp - b);
				return add(snq * sqp - b);
			}
			if (D < 0) { 
				var sqp = sqrt(p),
					phi = Math.acos(q / (sqp * sqp * sqp)) / 3,
					t = -2 * sqp,
					o = 2 * PI / 3;
				add(t * cos(phi) - b);
				add(t * cos(phi + o) - b);
				return add(t * cos(phi - o) - b);
			}
			var A = (q > 0 ? -1 : 1) * pow(abs(q) + sqrt(D), 1 / 3);
			return add(A + p / A - b);
		}
	};
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this.x = arg0;
			this.y = hasY ? arg1 : arg0;
			if (this.__read)
				this.__read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.x != null) {
				this.x = arg0.x;
				this.y = arg0.y;
			} else if (arg0.width != null) {
				this.x = arg0.width;
				this.y = arg0.height;
			} else if (arg0.angle != null) {
				this.x = arg0.length;
				this.y = 0;
				this.setAngle(arg0.angle);
			} else {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this.set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				return Math.acos(this.dot(point) / div);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var point = Point.read(arguments),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(arguments);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			s = Math.sin(angle),
			c = Math.cos(angle);
		point = new Point(
			point.x * c - point.y * s,
			point.x * s + point.y * c
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function(rect) {
		return rect.contains(this);
	},

	isClose: function(point, tolerance) {
		return this.getDistance(point) < tolerance;
	},

	isColinear: function(point) {
		return Math.abs(this.cross(point)) < 0.00001;
	},

	isOrthogonal: function(point) {
		return Math.abs(this.dot(point)) < 0.00001;
	},

	isZero: function() {
		return Numerical.isZero(this.x) && Numerical.isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments);
		if (point.isZero()) {
			return new Point(0, 0);
		} else {
			var scale = this.dot(point) / point.dot(point);
			return new Point(
				point.x * scale,
				point.y * scale
			);
		}
	},

	statics: {
		min: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this.width = arg0;
			this.height = hasHeight ? arg1 : arg0;
			if (this.__read)
				this.__read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.width = this.height = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.width = arg0[0];
				this.height = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.width != null) {
				this.width = arg0.width;
				this.height = arg0.height;
			} else if (arg0.x != null) {
				this.width = arg0.x;
				this.height = arg0.y;
			} else {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		return Numerical.isZero(this.width) && Numerical.isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var type = typeof arg0,
			read = 0;
		if (type === 'number') {
			this.x = arg0;
			this.y = arg1;
			this.width = arg2;
			this.height = arg3;
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = this.width = this.height = 0;
			read = arg0 === null ? 1 : 0;
		} else if (arguments.length === 1) {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0[1];
				this.width = arg0[2];
				this.height = arg0[3];
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this.x = arg0.x || 0;
				this.y = arg0.y || 0;
				this.width = arg0.width || 0;
				this.height = arg0.height || 0;
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this.x = this.y = this.width = this.height = 0;
				this._set(arg0);
				read = 1;
			}
		}
		if (!read) {
			var point = Point.readNamed(arguments, 'from'),
				next = Base.peek(arguments);
			this.x = point.x;
			this.y = point.y;
			if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
				var to = Point.readNamed(arguments, 'to');
				this.width = to.x - point.x;
				this.height = to.y - point.y;
				if (this.width < 0) {
					this.x = to.x;
					this.width = -this.width;
				}
				if (this.height < 0) {
					this.y = to.y;
					this.height = -this.height;
				}
			} else {
				var size = Size.read(arguments);
				this.width = size.width;
				this.height = size.height;
			}
			read = arguments.__index;
		}
		if (this.__read)
			this.__read = read;
	},

	set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (this._fixX)
			this.x += (this.width - size.width) * this._fixX;
		if (this._fixY)
			this.y += (this.height - size.height) * this._fixY;
		this.width = size.width;
		this.height = size.height;
		this._fixW = 1;
		this._fixH = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fixW)
			this.width -= left - this.x;
		this.x = left;
		this._fixX = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fixH)
			this.height -= top - this.y;
		this.y = top;
		this._fixY = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (this._fixX !== undefined && this._fixX !== 1)
			this._fixW = 0;
		if (this._fixW)
			this.x = right - this.width;
		else
			this.width = right - this.x;
		this._fixX = 1;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (this._fixY !== undefined && this._fixY !== 1)
			this._fixH = 0;
		if (this._fixH)
			this.y = bottom - this.height;
		else
			this.height = bottom - this.y;
		this._fixY = 1;
	},

	getCenterX: function() {
		return this.x + this.width * 0.5;
	},

	setCenterX: function(x) {
		this.x = x - this.width * 0.5;
		this._fixX = 0.5;
	},

	getCenterY: function() {
		return this.y + this.height * 0.5;
	},

	setCenterY: function(y) {
		this.y = y - this.height * 0.5;
		this._fixY = 0.5;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length == 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width > this.x
				&& rect.y + rect.height > this.y
				&& rect.x < this.x + this.width
				&& rect.y < this.y + this.height;
	},

	touches: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width >= this.x
				&& rect.y + rect.height >= this.y
				&& rect.x <= this.x + this.width
				&& rect.y <= this.y + this.height;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, new function() {
	return Base.each([
			['Top', 'Left'], ['Top', 'Right'],
			['Bottom', 'Left'], ['Bottom', 'Right'],
			['Left', 'Center'], ['Top', 'Center'],
			['Right', 'Center'], ['Bottom', 'Center']
		],
		function(parts, index) {
			var part = parts.join('');
			var xFirst = /^[RL]/.test(part);
			if (index >= 4)
				parts[1] += xFirst ? 'Y' : 'X';
			var x = parts[xFirst ? 0 : 1],
				y = parts[xFirst ? 1 : 0],
				getX = 'get' + x,
				getY = 'get' + y,
				setX = 'set' + x,
				setY = 'set' + y,
				get = 'get' + part,
				set = 'set' + part;
			this[get] = function(_dontLink) {
				var ctor = _dontLink ? Point : LinkedPoint;
				return new ctor(this[getX](), this[getY](), this, set);
			};
			this[set] = function() {
				var point = Point.read(arguments);
				this[setX](point.x);
				this[setY](point.y);
			};
		}, {
			beans: true
		});
});

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this.set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
}, new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key);
		var internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return this._owner._boundsSelected;
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner.setSelected) {
					owner._boundsSelected = selected;
					owner.setSelected(selected || owner._selectedSegmentState > 0);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg) {
		var count = arguments.length,
			ok = true;
		if (count === 6) {
			this.set.apply(this, arguments);
		} else if (count === 1) {
			if (arg instanceof Matrix) {
				this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
			} else if (Array.isArray(arg)) {
				this.set.apply(this, arg);
			} else {
				ok = false;
			}
		} else if (count === 0) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok)
			throw new Error('Unsupported matrix parameters');
	},

	set: function(a, c, b, d, tx, ty, _dontNotify) {
		this._a = a;
		this._c = c;
		this._b = b;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options) {
		return Base.serialize(this.getValues(), options);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(9);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._c, this._b, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._b),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._c), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._c = this._b = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function() {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, true);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._b;
		this._ty += x * this._c + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var scale = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._c *= scale.x;
		this._b *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * b;
		this._b = -sin * a + cos * b;
		this._c = cos * c + sin * d;
		this._d = -sin * c + cos * d;
		this._tx += tx * a + ty * b;
		this._ty += tx * c + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var shear = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			c = this._c;
		this._a += shear.y * this._b;
		this._c += shear.y * this._d;
		this._b += shear.x * a;
		this._d += shear.x * c;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var skew = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	concatenate: function(mx) {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = mx._a * a + mx._c * b;
		this._b = mx._b * a + mx._d * b;
		this._c = mx._a * c + mx._c * d;
		this._d = mx._b * c + mx._d * d;
		this._tx += mx._tx * a + mx._ty * b;
		this._ty += mx._tx * c + mx._ty * d;
		this._changed();
		return this;
	},

	preConcatenate: function(mx) {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty;
		this._a = mx._a * a + mx._b * c;
		this._b = mx._a * b + mx._b * d;
		this._c = mx._c * a + mx._d * c;
		this._d = mx._c * b + mx._d * d;
		this._tx = mx._a * tx + mx._b * ty + mx._tx;
		this._ty = mx._c * tx + mx._d * ty + mx._ty;
		this._changed();
		return this;
	},

	isIdentity: function() {
		return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isInvertible: function() {
		return !!this._getDeterminant();
	},

	isSingular: function() {
		return !this._getDeterminant();
	},

	transform: function( src, srcOffset, dst, dstOffset, count) {
		return arguments.length < 5
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, srcOffset, dst, dstOffset, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest.set(
			x * this._a + y * this._b + this._tx,
			x * this._c + y * this._d + this._ty,
			_dontNotify
		);
	},

	_transformCoordinates: function(src, srcOffset, dst, dstOffset, count) {
		var i = srcOffset,
			j = dstOffset,
			max = i + 2 * count;
		while (i < max) {
			var x = src[i++],
				y = src[i++];
			dst[j++] = x * this._a + y * this._b + this._tx;
			dst[j++] = x * this._c + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, 0, coords, 0, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = coords.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j])
				min[j] = val;
			else if (val > max[j])
				max[j] = val;
		}
		if (!dest)
			dest = new Rectangle();
		return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_getDeterminant: function() {
		var det = this._a * this._d - this._b * this._c;
		return isFinite(det) && !Numerical.isZero(det)
				&& isFinite(this._tx) && isFinite(this._ty)
				? det : null;
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var det = this._getDeterminant();
		if (!det)
			return null;
		var x = point.x - this._tx,
			y = point.y - this._ty;
		if (!dest)
			dest = new Point();
		return dest.set(
			(x * this._d - y * this._b) / det,
			(y * this._a - x * this._c) / det,
			_dontNotify
		);
	},

	decompose: function() {
		var a = this._a, b = this._b, c = this._c, d = this._d;
		if (Numerical.isZero(a * d - b * c))
			return null;

		var scaleX = Math.sqrt(a * a + b * b);
		a /= scaleX;
		b /= scaleX;

		var shear = a * c + b * d;
		c -= a * shear;
		d -= b * shear;

		var scaleY = Math.sqrt(c * c + d * d);
		c /= scaleY;
		d /= scaleY;
		shear /= scaleY;

		if (a * d < b * c) {
			a = -a;
			b = -b;
			shear = -shear;
			scaleX = -scaleX;
		}

		return {
			scaling: new Point(scaleX, scaleY),
			rotation: -Math.atan2(b, a) * 180 / Math.PI,
			shearing: shear
		};
	},

	getValues: function() {
		return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return (this.decompose() || {}).scaling;
	},

	getRotation: function() {
		return (this.decompose() || {}).rotation;
	},

	inverted: function() {
		var det = this._getDeterminant();
		return det && new Matrix(
				this._d / det,
				-this._c / det,
				-this._b / det,
				this._a / det,
				(this._b * this._ty - this._d * this._tx) / det,
				(this._c * this._tx - this._a * this._ty) / det);
	},

	shiftless: function() {
		return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
	},

	applyToContext: function(ctx) {
		ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
	}
}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
	var part = Base.capitalize(name),
		prop = '_' + name;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	getDistance: function(point) {
		return Math.abs(Line.getSignedDistance(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true));
	},

	statics: {
		intersect: function(apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector,
				isInfinite) {
			if (!asVector) {
				avx -= apx;
				avy -= apy;
				bvx -= bpx;
				bvy -= bpy;
			}
			var cross = bvy * avx - bvx * avy;
			if (!Numerical.isZero(cross)) {
				var dx = apx - bpx,
					dy = apy - bpy,
					ta = (bvx * dy - bvy * dx) / cross,
					tb = (avx * dy - avy * dx) / cross;
				if ((isInfinite || 0 <= ta && ta <= 1)
						&& (isInfinite || 0 <= tb && tb <= 1))
					return new Point(
								apx + ta * avx,
								apy + ta * avy);
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx; 
			if (ccw === 0) {
				ccw = v2x * vx + v2y * vy; 
				if (ccw > 0) {
					v2x -= vx;
					v2y -= vy;
					ccw = v2x * vx + v2y * vy;
					if (ccw < 0)
						ccw = 0;
				}
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var m = vy / vx, 
				b = py - m * px; 
			return (y - (m * x) - b) / Math.sqrt(m * m + 1);
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this.layers = [];
		this.symbols = [];
		this._currentStyle = new Style(null, null, this);
		this.activeLayer = new Layer();
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectedItems = {};
		this._selectedItemCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.layers, options, true, dictionary);
	},

	clear: function() {
		for (var i = this.layers.length - 1; i >= 0; i--)
			this.layers[i].remove();
		this.symbols = [];
	},

	isEmpty: function() {
		return this.layers.length <= 1
			&& (!this.activeLayer || this.activeLayer.isEmpty());
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.initialize(style);
	},

	getIndex: function() {
		return this._index;
	},

	addChild: function(child) {
		if (child instanceof Layer) {
			Base.splice(this.layers, [child]);
			if (!this.activeLayer)
				this.activeLayer = child;
		} else if (child instanceof Item) {
			(this.activeLayer
				|| this.addChild(new Layer(Item.NO_INSERT))).addChild(child);
		} else {
			child = null;
		}
		return child;
	},

	getSelectedItems: function() {
		var items = [];
		for (var id in this._selectedItems) {
			var item = this._selectedItems[id];
			if (item.isInserted())
				items.push(item);
		}
		return items;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectedItems = this._selectedItems;
		if (item._selected) {
			if (selectedItems[id] !== item) {
				this._selectedItemCount++;
				selectedItems[id] = item;
			}
		} else if (selectedItems[id] === item) {
			this._selectedItemCount--;
			delete selectedItems[id];
		}
	},

	selectAll: function() {
		var layers = this.layers;
		for (var i = 0, l = layers.length; i < l; i++)
			layers[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectedItems = this._selectedItems;
		for (var i in selectedItems)
			selectedItems[i].setFullySelected(false);
	},

	hitTest: function() {
		var point = Point.read(arguments),
			options = HitResult.getOptions(Base.read(arguments));
		for (var i = this.layers.length - 1; i >= 0; i--) {
			var res = this.layers[i].hitTest(point, options);
			if (res) return res;
		}
		return null;
	},

	getItems: function(match) {
		return Item._getItems(this.layers, match, true);
	},

	getItem: function(match) {
		return Item._getItems(this.layers, match, false);
	},

	importJSON: function(json) {
		this.activate();
		var layer = this.activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var param = new Base({
			offset: new Point(0, 0),
			pixelRatio: pixelRatio,
			trackTransforms: true,
			transforms: [matrix]
		});
		for (var i = 0, l = this.layers.length; i < l; i++)
			this.layers[i].draw(ctx, param);
		ctx.restore();

		if (this._selectedItemCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			for (var id in this._selectedItems) {
				var item = this._selectedItems[id],
					globalMatrix = item._globalMatrix,
					size = this._scope.settings.handleSize,
					half = size / 2;
				if (item._updateVersion === this._updateVersion
						&& (item._drawSelected || item._boundsSelected)
						&& globalMatrix) {
					var color = item.getSelectedColor()
							|| item.getLayer().getSelectedColor();
					ctx.strokeStyle = ctx.fillStyle = color
							? color.toCanvasStyle(ctx) : '#009dec';
					if (item._drawSelected)
						item._drawSelected(ctx, globalMatrix);
					if (item._boundsSelected) {
						var coords = globalMatrix._transformCorners(
								item.getInternalBounds());
						ctx.beginPath();
						for (var i = 0; i < 8; i++)
							ctx[i === 0 ? 'moveTo' : 'lineTo'](
									coords[i], coords[++i]);
						ctx.closePath();
						ctx.stroke();
						for (var i = 0; i < 8; i++)
							ctx.fillRect(coords[i] - half, coords[++i] - half,
									size, size);
					}
				}
			}
			ctx.restore();
		}
	}
});

var Symbol = Base.extend({
	_class: 'Symbol',

	initialize: function Symbol(item, dontCenter) {
		this._id = Symbol._id = (Symbol._id || 0) + 1;
		this.project = paper.project;
		this.project.symbols.push(this);
		if (item)
			this.setDefinition(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._definition],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8) {
			Item._clearBoundsCache(this);
		}
		if (flags & 1) {
			this.project._needsUpdate = true;
		}
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(item, _dontCenter) {
		if (item._parentSymbol)
			item = item.clone();
		if (this._definition)
			this._definition._parentSymbol = null;
		this._definition = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._parentSymbol = this;
		this._changed(9);
	},

	place: function(position) {
		return new PlacedSymbol(this, position);
	},

	clone: function() {
		return new Symbol(this._definition.clone(false));
	}
});

var Item = Base.extend(Callback, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = new Base(
						this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_applyMatrix: true,
	_canApplyMatrix: true,
	_boundsSelected: false,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		matrix: new Matrix(),
		pivot: null,
		locked: false,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		guide: false,
		selected: false,
		clipMask: false,
		applyMatrix: null,
		data: {}
	},

	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var internal = props && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = paper.project;
		if (!internal)
			this._id = Item._id = (Item._id || 0) + 1;
		this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (!this._project) {
			if (internal || props && props.insert === false) {
				this._setProject(project);
			} else {
				(project.activeLayer || new Layer()).addChild(this);
			}
		}
		return props && props !== Item.NO_INSERT
				? this._set(props, { insert: true }) 
				: true;
	},

	_events: new function() {

		var mouseFlags = {
			mousedown: {
				mousedown: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mouseup: {
				mouseup: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mousemove: {
				mousedrag: 1,
				mousemove: 1,
				mouseenter: 1,
				mouseleave: 1
			}
		};

		var mouseEvent = {
			install: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags) {
						counters[key] = (counters[key] || 0)
								+ (mouseFlags[key][type] || 0);
					}
				}
			},
			uninstall: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags)
						counters[key] -= mouseFlags[key][type] || 0;
				}
			}
		};

		return Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
			function(name) {
				this[name] = mouseEvent;
			}, {
				onFrame: {
					install: function() {
						this._animateItem(true);
					},
					uninstall: function() {
						this._animateItem(false);
					}
				},

				onLoad: {}
			}
		);
	},

	_animateItem: function(animate) {
		this.getView()._animateItem(this, animate);
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._parentSymbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed =
					this._globalMatrix = this._currentPath = undefined;
		}
		if (cacheParent && (flags
				& (8 | 32))) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project) {
			if (flags & 1) {
				project._needsUpdate = true;
			}
			if (project._changes) {
				var entry = project._changesById[this._id];
				if (entry) {
					entry.flags |= flags;
				} else {
					entry = { item: this, flags: flags };
					project._changesById[this._id] = entry;
					project._changes.push(entry);
				}
			}
		}
		if (symbol)
			symbol._changed(flags);
	},

	set: function(props) {
		if (props)
			this._set(props, { insert: true });
		return this;
	},

	getId: function() {
		return this._id;
	},

	getClassName: function() {
		return this._class;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name, unique) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		if (name && this._parent) {
			var children = this._parent._children,
				namedChildren = this._parent._namedChildren,
				orig = name,
				i = 1;
			while (unique && children[name])
				name = orig + ' ' + (i++);
			(namedChildren[name] = namedChildren[name] || []).push(this);
			children[name] = this;
		}
		this._name = name || undefined;
		this._changed(128);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			name = '_' + name;
		this['get' + part] = function() {
			return this[name];
		};
		this['set' + part] = function(value) {
			if (value != this[name]) {
				this[name] = value;
				this._changed(name === '_locked'
						? 128 : 129);
			}
		};
}, {}), {
	beans: true,

	_locked: false,

	_visible: true,

	_blendMode: 'normal',

	_opacity: 1,

	_guide: false,

	isSelected: function() {
		if (this._selectChildren) {
			for (var i = 0, l = this._children.length; i < l; i++)
				if (this._children[i].isSelected())
					return true;
		}
		return this._selected;
	},

	setSelected: function(selected, noChildren) {
		if (!noChildren && this._selectChildren) {
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i].setSelected(selected);
		}
		if ((selected = !!selected) ^ this._selected) {
			this._selected = selected;
			this._project._updateSelection(this);
			this._changed(129);
		}
	},

	_selected: false,

	isFullySelected: function() {
		if (this._children && this._selected) {
			for (var i = 0, l = this._children.length; i < l; i++)
				if (!this._children[i].isFullySelected())
					return false;
			return true;
		}
		return this._selected;
	},

	setFullySelected: function(selected) {
		if (this._children) {
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i].setFullySelected(selected);
		}
		this.setSelected(selected, true);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(129);
			if (this._parent)
				this._parent._changed(1024);
		}
	},

	_clipMask: false,

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var position = this._position,
			ctor = _dontLink ? Point : LinkedPoint;
		if (!position) {
			var pivot = this._pivot;
			position = this._position = pivot
					? this._matrix._transformPoint(pivot)
					: this.getBounds().getCenter(true);
		}
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	getPivot: function(_dontLink) {
		var pivot = this._pivot;
		if (pivot) {
			var ctor = _dontLink ? Point : LinkedPoint;
			pivot = new ctor(pivot.x, pivot.y, this, 'setAnchor');
		}
		return pivot;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments);
		this._position = undefined;
	},

	_pivot: null,

	getRegistration: '#getPivot',
	setRegistration: '#setPivot'
}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
		'internalBounds', 'internalRoughBounds'],
	function(key) {
		var getter = 'get' + Base.capitalize(key),
			match = key.match(/^internal(.*)$/),
			internalGetter = match ? 'get' + match[1] : null;
		this[getter] = function(_matrix) {
			var boundsGetter = this._boundsGetter,
				name = !internalGetter && (typeof boundsGetter === 'string'
						? boundsGetter : boundsGetter && boundsGetter[getter])
						|| getter,
				bounds = this._getCachedBounds(name, _matrix, null,
						internalGetter);
			return key === 'bounds'
					? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
							bounds.height, this, 'setBounds')
					: bounds;
		};
	},
{
	beans: true,

	_getBounds: function(getter, matrix, cacheItem) {
		var children = this._children;
		if (!children || children.length == 0)
			return new Rectangle();
		var x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			if (child._visible && !child.isEmpty()) {
				var rect = child._getCachedBounds(getter, matrix, cacheItem);
				x1 = Math.min(rect.x, x1);
				y1 = Math.min(rect.y, y1);
				x2 = Math.max(rect.x + rect.width, x2);
				y2 = Math.max(rect.y + rect.height, y2);
			}
		}
		return isFinite(x1)
				? new Rectangle(x1, y1, x2 - x1, y2 - y1)
				: new Rectangle();
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			matrix.scale(
					bounds.width != 0 ? rect.width / bounds.width : 1,
					bounds.height != 0 ? rect.height / bounds.height : 1);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
		matrix = matrix && matrix.orNullIfIdentity();
		var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
			cache = (!matrix || matrix.equals(_matrix)) && getter;
		var cacheParent = this._parent || this._parentSymbol;
		if (cacheItem && cacheParent) {
			var id = cacheItem._id,
				ref = cacheParent._boundsCache = cacheParent._boundsCache || {
					ids: {},
					list: []
				};
			if (!ref.ids[id]) {
				ref.list.push(cacheItem);
				ref.ids[id] = cacheItem;
			}
		}
		if (cache && this._bounds && this._bounds[cache])
			return this._bounds[cache].clone();
		matrix = !matrix
				? _matrix
				: _matrix
					? matrix.clone().concatenate(_matrix)
					: matrix;
		var bounds = this._getBounds(internalGetter || getter, matrix,
				cache ? this : cacheItem);
		if (cache) {
			if (!this._bounds)
				this._bounds = {};
			var cached = this._bounds[cache] = bounds.clone();
			cached._internal = !!internalGetter;
		}
		return bounds;
	},

	statics: {
		_clearBoundsCache: function(item) {
			if (item._boundsCache) {
				for (var i = 0, list = item._boundsCache.list, l = list.length;
						i < l; i++) {
					var child = list[i];
					child._bounds = child._position = undefined;
					if (child !== item && child._boundsCache)
						Item._clearBoundsCache(child);
				}
				item._boundsCache = undefined;
			}
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._decomposed = this._matrix.decompose();
	},

	getRotation: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			decomposed.rotation = rotation;
			this._decomposed = decomposed;
		}
	},

	getScaling: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.scaling;
	},

	setScaling: function() {
		var current = this.getScaling();
		if (current != null) {
			var scaling = Point.read(arguments, 0, { clone: true }),
				decomposed = this._decomposed;
			this.scale(scaling.x / current.x, scaling.y / current.y);
			decomposed.scaling = scaling;
			this._decomposed = decomposed;
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function(matrix) {
		this._matrix.initialize(matrix);
		if (this._applyMatrix) {
			this.transform(null, true);
		} else {
			this._changed(9);
		}
	},

	getGlobalMatrix: function(_internal) {
		var matrix = this._globalMatrix,
			updateVersion = this._project._updateVersion,
			viewMatrix = this.getView()._matrix;
		if (matrix && matrix._updateVersion !== updateVersion)
			matrix = null;
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			matrix.preConcatenate(this._parent
					? this._parent.getGlobalMatrix(true)
					: viewMatrix);
			matrix._updateVersion = updateVersion;
		}
		return _internal ? matrix : viewMatrix.inverted().concatenate(matrix);
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(transform) {
		if (this._applyMatrix = this._canApplyMatrix && !!transform)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project.getView();
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		return this._parent && this._parent._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		return this._parent && this._parent._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(insert) {
		return this._clone(new this.constructor(Item.NO_INSERT), insert);
	},

	_clone: function(copy, insert) {
		copy.setStyle(this._style);
		if (this._children) {
			for (var i = 0, l = this._children.length; i < l; i++)
				copy.addChild(this._children[i].clone(false), true);
		}
		if (insert || insert === undefined)
			copy.insertAbove(this);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide', '_applyMatrix'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (this.hasOwnProperty(key))
				copy[key] = this[key];
		}
		copy._matrix.initialize(this._matrix);
		copy._data = this._data ? Base.clone(this._data) : null;
		copy.setSelected(this._selected);
		if (this._name)
			copy.setName(this._name, true);
		return copy;
	},

	copyTo: function(itemOrProject) {
		return itemOrProject.addChild(this.clone(false));
	},

	rasterize: function(resolution) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			canvas = CanvasProvider.getCanvas(size.multiply(scale)),
			ctx = canvas.getContext('2d'),
			matrix = new Matrix().scale(scale).translate(topLeft.negate());
		ctx.save();
		matrix.applyToContext(ctx);
		this.draw(ctx, new Base({ transforms: [matrix] }));
		ctx.restore();
		var raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(canvas);
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		return !!this._contains(
				this._matrix._inverseTransform(Point.read(arguments)));
	},

	_contains: function(point) {
		if (this._children) {
			for (var i = this._children.length - 1; i >= 0; i--) {
				if (this._children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	hitTest: function(point, options) {
		point = Point.read(arguments);
		options = HitResult.getOptions(Base.read(arguments));
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty())
			return null;

		var matrix = this._matrix,
			parentTotalMatrix = options._totalMatrix,
			view = this.getView(),
			totalMatrix = options._totalMatrix = parentTotalMatrix
					? parentTotalMatrix.clone().concatenate(matrix)
					: this.getGlobalMatrix().clone().preConcatenate(
							view._matrix),
			tolerancePadding = options._tolerancePadding = new Size(
						Path._getPenPadding(1, totalMatrix.inverted())
					).multiply(
						Math.max(options.tolerance, 0.00001)
					);
		point = matrix._inverseTransform(point);

		if (!this._children && !this.getInternalRoughBounds()
				.expand(tolerancePadding.multiply(2))._containsPoint(point))
			return null;
		var type,
			checkSelf = !(options.guides && !this._guide
				|| options.selected && !this._selected
				|| (type = options.type) && (typeof type === 'string'
						? type !== Base.hyphenate(this._class)
						: !(this instanceof type))),
			that = this,
			res;

		function checkBounds(type, part) {
			var pt = bounds['get' + part]();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1)
				return new HitResult(type, that,
						{ name: Base.hyphenate(part), point: pt });
		}

		if (checkSelf && (options.center || options.bounds) && this._parent) {
			var bounds = this.getInternalBounds();
			if (options.center)
				res = checkBounds('center', 'Center');
			if (!res && options.bounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++)
					res = checkBounds('bounds', points[i]);
			}
		}

		var children = !res && this._children;
		if (children) {
			var opts = this._getChildHitTestOptions(options);
			for (var i = children.length - 1; i >= 0 && !res; i--)
				res = children[i].hitTest(point, opts);
		}
		if (!res && checkSelf)
			res = this._hitTest(point, options);
		if (res && res.point)
			res.point = matrix.transform(res.point);
		options._totalMatrix = parentTotalMatrix;
		return res;
	},

	_getChildHitTestOptions: function(options) {
		return options;
	},

	_hitTest: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	}
}, { 
	matches: function(match) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		for (var key in match) {
			if (match.hasOwnProperty(key)) {
				var value = this[key],
					compare = match[key];
				if (value === undefined && key === 'type')
					value = Base.hyphenate(this._class);
				if (/^(constructor|class)$/.test(key)) {
					if (!(this instanceof compare))
						return false;
				} else if (compare instanceof RegExp) {
					if (!compare.test(value))
						return false;
				} else if (typeof compare === 'function') {
					if (!compare(value))
						return false;
				} else if (Base.isPlainObject(compare)) {
					if (!matchObject(compare, value))
						return false;
				} else if (!Base.equals(value, compare)) {
					return false;
				}
			}
		}
		return true;
	},

	getItems: function(match) {
		return Item._getItems(this._children, match, true);
	},

	getItem: function(match) {
		return Item._getItems(this._children, match, false);
	},

	statics: {
		_getItems: function _getItems(children, match, list) {
			var items = list && [];
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i];
				if (child.matches(match)) {
					if (list) {
						items.push(child);
					} else {
						return child;
					}
				}
				var res = _getItems(child._children, match, list);
				if (list) {
					items.push.apply(items, res);
				} else if (res) {
					return res;
				}
			}
			return list ? items : null;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this
				? this.addChild(res)
				: res;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	insertChild: function(index, item, _preserve) {
		var res = this.insertChildren(index, [item], _preserve);
		return res && res[0];
	},

	addChildren: function(items, _preserve) {
		return this.insertChildren(this._children.length, items, _preserve);
	},

	insertChildren: function(index, items, _preserve, _proto) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Array.prototype.slice.apply(items);
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i];
				if (_proto && !(item instanceof _proto)) {
					items.splice(i, 1);
				} else {
					item._remove(false, true);
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project && project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				item._parent = this;
				item._setProject(this._project, true);
				if (item._name)
					item.setName(item._name);
				if (notifySelf)
					this._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insert: function(above, item, _preserve) {
		if (!item._parent)
			return null;
		var index = item._index + (above ? 1 : 0);
		if (item._parent === this._parent && index > this._index)
			 index--;
		return item._parent.insertChild(index, this, _preserve);
	},

	insertAbove: function(item, _preserve) {
		return this._insert(true, item, _preserve);
	},

	insertBelow: function(item, _preserve) {
	 	return this._insert(false, item, _preserve);
	 },

	sendToBack: function() {
		return this._parent.insertChild(0, this);
	},

	bringToFront: function() {
		return this._parent.addChild(this);
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	reduce: function() {
		if (this._children && this._children.length === 1) {
			var child = this._children[0].reduce();
			child.insertAbove(this);
			child.setStyle(this._style);
			this.remove();
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var children = this._parent._children,
			namedChildren = this._parent._namedChildren,
			name = this._name,
			namedArray = namedChildren[name],
			index = namedArray ? namedArray.indexOf(this) : -1;
		if (index == -1)
			return;
		if (children[name] == this)
			delete children[name];
		namedArray.splice(index, 1);
		if (namedArray.length) {
			children[name] = namedArray[namedArray.length - 1];
		} else {
			delete namedChildren[name];
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var parent = this._parent;
		if (parent) {
			if (this._name)
				this._removeNamed();
			if (this._index != null)
				Base.splice(parent._children, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf) {
				var project = this._project;
				if (project && project._changes)
					this._changed(5);
			}
			if (notifyParent)
				parent._changed(11);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	removeChildren: function(from, to) {
		if (!this._children)
			return null;
		from = from || 0;
		to = Base.pick(to, this._children.length);
		var removed = Base.splice(this._children, null, from, to - from);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function() {
		return !this._children || this._children.length == 0;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent == item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	rotate: function(angle ) {
		return this.transform(new Matrix().rotate(angle,
				Point.read(arguments, 1, { readNull: true })
					|| this.getPosition(true)));
	}
}, Base.each(['scale', 'shear', 'skew'], function(name) {
	this[name] = function() {
		var point = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[name](point,
				center || this.getPosition(true)));
	};
}, {

}), {
	transform: function(matrix, _applyMatrix) {
		if (matrix && matrix.isIdentity())
			matrix = null;
		var _matrix = this._matrix,
			applyMatrix = (_applyMatrix || this._applyMatrix)
				&& (!_matrix.isIdentity() || matrix);
		if (!matrix && !applyMatrix)
			return this;
		if (matrix)
			_matrix.preConcatenate(matrix);
		if (applyMatrix = applyMatrix && this._transformContent(_matrix)) {
			var pivot = this._pivot,
				style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (pivot)
				pivot.transform(_matrix);
			if (fillColor)
				fillColor.transform(_matrix);
			if (strokeColor)
				strokeColor.transform(_matrix);
			_matrix.reset(true);
		}
		var bounds = this._bounds,
			position = this._position;
		this._changed(9);
		var decomp = bounds && matrix && matrix.decompose();
		if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var rect = bounds[key];
				if (applyMatrix || !rect._internal)
					matrix._transformBounds(rect, rect);
			}
			var getter = this._boundsGetter,
				rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
			if (rect)
				this._position = rect.getCenter(true);
			this._bounds = bounds;
		} else if (matrix && position) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].transform(matrix, true);
			return true;
		}
	},

	globalToLocal: function() {
		var matrix = this.getGlobalMatrix();
		return matrix && matrix._inverseTransform(Point.read(arguments));
	},

	localToGlobal: function() {
		var matrix = this.getGlobalMatrix();
		return matrix && matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	},

	_setStyles: function(ctx) {
		var style = this._style,
			fillColor = style.getFillColor(),
			strokeColor = style.getStrokeColor(),
			shadowColor = style.getShadowColor();
		if (fillColor)
			ctx.fillStyle = fillColor.toCanvasStyle(ctx);
		if (strokeColor) {
			var strokeWidth = style.getStrokeWidth();
			if (strokeWidth > 0) {
				ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
				ctx.lineWidth = strokeWidth;
				var strokeJoin = style.getStrokeJoin(),
					strokeCap = style.getStrokeCap(),
					miterLimit = style.getMiterLimit();
				if (strokeJoin)
					ctx.lineJoin = strokeJoin;
				if (strokeCap)
					ctx.lineCap = strokeCap;
				if (miterLimit)
					ctx.miterLimit = miterLimit;
				if (paper.support.nativeDash) {
					var dashArray = style.getDashArray(),
						dashOffset = style.getDashOffset();
					if (dashArray && dashArray.length) {
						if ('setLineDash' in ctx) {
							ctx.setLineDash(dashArray);
							ctx.lineDashOffset = dashOffset;
						} else {
							ctx.mozDash = dashArray;
							ctx.mozDashOffset = dashOffset;
						}
					}
				}
			}
		}
		if (shadowColor) {
			var shadowBlur = style.getShadowBlur();
			if (shadowBlur > 0) {
				ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
				ctx.shadowBlur = shadowBlur;
				var offset = this.getShadowOffset();
				ctx.shadowOffsetX = offset.x;
				ctx.shadowOffsetY = offset.y;
			}
		}
	},

	draw: function(ctx, param) {
		if (!this._visible || this._opacity === 0)
			return;
		var updateVersion = this._updateVersion = this._project._updateVersion;
		var trackTransforms = param.trackTransforms,
			transforms = param.transforms,
			matrix = this._matrix,
			parentMatrix = transforms[transforms.length - 1],
			globalMatrix = parentMatrix.clone().concatenate(matrix);
		if (!globalMatrix.isInvertible())
			return;
		if (trackTransforms) {
			transforms.push(this._globalMatrix = globalMatrix);
			globalMatrix._updateVersion = updateVersion;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(parentMatrix);
			if (!bounds.width || !bounds.height)
				return;
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(
					bounds.getSize().ceil().add(new Size(1, 1)),
					param.pixelRatio);
		}
		ctx.save();
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		(direct ? matrix : globalMatrix).applyToContext(ctx);
		if (!direct && param.clipItem)
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		this._draw(ctx, param);
		ctx.restore();
		if (trackTransforms)
			transforms.pop();
		if (param.clip && !param.dontFinish)
			ctx.clip();
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(param.pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
	this['removeOn' + Base.capitalize(name)] = function() {
		var hash = {};
		hash[name] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}));

var Group = Item.extend({
	_class: 'Group',
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & (2 | 1024)) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			for (var i = 0, l = this._children.length; i < l; i++) {
				var child = this._children[i];
				if (child._clipMask) {
					clipItem = child;
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem(),
			draw = true;
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
				draw = false;
			} else {
				ctx.beginPath();
				param.dontStart = param.dontFinish = true;
			}
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (draw) {
			for (var i = 0, l = this._children.length; i < l; i++) {
				var item = this._children[i];
				if (item !== clipItem)
					item.draw(ctx, param);
			}
		}
		if (clip) {
			this._currentPath = ctx.currentPath;
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer(arg) {
		var props = Base.isPlainObject(arg)
				? new Base(arg) 
				: { children: Array.isArray(arg) ? arg : arguments },
			insert = props.insert;
		props.insert = false;
		Group.call(this, props);
		if (insert || insert === undefined) {
			this._project.addChild(this);
			this.activate();
		}
	},

	_remove: function _remove(notify) {
		if (this._parent)
			return _remove.base.call(this, notify);
		if (this._index != null) {
			if (this._project.activeLayer === this)
				this._project.activeLayer = this.getNextSibling()
						|| this.getPreviousSibling();
			Base.splice(this._project.layers, null, this._index, 1);
			this._installEvents(false);
			this._project._needsUpdate = true;
			return true;
		}
		return false;
	},

	getNextSibling: function getNextSibling() {
		return this._parent ? getNextSibling.base.call(this)
				: this._project.layers[this._index + 1] || null;
	},

	getPreviousSibling: function getPreviousSibling() {
		return this._parent ? getPreviousSibling.base.call(this)
				: this._project.layers[this._index - 1] || null;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project.activeLayer = this;
	},

	_insert: function _insert(above, item, _preserve) {
		if (item instanceof Layer && !item._parent) {
			this._remove(true, true);
			Base.splice(item._project.layers, [this],
					item._index + (above ? 1 : 0), 0);
			this._setProject(item._project, true);
			return this;
		}
		return _insert.base.call(this, above, item, _preserve);
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsSelected: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props) {
		this._initialize(props);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	clone: function(insert) {
		var copy = new Shape(Item.NO_INSERT);
		copy.setType(this._type);
		copy.setSize(this._size);
		copy.setRadius(this._radius);
		return this._clone(copy, insert);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				var radius = Size.min(this._radius, size.divide(2));
				this._radius.set(radius.width, radius.height);
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius.set(width / 2, height / 2);
			}
			this._size.set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size.set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius.width, radius.height);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size.width, size.height);
				} else if (type === 'ellipse') {
					this._size.set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.setStyle(this._style);
		path.transform(this._matrix);
		if (insert || insert === undefined)
			path.insertAbove(this);
		return path;
	},

	_draw: function(ctx, param) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip;
		if (hasFill || hasStroke || dontPaint) {
			var radius = this._radius,
				type = this._type;
			if (!param.dontStart)
				ctx.beginPath();
			if (type === 'circle') {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = radius.width,
					ry = radius.height,
					kappa = 0.5522847498307936;
				if (type === 'ellipse') {
					var	cx = rx * kappa,
						cy = ry * kappa;
					ctx.moveTo(-rx, 0);
					ctx.bezierCurveTo(-rx, -cy, -cx, -ry, 0, -ry);
					ctx.bezierCurveTo(cx, -ry, rx, -cy, rx, 0);
					ctx.bezierCurveTo(rx, cy, cx, ry, 0, ry);
					ctx.bezierCurveTo(-cx, ry, -rx, cy, -rx, 0);
				} else { 
					var size = this._size,
						width = size.width,
						height = size.height;
					if (rx === 0 && ry === 0) {
						ctx.rect(-width / 2, -height / 2, width, height);
					} else {
						kappa = 1 - kappa;
						var x = width / 2,
							y = height / 2,
							cx = rx * kappa,
							cy = ry * kappa;
						ctx.moveTo(-x, -y + ry);
						ctx.bezierCurveTo(-x, -y + cy, -x + cx, -y, -x + rx, -y);
						ctx.lineTo(x - rx, -y);
						ctx.bezierCurveTo(x - cx, -y, x, -y + cy, x, -y + ry);
						ctx.lineTo(x, y - ry);
						ctx.bezierCurveTo(x, y - cy, x - cx, y, x - rx, y);
						ctx.lineTo(-x + rx, y);
						ctx.bezierCurveTo(-x + cx, y, -x, y - cy, -x, y - ry);
					}
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx);
			if (hasFill) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		if (getter !== 'getBounds' && this.hasStroke())
			rect = rect.expand(this.getStrokeWidth());
		return matrix ? matrix._transformBounds(rect) : rect;
	}
},
new function() { 

	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var i = 0; i < 4; i++) {
				var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(corner, center);
				if ((expand ? rect.expand(expand) : rect).contains(point))
					return center;
			}
		}
	}

	function getEllipseRadius(point, radius) {
		var angle = point.getAngleInRadians(),
			width = radius.width * 2,
			height = radius.height * 2,
			x = width * Math.sin(angle),
			y = height * Math.cos(angle);
		return width * height / (2 * Math.sqrt(x * x + y * y));
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTest: function _hitTest(point, options) {
			var hit = false;
			if (this.hasStroke()) {
				var type = this._type,
					radius = this._radius,
					strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
				if (type === 'rectangle') {
					var center = getCornerCenter(this, point, strokeWidth);
					if (center) {
						var pt = point.subtract(center);
						hit = 2 * Math.abs(pt.getLength()
								- getEllipseRadius(pt, radius)) <= strokeWidth;
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(strokeWidth),
							inner = rect.expand(-strokeWidth);
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					if (type === 'ellipse')
						radius = getEllipseRadius(point, radius);
					hit = 2 * Math.abs(point.getLength() - radius)
							<= strokeWidth;
				}
			}
			return hit
					? new HitResult('stroke', this)
					: _hitTest.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = new Shape(Base.getNamed(args));
		item._type = type;
		item._size = size;
		item._radius = radius;
		return item.translate(point);
	}

	return {
		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.min(Size.readNamed(arguments, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, arguments);
		},

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, arguments);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: 'getBounds',
	_boundsSelected: true,
	_serializeFields: {
		source: null
	},

	initialize: function Raster(object, position) {
		if (!this._initialize(object,
				position !== undefined && Point.read(arguments, 1))) {
			if (typeof object === 'string') {
				this.setSource(object);
			} else {
				this.setImage(object);
			}
		}
		if (!this._size)
			this._size = new Size();
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	clone: function(insert) {
		var copy = new Raster(Item.NO_INSERT),
			image = this._image,
			canvas = this._canvas;
		if (image) {
			copy.setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(this._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			copy.setCanvas(copyCanvas);
		}
		return this._clone(copy, insert);
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size.equals(size)) {
			var element = this.getElement();
			this.setCanvas(CanvasProvider.getCanvas(size));
			if (element)
				this.getContext(true).drawImage(element, 0, 0,
						size.width, size.height);
		}
	},

	getWidth: function() {
		return this._size.width;
	},

	getHeight: function() {
		return this._size.height;
	},

	isEmpty: function() {
		return this._size.width == 0 && this._size.height == 0;
	},

	getPpi: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image.getContext) {
			this._image = null;
			this._canvas = image;
		} else {
			this._image = image;
			this._canvas = null;
		}
		this._size = new Size(
				image.naturalWidth || image.width,
				image.naturalHeight || image.height);
		this._context = null;
		this._changed(9 | 513);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(modify) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (modify) {
			this._image = null;
			this._changed(513);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		return this._image && this._image.src || this.toDataURL();
	},

	setSource: function(src) {
		var that = this,
			image;

		function loaded() {
			var view = that.getView();
			if (view) {
				paper = view._scope;
				that.setImage(image);
				that.fire('load');
				view.update();
			}
		}

			image = document.getElementById(src) || new Image();

		if (image.naturalWidth && image.naturalHeight) {
			setTimeout(loaded, 0);
		} else {
			DomEvent.add(image, {
				load: loaded
			});
			if (!image.src)
				image.src = src;
		}
		this.setImage(image);
	},

	getElement: function() {
		return this._canvas || this._image;
	},

	getSubCanvas: function(rect) { 
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function(rect) { 
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.preConcatenate(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var src = this._image && this._image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL() : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (object.width) {
			bounds = new Rectangle(object);
		} else if (object.x) {
			bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
		}
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, transforms: [matrix] }));
		this._matrix.applyToContext(ctx);
		ctx.drawImage(this.getElement(),
				-this._size.width / 2, -this._size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function(point) { 
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var point = Point.read(arguments),
			color = Color.read(arguments),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function(rect) { 
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTest: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx) {
		var element = this.getElement();
		if (element) {
			ctx.globalAlpha = this._opacity;
			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var PlacedSymbol = Item.extend({
	_class: 'PlacedSymbol',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: { getBounds: 'getStrokeBounds' },
	_boundsSelected: true,
	_serializeFields: {
		symbol: null
	},

	initialize: function PlacedSymbol(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
	},

	_equals: function(item) {
		return this._symbol === item._symbol;
	},

	getSymbol: function() {
		return this._symbol;
	},

	setSymbol: function(symbol) {
		this._symbol = symbol;
		this._changed(9);
	},

	clone: function(insert) {
		var copy = new PlacedSymbol(Item.NO_INSERT);
		copy.setSymbol(this._symbol);
		return this._clone(copy, insert);
	},

	isEmpty: function() {
		return this._symbol._definition.isEmpty();
	},

	_getBounds: function(getter, matrix, cacheItem) {
		return this.symbol._definition._getCachedBounds(getter, matrix,
				cacheItem);
	},

	_hitTest: function(point, options) {
		var res = this._symbol._definition.hitTest(point, options);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this.symbol._definition.draw(ctx, param);
	}

});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values) {
			values.enumerable = true;
			this.inject(values);
		}
	},

	statics: {
		getOptions: function(options) {
			return options && options._merged ? options : new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false,
				_merged: true
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut;
		if (count === 0) {
		} else if (count === 1) {
			if (arg0.point) {
				point = arg0.point;
				handleIn = arg0.handleIn;
				handleOut = arg0.handleOut;
			} else {
				point = arg0;
			}
		} else if (count === 2 && typeof arg0 === 'number') {
			point = arguments;
		} else if (count <= 3) {
			point = arg0;
			handleIn = arg1;
			handleOut = arg2;
		} else { 
			point = arg0 !== undefined ? [ arg0, arg1 ] : null;
			handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
			handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
	},

	_serialize: function(options) {
		return Base.serialize(this.isLinear() ? this._point
				: [this._point, this._handleIn, this._handleOut],
				options, true);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curveIn, curveOut;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curveIn = curves[index - 1]
						|| path._closed && curves[curves.length - 1]))
				curveIn._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curveOut = curves[index]))
				curveOut._changed();
		}
		path._changed(25);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this._point.set(point.x, point.y);
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		var point = Point.read(arguments);
		this._handleIn.set(point.x, point.y);
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		var point = Point.read(arguments);
		this._handleOut.set(point.x, point.y);
	},

	isLinear: function() {
		return this._handleIn.isZero() && this._handleOut.isZero();
	},

	setLinear: function() {
		this._handleIn.set(0, 0);
		this._handleOut.set(0, 0);
	},

	isColinear: function(segment) {
		var next1 = this.getNext(),
			next2 = segment.getNext();
		return this._handleOut.isZero() && next1._handleIn.isZero()
				&& segment._handleOut.isZero() && next2._handleIn.isZero()
				&& next1._point.subtract(this._point).isColinear(
					next2._point.subtract(segment._point));
	},

	isOrthogonal: function() {
		var prev = this.getPrevious(),
			next = this.getNext();
		return prev._handleOut.isZero() && this._handleIn.isZero()
			&& this._handleOut.isZero() && next._handleIn.isZero()
			&& this._point.subtract(prev._point).isOrthogonal(
					next._point.subtract(this._point));
	},

	isArc: function() {
		var next = this.getNext(),
			handle1 = this._handleOut,
			handle2 = next._handleIn,
			kappa = 0.5522847498307936;
		if (handle1.isOrthogonal(handle2)) {
			var from = this._point,
				to = next._point,
				corner = new Line(from, handle1, true).intersect(
						new Line(to, handle2, true), true);
			return corner && Numerical.isZero(handle1.getLength() /
					corner.subtract(from).getLength() - kappa)
				&& Numerical.isZero(handle2.getLength() /
					corner.subtract(to).getLength() - kappa);
		}
		return false;
	},

	_selectionState: 0,

	isSelected: function(_point) {
		var state = this._selectionState;
		return !_point ? !!(state & 7)
			: _point === this._point ? !!(state & 4)
			: _point === this._handleIn ? !!(state & 1)
			: _point === this._handleOut ? !!(state & 2)
			: false;
	},

	setSelected: function(selected, _point) {
		var path = this._path,
			selected = !!selected, 
			state = this._selectionState,
			oldState = state,
			flag = !_point ? 7
					: _point === this._point ? 4
					: _point === this._handleIn ? 1
					: _point === this._handleOut ? 2
					: 0;
		if (selected) {
			state |= flag;
		} else {
			state &= ~flag;
		}
		this._selectionState = state;
		if (path && state !== oldState) {
			path._updateSelection(this, oldState, state);
			path._changed(129);
		}
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	reverse: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn =  !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, 0, coords, 0, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i  = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y, selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) { 
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	_serialize: function(options) {
		var f = options.formatter,
			x = f.number(this._x),
			y = f.number(this._y);
		return this.isSelected()
				? { x: x, y: y, selected: true }
				: [x, y];
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		return Numerical.isZero(this._x) && Numerical.isZero(this._y);
	},

	setSelected: function(selected) {
		this._owner.setSelected(selected, this);
	},

	isSelected: function() {
		return this._owner.isSelected(this);
	}
});

var Curve = Base.extend({
	_class: 'Curve',
	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length;
		if (count === 3) {
			this._path = arg0;
			this._segment1 = arg1;
			this._segment2 = arg2;
		} else if (count === 0) {
			this._segment1 = new Segment();
			this._segment2 = new Segment();
		} else if (count === 1) {
			this._segment1 = new Segment(arg0.segment1);
			this._segment2 = new Segment(arg0.segment2);
		} else if (count === 2) {
			this._segment1 = new Segment(arg0);
			this._segment2 = new Segment(arg1);
		} else {
			var point1, handle1, handle2, point2;
			if (count === 4) {
				point1 = arg0;
				handle1 = arg1;
				handle2 = arg2;
				point2 = arg3;
			} else if (count === 8) {
				point1 = [arg0, arg1];
				point2 = [arg6, arg7];
				handle1 = [arg2 - arg0, arg3 - arg1];
				handle2 = [arg4 - arg6, arg5 - arg7];
			}
			this._segment1 = new Segment(point1, null, handle1);
			this._segment2 = new Segment(point2, handle2, null);
		}
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		var point = Point.read(arguments);
		this._segment1._point.set(point.x, point.y);
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		var point = Point.read(arguments);
		this._segment2._point.set(point.x, point.y);
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		var point = Point.read(arguments);
		this._segment1._handleOut.set(point.x, point.y);
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		var point = Point.read(arguments);
		this._segment2._handleIn.set(point.x, point.y);
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	},

	getLength: function() {
		if (this._length == null) {
			this._length = this.isLinear()
				? this._segment2._point.getDistance(this._segment1._point)
				: Curve.getLength(this.getValues(), 0, 1);
		}
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	isLinear: function() {
		return this._segment1._handleOut.isZero()
				&& this._segment2._handleIn.isZero();
	},

	isHorizontal: function() {
		return this.isLinear() && Numerical.isZero(
				this._segment1._point._y - this._segment2._point._y);
	},

	getIntersections: function(curve) {
		return Curve.getIntersections(this.getValues(), curve.getValues(),
				this, curve, []);
	},

	_getParameter: function(offset, isParameter) {
		return isParameter
				? offset
				: offset && offset.curve === this
					? offset.parameter
					: offset === undefined && isParameter === undefined
						? 0.5 
						: this.getParameterAt(offset, 0);
	},

	divide: function(offset, isParameter, ignoreLinear) {
		var parameter = this._getParameter(offset, isParameter),
			tolerance = 0.00001,
			res = null;
		if (parameter > tolerance && parameter < 1 - tolerance) {
			var parts = Curve.subdivide(this.getValues(), parameter),
				isLinear = ignoreLinear ? false : this.isLinear(),
				left = parts[0],
				right = parts[1];

			if (!isLinear) {
				this._segment1._handleOut.set(left[2] - left[0],
						left[3] - left[1]);
				this._segment2._handleIn.set(right[4] - right[6],
						right[5] - right[7]);
			}

			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						!isLinear && new Point(left[4] - x, left[5] - y),
						!isLinear && new Point(right[2] - x, right[3] - y));

			if (this._path) {
				if (this._segment1._index > 0 && this._segment2._index === 0) {
					this._path.add(segment);
				} else {
					this._path.insert(this._segment2._index, segment);
				}
				res = this; 
			} else {
				var end = this._segment2;
				this._segment2 = segment;
				res = new Curve(segment, end);
			}
		}
		return res;
	},

	split: function(offset, isParameter) {
		return this._path
			? this._path.split(this._segment1._index,
					this._getParameter(offset, isParameter))
			: null;
	},

	reverse: function() {
		return new Curve(this._segment2.reverse(), this._segment1.reverse());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut.x, handleOut.y);
		}
		return removed;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

statics: {
	getValues: function(segment1, segment2, matrix) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			values = [
				p1._x, p1._y,
				p1._x + h1._x, p1._y + h1._y,
				p2._x + h2._x, p2._y + h2._y,
				p2._x, p2._y
			];
		if (matrix)
			matrix._transformCoordinates(values, 0, values, 0, 6);
		return values;
	},

	evaluate: function(v, t, type) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			tolerance = 0.00001,
			x, y;

		if (type === 0 && (t < tolerance || t > 1 - tolerance)) {
			var isZero = t < tolerance;
			x = isZero ? p1x : p2x;
			y = isZero ? p1y : p2y;
		} else {
			var cx = 3 * (c1x - p1x),
				bx = 3 * (c2x - c1x) - cx,
				ax = p2x - p1x - cx - bx,

				cy = 3 * (c1y - p1y),
				by = 3 * (c2y - c1y) - cy,
				ay = p2y - p1y - cy - by;
			if (type === 0) {
				x = ((ax * t + bx) * t + cx) * t + p1x;
				y = ((ay * t + by) * t + cy) * t + p1y;
			} else {
				if (t < tolerance && c1x === p1x && c1y === p1y
						|| t > 1 - tolerance && c2x === p2x && c2y === p2y) {
					x = p2x - p1x;
					y = p2y - p1y;
				} else if (t < tolerance) {
					x = cx;
					y = cy;
				} else if (t > 1 - tolerance) {
					x = 3 * (p2x - c2x);
					y = 3 * (p2y - c2y);
				} else {
					x = (3 * ax * t + 2 * bx) * t + cx;
					y = (3 * ay * t + 2 * by) * t + cy;
				}
				if (type === 3) {
					var x2 = 6 * ax * t + 2 * bx,
						y2 = 6 * ay * t + 2 * by;
					return (x * y2 - y * x2) / Math.pow(x * x + y * y, 3 / 2);
				}
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	},

	subdivide: function(v, t) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
			p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
			p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
			p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
			p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
			p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
		return [
			[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y], 
			[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y] 
		];
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var p1 = v[coord],
			c1 = v[coord + 2],
			c2 = v[coord + 4],
			p2 = v[coord + 6],
			c = 3 * (c1 - p1),
			b = 3 * (c2 - c1) - c,
			a = p2 - p1 - c - b;
		return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
	},

	getParameterOf: function(v, x, y) {
		var tolerance = 0.00001;
		if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance)
			return 0;
		if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance)
			return 1;
		var txs = [],
			tys = [],
			sx = Curve.solveCubic(v, 0, x, txs),
			sy = Curve.solveCubic(v, 1, y, tys),
			tx, ty;
		for (var cx = 0;  sx == -1 || cx < sx;) {
			if (sx == -1 || (tx = txs[cx++]) >= 0 && tx <= 1) {
				for (var cy = 0; sy == -1 || cy < sy;) {
					if (sy == -1 || (ty = tys[cy++]) >= 0 && ty <= 1) {
						if (sx == -1) tx = ty;
						else if (sy == -1) ty = tx;
						if (Math.abs(tx - ty) < tolerance)
							return (tx + ty) * 0.5;
					}
				}
				if (sx == -1)
					break;
			}
		}
		return null;
	},

	getPart: function(v, from, to) {
		if (from > 0)
			v = Curve.subdivide(v, from)[1]; 
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0]; 
		return v;
	},

	isLinear: function(v) {
		var isZero = Numerical.isZero;
		return isZero(v[0] - v[2]) && isZero(v[1] - v[3])
				&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]);
	},

	isFlatEnough: function(v, tolerance) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			ux = 3 * c1x - 2 * p1x - p2x,
			uy = 3 * c1y - 2 * p1y - p2y,
			vx = 3 * c2x - 2 * p2x - p1x,
			vy = 3 * c2y - 2 * p2y - p1y;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				< 10 * tolerance * tolerance;
	},

	getArea: function(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		return (  3.0 * c1y * p1x - 1.5 * c1y * c2x
				- 1.5 * c1y * p2x - 3.0 * p1y * c1x
				- 1.5 * p1y * c2x - 0.5 * p1y * p2x
				+ 1.5 * c2y * p1x + 1.5 * c2y * c1x
				- 3.0 * c2y * p2x + 0.5 * p2y * p1x
				+ 1.5 * p2y * c1x + 3.0 * p2y * c2x) / 10;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2), 
			max = min.slice(), 
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}
		var a = 3 * (v1 - v2) - v0 + v3,
			b = 2 * (v0 + v2) - 4 * v1,
			c = v1 - v0,
			count = Numerical.solveQuadratic(a, b, c, roots),
			tMin = 0.00001,
			tMax = 1 - tMin;
		add(v3, 0);
		for (var i = 0; i < count; i++) {
			var t = roots[i],
				u = 1 - t;
			if (tMin < t && t < tMax)
				add(u * u * u * v0
					+ 3 * u * u * t * v1
					+ 3 * u * t * t * v2
					+ t * t * t * v3,
					padding);
		}
	}
}}, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name]([this._segment1,
						this._segment2], false, this._path.getStyle());
			}
			return bounds.clone();
		};
	},
{

}), Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name, index) {
		this[name + 'At'] = function(offset, isParameter) {
			var values = this.getValues();
			return Curve.evaluate(values, isParameter
					? offset : Curve.getParameterAt(values, offset, 0), index);
		};
		this[name] = function(parameter) {
			return Curve.evaluate(this.getValues(), parameter, index);
		};
	},
{
	getParameterAt: function(offset, start) {
		return Curve.getParameterAt(this.getValues(), offset,
				start !== undefined ? start : offset < 0 ? 1 : 0);
	},

	getParameterOf: function(point) { 
		var point = Point.read(arguments);
		return Curve.getParameterOf(this.getValues(), point.x, point.y);
	},

	getLocationAt: function(offset, isParameter) {
		if (!isParameter)
			offset = this.getParameterAt(offset);
		return new CurveLocation(this, offset);
	},

	getLocationOf: function(point) { 
		var point = Point.read(arguments),
			t = this.getParameterOf(point);
		return t != null ? new CurveLocation(this, t) : null;
	},

	getNearestLocation: function(point) { 
		var point = Point.read(arguments),
			values = this.getValues(),
			count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(
						Curve.evaluate(values, t, 0), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 0.00001) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		var pt = Curve.evaluate(values, minT, 0);
		return new CurveLocation(this, minT, pt, null, null, null,
				point.getDistance(pt));
	},

	getNearestPoint: function(point) {
		var point = Point.read(arguments);
		return this.getNearestLocation(point).getPoint();
	}

}),
new function() { 

	function getLengthIntegrand(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],

			ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
			bx = 6 * (p1x + c2x) - 12 * c1x,
			cx = 3 * (c1x - p1x),

			ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
			by = 6 * (p1y + c2y) - 12 * c1y,
			cy = 3 * (c1y - p1y);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	return {
		statics: true,

		getLength: function(v, a, b) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			var isZero = Numerical.isZero;
			if (a === 0 && b === 1
					&& isZero(v[0] - v[2]) && isZero(v[1] - v[3])
					&& isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
				var dx = v[6] - v[0], 
					dy = v[7] - v[1]; 
				return Math.sqrt(dx * dx + dy * dy);
			}
			var ds = getLengthIntegrand(v);
			return Numerical.integrate(ds, a, b, getIterations(a, b));
		},

		getParameterAt: function(v, offset, start) {
			if (offset === 0)
				return start;
			var forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				offset = Math.abs(offset),
				ds = getLengthIntegrand(v),
				rangeLength = Numerical.integrate(ds, a, b,
						getIterations(a, b));
			if (offset >= rangeLength)
				return forward ? b : a;
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				var count = getIterations(start, t);
				length += start < t
						? Numerical.integrate(ds, start, t, count)
						: -Numerical.integrate(ds, t, start, count);
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds,
					forward ? a + guess : b - guess, 
					a, b, 16, 0.00001);
		}
	};
}, new function() { 
	function addLocation(locations, include, curve1, t1, point1, curve2, t2,
			point2) {
		var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
		if (!include || include(loc))
			locations.push(loc);
	}

	function addCurveIntersections(v1, v2, curve1, curve2, locations, include,
			tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
		if (recursion > 20)
			return;
		var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			tolerance = 0.00001,
			hullEpsilon = 1e-9,
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0,
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0,
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			tMinNew, tMaxNew, tDiff;
		if (q0x === q3x && uMax - uMin <= hullEpsilon && recursion > 3) {
			tMinNew = (tMax + tMin) / 2;
			tMaxNew = tMinNew;
			tDiff = 0;
		} else {
			var hull = getConvexHull(dp0, dp1, dp2, dp3),
				top = hull[0],
				bottom = hull[1],
				tMinClip, tMaxClip;
			tMinClip = clipConvexHull(top, bottom, dMin, dMax);
			top.reverse();
			bottom.reverse();
			tMaxClip = clipConvexHull(top, bottom, dMin, dMax);
			if (tMinClip == null || tMaxClip == null)
				return false;
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			tDiff = tMaxClip - tMinClip;
			tMinNew = tMax * tMinClip + tMin * (1 - tMinClip);
			tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip);
		}
		if (oldTDiff > 0.8 && tDiff > 0.8) {
			if (tMaxNew - tMinNew > uMax - uMin) {
				var parts = Curve.subdivide(v1, 0.5),
					t = tMinNew + (tMaxNew - tMinNew) / 2;
				addCurveIntersections(
					v2, parts[0], curve2, curve1, locations, include,
					uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					v2, parts[1], curve2, curve1, locations, include,
					uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
			} else {
				var parts = Curve.subdivide(v2, 0.5),
					t = uMin + (uMax - uMin) / 2;
				addCurveIntersections(
					parts[0], v1, curve2, curve1, locations, include,
					uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					parts[1], v1, curve2, curve1, locations, include,
					t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
			}
		} else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
			var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
				t2 = uMin + (uMax - uMin) / 2;
			if (reverse) {
				addLocation(locations, include,
						curve2, t2, Curve.evaluate(v2, t2, 0),
						curve1, t1, Curve.evaluate(v1, t1, 0));
			} else {
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		} else { 
			addCurveIntersections(v2, v1, curve2, curve1, locations, include,
					uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
		}
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			getSignedDistance = Line.getSignedDistance,
			dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1),
			dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2),
			flip = false,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
			flip = dist1 < 0;
		} else {
			var pmax, cross = 0,
				distZero = dist1 === 0 || dist2 === 0;
			if (Math.abs(dist1) > Math.abs(dist2)) {
				pmax = p1;
				cross = (dq3 - dq2 - (dq3 - dq0) / 3)
						* (2 * (dq3 - dq2) - dq3 + dq1) / 3;
			} else {
				pmax = p2;
				cross = (dq1 - dq0 + (dq0 - dq3) / 3)
						* (-2 * (dq0 - dq1) + dq0 - dq2) / 3;
			}
			hull = cross < 0 || distZero
					? [[p0, pmax, p3], [p0, p3]]
					: [[p0, p1, p2, p3], [p0, p3]];
			flip = dist1 ? dist1 < 0 : dist2 < 0;
		}
		return flip ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		var tProxy,
			tVal = null,
			px, py,
			qx, qy;
		for (var i = 0, l = hullBottom.length - 1; i < l; i++) {
			py = hullBottom[i][1];
			qy = hullBottom[i + 1][1];
			if (py < qy) {
				tProxy = null;
			} else if (qy <= dMax) {
				px = hullBottom[i][0];
				qx = hullBottom[i + 1][0];
				tProxy = px + (dMax  - py) * (qx - px) / (qy - py);
			} else {
				continue;
			}
			break;
		}
		if (hullTop[0][1] <= dMax)
			tProxy = hullTop[0][0];
		for (var i = 0, l = hullTop.length - 1; i < l; i++) {
			py = hullTop[i][1];
			qy = hullTop[i + 1][1];
			if (py >= dMin) {
				tVal = tProxy;
			} else if (py > qy) {
				tVal = null;
			} else if (qy >= dMin) {
				px = hullTop[i][0];
				qx = hullTop[i + 1][0];
				tVal = px + (dMin  - py) * (qx - px) / (qy - py);
			} else {
				continue;
			}
			break;
		}
		return tVal;
	}

	function addCurveLineIntersections(v1, v2, curve1, curve2, locations,
			include) {
		var flip = Curve.isLinear(v1),
			vc = flip ? v2 : v1,
			vl = flip ? v1 : v2,
			lx1 = vl[0], ly1 = vl[1],
			lx2 = vl[6], ly2 = vl[7],
			ldx = lx2 - lx1,
			ldy = ly2 - ly1,
			angle = Math.atan2(-ldy, ldx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rlx2 = ldx * cos - ldy * sin,
			rvl = [0, 0, 0, 0, rlx2, 0, rlx2, 0],
			rvc = [];
		for(var i = 0; i < 8; i += 2) {
			var x = vc[i] - lx1,
				y = vc[i + 1] - ly1;
			rvc.push(
				x * cos - y * sin,
				y * cos + x * sin);
		}
		var roots = [],
			count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
		for (var i = 0; i < count; i++) {
			var tc = roots[i],
				x = Curve.evaluate(rvc, tc, 0).x;
			if (x >= 0 && x <= rlx2) {
				var tl = Curve.getParameterOf(rvl, x, 0),
					t1 = flip ? tl : tc,
					t2 = flip ? tc : tl;
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		}
	}

	function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
		var point = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (point) {
			var x = point.x,
				y = point.y;
			addLocation(locations, include,
					curve1, Curve.getParameterOf(v1, x, y), point,
					curve2, Curve.getParameterOf(v2, x, y), point);
		}
	}

	return { statics: {
		getIntersections: function(v1, v2, curve1, curve2, locations, include) {
			var linear1 = Curve.isLinear(v1),
				linear2 = Curve.isLinear(v2);
			(linear1 && linear2
				? addLineIntersection
				: linear1 || linear2
					? addCurveLineIntersections
					: addCurveIntersections)(
						v1, v2, curve1, curve2, locations, include,
						0, 1, 0, 1, 0, false, 0);
			return locations;
		}
	}};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',
	beans: true,

	initialize: function CurveLocation(curve, parameter, point, _curve2,
			_parameter2, _point2, _distance) {
		this._id = CurveLocation._id = (CurveLocation._id || 0) + 1;
		this._curve = curve;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
		this._parameter = parameter;
		this._point = point;
		this._curve2 = _curve2;
		this._parameter2 = _parameter2;
		this._point2 = _point2;
		this._distance = _distance;
	},

	getSegment: function(_preferFirst) {
		if (!this._segment) {
			var curve = this.getCurve(),
				parameter = this.getParameter();
			if (parameter === 1) {
				this._segment = curve._segment2;
			} else if (parameter === 0 || _preferFirst) {
				this._segment = curve._segment1;
			} else if (parameter == null) {
				return null;
			} else {
				this._segment = curve.getPartLength(0, parameter)
					< curve.getPartLength(parameter, 1)
						? curve._segment1
						: curve._segment2;
			}
		}
		return this._segment;
	},

	getCurve: function(_uncached) {
		if (!this._curve || _uncached) {
			this._curve = this._segment1.getCurve();
			if (this._curve.getParameterOf(this._point) == null)
				this._curve = this._segment2.getPrevious().getCurve();
		}
		return this._curve;
	},

	getIntersection: function() {
		var intersection = this._intersection;
		if (!intersection && this._curve2) {
			var param = this._parameter2;
			this._intersection = intersection = new CurveLocation(
					this._curve2, param, this._point2 || this._point, this);
			intersection._intersection = this;
		}
		return intersection;
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getOffset: function() {
		var path = this.getPath();
		return path && path._getOffset(this);
	},

	getCurveOffset: function() {
		var curve = this.getCurve(),
			parameter = this.getParameter();
		return parameter != null && curve && curve.getPartLength(0, parameter);
	},

	getParameter: function(_uncached) {
		if ((this._parameter == null || _uncached) && this._point) {
			var curve = this.getCurve(_uncached && this._point);
			this._parameter = curve && curve.getParameterOf(this._point);
		}
		return this._parameter;
	},

	getPoint: function(_uncached) {
		if ((!this._point || _uncached) && this._parameter != null) {
			var curve = this.getCurve();
			this._point = curve && curve.getPointAt(this._parameter, true);
		}
		return this._point;
	},

	getTangent: function() {
		var parameter = this.getParameter(),
			curve = this.getCurve();
		return parameter != null && curve && curve.getTangentAt(parameter, true);
	},

	getNormal: function() {
		var parameter = this.getParameter(),
			curve = this.getCurve();
		return parameter != null && curve && curve.getNormalAt(parameter, true);
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(true);
		return curve && curve.divide(this.getParameter(true), true);
	},

	split: function() {
		var curve = this.getCurve(true);
		return curve && curve.split(this.getParameter(true), true);
	},

	equals: function(loc) {
		var isZero = Numerical.isZero;
		return this === loc
				|| loc
					&& this._curve === loc._curve
					&& this._curve2 === loc._curve2
					&& isZero(this._parameter - loc._parameter)
					&& isZero(this._parameter2 - loc._parameter2)
				|| false;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var parameter = this.getParameter();
		if (parameter != null)
			parts.push('parameter: ' + f.number(parameter));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	}
});

var PathItem = Item.extend({
	_class: 'PathItem',

	initialize: function PathItem() {
	},

	getIntersections: function(path, _expand) {
		if (this === path)
			path = null;
		if (path && !this.getBounds().touches(path.getBounds()))
			return [];
		var locations = [],
			curves1 = this.getCurves(),
			curves2 = path ? path.getCurves() : curves1,
			matrix1 = this._matrix.orNullIfIdentity(),
			matrix2 = path ? path._matrix.orNullIfIdentity() : matrix1,
			length1 = curves1.length,
			length2 = path ? curves2.length : length1,
			values2 = [],
			MIN = 1e-11,
			MAX = 1 - 1e-11;
		for (var i = 0; i < length2; i++)
			values2[i] = curves2[i].getValues(matrix2);
		for (var i = 0; i < length1; i++) {
			var curve1 = curves1[i],
				values1 = path ? curve1.getValues(matrix1) : values2[i];
			if (!path) {
				var seg1 = curve1.getSegment1(),
					seg2 = curve1.getSegment2(),
					h1 = seg1._handleOut,
					h2 = seg2._handleIn;
				if (new Line(seg1._point.subtract(h1), h1.multiply(2), true)
						.intersect(new Line(seg2._point.subtract(h2),
						h2.multiply(2), true), false)) {
					var parts = Curve.subdivide(values1);
					Curve.getIntersections(
						parts[0], parts[1], curve1, curve1, locations,
						function(loc) {
							if (loc._parameter <= MAX) {
								loc._parameter /= 2;
								loc._parameter2 = 0.5 + loc._parameter2 / 2;
								return true;
							}
						}
					);
				}
			}
			for (var j = path ? 0 : i + 1; j < length2; j++) {
				Curve.getIntersections(
					values1, values2[j], curve1, curves2[j], locations,
					!path && (j === i + 1 || j === length2 - 1 && i === 0)
						&& function(loc) {
							var t = loc._parameter;
							return t >= MIN && t <= MAX;
						}
				);
			}
		}
		var last = locations.length - 1;
		for (var i = last; i >= 0; i--) {
			var loc = locations[i],
				next = loc._curve.getNext(),
				next2 = loc._curve2.getNext();
			if (next && loc._parameter >= MAX) {
				loc._parameter = 0;
				loc._curve = next;
			}
			if (next2 && loc._parameter2 >= MAX) {
				loc._parameter2 = 0;
				loc._curve2 = next2;
			}
		}

		function compare(loc1, loc2) {
			var path1 = loc1.getPath(),
				path2 = loc2.getPath();
			return path1 === path2
					? (loc1.getIndex() + loc1.getParameter())
							- (loc2.getIndex() + loc2.getParameter())
					: path1._id - path2._id;
		}

		if (last > 0) {
			locations.sort(compare);
			for (var i = last; i >= 0; i--) {
				if (locations[i].equals(locations[i === 0 ? last : i - 1])) {
					locations.splice(i, 1);
					last--;
				}
			}
		}
		if (_expand) {
			for (var i = last; i >= 0; i--)
				locations.push(locations[i].getIntersection());
			locations.sort(compare);
		}
		return locations;
	},

	setPathData: function(data) {

		var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current = start);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				if (move && previous && previous !== 'z')
					this.closePath(true);
				for (var j = 0; j < length; j += 2)
					this[j === 0 && move ? 'moveTo' : 'lineTo'](
							current = getPoint(j));
				control = current;
				if (move)
					start = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[0], +coords[1]),
							+coords[2], +coords[4], +coords[3]);
				}
				break;
			case 'z':
				this.closePath(true);
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = this._getWinding(point, false, true);
		return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
	}

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		var segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: arguments
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? arguments
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined; 
			this._selectedSegmentState = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return Base.equals(this._segments, item._segments);
	},

	clone: function(insert) {
		var copy = new Path(Item.NO_INSERT);
		copy.setSegments(this._segments);
		copy._closed = this._closed;
		if (this._clockwise !== undefined)
			copy._clockwise = this._clockwise;
		return this._clone(copy, insert);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			var parent = this._parent;
			if (parent)
				parent._currentPath = undefined;
			this._length = this._clockwise = undefined;
			if (this._curves && !(flags & 16)) {
				for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
			this._monoCurves = undefined;
		} else if (flags & 32) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected();
		this._segments.length = 0;
		this._selectedSegmentState = 0;
		this._curves = undefined;
		if (segments && segments.length > 0)
			this._add(Segment.readAll(segments));
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(25);
		}
	}
}, {
	beans: true,

	getPathData: function(_precision) {
		var segments = this._segments,
			f = Formatter.instance,
			parts = [];

		function addCurve(seg1, seg2, skipLine) {
			var point1 = seg1._point,
				point2 = seg2._point,
				handle1 = seg1._handleOut,
				handle2 = seg2._handleIn;
			if (handle1.isZero() && handle2.isZero()) {
				if (!skipLine) {
					parts.push('L' + f.point(point2, _precision));
				}
			} else {
				var end = point2.subtract(point1);
				parts.push('c' + f.point(handle1, _precision)
						+ ' ' + f.point(end.add(handle2), _precision)
						+ ' ' + f.point(end, _precision));
			}
		}

		if (segments.length === 0)
			return '';
		parts.push('M' + f.point(segments[0]._point));
		for (var i = 0, l = segments.length  - 1; i < l; i++)
			addCurve(segments[i], segments[i + 1], false);
		if (this._closed) {
			addCurve(segments[segments.length - 1], segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	}
}, {

	isEmpty: function() {
		return this._segments.length === 0;
	},

	isPolygon: function() {
		for (var i = 0, l = this._segments.length; i < l; i++) {
			if (!this._segments[i].isLinear())
				return false;
		}
		return true;
	},

	_transformContent: function(matrix) {
		var coords = new Array(6);
		for (var i = 0, l = this._segments.length; i < l; i++)
			this._segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selectionState)
				this._updateSelection(segment, 0, segment._selectionState);
		}
		if (append) {
			segments.push.apply(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves || segs._curves) {
			if (!curves)
				curves = this._curves = [];
			var from = index > 0 ? index - 1 : index,
				start = from,
				to = Math.min(from + amount, this._countCurves());
			if (segs._curves) {
				curves.splice.apply(curves, [from, 0].concat(segs._curves));
				start += segs._curves.length;
			}
			for (var i = start; i < to; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(from, to);
		}
		this._changed(25);
		return segs;
	},

	_adjustCurves: function(from, to) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = from; i < to; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
		}
		if (curve = curves[this._closed && from === 0 ? segments.length - 1
				: from - 1])
			curve._segment2 = segments[from] || segments[0];
		if (curve = curves[to])
			curve._segment1 = segments[to];
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		return arguments.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments))
			: this._add([ Segment.read(arguments) ])[0];
	},

	insert: function(index, segment1 ) {
		return arguments.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments, 1), index)
			: this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readAll(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readAll(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(from, to, _includeCurves) {
		from = from || 0;
		to = Base.pick(to, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length, 
			removed = segments.splice(from, to - from),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selectionState)
				this._updateSelection(segment, segment._selectionState, 0);
			segment._index = segment._path = null;
		}
		for (var i = from, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = from > 0 && to === count + (this._closed ? 1 : 0)
					? from - 1
					: from,
				curves = curves.splice(index, amount);
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(25);
		return removed;
	},

	clear: '#removeSegments',

	isFullySelected: function() {
		var length = this._segments.length;
		return this._selected && length > 0 && this._selectedSegmentState
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelected: function setSelected(selected) {
		if (!selected)
			this._selectSegments(false);
		setSelected.base.call(this, selected);
	},

	_selectSegments: function(selected) {
		var length = this._segments.length;
		this._selectedSegmentState = selected
				? length * 7 : 0;
		for (var i = 0; i < length; i++)
			this._segments[i]._selectionState = selected
					? 7 : 0;
	},

	_updateSelection: function(segment, oldState, newState) {
		segment._selectionState = newState;
		var total = this._selectedSegmentState += newState - oldState;
		if (total > 0)
			this.setSelected(true);
	},

	flatten: function(maxDistance) {
		var flattener = new PathFlattener(this),
			pos = 0,
			step = flattener.length / Math.ceil(flattener.length / maxDistance),
			end = flattener.length + (this._closed ? -step : step) / 2;
		var segments = [];
		while (pos <= end) {
			segments.push(new Segment(flattener.evaluate(pos, 0)));
			pos += step;
		}
		this.setSegments(segments);
	},

	reduce: function() {
		var curves = this.getCurves();
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (curve.isLinear() && curve.getLength() === 0)
				curve.remove();
		}
		return this;
	},

	simplify: function(tolerance) {
		if (this._segments.length > 2) {
			var fitter = new PathFitter(this, tolerance || 2.5);
			this.setSegments(fitter.fit());
		}
	},

	split: function(index, parameter) {
		if (parameter === null)
			return;
		if (arguments.length === 1) {
			var arg = index;
			if (typeof arg === 'number')
				arg = this.getLocationAt(arg);
			index = arg.index;
			parameter = arg.parameter;
		}
		var tolerance = 0.00001;
		if (parameter >= 1 - tolerance) {
			index++;
			parameter--;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (parameter > tolerance) {
				curves[index++].divide(parameter, true);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else if (index > 0) {
				path = this._clone(new Path().insertAbove(this, true));
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	isClockwise: function() {
		if (this._clockwise !== undefined)
			return this._clockwise;
		return Path.isClockwise(this._segments);
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
		this._clockwise = clockwise;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		if (this._clockwise !== undefined)
			this._clockwise = !this._clockwise;
	},

	join: function(path) {
		if (path) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (last1._point.equals(last2._point))
				path.reverse();
			var first1,
				first2 = path.getFirstSegment();
			if (last1._point.equals(first2._point)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				first1 = this.getFirstSegment();
				if (first1._point.equals(first2._point))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1._point.equals(last2._point)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path.closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.equals(last._point)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
	},

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves();
			this._length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				this._length += curves[i].getLength();
		}
		return this._length;
	},

	getArea: function() {
		var curves = this.getCurves();
		var area = 0;
		for (var i = 0, l = curves.length; i < l; i++)
			area += curves[i].getArea();
		return area;
	},

	_getOffset: function(location) {
		var index = location && location.getIndex();
		if (index != null) {
			var curves = this.getCurves(),
				offset = 0;
			for (var i = 0; i < index; i++)
				offset += curves[i].getLength();
			var curve = curves[index],
				parameter = location.getParameter();
			if (parameter > 0)
				offset += curve.getPartLength(0, parameter);
			return offset;
		}
		return null;
	},

	getLocationOf: function(point) { 
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getLocationAt: function(offset, isParameter) {
		var curves = this.getCurves(),
			length = 0;
		if (isParameter) {
			var index = ~~offset; 
			return curves[index].getLocationAt(offset - index, true);
		}
		for (var i = 0, l = curves.length; i < l; i++) {
			var start = length,
				curve = curves[i];
			length += curve.getLength();
			if (length > offset) {
				return curve.getLocationAt(offset - start);
			}
		}
		if (offset <= this.getLength())
			return new CurveLocation(curves[curves.length - 1], 1);
		return null;
	},

	getPointAt: function(offset, isParameter) {
		var loc = this.getLocationAt(offset, isParameter);
		return loc && loc.getPoint();
	},

	getTangentAt: function(offset, isParameter) {
		var loc = this.getLocationAt(offset, isParameter);
		return loc && loc.getTangent();
	},

	getNormalAt: function(offset, isParameter) {
		var loc = this.getLocationAt(offset, isParameter);
		return loc && loc.getNormal();
	},

	getNearestLocation: function(point) { 
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function(point) { 
		var point = Point.read(arguments);
		return this.getNearestLocation(point).getPoint();
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isColinear(i, j) {
			return segments[i].isColinear(segments[j]);
		}

		function isOrthogonal(i) {
			return segments[i].isOrthogonal();
		}

		function isArc(i) {
			return segments[i].isArc();
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (this.isPolygon() && segments.length === 4
				&& isColinear(0, 2) && isColinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isColinear(1, 5) && isColinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			shape.setStyle(this._style);
			if (insert || insert === undefined)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	_hitTest: function(point, options) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hasStroke = options.stroke && style.hasStroke(),
			hasFill = options.fill && style.hasFill(),
			radius = hasStroke ? style.getStrokeWidth() / 2
					: hasFill ? 0 : null;
		if (radius != null) {
			if (radius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = radius * style.getMiterLimit();
				strokePadding = tolerancePadding.add(new Point(radius, radius));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			if (join !== 'round' || cap !== 'round') {
				area = new Path({ internal: true, closed: true });
				if (closed || segment._index > 0
						&& segment._index < numSegments - 1) {
					if (join !== 'round' && (segment._handleIn.isZero()
							|| segment._handleOut.isZero()))
						Path._addBevelJoin(segment, join, radius, miterLimit,
								addToArea, true);
				} else if (cap !== 'round') {
					Path._addSquareCap(segment, cap, radius, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
			return isCloseEnough(segment._point, strokePadding);
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (radius != null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var parameter = loc.getParameter();
				if (parameter === 0 || parameter === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else  if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point) <= miterLimit
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hasFill && this._contains(point) || loc && !hasStroke
				? new HitResult('fill', this)
				: loc
					? new HitResult('stroke', this, {
						location: loc,
						point: loc.getPoint()
					})
					: null;
	}

}, new function() { 

	function drawHandles(ctx, segments, matrix, size) {
		var half = size / 2;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		var coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			var state = segment._selectionState,
				pX = coords[0],
				pY = coords[1];
			if (state & 1)
				drawHandle(2);
			if (state & 2)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (!(state & 4)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(i) {
			var segment = segments[i];
			if (matrix) {
				segment._transformCoordinates(matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX == curX && inY == curY && outX == prevX && outY == prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(i);
		if (path._closed && length > 0)
			drawSegment(0);
	}

	return {
		_draw: function(ctx, param) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip;
			if (!dontStart)
				ctx.beginPath();

			var style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontStart && this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this);
				if (this._closed)
					ctx.closePath();
				if (!dontStart)
					this._currentPath = ctx.currentPath;
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var flattener = new PathFlattener(this),
							length = flattener.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								flattener.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
}, new function() { 

	function getFirstControlPoints(rhs) {
		var n = rhs.length,
			x = [], 
			tmp = [], 
			b = 2;
		x[0] = rhs[0] / b;
		for (var i = 1; i < n; i++) {
			tmp[i] = 1 / b;
			b = (i < n - 1 ? 4 : 2) - tmp[i];
			x[i] = (rhs[i] - x[i - 1]) / b;
		}
		for (var i = 1; i < n; i++) {
			x[n - i - 1] -= tmp[n - i] * x[n - i];
		}
		return x;
	}

	return {
		smooth: function() {
			var segments = this._segments,
				size = segments.length,
				closed = this._closed,
				n = size,
				overlap = 0;
			if (size <= 2)
				return;
			if (closed) {
				overlap = Math.min(size, 4);
				n += Math.min(size, overlap) * 2;
			}
			var knots = [];
			for (var i = 0; i < size; i++)
				knots[i + overlap] = segments[i]._point;
			if (closed) {
				for (var i = 0; i < overlap; i++) {
					knots[i] = segments[i + size - overlap]._point;
					knots[i + size + overlap] = segments[i]._point;
				}
			} else {
				n--;
			}
			var rhs = [];

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
			rhs[0] = knots[0]._x + 2 * knots[1]._x;
			rhs[n - 1] = 3 * knots[n - 1]._x;
			var x = getFirstControlPoints(rhs);

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
			rhs[0] = knots[0]._y + 2 * knots[1]._y;
			rhs[n - 1] = 3 * knots[n - 1]._y;
			var y = getFirstControlPoints(rhs);

			if (closed) {
				for (var i = 0, j = size; i < overlap; i++, j++) {
					var f1 = i / overlap,
						f2 = 1 - f1,
						ie = i + overlap,
						je = j + overlap;
					x[j] = x[i] * f1 + x[j] * f2;
					y[j] = y[i] * f1 + y[j] * f2;
					x[je] = x[ie] * f2 + x[je] * f1;
					y[je] = y[ie] * f2 + y[je] * f1;
				}
				n--;
			}
			var handleIn = null;
			for (var i = overlap; i <= n - overlap; i++) {
				var segment = segments[i - overlap];
				if (handleIn)
					segment.setHandleIn(handleIn.subtract(segment._point));
				if (i < n) {
					segment.setHandleOut(
							new Point(x[i], y[i]).subtract(segment._point));
					handleIn = i < n - 1
							? new Point(
								2 * knots[i + 1]._x - x[i + 1],
								2 * knots[i + 1]._y - y[i + 1])
							: new Point(
								(knots[n]._x + x[n - 1]) / 2,
								(knots[n]._y + y[n - 1]) / 2);
				}
			}
			if (closed && handleIn) {
				var segment = this._segments[0];
				segment.setHandleIn(handleIn.subtract(segment._point));
			}
		}
	};
}, new function() { 
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (segments.length === 0)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				t = Base.pick(Base.read(arguments), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(arguments),
				through,
				peek = Base.peek(arguments),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(arguments) <= 2) {
				through = to;
				to = Point.read(arguments);
			} else {
				var radius = Size.read(arguments);
				if (radius.isZero())
					return this.lineTo(to);
				var rotation = Base.read(arguments),
					clockwise = !!Base.read(arguments),
					large = !!Base.read(arguments),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					abs = Math.abs,
					EPSILON = 1e-11,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq =  x * x,
					ySq =  y * y;
				var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < EPSILON)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1)
							* Math.sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center);
				if (centerSide === 0) {
					extent = throughSide * Math.abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			var ext = Math.abs(extent),
				count =  ext >= 360 ? 4 : Math.ceil(ext / 90),
				inc = extent / count,
				half = inc * Math.PI / 360,
				z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
				segments = [];
			for (var i = 0; i <= count; i++) {
				var pt = to,
					out = null;
				if (i < count) {
					out = vector.rotate(90).multiply(z);
					if (matrix) {
						pt = matrix._transformPoint(vector);
						out = matrix._transformPoint(vector.add(out))
								.subtract(pt);
					} else {
						pt = center.add(vector);
					}
				}
				if (i === 0) {
					current.setHandleOut(out);
				} else {
					var _in = vector.rotate(-90).multiply(z);
					if (matrix) {
						_in = matrix._transformPoint(vector.add(_in))
								.subtract(pt);
					}
					segments.push(new Segment(pt, _in, out));
				}
				vector = vector.rotate(inc);
			}
			this._add(segments);
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				parameter = Base.read(arguments),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var current = getCurrentSegment(this)._point,
				point = current.add(Point.read(arguments)),
				clockwise = Base.pick(Base.peek(arguments), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(arguments)));
			}
		},

		closePath: function(join) {
			this.setClosed(true);
			if (join)
				this.join();
		}
	};
}, {  

	_getBounds: function(getter, matrix) {
		return Path[getter](this._segments, this._closed, this.getStyle(),
				matrix);
	},

statics: {
	isClockwise: function(segments) {
		var sum = 0;
		for (var i = 0, l = segments.length; i < l; i++) {
			var v = Curve.getValues(
					segments[i], segments[i + 1 < l ? i + 1 : 0]);
			for (var j = 2; j < 8; j += 2)
				sum += (v[j - 2] - v[j]) * (v[j + 1] + v[j - 1]);
		}
		return sum > 0;
	},

	getBounds: function(segments, closed, style, matrix, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6), false),
			min = prevCoords.slice(0, 2), 
			max = min.slice(), 
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords, false);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i], 
					prevCoords[i + 4], 
					coords[i + 2], 
					coords[i], 
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, style, matrix) {
		if (!style.hasStroke())
			return Path.getBounds(segments, closed, style, matrix);
		var length = segments.length - (closed ? 0 : 1),
			radius = style.getStrokeWidth() / 2,
			padding = Path._getPenPadding(radius, matrix),
			bounds = Path.getBounds(segments, closed, style, matrix, padding),
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = radius * style.getMiterLimit();
		var joinBounds = new Rectangle(new Size(padding).multiply(2));

		function add(point) {
			bounds = bounds.include(matrix
				? matrix._transformPoint(point, point) : point);
		}

		function addRound(segment) {
			bounds = bounds.unite(joinBounds.setCenter(matrix
				? matrix._transformPoint(segment._point) : segment._point));
		}

		function addJoin(segment, join) {
			var handleIn = segment._handleIn,
				handleOut = segment._handleOut
			if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
					&& handleIn.isColinear(handleOut)) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, radius, miterLimit, add);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, radius, add);
			}
		}

		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getPenPadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var mx = matrix.shiftless(),
			hor = mx.transform(new Point(radius, 0)),
			ver = mx.transform(new Point(0, radius)),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = -Math.atan(b * tan / a),
			ty = Math.atan(b / (tan * a));
		return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPointAt(0, true),
			normal1 = curve1.getNormalAt(1, true),
			normal2 = curve2.getNormalAt(0, true),
			step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
		normal1.setLength(step);
		normal2.setLength(step);
		if (area) {
			addPoint(point);
			addPoint(point.add(normal1));
		}
		if (join === 'miter') {
			var corner = new Line(
					point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(
					point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit) {
				addPoint(corner);
				if (!area)
					return;
			}
		}
		if (!area)
			addPoint(point.add(normal1));
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, addPoint, area) {
		var point = segment._point,
			loc = segment.getLocation(),
			normal = loc.getNormal().normalize(radius);
		if (area) {
			addPoint(point.subtract(normal));
			addPoint(point.add(normal));
		}
		if (cap === 'square')
			point = point.add(normal.rotate(loc.getParameter() == 0 ? -90 : 90));
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, style, matrix, strokePadding,
			joinPadding) {
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			for (var j = 0; j < 6; j += 2) {
				var padding = j == 0 ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	getRoughBounds: function(segments, closed, style, matrix) {
		var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
			joinRadius = strokeRadius;
		if (strokeRadius > 0) {
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
		}
		return Path.getHandleBounds(segments, closed, style, matrix,
				Path._getPenPadding(strokeRadius, matrix),
				Path._getPenPadding(joinRadius, matrix));
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert === false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props);
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			return createPath([
				new Segment(Point.readNamed(arguments, 'from')),
				new Segment(Point.readNamed(arguments, 'to'))
			], false, arguments);
		},

		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createEllipse(center, new Size(radius), arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.readNamed(arguments, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, arguments);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments);
			return createEllipse(ellipse.center, ellipse.radius, arguments);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var from = Point.readNamed(arguments, 'from'),
				through = Point.readNamed(arguments, 'through'),
				to = Point.readNamed(arguments, 'to'),
				props = Base.getNamed(arguments),
				path = new Path(props && props.insert === false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var center = Point.readNamed(arguments, 'center'),
				sides = Base.readNamed(arguments, 'sides'),
				radius = Base.readNamed(arguments, 'radius'),
				step = 360 / sides,
				three = !(sides % 3),
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, arguments);
		},

		Star: function() {
			var center = Point.readNamed(arguments, 'center'),
				points = Base.readNamed(arguments, 'points') * 2,
				radius1 = Base.readNamed(arguments, 'radius1'),
				radius2 = Base.readNamed(arguments, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, arguments);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items, _preserve) {
		items = insertChildren.base.call(this, index, items, _preserve, Path);
		for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
			var item = items[i];
			if (item._clockwise === undefined)
				item.setClockwise(item._index === 0);
		}
		return items;
	},

	reverse: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].reverse();
	},

	smooth: function() {
		for (var i = 0, l = this._children.length; i < l; i++)
			this._children[i].smooth();
	},

	isClockwise: function() {
		var child = this.getFirstChild();
		return child && child.isClockwise();
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() !== !!clockwise)
			this.reverse();
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++)
			curves.push.apply(curves, children[i].getCurves());
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getFirstCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	}
}, {
	beans: true,

	getPathData: function(_precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++)
			paths.push(children[i].getPathData(_precision));
		return paths.join(' ');
	}
}, {
	_getChildHitTestOptions: function(options) {
		return options.type === 'path'
				? options
				: new Base(options, { fill: false });
	},

	_draw: function(ctx, param) {
		var children = this._children;
		if (children.length === 0)
			return;

		if (this._currentPath) {
			ctx.currentPath = this._currentPath;
		} else {
			param = param.extend({ dontStart: true, dontFinish: true });
			ctx.beginPath();
			for (var i = 0, l = children.length; i < l; i++)
				children[i].draw(ctx, param);
			this._currentPath = ctx.currentPath;
		}

		if (!param.clip) {
			this._setStyles(ctx);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			child._drawSelected(ctx, mx.isIdentity() ? matrix
					: matrix.clone().concatenate(child._matrix));
		}
	}
}, new function() { 
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && children.length === 0)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	var fields = {
		moveTo: function() {
			var current = getCurrentPath(this),
				path = current && current.isEmpty() ? current : new Path();
			if (path !== current)
				this.addChild(path);
			path.moveTo.apply(path, arguments);
		},

		moveBy: function() {
			var current = getCurrentPath(this, true),
				last = current && current.getLastSegment(),
				point = Point.read(arguments);
			this.moveTo(last ? point.add(last._point) : point);
		},

		closePath: function(join) {
			getCurrentPath(this, true).closePath(join);
		}
	};

	Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
			'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
			function(key) {
				fields[key] = function() {
					var path = getCurrentPath(this, true);
					path[key].apply(path, arguments);
				};
			}
	);

	return fields;
});

PathItem.inject(new function() {
	function computeBoolean(path1, path2, operator, subtract) {
		function preparePath(path) {
			return path.clone(false).reduce().reorient().transform(null, true);
		}

		var _path1 = preparePath(path1),
			_path2 = path2 && path1 !== path2 && preparePath(path2);
		if (!_path1.isClockwise())
			_path1.reverse();
		if (_path2 && !(subtract ^ _path2.isClockwise()))
			_path2.reverse();
		splitPath(_path1.getIntersections(_path2, true));

		var chain = [],
			windings = [],
			lengths = [],
			segments = [],
			monoCurves = [];

		function collect(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				segments.push.apply(segments, path._segments);
				monoCurves.push.apply(monoCurves, path._getMonoCurves());
			}
		}

		collect(_path1._children || [_path1]);
		if (_path2)
			collect(_path2._children || [_path2]);
		segments.sort(function(a, b) {
			var _a = a._intersection,
				_b = b._intersection;
			return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1;
		});
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			if (segment._winding != null)
				continue;
			chain.length = windings.length = lengths.length = 0;
			var totalLength = 0,
				startSeg = segment;
			do {
				chain.push(segment);
				lengths.push(totalLength += segment.getCurve().getLength());
				segment = segment.getNext();
			} while (segment && !segment._intersection && segment !== startSeg);
			for (var j = 0; j < 3; j++) {
				var length = totalLength * Math.random(),
					amount = lengths.length,
					k = 0;
				do {
					if (lengths[k] >= length) {
						if (k > 0)
							length -= lengths[k - 1];
						break;
					}
				} while (++k < amount);
				var curve = chain[k].getCurve(),
					point = curve.getPointAt(length),
					hor = curve.isHorizontal(),
					path = curve._path;
				if (path._parent instanceof CompoundPath)
					path = path._parent;
				windings[j] = subtract && _path2
						&& (path === _path1 && _path2._getWinding(point, hor)
						|| path === _path2 && !_path1._getWinding(point, hor))
						? 0
						: getWinding(point, monoCurves, hor);
			}
			windings.sort();
			var winding = windings[1];
			for (var j = chain.length - 1; j >= 0; j--)
				chain[j]._winding = winding;
		}
		var result = new CompoundPath();
		result.addChildren(tracePaths(segments, operator), true);
		_path1.remove();
		if (_path2)
			_path2.remove();
		return result.reduce();
	}

	function splitPath(intersections) {
		var TOLERANCE = 0.00001,
			linearSegments;

		function resetLinear() {
			for (var i = 0, l = linearSegments.length; i < l; i++) {
				var segment = linearSegments[i];
				segment._handleOut.set(0, 0);
				segment._handleIn.set(0, 0);
			}
		}

		for (var i = intersections.length - 1, curve, prevLoc; i >= 0; i--) {
			var loc = intersections[i],
				t = loc._parameter;
			if (prevLoc && prevLoc._curve === loc._curve
					&& prevLoc._parameter > 0) {
				t /= prevLoc._parameter;
			} else {
				if (linearSegments)
					resetLinear();
				curve = loc._curve;
				linearSegments = curve.isLinear() && [];
			}
			var newCurve,
				segment;
			if (newCurve = curve.divide(t, true, true)) {
				segment = newCurve._segment1;
				curve = newCurve.getPrevious();
			} else {
				segment = t < TOLERANCE
					? curve._segment1
					: t > 1 - TOLERANCE
						? curve._segment2
						: curve.getPartLength(0, t) < curve.getPartLength(t, 1)
							? curve._segment1
							: curve._segment2;
			}
			segment._intersection = loc.getIntersection();
			loc._segment = segment;
			if (linearSegments)
				linearSegments.push(segment);
			prevLoc = loc;
		}
		if (linearSegments)
			resetLinear();
	}

	function getWinding(point, curves, horizontal, testContains) {
		var TOLERANCE = 0.00001,
			x = point.x,
			y = point.y,
			windLeft = 0,
			windRight = 0,
			roots = [],
			abs = Math.abs,
			MAX = 1 - TOLERANCE;
		if (horizontal) {
			var yTop = -Infinity,
				yBottom = Infinity,
				yBefore = y - TOLERANCE,
				yAfter = y + TOLERANCE;
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if (Curve.solveCubic(values, 0, x, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--) {
						var y0 = Curve.evaluate(values, roots[j], 0).y;
						if (y0 < yBefore && y0 > yTop) {
							yTop = y0;
						} else if (y0 > yAfter && y0 < yBottom) {
							yBottom = y0;
						}
					}
				}
			}
			yTop = (yTop + y) / 2;
			yBottom = (yBottom + y) / 2;
			if (yTop > -Infinity)
				windLeft = getWinding(new Point(x, yTop), curves);
			if (yBottom < Infinity)
				windRight = getWinding(new Point(x, yBottom), curves);
		} else {
			var xBefore = x - TOLERANCE,
				xAfter = x + TOLERANCE;
			for (var i = 0, l = curves.length; i < l; i++) {
				var curve = curves[i],
					values = curve.values,
					winding = curve.winding,
					next = curve.next;
				if (winding && (winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
					&& Curve.solveCubic(values, 1, y, roots, 0,
						!next.winding && next.values[1] === y ? 1 : MAX) === 1){
					var t = roots[0],
						x0 = Curve.evaluate(values, t, 0).x,
						slope = Curve.evaluate(values, t, 1).y;
					if (abs(slope) < TOLERANCE && !Curve.isLinear(values)
							|| t < TOLERANCE && slope * Curve.evaluate(
								curve.previous.values, t, 1).y < 0) {
						if (testContains && x0 >= xBefore && x0 <= xAfter) {
							++windLeft;
							++windRight;
						}
					} else if (x0 <= xBefore) {
						windLeft += winding;
					} else if (x0 >= xAfter) {
						windRight += winding;
					}
				}
			}
		}
		return Math.max(abs(windLeft), abs(windRight));
	}

	function tracePaths(segments, operator, selfOp) {
		operator = operator || function() {
			return true;
		};
		var paths = [],
			ZERO = 1e-3,
			ONE = 1 - 1e-3;
		for (var i = 0, seg, startSeg, l = segments.length; i < l; i++) {
			seg = startSeg = segments[i];
			if (seg._visited || !operator(seg._winding))
				continue;
			var path = new Path(Item.NO_INSERT),
				inter = seg._intersection,
				startInterSeg = inter && inter._segment,
				added = false, 
				dir = 1;
			do {
				var handleIn = dir > 0 ? seg._handleIn : seg._handleOut,
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn,
					interSeg;
				if (added && (!operator(seg._winding) || selfOp)
						&& (inter = seg._intersection)
						&& (interSeg = inter._segment)
						&& interSeg !== startSeg) {
					if (selfOp) {
						seg._visited = interSeg._visited;
						seg = interSeg;
						dir = 1;
					} else {
						var c1 = seg.getCurve();
						if (dir > 0)
							c1 = c1.getPrevious();
						var t1 = c1.getTangentAt(dir < 1 ? ZERO : ONE, true),
							c4 = interSeg.getCurve(),
							c3 = c4.getPrevious(),
							t3 = c3.getTangentAt(ONE, true),
							t4 = c4.getTangentAt(ZERO, true),
							w3 = t1.cross(t3),
							w4 = t1.cross(t4);
						if (w3 * w4 !== 0) {
							var curve = w3 < w4 ? c3 : c4,
								nextCurve = operator(curve._segment1._winding)
									? curve
									: w3 < w4 ? c4 : c3,
								nextSeg = nextCurve._segment1;
							dir = nextCurve === c3 ? -1 : 1;
							if (nextSeg._visited && seg._path !== nextSeg._path
										|| !operator(nextSeg._winding)) {
								dir = 1;
							} else {
								seg._visited = interSeg._visited;
								seg = interSeg;
								if (nextSeg._visited)
									dir = 1;
							}
						} else {
							dir = 1;
						}
					}
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
				}
				path.add(new Segment(seg._point, added && handleIn, handleOut));
				added = true;
				seg._visited = true;
				seg = dir > 0 ? seg.getNext() : seg. getPrevious();
			} while (seg && !seg._visited
					&& seg !== startSeg && seg !== startInterSeg
					&& (seg._intersection || operator(seg._winding)));
			if (seg && (seg === startSeg || seg === startInterSeg)) {
				path.firstSegment.setHandleIn((seg === startInterSeg
						? startInterSeg : seg)._handleIn);
				path.setClosed(true);
			} else {
				path.lastSegment._handleOut.set(0, 0);
			}
			if (path._segments.length >
					(path._closed ? path.isPolygon() ? 2 : 0 : 1))
				paths.push(path);
		}
		return paths;
	}

	return {
		_getWinding: function(point, horizontal, testContains) {
			return getWinding(point, this._getMonoCurves(),
					horizontal, testContains);
		},

		unite: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 1 || w === 0;
			}, false);
		},

		intersect: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 2;
			}, false);
		},

		subtract: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 1;
			}, true);
		},

		exclude: function(path) {
			return new Group([this.subtract(path), path.subtract(this)]);
		},

		divide: function(path) {
			return new Group([this.subtract(path), this.intersect(path)]);
		}
	};
});

Path.inject({
	_getMonoCurves: function() {
		var monoCurves = this._monoCurves,
			prevCurve;

		function insertCurve(v) {
			var y0 = v[1],
				y1 = v[7],
				curve = {
					values: v,
					winding: y0 === y1
						? 0 
						: y0 > y1
							? -1 
							: 1, 
					previous: prevCurve,
					next: null 
				};
			if (prevCurve)
				prevCurve.next = curve;
			monoCurves.push(curve);
			prevCurve = curve;
		}

		function handleCurve(v) {
			if (Curve.getLength(v) === 0)
				return;
			var y0 = v[1],
				y1 = v[3],
				y2 = v[5],
				y3 = v[7];
			if (Curve.isLinear(v)) {
				insertCurve(v);
			} else {
				var a = 3 * (y1 - y2) - y0 + y3,
					b = 2 * (y0 + y2) - 4 * y1,
					c = y1 - y0,
					TOLERANCE = 0.00001,
					roots = [];
				var count = Numerical.solveQuadratic(a, b, c, roots, TOLERANCE,
						1 - TOLERANCE);
				if (count === 0) {
					insertCurve(v);
				} else {
					roots.sort();
					var t = roots[0],
						parts = Curve.subdivide(v, t);
					insertCurve(parts[0]);
					if (count > 1) {
						t = (roots[1] - t) / (1 - t);
						parts = Curve.subdivide(parts[1], t);
						insertCurve(parts[0]);
					}
					insertCurve(parts[1]);
				}
			}
		}

		if (!monoCurves) {
			monoCurves = this._monoCurves = [];
			var curves = this.getCurves(),
				segments = this._segments;
			for (var i = 0, l = curves.length; i < l; i++)
				handleCurve(curves[i].getValues());
			if (!this._closed && segments.length > 1) {
				var p1 = segments[segments.length - 1]._point,
					p2 = segments[0]._point,
					p1x = p1._x, p1y = p1._y,
					p2x = p2._x, p2y = p2._y;
				handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
			}
			if (monoCurves.length > 0) {
				var first = monoCurves[0],
					last = monoCurves[monoCurves.length - 1];
				first.previous = last;
				last.next = first;
			}
		}
		return monoCurves;
	},

	getInteriorPoint: function() {
		var bounds = this.getBounds(),
			point = bounds.getCenter(true);
		if (!this.contains(point)) {
			var curves = this._getMonoCurves(),
				roots = [],
				y = point.y,
				xIntercepts = [];
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if ((curves[i].winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
						&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--)
						xIntercepts.push(Curve.evaluate(values, roots[j], 0).x);
				}
				if (xIntercepts.length > 1)
					break;
			}
			point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
		}
		return point;
	},

	reorient: function() {
		this.setClockwise(true);
		return this;
	}
});

CompoundPath.inject({
	_getMonoCurves: function() {
		var children =  this._children,
			monoCurves = [];
		for (var i = 0, l = children.length; i < l; i++)
			monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
		return monoCurves;
	},

	reorient: function() {
		var children = this.removeChildren().sort(function(a, b) {
			return b.getBounds().getArea() - a.getBounds().getArea();
		});
		this.addChildren(children);
		var clockwise = children[0].isClockwise();
		for (var i = 1, l = children.length; i < l; i++) { 
			var point = children[i].getInteriorPoint(),
				counters = 0;
			for (var j = i - 1; j >= 0; j--) {
				if (children[j].contains(point))
					counters++;
			}
			children[i].setClockwise(counters % 2 === 0 && clockwise);
		}
		return this;
	}
});

var PathFlattener = Base.extend({
	initialize: function(path) {
		this.curves = []; 
		this.parts = []; 
		this.length = 0; 
		this.index = 0;

		var segments = path._segments,
			segment1 = segments[0],
			segment2,
			that = this;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2);
			that.curves.push(curve);
			that._computeParts(curve, segment1._index, 0, 1);
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2, segments[0]);
	},

	_computeParts: function(curve, index, minT, maxT) {
		if ((maxT - minT) > 1 / 32 && !Curve.isFlatEnough(curve, 0.25)) {
			var curves = Curve.subdivide(curve);
			var halfT = (minT + maxT) / 2;
			this._computeParts(curves[0], index, minT, halfT);
			this._computeParts(curves[1], index, halfT, maxT);
		} else {
			var x = curve[6] - curve[0],
				y = curve[7] - curve[1],
				dist = Math.sqrt(x * x + y * y);
			if (dist > 0.00001) {
				this.length += dist;
				this.parts.push({
					offset: this.length,
					value: maxT,
					index: index
				});
			}
		}
	},

	getParameterAt: function(offset) {
		var i, j = this.index;
		for (;;) {
			i = j;
			if (j == 0 || this.parts[--j].offset < offset)
				break;
		}
		for (var l = this.parts.length; i < l; i++) {
			var part = this.parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = this.parts[i - 1];
				var prevVal = prev && prev.index == part.index ? prev.value : 0,
					prevLen = prev ? prev.offset : 0;
				return {
					value: prevVal + (part.value - prevVal)
						* (offset - prevLen) /  (part.offset - prevLen),
					index: part.index
				};
			}
		}
		var part = this.parts[this.parts.length - 1];
		return {
			value: 1,
			index: part.index
		};
	},

	evaluate: function(offset, type) {
		var param = this.getParameterAt(offset);
		return Curve.evaluate(this.curves[param.index], param.value, type);
	},

	drawPart: function(ctx, from, to) {
		from = this.getParameterAt(from);
		to = this.getParameterAt(to);
		for (var i = from.index; i <= to.index; i++) {
			var curve = Curve.getPart(this.curves[i],
					i == from.index ? from.value : 0,
					i == to.index ? to.value : 1);
			if (i == from.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
});

var PathFitter = Base.extend({
	initialize: function(path, error) {
		this.points = [];
		var segments = path._segments,
			prev;
		for (var i = 0, l = segments.length; i < l; i++) {
			var point = segments[i].point.clone();
			if (!prev || !prev.equals(point)) {
				this.points.push(point);
				prev = point;
			}
		}
		this.error = error;
	},

	fit: function() {
		var points = this.points,
			length = points.length;
		this.segments = length > 0 ? [new Segment(points[0])] : [];
		if (length > 1)
			this.fitCubic(0, length - 1,
				points[1].subtract(points[0]).normalize(),
				points[length - 2].subtract(points[length - 1]).normalize());
		return this.segments;
	},

	fitCubic: function(first, last, tan1, tan2) {
		if (last - first == 1) {
			var pt1 = this.points[first],
				pt2 = this.points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(this.error, this.error * this.error),
			split;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < this.error) {
				this.addCurve(curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var V1 = this.points[split - 1].subtract(this.points[split]),
			V2 = this.points[split].subtract(this.points[split + 1]),
			tanCenter = V1.add(V2).divide(2).normalize();
		this.fitCubic(first, split, tan1, tanCenter);
		this.fitCubic(split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(curve) {
		var prev = this.segments[this.segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		this.segments.push(
				new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-11,
			pt1 = this.points[first],
			pt2 = this.points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = this.points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1, alpha2;
		if (Math.abs(detC0C1) > epsilon) {
			var detC0X  = C[0][0] * X[1]    - C[1][0] * X[0],
				detXC1  = X[0]    * C[1][1] - X[1]    * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			if (Math.abs(c0) > epsilon) {
				alpha1 = alpha2 = X[0] / c0;
			} else if (Math.abs(c1) > epsilon) {
				alpha1 = alpha2 = X[1] / c1;
			} else {
				alpha1 = alpha2 = 0;
			}
		}

		var segLength = pt2.getDistance(pt1);
		epsilon *= segLength;
		if (alpha1 < epsilon || alpha2 < epsilon) {
			alpha1 = alpha2 = segLength / 3;
		}

		return [pt1, pt1.add(tan1.normalize(alpha1)),
				pt2.add(tan2.normalize(alpha2)), pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		if (Math.abs(df) < 0.00001)
			return u;
		return u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y; 
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_boundsSelected: true,
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsGetter: 'getBounds',

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	_clone: function _clone(copy) {
		copy.setContent(this._content);
		return _clone.base.call(this, copy);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(265);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	clone: function(insert) {
		return this._clone(new PointText(Item.NO_INSERT), insert);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx) {
		if (!this._content)
			return;
		this._setStyles(ctx);
		var style = this._style,
			lines = this._lines,
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (style.hasFill()) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(getter, matrix) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var bounds = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
	}
});

var Color = Base.extend(new function() {

	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		colorCache = {},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
			components;
		if (match) {
			components = [0, 0, 0];
			for (var i = 0; i < 3; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^rgba?\((.*)\)$/)) {
			components = match[1].split(',');
			for (var i = 0, l = components.length; i < l; i++) {
				var value = +components[i];
				components[i] = i < 3 ? value / 255 : value;
			}
		} else {
			var cached = colorCache[string];
			if (!cached) {
				if (!colorCtx) {
					colorCtx = CanvasProvider.getContext(1, 1);
					colorCtx.globalCompositeOperation = 'copy';
				}
				colorCtx.fillStyle = 'rgba(0,0,0,0)';
				colorCtx.fillStyle = string;
				colorCtx.fillRect(0, 0, 1, 1);
				var data = colorCtx.getImageData(0, 0, 1, 1).data;
				cached = colorCache[string] = [
					data[0] / 255,
					data[1] / 255,
					data[2] / 255
				];
			}
			components = cached.slice();
		}
		return components;
	}

	var hsbIndices = [
		[0, 3, 1], 
		[2, 0, 1], 
		[1, 0, 3], 
		[1, 2, 0], 
		[3, 1, 0], 
		[0, 1, 2]  
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60; 
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h), 
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,						
					b * (1 - s),			
					b * (1 - s * f),		
					b * (1 - s * (1 - f))	
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60, 
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = name === 'gradient'
					? function(value) {
						var current = this._components[0];
						value = Gradient.read(Array.isArray(value) ? value
								: arguments, 0, { readNull: true });
						if (current !== value) {
							if (current)
								current._removeOwner(this);
							if (value)
								value._addOwner(this);
						}
						return value;
					}
					: type === 'gradient'
						? function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
						: function(value) {
							return value == null || isNaN(value) ? 0 : value;
						};

			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				value = parser.call(this, value);
				if (value != null) {
					this._components[index] = value;
					this._changed();
				}
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var slice = Array.prototype.slice,
				args = arguments,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (this.__read)
						read = 1; 
					args = slice.call(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (this.__read)
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					if (values.length > length)
						values = slice.call(values, 0, length);
				} else if (argType === 'string') {
					type = 'rgb';
					components = fromCSS(arg);
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type];
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && i === 0 && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (this.__read && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (type === 'gradient')
				this._id = Color._id = (Color._id || 0) + 1;
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (this.__read)
				this.__read = read;
		},

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner)
				this._owner._changed(65);
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this._alpha === col._alpha
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				canvasGradient;
			if (gradient._radial) {
				var radius = destination.getDistance(origin),
					highlight = components[3];
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i];
				canvasGradient.addColorStop(stop._rampPoint,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			}
		}
	});
}, new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

Base.each(Color._types, function(properties, type) {
	var ctor = this[Base.capitalize(type) + 'Color'] = function(arg) {
			var argType = arg != null && typeof arg,
				components = argType === 'object' && arg.length != null
					? arg
					: argType === 'string'
						? null
						: arguments;
			return components
					? new Color(type, components)
					: new Color(arg);
		};
	if (type.length == 3) {
		var acronym = type.toUpperCase();
		Color[acronym] = this[acronym + 'Color'] = ctor;
	}
}, Base.exports);

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = Gradient._id = (Gradient._id || 0) + 1;
		if (stops && this._set(stops))
			stops = radial = null;
		if (!this._stops)
			this.setStops(stops || ['white', 'black']);
		if (this._radial == null)
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
			this._owners[i]._changed();
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (this._owners.length === 0)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++)
			stops[i] = this._stops[i].clone();
		return new Gradient(stops);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (this.stops) {
			for (var i = 0, l = this._stops.length; i < l; i++)
				this._stops[i]._owner = undefined;
		}
		if (stops.length < 2)
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		this._stops = GradientStop.readAll(stops, 0, { clone: true });
		for (var i = 0, l = this._stops.length; i < l; i++) {
			var stop = this._stops[i];
			stop._owner = this;
			if (stop._defaultRamp)
				stop.setRampPoint(i / (l - 1));
		}
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient &&  this._class === gradient._class
				&& this._stops.length === gradient._stops.length) {
			for (var i = 0, l = this._stops.length; i < l; i++) {
				if (!this._stops[i].equals(gradient._stops[i]))
					return false;
			}
			return true;
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		if (arg0) {
			var color, rampPoint;
			if (arg1 === undefined && Array.isArray(arg0)) {
				color = arg0[0];
				rampPoint = arg0[1];
			} else if (arg0.color) {
				color = arg0.color;
				rampPoint = arg0.rampPoint;
			} else {
				color = arg0;
				rampPoint = arg1;
			}
			this.setColor(color);
			this.setRampPoint(rampPoint);
		}
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._rampPoint);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize([this._color, this._rampPoint], options, true,
				dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(65);
	},

	getRampPoint: function() {
		return this._rampPoint;
	},

	setRampPoint: function(rampPoint) {
		this._defaultRamp = rampPoint == null;
		this._rampPoint = rampPoint || 0;
		this._changed();
	},

	getColor: function() {
		return this._color;
	},

	setColor: function(color) {
		this._color = Color.read(arguments);
		if (this._color === color)
			this._color = color.clone();
		this._color._owner = this;
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._rampPoint == stop._rampPoint
				|| false;
	}
});

var Style = Base.extend(new function() {
	var defaults = {
		fillColor: undefined,
		strokeColor: undefined,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		windingRule: 'nonzero',
		shadowColor: undefined,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: undefined,
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		font: 'sans-serif', 
		leading: null,
		justification: 'left'
	};

	var flags = {
		strokeWidth: 97,
		strokeCap: 97,
		strokeJoin: 97,
		miterLimit: 97,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9, 
		leading: 9,
		justification: 9
	};

	var item = {},
		fields = {
			_defaults: defaults,
			_textDefaults: new Base(defaults, {
				fillColor: new Color() 
			}),
			beans: true
		};

	Base.each(defaults, function(value, key) {
		var isColor = /Color$/.test(key),
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children;
			if (children && children.length > 0
					&& !(owner instanceof CompoundPath)) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			} else {
				var old = this._values[key];
				if (old != value) {
					if (isColor) {
						if (old)
							old._owner = undefined;
						if (value && value.constructor === Color) {
							if (value._owner)
								value = value.clone();
							value._owner = owner;
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 65);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				value;
			if (!children || children.length === 0 || _dontMerge
					|| owner instanceof CompoundPath) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone)
						value = value.clone();
					this._values[key] = value;
				} else if (isColor && !(value && value.constructor === Color)) {
					this._values[key] = value = Color.read([value], 0,
							{ readNull: true, clone: true });
					if (value)
						value._owner = owner;
				}
				return value;
			}
			for (var i = 0, l = children.length; i < l; i++) {
				var childValue = children[i]._style[get]();
				if (i === 0) {
					value = childValue;
				} else if (!Base.equals(value, childValue)) {
					return undefined;
				}
			}
			return value;
		};

		item[get] = function() {
			return this._style[get]();
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Item.inject(item);
	return fields;
}, {
	_class: 'Style',

	initialize: function Style(style, _owner, _project) {
		this._values = {};
		this._owner = _owner;
		this._project = _owner && _owner._project || _project || paper.project;
		if (_owner instanceof TextItem)
			this._defaults = this._textDefaults;
		if (style)
			this.set(style);
	},

	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		return style === this || style && this._class === style._class
				&& Base.equals(this._values, style._values)
				|| false;
	},

	hasFill: function() {
		return !!this.getFillColor();
	},

	hasStroke: function() {
		return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		return !!this.getShadowColor() && this.getShadowBlur() > 0;
	},

	getView: function() {
		return this._project.getView();
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {

	var special = /^(checked|value|selected|disabled)$/i,
		translated = { text: 'textContent', html: 'innerHTML' },
		unitless = { lineHeight: 1, zoom: 1, zIndex: 1, opacity: 1 };

	function create(nodes, parent) {
		var res = [];
		for (var i =  0, l = nodes && nodes.length; i < l;) {
			var el = nodes[i++];
			if (typeof el === 'string') {
				el = document.createElement(el);
			} else if (!el || !el.nodeType) {
				continue;
			}
			if (Base.isPlainObject(nodes[i]))
				DomElement.set(el, nodes[i++]);
			if (Array.isArray(nodes[i]))
				create(nodes[i++], el);
			if (parent)
				parent.appendChild(el);
			res.push(el);
		}
		return res;
	}

	function handlePrefix(el, name, set, value) {
		var prefixes = ['webkit', 'moz', 'Moz', 'ms', 'o', ''],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		create: function(nodes, parent) {
			var isArray = Array.isArray(nodes),
				res = create(isArray ? nodes : arguments, isArray ? parent : null);
			return res.length == 1 ? res[0] : res;
		},

		find: function(selector, root) {
			return (root || document).querySelector(selector);
		},

		findAll: function(selector, root) {
			return (root || document).querySelectorAll(selector);
		},

		get: function(el, key) {
			return el
				? special.test(key)
					? key === 'value' || typeof el[key] !== 'string'
						? el[key]
						: true
					: key in translated
						? el[translated[key]]
						: el.getAttribute(key)
				: null;
		},

		set: function(el, key, value) {
			if (typeof key !== 'string') {
				for (var name in key)
					if (key.hasOwnProperty(name))
						this.set(el, name, key[name]);
			} else if (!el || value === undefined) {
				return el;
			} else if (special.test(key)) {
				el[key] = value;
			} else if (key in translated) {
				el[translated[key]] = value;
			} else if (key === 'style') {
				this.setStyle(el, value);
			} else if (key === 'events') {
				DomEvent.add(el, value);
			} else {
				el.setAttribute(key, value);
			}
			return el;
		},

		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getStyle: function(el, key) {
			return el && el.style[key] || this.getStyles(el)[key] || null;
		},

		setStyle: function(el, key, value) {
			if (typeof key !== 'string') {
				for (var name in key)
					if (key.hasOwnProperty(name))
						this.setStyle(el, name, key[name]);
			} else {
				if (/^-?[\d\.]+$/.test(value) && !(key in unitless))
					value += 'px';
				el.style[key] = value;
			}
			return el;
		},

		hasClass: function(el, cls) {
			return new RegExp('\\s*' + cls + '\\s*').test(el.className);
		},

		addClass: function(el, cls) {
			el.className = (el.className + ' ' + cls).trim();
		},

		removeClass: function(el, cls) {
			el.className = el.className.replace(
				new RegExp('\\s*' + cls + '\\s*'), ' ').trim();
		},

		remove: function(el) {
			if (el.parentNode)
				el.parentNode.removeChild(el);
		},

		removeChildren: function(el) {
			while (el.firstChild)
				el.removeChild(el.firstChild);
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop  || body.clientTop  || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return this.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return this.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return this.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !this.isInvisible(el) && this.getViewportBounds(el).intersects(
					this.getBounds(el, true));
		},

		getPrefixed: function(el, name) {
			return handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.addEventListener(parts[i], func, false);
		}
	},

	remove: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.removeEventListener(parts[i], func, false);
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	},

	stop: function(event) {
		event.stopPropagation();
		event.preventDefault();
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		focused = true,
		timer;

	DomEvent.add(window, {
		focus: function() {
			focused = true;
		},
		blur: function() {
			focused = false;
		}
	});

	function handleCallbacks() {
		for (var i = callbacks.length - 1; i >= 0; i--) {
			var entry = callbacks[i],
				func = entry[0],
				el = entry[1];
			if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
					|| focused) && DomElement.isInView(el)) {
				callbacks.splice(i, 1);
				func();
			}
		}
		if (nativeRequest) {
			if (callbacks.length) {
				nativeRequest(handleCallbacks);
			} else {
				requested = false;
			}
		}
	}

	return function(callback, element) {
		callbacks.push([callback, element]);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Callback, {
	_class: 'View',

	initialize: function View(project, element) {
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		var size;
		if (!this._pixelRatio)
			this._pixelRatio = window.devicePixelRatio || 1;
		this._id = element.getAttribute('id');
		if (this._id == null)
			element.setAttribute('id', this._id = 'view-' + View._id++);
		DomEvent.add(element, this._viewEvents);
		var none = 'none';
		DomElement.setPrefixed(element.style, {
			userSelect: none,
			touchAction: none,
			touchCallout: none,
			contentZooming: none,
			userDrag: none,
			tapHighlightColor: 'rgba(0,0,0,0)'
		});
		if (PaperScope.hasAttribute(element, 'resize')) {
			var offset = DomElement.getOffset(element, true),
				that = this;
			size = DomElement.getViewportBounds(element)
					.getSize().subtract(offset);
			this._windowEvents = {
				resize: function() {
					if (!DomElement.isInvisible(element))
						offset = DomElement.getOffset(element, true);
					that.setViewSize(DomElement.getViewportBounds(element)
							.getSize().subtract(offset));
				}
			};
			DomEvent.add(window, this._windowEvents);
		} else {
			size = DomElement.getSize(element);
			if (size.isNaN() || size.isZero()) {
				var getSize = function(name) {
					return element[name]
							|| parseInt(element.getAttribute(name), 10);
				};
				size = new Size(getSize('width'), getSize('height'));
			}
		}
		this._setViewSize(size);
		if (PaperScope.hasAttribute(element, 'stats')
				&& typeof Stats !== 'undefined') {
			this._stats = new Stats();
			var stats = this._stats.domElement,
				style = stats.style,
				offset = DomElement.getOffset(element);
			style.position = 'absolute';
			style.left = offset.x + 'px';
			style.top = offset.y + 'px';
			document.body.appendChild(stats);
		}
		View._views.push(this);
		View._viewsById[this._id] = this;
		this._viewSize = size;
		(this._matrix = new Matrix())._owner = this;
		this._zoom = 1;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		if (this._project._view === this)
			this._project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.detach('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: {
		onFrame: {
			install: function() {
				this.play();
			},

			uninstall: function() {
				this.pause();
			}
		},

		onResize: {}
	},

	_animate: false,
	_time: 0,
	_count: 0,

	_requestFrame: function() {
		var that = this;
		DomEvent.requestAnimationFrame(function() {
			that._requested = false;
			if (!that._animate)
				return;
			that._requestFrame();
			that._handleFrame();
		}, this._element);
		this._requested = true;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._before ? now - this._before : 0;
		this._before = now;
		this._handlingFrame = true;
		this.fire('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
		this._handlingFrame = false;
		this.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.attach('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.detach('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.fire('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_update: function() {
		this._project._needsUpdate = true;
		if (this._handlingFrame)
			return;
		if (this._animate) {
			this._handleFrame();
		} else {
			this.update();
		}
	},

	_changed: function(flags) {
		if (flags & 1)
			this._project._needsUpdate = true;
	},

	_transform: function(matrix) {
		this._matrix.concatenate(matrix);
		this._bounds = null;
		this._update();
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._viewSize.set(size.width, size.height);
		this._setViewSize(size);
		this._bounds = null; 
		this.fire('resize', {
			size: size,
			delta: delta
		});
		this._update();
	},

	_setViewSize: function(size) {
		var element = this._element;
		element.width = size.width;
		element.height = size.height;
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function(center) {
		center = Point.read(arguments);
		this.scrollBy(center.subtract(this.getCenter()));
	},

	getZoom: function() {
		return this._zoom;
	},

	setZoom: function(zoom) {
		this._transform(new Matrix().scale(zoom / this._zoom,
			this.getCenter()));
		this._zoom = zoom;
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	scrollBy: function() {
		this._transform(new Matrix().translate(Point.read(arguments).negate()));
	},

	play: function() {
		this._animate = true;
		if (!this._requested)
			this._requestFrame();
	},

	pause: function() {
		this._animate = false;
	},

	draw: function() {
		this.update();
	},

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	}

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (typeof element === 'string')
				element = document.getElementById(element);
			return new CanvasView(project, element);
		}
	}
}, new function() {
	var tool,
		prevFocus,
		tempFocus,
		dragging = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[target.getAttribute('id')];
	}

	function viewToProject(view, event) {
		return view.viewToProject(DomEvent.getOffset(event, view._element));
	}

	function updateFocus() {
		if (!View._focused || !View._focused.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				var view = View._views[i];
				if (view && view.isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, point, event) {
		view._handleEvent('mousemove', point, event);
		var tool = view._scope.tool;
		if (tool) {
			tool._handleEvent(dragging && tool.responds('mousedrag')
					? 'mousedrag' : 'mousemove', point, event);
		}
		view.update();
		return tool;
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {
		'selectstart dragstart': function(event) {
			if (dragging)
				event.preventDefault();
		}
	};

	var docEvents = {
		mouseout: function(event) {
			var view = View._focused,
				target = DomEvent.getRelatedTarget(event);
			if (view && (!target || target.nodeName === 'HTML'))
				handleMouseMove(view, viewToProject(view, event), event);
		},

		scroll: updateFocus
	};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event),
			point = viewToProject(view, event);
		dragging = true;
		view._handleEvent('mousedown', point, event);
		if (tool = view._scope.tool)
			tool._handleEvent('mousedown', point, event);
		view.update();
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!dragging) {
			var target = getView(event);
			if (target) {
				if (view !== target)
					handleMouseMove(view, viewToProject(view, event), event);
				prevFocus = view;
				view = View._focused = tempFocus = target;
			} else if (tempFocus && tempFocus === view) {
				view = View._focused = prevFocus;
				updateFocus();
			}
		}
		if (view) {
			var point = viewToProject(view, event);
			if (dragging || view.getBounds().contains(point))
				tool = handleMouseMove(view, point, event);
		}
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (!view || !dragging)
			return;
		var point = viewToProject(view, event);
		dragging = false;
		view._handleEvent('mouseup', point, event);
		if (tool)
			tool._handleEvent('mouseup', point, event);
		view.update();
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	return {
		_viewEvents: viewEvents,

		_handleEvent: function() {},

		statics: {
			updateFocus: updateFocus
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof HTMLCanvasElement)) {
			var size = Size.read(arguments);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ canvas);
			canvas = CanvasProvider.getCanvas(size);
		}
		this._context = canvas.getContext('2d');
		this._eventCounters = {};
		this._pixelRatio = 1;
		if (PaperScope.getAttribute(canvas, 'hidpi') !== 'off') {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(this._context,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
	},

	_setViewSize: function(size) {
		var width = size.width,
			height = size.height,
			pixelRatio = this._pixelRatio,
			element = this._element,
			style = element.style;
		element.width = width * pixelRatio;
		element.height = height * pixelRatio;
		if (pixelRatio !== 1) {
			style.width = width + 'px';
			style.height = height + 'px';
			this._context.scale(pixelRatio, pixelRatio);
		}
	},

	getPixelSize: function(size) {
		var ctx = this._context,
			prevFont = ctx.font;
		ctx.font = size + ' serif';
		size = parseFloat(ctx.font);
		ctx.font = prevFont;
		return size;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		var project = this._project;
		if (!project || !project._needsUpdate)
			return false;
		var ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		project.draw(ctx, this._matrix, this._pixelRatio);
		project._needsUpdate = false;
		return true;
	}
}, new function() { 

	var downPoint,
		lastPoint,
		overPoint,
		downItem,
		lastItem,
		overItem,
		dragItem,
		dblClick,
		clickTime;

	function callEvent(view, type, event, point, target, lastPoint) {
		var item = target,
			mouseEvent;

		function call(obj) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point, target,
							lastPoint ? point.subtract(lastPoint) : null);
				}
				if (obj.fire(type, mouseEvent) && mouseEvent.isStopped) {
					event.preventDefault();
					return true;
				}
			}
		}

		while (item) {
			if (call(item))
				return true;
			item = item.getParent();
		}
		if (call(view))
			return true;
		return false;
	}

	return {
		_handleEvent: function(type, point, event) {
			if (!this._eventCounters[type])
				return;
			var project = this._project,
				hit = project.hitTest(point, {
					tolerance: this._scope.settings.hitTolerance,
					fill: true,
					stroke: true
				}),
				item = hit && hit.item,
				stopped = false;
			switch (type) {
			case 'mousedown':
				stopped = callEvent(this, type, event, point, item);
				dblClick = lastItem == item && (Date.now() - clickTime < 300);
				downItem = lastItem = item;
				downPoint = lastPoint = overPoint = point;
				dragItem = !stopped && item;
				while (dragItem && !dragItem.responds('mousedrag'))
					dragItem = dragItem._parent;
				break;
			case 'mouseup':
				stopped = callEvent(this, type, event, point, item, downPoint);
				if (dragItem) {
					if (lastPoint && !lastPoint.equals(point))
						callEvent(this, 'mousedrag', event, point, dragItem,
								lastPoint);
					if (item !== dragItem) {
						overPoint = point;
						callEvent(this, 'mousemove', event, point, item,
								overPoint);
					}
				}
				if (!stopped && item && item === downItem) {
					clickTime = Date.now();
					callEvent(this, dblClick && downItem.responds('doubleclick')
							? 'doubleclick' : 'click', event, downPoint, item);
					dblClick = false;
				}
				downItem = dragItem = null;
				break;
			case 'mousemove':
				if (dragItem)
					stopped = callEvent(this, 'mousedrag', event, point,
							dragItem, lastPoint);
				if (!stopped) {
					if (item !== overItem)
						overPoint = point;
					stopped = callEvent(this, type, event, point, item,
							overPoint);
				}
				lastPoint = overPoint = point;
				if (item !== overItem) {
					callEvent(this, 'mouseleave', event, point, overItem);
					overItem = item;
					callEvent(this, 'mouseenter', event, point, item);
				}
				break;
			}
			return stopped;
		}
	};
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
	},

	isPrevented: false,
	isStopped: false,

	preventDefault: function() {
		this.isPrevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.isStopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(down, key, character, event) {
		Event.call(this, event);
		this.type = down ? 'keydown' : 'keyup';
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {

	var specialKeys = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'control',
		18: 'option',
		19: 'pause',
		20: 'caps-lock',
		27: 'escape',
		32: 'space',
		35: 'end',
		36: 'home',
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down',
		46: 'delete',
		91: 'command',
		93: 'command', 
		224: 'command'  
	},

	specialChars = {
		9: true, 
		13: true, 
		32: true 
	},

	modifiers = new Base({
		shift: false,
		control: false,
		option: false,
		command: false,
		capsLock: false,
		space: false
	}),

	charCodeMap = {}, 
	keyMap = {}, 
	downCode; 

	function handleKey(down, keyCode, charCode, event) {
		var character = charCode ? String.fromCharCode(charCode) : '',
			specialKey = specialKeys[keyCode],
			key = specialKey || character.toLowerCase(),
			type = down ? 'keydown' : 'keyup',
			view = View._focused,
			scope = view && view.isVisible() && view._scope,
			tool = scope && scope.tool,
			name;
		keyMap[key] = down;
		if (specialKey && (name = Base.camelize(specialKey)) in modifiers)
			modifiers[name] = down;
		if (down) {
			charCodeMap[keyCode] = charCode;
		} else {
			delete charCodeMap[keyCode];
		}
		if (tool && tool.responds(type)) {
			paper = scope;
			tool.fire(type, new KeyEvent(down, key, character, event));
			if (view)
				view.update();
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var code = event.which || event.keyCode;
			if (code in specialKeys || modifiers.command) {
				handleKey(true, code,
						code in specialChars || modifiers.command ? code : 0,
						event);
			} else {
				downCode = code;
			}
		},

		keypress: function(event) {
			if (downCode != null) {
				handleKey(true, downCode, event.which || event.keyCode, event);
				downCode = null;
			}
		},

		keyup: function(event) {
			var code = event.which || event.keyCode;
			if (code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		Event.call(this, event);
		this.type = type;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

 Base.extend(Callback, {
	_class: 'Palette',
	_events: [ 'onChange' ],

	initialize: function Palette(title, components, values) {
		var parent = DomElement.find('.palettejs-panel')
			|| DomElement.find('body').appendChild(
				DomElement.create('div', { 'class': 'palettejs-panel' }));
		this._element = parent.appendChild(
			DomElement.create('table', { 'class': 'palettejs-pane' }));
		this._title = title;
		if (!values)
			values = {};
		for (var name in (this.components = components)) {
			var component = components[name];
			if (!(component instanceof Component)) {
				if (component.value == null)
					component.value = values[name];
				component.name = name;
				component = components[name] = new Component(component);
			}
			this._element.appendChild(component._element);
			component._palette = this;
			if (values[name] === undefined)
				values[name] = component.value;
		}
		this.values = Base.each(values, function(value, name) {
			var component = components[name];
			if (component) {
				Base.define(values, name, {
					enumerable: true,
					configurable: true,
					get: function() {
						return component._value;
					},
					set: function(val) {
						component.setValue(val);
					}
				});
			}
		});
		if (window.paper)
			paper.palettes.push(this);
	},

	reset: function() {
		for (var i in this.components)
			this.components[i].reset();
	},

	remove: function() {
		DomElement.remove(this._element);
	}
});

var Component = Base.extend(Callback, {
	_class: 'Component',
	_events: [ 'onChange', 'onClick' ],

	_types: {
		'boolean': {
			type: 'checkbox',
			value: 'checked'
		},

		string: {
			type: 'text'
		},

		number: {
			type: 'number',
			number: true
		},

		button: {
			type: 'button'
		},

		text: {
			tag: 'div',
			value: 'text'
		},

		slider: {
			type: 'range',
			number: true
		},

		list: {
			tag: 'select',

			setOptions: function() {
				DomElement.removeChildren(this._input);
				DomElement.create(Base.each(this._options, function(option) {
					this.push('option', { value: option, text: option });
				}, []), this._input);
			}
		},

		color: {
			type: 'color',

			getValue: function(value) {
				return new Color(value);
			},

			setValue: function(value) {
				return new Color(value).toCSS(
						DomElement.get(this._input, 'type') === 'color');
			}
		}
	},

	initialize: function Component(obj) {
		this._id = Component._id = (Component._id || 0) + 1;
		this._type = obj.type in this._types
			? obj.type
			: 'options' in obj
				? 'list'
				: 'onClick' in obj
					? 'button'
					: typeof obj.value;
		this._meta = this._types[this._type] || { type: this._type };
		var that = this,
			id = 'component-' + this._id;
		this._dontFire = true;
		this._input = DomElement.create(this._meta.tag || 'input', {
			id: id,
			type: this._meta.type,
			events: {
				change: function() {
					that.setValue(
						DomElement.get(this, that._meta.value || 'value'));
				},
				click: function() {
					that.fire('click');
				}
			}
		});
		this.attach('change', function(value) {
			if (!this._dontFire)
				this._palette.fire('change', this, this.name, value);
		});
		this._element = DomElement.create('tr', [
			'td', [this._label = DomElement.create('label', { 'for': id })],
			'td', [this._input]
		]);
		Base.each(obj, function(value, key) {
			this[key] = value;
		}, this);
		this._defaultValue = this._value;
		this._dontFire = false;
	},

	getType: function() {
		return this._type;
	},

	getLabel: function() {
		return this.__label;
	},

	setLabel: function(label) {
		this.__label = label;
		DomElement.set(this._label, 'text', label + ':');
	},

	getOptions: function() {
		return this._options;
	},

	setOptions: function(options) {
		this._options = options;
		var setOptions = this._meta.setOptions;
		if (setOptions)
			setOptions.call(this);
	},

	getValue: function() {
		var value = this._value,
			getValue = this._meta.getValue;
		return getValue ? getValue.call(this, value) : value;
	},

	setValue: function(value) {
		var key = this._meta.value || 'value',
			setValue = this._meta.setValue;
		if (setValue)
			value = setValue.call(this, value);
		DomElement.set(this._input, key, value);
		value = DomElement.get(this._input, key);
		if (this._meta.number)
			value = parseFloat(value, 10);
		if (this._value !== value) {
			this._value = value;
			if (!this._dontFire)
				this.fire('change', this.getValue());
		}
	},

	getRange: function() {
		return [parseFloat(DomElement.get(this._input, 'min')),
				parseFloat(DomElement.get(this._input, 'max'))];
	},

	setRange: function(min, max) {
		var range = Array.isArray(min) ? min : [min, max];
		DomElement.set(this._input, { min: range[0], max: range[1] });
	},

	getMin: function() {
		return this.getRange()[0];
	},

	setMin: function(min) {
		this.setRange(min, this.getMax());
	},

	getMax: function() {
		return this.getRange()[1];
	},

	setMax: function(max) {
		this.setRange(this.getMin(), max);
	},

	getStep: function() {
		return parseFloat(DomElement.get(this._input, 'step'));
	},

	setStep: function(step) {
		DomElement.set(this._input, 'step', step);
	},

	reset: function() {
		this.setValue(this._defaultValue);
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
		 		? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return /^mouse(down|up)$/.test(this.type)
				? this.tool._downCount
				: this.tool._count;
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
			'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onKeyDown', 'onKeyUp' ],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._firstMove = true;
		this._count = 0;
		this._downCount = 0;
		this._set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (this._minDistance != null && this._maxDistance != null
				&& this._minDistance > this._maxDistance) {
			this._maxDistance = this._minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && this._maxDistance != null
				&& this._maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = distance;
		this._maxDistance = distance;
	},

	_updateEvent: function(type, point, minDistance, maxDistance, start,
			needsChange, matchMaxDistance) {
		if (!start) {
			if (minDistance != null || maxDistance != null) {
				var minDist = minDistance != null ? minDistance : 0,
					vector = point.subtract(this._point),
					distance = vector.getLength();
				if (distance < minDist)
					return false;
				var maxDist = maxDistance != null ? maxDistance : 0;
				if (maxDist != 0) {
					if (distance > maxDist) {
						point = this._point.add(vector.normalize(maxDist));
					} else if (matchMaxDistance) {
						return false;
					}
				}
			}
			if (needsChange && point.equals(this._point))
				return false;
		}
		this._lastPoint = start && type == 'mousemove' ? point : this._point;
		this._point = point;
		switch (type) {
		case 'mousedown':
			this._lastPoint = this._downPoint;
			this._downPoint = this._point;
			this._downCount++;
			break;
		case 'mouseup':
			this._lastPoint = this._downPoint;
			break;
		}
		this._count = start ? 0 : this._count + 1;
		return true;
	},

	_fireEvent: function(type, event) {
		var sets = paper.project._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
		return this.responds(type)
				&& this.fire(type, new ToolEvent(this, type, event));
	},

	_handleEvent: function(type, point, event) {
		paper = this._scope;
		var called = false;
		switch (type) {
		case 'mousedown':
			this._updateEvent(type, point, null, null, true, false, false);
			called = this._fireEvent(type, event);
			break;
		case 'mousedrag':
			var needsChange = false,
				matchMaxDistance = false;
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, false, needsChange, matchMaxDistance)) {
				called = this._fireEvent(type, event) || called;
				needsChange = true;
				matchMaxDistance = true;
			}
			break;
		case 'mouseup':
			if (!point.equals(this._point)
					&& this._updateEvent('mousedrag', point, this.minDistance,
							this.maxDistance, false, false, false)) {
				called = this._fireEvent('mousedrag', event);
			}
			this._updateEvent(type, point, null, this.maxDistance, false,
					false, false);
			called = this._fireEvent(type, event) || called;
			this._updateEvent(type, point, null, null, true, false, false);
			this._firstMove = true;
			break;
		case 'mousemove':
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, this._firstMove, true, false)) {
				called = this._fireEvent(type, event) || called;
				this._firstMove = false;
			}
			break;
		}
		if (called)
			event.preventDefault();
		return called;
	}

});

var Http = {
	request: function(method, url, callback) {
		var xhr = new (window.ActiveXObject || XMLHttpRequest)(
					'Microsoft.XMLHTTP');
		xhr.open(method.toUpperCase(), url, true);
		if ('overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain');
		xhr.onreadystatechange = function() {
			if (xhr.readyState === 4) {
				var status = xhr.status;
				if (status === 0 || status === 200) {
					callback.call(xhr, xhr.responseText);
				} else {
					throw new Error('Could not load ' + url + ' (Error '
							+ status + ')');
				}
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height, pixelRatio) {
		var canvas,
			init = true;
		if (typeof width === 'object') {
			pixelRatio = height;
			height = width.height;
			width = width.width;
		}
		if (!pixelRatio) {
			pixelRatio = 1;
		} else if (pixelRatio !== 1) {
			width *= pixelRatio;
			height *= pixelRatio;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
		}
		var ctx = canvas.getContext('2d');
		if (canvas.width === width && canvas.height === height) {
			if (init)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		if (pixelRatio !== 1)
			ctx.scale(pixelRatio, pixelRatio);
		return canvas;
	},

	getContext: function(width, height, pixelRatio) {
		return this.getCanvas(width, height, pixelRatio).getContext('2d');
	},

	release: function(obj) {
		var canvas = obj.canvas ? obj.canvas : obj;
		canvas.getContext('2d').restore();
		this.canvases.push(canvas);
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa, 
		br, bg, bb, ba, 
		dr, dg, db;     

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b), 
			mn = min(r, g, b), 
			md; 
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	Base.each(modes, function(func, mode) {
		var darken = mode === 'darken',
			ok = false;
		ctx.save();
		try {
			ctx.fillStyle = darken ? '#300' : '#a00';
			ctx.fillRect(0, 0, 1, 1);
			ctx.globalCompositeOperation = mode;
			if (ctx.globalCompositeOperation === mode) {
				ctx.fillStyle = darken ? '#a00' : '#300';
				ctx.fillRect(0, 0, 1, 1);
				ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
			}
		} catch (e) {}
		ctx.restore();
		nativeModes[mode] = ok;
	});
	CanvasProvider.release(ctx);

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst  = dstData.data,
				src  = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SVGStyles = Base.each({
	fillColor: ['fill', 'color'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'string']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

var SVGNamespaces = {
	href: 'http://www.w3.org/1999/xlink',
	xlink: 'http://www.w3.org/2000/xmlns'
};

new function() {
	var formatter;

	function setAttributes(node, attrs) {
		for (var key in attrs) {
			var val = attrs[key],
				namespace = SVGNamespaces[key];
			if (typeof val === 'number')
				val = formatter.number(val);
			if (namespace) {
				node.setAttributeNS(namespace, key, val);
			} else {
				node.setAttribute(key, val);
			}
		}
		return node;
	}

	function createElement(tag, attrs) {
		return setAttributes(
			document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
	}

	function getTransform(item, coordinates, center) {
		var matrix = item._matrix,
			trans = matrix.getTranslation(),
			attrs = {};
		if (coordinates) {
			matrix = matrix.shiftless();
			var point = matrix._inverseTransform(trans);
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
			trans = null;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed && !decomposed.shearing) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item),
			children = item._children;
		var node = createElement('g', attrs);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = createElement('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					setAttributes(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item) {
		var attrs = getTransform(item, true),
			size = item.getSize();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = item.toDataURL();
		return createElement('image', attrs);
	}

	function exportPath(item, options) {
		if (options.matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			type,
			attrs;
		if (segments.length === 0)
			return null;
		if (item.isPolygon()) {
			if (segments.length >= 3) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for(i = 0, l = segments.length; i < l; i++)
					parts.push(formatter.point(segments[i]._point));
				attrs = {
					points: parts.join(' ')
				};
			} else {
				type = 'line';
				var first = segments[0]._point,
					last = segments[segments.length - 1]._point;
				attrs = {
					x1: first.x,
					y1: first.y,
					x2: last.x,
					y2: last.y
				};
			}
		} else {
			type = 'path';
			var data = item.getPathData();
			attrs = data && { d: data };
		}
		return createElement(type, attrs);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect'; 
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return createElement(type, attrs);
	}

	function exportCompoundPath(item) {
		var attrs = getTransform(item, true);
		var data = item.getPathData();
		if (data)
			attrs.d = data;
		return createElement('path', attrs);
	}

	function exportPlacedSymbol(item, options) {
		var attrs = getTransform(item, true),
			symbol = item.getSymbol(),
			symbolNode = getDefinition(symbol, 'symbol'),
			definition = symbol.getDefinition(),
			bounds = definition.getBounds();
		if (!symbolNode) {
			symbolNode = createElement('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			symbolNode.appendChild(exportSVG(definition, options));
			setDefinition(symbol, symbolNode, 'symbol');
		}
		attrs.href = '#' + symbolNode.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = formatter.number(bounds.width);
		attrs.height = formatter.number(bounds.height);
		return createElement('use', attrs);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin().transform(),
				destination = color.getDestination().transform(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					highlight = highlight.transform();
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = createElement(
					(radial ? 'radial' : 'linear') + 'Gradient', attrs);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha();
				attrs = {
					offset: stop._rampPoint,
					'stop-color': stopColor.toCSS(true)
				};
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(createElement('stop', attrs));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = createElement('text', getTransform(item, true));
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		PlacedSymbol: exportPlacedSymbol,
		PointText: exportText
	};

	function applyStyle(item, node) {
		var attrs = {},
			parent = item.getParent();

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SVGStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (!parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				attrs[entry.attribute] = value == null
					? 'none'
					: type === 'number'
						? formatter.number(value)
						: type === 'color'
							? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array'
								? value.join(',')
								: type === 'lookup'
									? entry.toSVG[value]
									: value;
			}
		});

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (item._visibility != null && !item._visibility)
			attrs.visibility = 'hidden';

		return setAttributes(node, attrs);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-' + item._id];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + id;
		definitions.svgs[type + '-' + item._id] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = createElement('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(createElement('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node && item._data) {
			var data = JSON.stringify(item._data);
			if (data !== '{}')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var layers = this.layers,
				size = this.getView().getSize(),
				node = createElement('svg', {
					x: 0,
					y: 0,
					width: size.width,
					height: size.height,
					version: '1.1',
					xmlns: 'http://www.w3.org/2000/svg',
					'xmlns:xlink': 'http://www.w3.org/1999/xlink'
				});
			for (var i = 0, l = layers.length; i < l; i++)
				node.appendChild(exportSVG(layers[i], options));
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	function getValue(node, name, isString, allowNull) {
		var namespace = SVGNamespaces[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		if (value === 'null')
			value = null;
		return value == null
				? allowNull
					? null
					: isString
						? ''
						: 0
				: isString
					? value
					: parseFloat(value);
	}

	function getPoint(node, x, y, allowNull) {
		x = getValue(node, x, false, allowNull);
		y = getValue(node, y, false, allowNull);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull) {
		w = getValue(node, w, false, allowNull);
		h = getValue(node, h, false, allowNull);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none'
				? null
				: type === 'number'
					? parseFloat(value)
					: type === 'array'
						? value ? value.split(/[\s,]+/g).map(parseFloat) : []
						: type === 'color'
							? getDefinition(value) || value
							: type === 'lookup'
								? lookup[value]
								: value;
	}

	function importGroup(node, type, isRoot, options) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& (child = importSVG(childNode, false, options))
					&& !(child instanceof Symbol))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || type === 'defs') {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		var data = node.getAttribute('d'),
			param = { pathData: data };
		return data.match(/m/gi).length > 1 || /z\S+/i.test(data)
				? new CompoundPath(param)
				: new Path(param);
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			isRadial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, isRadial);
		}
		var origin, destination, highlight;
		if (isRadial) {
			origin = getPoint(node, 'cx', 'cy');
			destination = origin.add(getValue(node, 'r'), 0);
			highlight = getPoint(node, 'fx', 'fy', true);
		} else {
			origin = getPoint(node, 'x1', 'y1');
			destination = getPoint(node, 'x2', 'y2');
		}
		applyAttributes(
			new Color(gradient, origin, destination, highlight), node);
		return null;
	}

	var importers = {
		'#document': function (node, type, isRoot, options) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1) {
					var next = child.nextSibling;
					document.body.appendChild(child);
					var item = importSVG(child, isRoot, options);
					if (next) {
						node.insertBefore(child, next);
					} else {
						node.appendChild(child);
					}
					return item;
				}
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.attach('load', function() {
				var size = getSize(node, 'width', 'height');
				this.setSize(size);
				var center = this._matrix._transformPoint(
						getPoint(node, 'x', 'y').add(size.divide(2)));
				this.translate(center);
			});
			return raster;
		},

		symbol: function(node, type, isRoot, options) {
			return new Symbol(importGroup(node, type, isRoot, options), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node, 'x', 'y');
			return definition
					? definition instanceof Symbol
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			var point = getPoint(node, 'x', 'y'),
				size = getSize(node, 'width', 'height'),
				radius = getSize(node, 'rx', 'ry');
			return new Shape.Rectangle(new Rectangle(point, size), radius);
		},

		line: function(node) {
			return new Path.Line(getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node, 'x', 'y')
					.add(getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		}
	};

	function applyTransform(item, value, name, node) {
		var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
			matrix = new Matrix();
		for (var i = 0, l = transforms.length; i < l; i++) {
			var transform = transforms[i];
			if (!transform)
				break;
			var parts = transform.split('('),
				command = parts[0],
				v = parts[1].split(/[\s,]+/g);
			for (var j = 0, m = v.length; j < m; j++)
				v[j] = parseFloat(v[j]);
			switch (command) {
			case 'matrix':
				matrix.concatenate(
						new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
				break;
			case 'rotate':
				matrix.rotate(v[0], v[1], v[2]);
				break;
			case 'translate':
				matrix.translate(v[0], v[1]);
				break;
			case 'scale':
				matrix.scale(v);
				break;
			case 'skewX':
				matrix.skew(v[0], 0);
				break;
			case 'skewY':
				matrix.skew(0, v[0]);
				break;
			}
		}
		item.transform(matrix);
	}

	function applyOpacity(item, value, name) {
		var color = item[name === 'fill-opacity' ? 'getFillColor'
				: 'getStrokeColor']();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.each(SVGStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			item[entry.set](convertValue(value, entry.type, entry.fromSVG));
			if (entry.type === 'color' && item instanceof Shape) {
				var color = item[entry.get]();
				if (color)
					color.transform(new Matrix().translate(
							item.getPosition(true).negate()));
			}
		};
	}, {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			item.setVisible(value === 'visible');
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			var percentage = value.match(/(.*)%$/);
			item.setRampPoint(percentage
					? percentage[1] / 100
					: parseFloat(value));
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, 'width', 'height', true);
			if (item instanceof Group) {
				var scale = size ? rect.getSize().divide(size) : 1,
					matrix = new Matrix().translate(rect.getPoint()).scale(scale);
				item.transform(matrix.inverted());
			} else if (item instanceof Symbol) {
				if (size)
					rect.setSize(size);
				var clip = getAttribute(node, 'overflow', styles) != 'visible',
					group = item._definition;
				if (clip && !rect.contains(group.getBounds())) {
					clip = new Shape.Rectangle(rect).transform(group._matrix);
					clip.setClipMask(true);
					group.addChild(clip);
				}
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value
				? undefined
				: value === 'none'
					? null
					: value;
	}

	function applyAttributes(item, node, isRoot) {
		var styles = {
			node: DomElement.getStyles(node) || {},
			parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
		};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			if (value !== undefined)
				item = Base.pick(apply(item, value, name, node, styles), item);
		});
		return item;
	}

	var definitions = {};
	function getDefinition(value) {
		var match = value && value.match(/\((?:#|)([^)']+)/);
		return match && definitions[match[1]];
	}

	function importSVG(source, isRoot, options) {
		if (!source)
			return null;
		if (!options) {
			options = {};
		} else if (typeof options === 'function') {
			options = { onLoad: options };
		}

		var node = source,
			scope = paper;

		function onLoadCallback(svg) {
			paper = scope;
			var item = importSVG(svg, isRoot, options),
				onLoad = options.onLoad,
				view = scope.project && scope.getView();
			if (onLoad)
				onLoad.call(this, item);
			view.update();
		}

		if (isRoot) {
			if (typeof source === 'string' && !/^.*</.test(source)) {
				node = document.getElementById(source);
				if (node) {
					source = null;
				} else {
					return Http.request('get', source, onLoadCallback);
				}
			} else if (typeof File !== 'undefined' && source instanceof File) {
				var reader = new FileReader();
				reader.onload = function() {
					onLoadCallback(reader.result);
				};
				return reader.readAsText(source);
			}
		}

		if (typeof source === 'string')
			node = new DOMParser().parseFromString(source, 'image/svg+xml');
		if (!node.nodeName)
			throw new Error('Unsupported SVG source: ' + source);
		var type = node.nodeName.toLowerCase(),
			importer = importers[type],
			item,
			data = node.getAttribute && node.getAttribute('data-paper-data'),
			settings = scope.settings,
			prevApplyMatrix = settings.applyMatrix;
		settings.applyMatrix = false;
		item = importer && importer(node, type, isRoot, options) || null;
		settings.applyMatrix = prevApplyMatrix;
		if (item) {
			if (!(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (isRoot)
			definitions = {};
		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return this.addChild(importSVG(node, true, options));
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, true, options);
		}
	});
};

Base.exports.PaperScript = (function() {
	var exports, define,
		scope = this;
!function(e,r){return"object"==typeof exports&&"object"==typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){"use strict";function r(e){fr=e||{};for(var r in hr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=hr[r]);mr=fr.sourceFile||null}function t(e,r){var t=vr(pr,e);r+=" ("+t.line+":"+t.column+")";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+="return str === "+JSON.stringify(e[0])+";";t+="switch(str){";for(var r=0;r<e.length;++r)t+="case "+JSON.stringify(e[r])+":";t+="return true}return false;"}e=e.split(" ");var t="",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+="switch(str.length){";for(var a=0;a<n.length;++a){var i=n[a];t+="case "+i[0].length+":",r(i)}t+="}"}else r(e);return new Function("str",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=pr.indexOf("*/",br+=2);if(-1===n&&t(br-2,"Unterminated comment"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(pr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,pr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=pr.charCodeAt(br+=2);dr>br&&10!==t&&13!==t&&8232!==t&&8329!==t;)++br,t=pr.charCodeAt(br);fr.onComment&&fr.onComment(!1,pr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;dr>br;){var e=pr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=pr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e)++br,++Ar,Sr=br;else if(14>e&&e>8)++br;else if(47===e){var r=pr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=pr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=pr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function p(){var e=pr.charCodeAt(br+1);return 61===e?x(Et,2):x(Ft,1)}function d(e){var r=pr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Vt,1)}function m(){var e=pr.charCodeAt(br+1);return 61===e?x(Et,2):x(Tt,1)}function h(e){var r=pr.charCodeAt(br+1);return r===e?x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=pr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===pr.charCodeAt(br+2)?3:2,61===pr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):(61===r&&(t=61===pr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=pr.charCodeAt(br+1);return 61===r?x(qt,61===pr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(ht);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(pt);case 123:return++br,i(dt);case 125:return++br,i(mt);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=pr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return p();case 124:case 38:return d(e);case 94:return m();case 43:case 45:return h(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=dr)return i(Br);var r=pr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if("\\"===o||$t.test(o))return L();t(br,"Unexpected character '"+o+"'")}return n}function x(e,r){var t=pr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n="",a=br;;){br>=dr&&t(a,"Unterminated regular expression");var o=pr.charAt(br);if(Gt.test(o)&&t(a,"Unterminated regular expression"),e)e=!1;else{if("["===o)r=!0;else if("]"===o&&r)r=!1;else if("/"===o&&!r)break;e="\\"===o}++br}var n=pr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,"Invalid regexp flag"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=pr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,"Expected hexadecimal number"),Qt(pr.charCodeAt(br))&&t(br,"Identifier directly after number"),i(Or,e)}function E(e){var r=br,n=!1,a=48===pr.charCodeAt(br);e||null!==w(10)||t(r,"Invalid number"),46===pr.charCodeAt(br)&&(++br,w(10),n=!0);var o=pr.charCodeAt(br);(69===o||101===o)&&(o=pr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,"Invalid number"),n=!0),Qt(pr.charCodeAt(br))&&t(br,"Identifier directly after number");var s,c=pr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Vr?t(r,"Invalid number"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r="";;){br>=dr&&t(yr,"Unterminated string constant");var n=pr.charCodeAt(br);if(n===e)return++br,i(Fr,r);if(92===n){n=pr.charCodeAt(++br);var a=/^[0-7]+/.exec(pr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if("0"===a&&(a=null),++br,a)Vr&&t(br-2,"Octal literal in strict mode"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+="\n";break;case 114:r+="\r";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+="	";break;case 98:r+="\b";break;case 118:r+="";break;case 102:r+="\f";break;case 48:r+="\0";break;case 13:10===pr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8329===n)&&t(yr,"Unterminated string constant"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,"Bad character escape sequence"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=pr.charCodeAt(br);if(Yt(a))Bt&&(e+=pr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=pr.slice(n,br)),Bt=!0,117!=pr.charCodeAt(++br)&&t(br,"Expecting Unicode escape sequence \\uXXXX"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,"Invalid Unicode escape"),(r?Qt(o):Yt(o))||t(br-4,"Invalid Unicode escape"),e+=i}r=!1}return Bt?e:pr.slice(n,br)}function L(){var e=I(),r=Dr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Vr&&Xt(e))&&t(yr,"The keyword '"+e+"' is reserved")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){for(Vr=e,br=Lr;Sr>br;)Sr=pr.lastIndexOf("\n",Sr-2)+1,--Ar;u(),g()}function T(){this.type=null,this.start=yr,this.end=null}function V(){this.start=xr,this.end=null,null!==mr&&(this.source=mr)}function q(){var e=new T;return fr.locations&&(e.loc=new V),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new T;return r.start=e.start,fr.locations&&(r.loc=new V,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function F(e){return fr.ecmaVersion>=5&&"ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"use strict"===e.expression.value}function D(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===mt||Gt.test(pr.slice(Lr,yr)))}function M(){D(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,"Unexpected token")}function N(e){"Identifier"!==e.type&&"MemberExpression"!==e.type&&t(e.start,"Assigning to rvalue"),Vr&&"Identifier"===e.type&&Nt(e.name)&&t(e.start,"Assigning to "+e.name+" in strict mode")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Vr=null,Tr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&F(n)&&R(!0),t=!1}return j(r,"Program")}function J(){wr===wt&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;D(yt)||B()?r.label=null:wr!==Dr?X():(r.label=lr(),M());for(var a=0;a<Tr.length;++a){var o=Tr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||"loop"===o.kind))break;if(r.label&&n)break}}return a===Tr.length&&t(r.start,"Unsyntactic "+e.keyword),j(r,n?"BreakStatement":"ContinueStatement");case Wr:return U(),M(),j(r,"DebuggerStatement");case Pr:return U(),Tr.push(Zt),r.body=J(),Tr.pop(),z(tt),r.test=P(),M(),j(r,"DoWhileStatement");case _r:if(U(),Tr.push(Zt),z(ht),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),1===i.declarations.length&&D(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return D(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=D(Hr)?J():null,j(r,"IfStatement");case Qr:return Rr||t(yr,"'return' outside of function"),U(),D(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,"ReturnStatement");case Yr:U(),r.discriminant=P(),r.cases=[],z(dt),Tr.push(en);for(var s,c;wr!=mt;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,"SwitchCase"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,"Multiple default clauses"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,"SwitchCase"),U(),Tr.pop(),j(r,"SwitchStatement");case Zr:return U(),Gt.test(pr.slice(Lr,yr))&&t(Lr,"Illegal newline after throw"),r.argument=K(),M(),j(r,"ThrowStatement");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(ht),l.param=lr(),Vr&&Nt(l.param.name)&&t(l.param.start,"Binding "+l.param.name+" in strict mode"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,"CatchClause")}return r.guardedHandlers=qr,r.finalizer=D($r)?H():null,r.handler||r.finalizer||t(r.start,"Missing catch or finally clause"),j(r,"TryStatement");case rt:return U(),r=G(r),M(),r;case tt:return U(),r.test=P(),Tr.push(Zt),r.body=J(),Tr.pop(),j(r,"WhileStatement");case nt:return Vr&&t(yr,"'with' in strict mode"),U(),r.object=P(),r.body=J(),j(r,"WithStatement");case dt:return H();case yt:return U(),j(r,"EmptyStatement");default:var f=Cr,p=K();if(e===Dr&&"Identifier"===p.type&&D(gt)){for(var a=0;a<Tr.length;++a)Tr[a].name===f&&t(p.start,"Label '"+f+"' is already declared");var d=wr.isLoop?"loop":wr===Yr?"switch":null;return Tr.push({name:f,kind:d}),r.body=J(),Tr.pop(),r.label=p,j(r,"LabeledStatement")}return r.expression=p,M(),j(r,"ExpressionStatement")}}function P(){z(ht);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(dt);!D(mt);){var o=J();t.body.push(o),n&&e&&F(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,"BlockStatement")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Tr.pop(),j(e,"ForStatement")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Tr.pop(),j(e,"ForInStatement")}function G(e,r){for(e.declarations=[],e.kind="var";;){var n=q();if(n.id=lr(),Vr&&Nt(n.id.name)&&t(n.id.start,"Binding "+n.id.name+" in strict mode"),n.init=D(Ct)?K(!0,r):null,e.declarations.push(j(n,"VariableDeclarator")),!D(bt))break}return j(e,"VariableDeclaration")}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];D(bt);)n.expressions.push(Q(r));return j(n,"SequenceExpression")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,"AssignmentExpression")}return r}function Y(e){var r=Z(e);if(D(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,"ConditionalExpression")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var a=j(a,/&&|\|\|/.test(a.operator)?"LogicalExpression":"BinaryExpression");return er(a,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,U(),e.argument=rr(),r?N(e.argument):Vr&&"delete"===e.operator&&"Identifier"===e.argument.type&&t(e.start,"Deleting local variable in strict mode"),j(e,r?"UpdateExpression":"UnaryExpression")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,"UpdateExpression")}return n}function tr(){return nr(ar())}function nr(e,r){if(D(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,"MemberExpression"),r)}if(D(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(pt),nr(j(t,"MemberExpression"),r)}if(!r&&D(ht)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,"CallExpression"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,"ThisExpression");case Dr:return lr();case Or:case Fr:case jr:var e=q();return e.value=Cr,e.raw=pr.slice(yr,gr),U(),j(e,"Literal");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,"Literal");case ht:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(pt,!0,!0),j(e,"ArrayExpression");case dt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=D(ht)?ur(vt,!1):qr,j(e,"NewExpression")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!D(mt);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&D(mt))break;var a,o={key:sr()},i=!1;if(D(gt)?(o.value=K(!0),a=o.kind="init"):fr.ecmaVersion>=5&&"Identifier"===o.key.type&&("get"===o.key.name||"set"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==ht&&X(),o.value=cr(q(),!1)):X(),"Identifier"===o.key.type&&(Vr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&"init"===c.kind||"init"===a&&("get"===c.kind||"set"===c.kind);u&&!Vr&&"init"===a&&"init"===c.kind&&(u=!1),u&&t(o.key.start,"Redefinition of property")}}e.properties.push(o)}return j(e,"ObjectExpression")}function sr(){return wr===Or||wr===Fr?ar():lr(!0)}function cr(e,r){wr===Dr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(ht);!D(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Tr;if(Rr=!0,Tr=[],e.body=H(!0),Rr=a,Tr=o,Vr||e.body.body.length&&F(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,"Defining '"+s.name+"' in strict mode"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,"Argument name clash in strict mode")}return j(e,r?"FunctionDeclaration":"FunctionExpression")}function ur(e,r,t){for(var n=[],a=!0;!D(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&D(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Dr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),U(),j(r,"Identifier")}e.version="0.3.2";var fr,pr,dr,mr;e.parse=function(e,t){return pr=String(e),dr=pr.length,r(t),o(),W(fr.program)};var hr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}pr=String(e),dr=pr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(pr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Tr,Vr,qr=[],Or={type:"num"},jr={type:"regexp"},Fr={type:"string"},Dr={type:"name"},Br={type:"eof"},Mr={keyword:"break"},zr={keyword:"case",beforeExpr:!0},Xr={keyword:"catch"},Nr={keyword:"continue"},Wr={keyword:"debugger"},Jr={keyword:"default"},Pr={keyword:"do",isLoop:!0},Hr={keyword:"else",beforeExpr:!0},$r={keyword:"finally"},_r={keyword:"for",isLoop:!0},Gr={keyword:"function"},Kr={keyword:"if"},Qr={keyword:"return",beforeExpr:!0},Yr={keyword:"switch"},Zr={keyword:"throw",beforeExpr:!0},et={keyword:"try"},rt={keyword:"var"},tt={keyword:"while",isLoop:!0},nt={keyword:"with"},at={keyword:"new",beforeExpr:!0},ot={keyword:"this"},it={keyword:"null",atomValue:null},st={keyword:"true",atomValue:!0},ct={keyword:"false",atomValue:!1},ut={keyword:"in",binop:7,beforeExpr:!0},lt={"break":Mr,"case":zr,"catch":Xr,"continue":Nr,"debugger":Wr,"default":Jr,"do":Pr,"else":Hr,"finally":$r,"for":_r,"function":Gr,"if":Kr,"return":Qr,"switch":Yr,"throw":Zr,"try":et,"var":rt,"while":tt,"with":nt,"null":it,"true":st,"false":ct,"new":at,"in":ut,"instanceof":{keyword:"instanceof",binop:7,beforeExpr:!0},"this":ot,"typeof":{keyword:"typeof",prefix:!0,beforeExpr:!0},"void":{keyword:"void",prefix:!0,beforeExpr:!0},"delete":{keyword:"delete",prefix:!0,beforeExpr:!0}},ft={type:"[",beforeExpr:!0},pt={type:"]"},dt={type:"{",beforeExpr:!0},mt={type:"}"},ht={type:"(",beforeExpr:!0},vt={type:")"},bt={type:",",beforeExpr:!0},yt={type:";",beforeExpr:!0},gt={type:":",beforeExpr:!0},xt={type:"."},kt={type:"?",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Tt={binop:4,beforeExpr:!0},Vt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Ft={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:pt,braceL:dt,braceR:mt,parenL:ht,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Dr,eof:Br,num:Or,regexp:jr,string:Fr};for(var Dt in lt)e.tokTypes["_"+Dt]=lt[Dt];var Bt,Mt=n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),zt=n("class enum extends super const export import"),Xt=n("implements interface let package private protected public static yield"),Nt=n("eval arguments"),Wt=n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),Jt=/[\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/,Pt="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",Ht="\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f",$t=new RegExp("["+Pt+"]"),_t=new RegExp("["+Pt+Ht+"]"),Gt=/[\n\r\u2028\u2029]/,Kt=/\r\n|[\n\r\u2028\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:"loop"},en={kind:"switch"}});

	var binaryOperators = {
		'+': '__add',
		'-': '__subtract',
		'*': '__multiply',
		'/': '__divide',
		'%': '__modulo',
		'==': 'equals',
		'!=': 'equals'
	};

	var unaryOperators = {
		'-': '__negate',
		'+': null
	};

	var fields = Base.each(
		['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],
		function(name) {
			this['__' + name] = '#' + name;
		},
		{}
	);
	Point.inject(fields);
	Size.inject(fields);
	Color.inject(fields);

	function _$_(left, operator, right) {
		var handler = binaryOperators[operator];
		if (left && left[handler]) {
			var res = left[handler](right);
			return operator === '!=' ? !res : res;
		}
		switch (operator) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
		case '%': return left % right;
		case '==': return left == right;
		case '!=': return left != right;
		}
	}

	function $_(operator, value) {
		var handler = unaryOperators[operator];
		if (handler && value && value[handler])
			return value[handler]();
		switch (operator) {
		case '+': return +value;
		case '-': return -value;
		}
	}

	function compile(code) {

		var insertions = [];

		function getOffset(offset) {
			for (var i = 0, l = insertions.length; i < l; i++) {
				var insertion = insertions[i];
				if (insertion[0] >= offset)
					break;
				offset += insertion[1];
			}
			return offset;
		}

		function getCode(node) {
			return code.substring(getOffset(node.range[0]),
					getOffset(node.range[1]));
		}

		function replaceCode(node, str) {
			var start = getOffset(node.range[0]),
				end = getOffset(node.range[1]),
				insert = 0;
			for (var i = insertions.length - 1; i >= 0; i--) {
				if (start > insertions[i][0]) {
					insert = i + 1;
					break;
				}
			}
			insertions.splice(insert, 0, [start, str.length - end + start]);
			code = code.substring(0, start) + str + code.substring(end);
		}

		function walkAST(node, parent) {
			if (!node)
				return;
			for (var key in node) {
				if (key === 'range')
					continue;
				var value = node[key];
				if (Array.isArray(value)) {
					for (var i = 0, l = value.length; i < l; i++)
						walkAST(value[i], node);
				} else if (value && typeof value === 'object') {
					walkAST(value, node);
				}
			}
			switch (node && node.type) {
			case 'UnaryExpression': 
				if (node.operator in unaryOperators
						&& node.argument.type !== 'Literal') {
					var arg = getCode(node.argument);
					replaceCode(node, '$_("' + node.operator + '", '
							+ arg + ')');
				}
				break;
			case 'BinaryExpression': 
				if (node.operator in binaryOperators
						&& node.left.type !== 'Literal') {
					var left = getCode(node.left),
						right = getCode(node.right);
					replaceCode(node, '_$_(' + left + ', "' + node.operator
							+ '", ' + right + ')');
				}
				break;
			case 'UpdateExpression': 
			case 'AssignmentExpression': 
				if (!(parent && (
						parent.type === 'ForStatement'
						|| parent.type === 'BinaryExpression'
							&& /^[=!<>]/.test(parent.operator)
						|| parent.type === 'MemberExpression'
							&& parent.computed))) {
					if (node.type === 'UpdateExpression') {
						if (!node.prefix) {
							var arg = getCode(node.argument);
							replaceCode(node, arg + ' = _$_(' + arg + ', "'
									+ node.operator[0] + '", 1)');
						}
					} else { 
						if (/^.=$/.test(node.operator)
								&& node.left.type !== 'Literal') {
							var left = getCode(node.left),
								right = getCode(node.right);
							replaceCode(node, left + ' = _$_(' + left + ', "'
									+ node.operator[0] + '", ' + right + ')');
						}
					}
				}
				break;
			}
		}
		walkAST(scope.acorn.parse(code, { ranges: true }));
		return code;
	}

	function execute(code, scope) {
		paper = scope;
		var view = scope.getView(),
			tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code)
					? new Tool()
					: null,
			toolHandlers = tool ? tool._events : [],
			handlers = ['onFrame', 'onResize'].concat(toolHandlers),
			params = [],
			args = [],
			func;
		code = compile(code);
		function expose(scope, hidden) {
			for (var key in scope) {
				if ((hidden || !/^_/.test(key)) && new RegExp(
						'\\b' + key.replace(/\$/g, '\\$') + '\\b').test(code)) {
					params.push(key);
					args.push(scope[key]);
				}
			}
		}
		expose({ _$_: _$_, $_: $_, view: view, tool: tool }, true);
		expose(scope);
		handlers = Base.each(handlers, function(key) {
			if (new RegExp('\\s+' + key + '\\b').test(code)) {
				params.push(key);
				this.push(key + ': ' + key);
			}
		}, []).join(', ');
		if (handlers)
			code += '\nreturn { ' + handlers + ' };';
		var firefox = window.InstallTrigger;
		if (firefox || window.chrome) {
			var script = document.createElement('script'),
				head = document.head;
			if (firefox)
				code = '\n' + code;
			script.appendChild(document.createTextNode(
				'paper._execute = function(' + params + ') {' + code + '\n}'
			));
			head.appendChild(script);
			func = paper._execute;
			delete paper._execute;
			head.removeChild(script);
		} else {
			func = Function(params, code);
		}
		var res = func.apply(scope, args) || {};
		Base.each(toolHandlers, function(key) {
			var value = res[key];
			if (value)
				tool[key] = value;
		});
		if (view) {
			if (res.onResize)
				view.setOnResize(res.onResize);
			view.fire('resize', {
				size: view.size,
				delta: new Point()
			});
			if (res.onFrame)
				view.setOnFrame(res.onFrame);
			view.update();
		}
	}

	function load() {
		Base.each(document.getElementsByTagName('script'), function(script) {
			if (/^text\/(?:x-|)paperscript$/.test(script.type)
					&& !script.getAttribute('data-paper-ignore')) {
				var canvas = PaperScope.getAttribute(script, 'canvas'),
					scope = PaperScope.get(canvas)
							|| new PaperScope(script).setup(canvas),
					src = script.src;
				if (src) {
					Http.request('get', src, function(code) {
						execute(code, scope);
					});
				} else {
					execute(script.innerHTML, scope);
				}
				script.setAttribute('data-paper-ignore', true);
			}
		}, this);
	}

	if (document.readyState === 'complete') {
		setTimeout(load);
	} else {
		DomEvent.add(window, { load: load });
	}

	return {
		compile: compile,
		execute: execute,
		load: load,
		lineNumberBase: 0
	};

}).call(this);

paper = new (PaperScope.inject(Base.exports, {
	enumerable: true,
	Base: Base,
	Numerical: Numerical,
	DomElement: DomElement,
	DomEvent: DomEvent,
	Http: Http,
	Key: Key
}))();

if (typeof define === 'function' && define.amd)
	define('paper', paper);
else if (typeof exports === 'object')
	module.exports = paper;

return paper;
};

},{}],2:[function(require,module,exports){
var Backbone, GroupCollection, GroupModel, async, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

_ = require('underscore');

GroupModel = require('../models/group');

async = require('async');

GroupCollection = (function(_super) {
  __extends(GroupCollection, _super);

  function GroupCollection() {
    return GroupCollection.__super__.constructor.apply(this, arguments);
  }

  GroupCollection.prototype.model = GroupModel;

  GroupCollection.prototype.comparator = 'position';

  GroupCollection.prototype.url = '/groups';

  GroupCollection.prototype.belongsTo = 'recipes';

  GroupCollection.prototype.initialize = function(attrs, options) {
    if (attrs == null) {
      attrs = {};
    }
    if (options == null) {
      options = {};
    }
    return this.app = options.app, options;
  };

  GroupCollection.prototype.fetchRecursive = function(app, parent, parentCallback) {
    this.app = app;
    this.parent = parent;
    return this.fetch({
      url: "/" + this.belongsTo + "/" + (this.parent.get('id')) + this.url,
      success: (function(_this) {
        return function(collection, models, options) {
          var fetchTasks;
          fetchTasks = [];
          _this.each(function(model) {
            fetchTasks.push(function(callback) {
              return model.sounds.fetchRecursive(_this.app, model, callback);
            });
            return fetchTasks.push(function(callback2) {
              return model.patterns.fetchRecursive(_this.app, model, callback2);
            });
          });
          return async.parallel(fetchTasks, parentCallback);
        };
      })(this)
    }, {
      reset: true
    });
  };

  return GroupCollection;

})(Backbone.Collection);

module.exports = GroupCollection;


},{"../models/group":8}],3:[function(require,module,exports){
var Backbone, PatternCollection, PatternModel, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

_ = require('underscore');

PatternModel = require('../models/pattern');

PatternCollection = (function(_super) {
  __extends(PatternCollection, _super);

  function PatternCollection() {
    return PatternCollection.__super__.constructor.apply(this, arguments);
  }

  PatternCollection.prototype.initialize = function(models, options) {
    if (models == null) {
      models = {};
    }
    if (options == null) {
      options = {};
    }
    return this.group = options.group, options;
  };

  PatternCollection.prototype.comparator = 'position';

  PatternCollection.prototype.model = PatternModel;

  PatternCollection.prototype.belongsTo = 'groups';

  PatternCollection.prototype.url = '/patterns';

  PatternCollection.prototype.fetchRecursive = function(app, parent, parentCallback) {
    this.app = app;
    this.parent = parent;
    return this.fetch({
      url: "/" + this.belongsTo + "/" + (this.parent.get('id')) + this.url,
      success: (function(_this) {
        return function(collection, models, options) {
          return parentCallback.call(_this, null, models);
        };
      })(this),
      group: this.parent
    }, app, this.app, {
      reset: true
    });
  };

  return PatternCollection;

})(Backbone.Collection);

module.exports = PatternCollection;


},{"../models/pattern":9}],4:[function(require,module,exports){
var Backbone, SoundCollection, SoundModel, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

_ = require('underscore');

SoundModel = require('../models/sound');

SoundCollection = (function(_super) {
  __extends(SoundCollection, _super);

  function SoundCollection() {
    return SoundCollection.__super__.constructor.apply(this, arguments);
  }

  SoundCollection.prototype.initialize = function(models, options) {
    if (options == null) {
      options = {};
    }
    return this.group = options.group, options;
  };

  SoundCollection.prototype.model = SoundModel;

  SoundCollection.prototype.belongsTo = 'recipes';

  SoundCollection.prototype.url = '/sounds';

  SoundCollection.prototype.fetchRecursive = function(app, parent, parentCallback) {
    this.app = app;
    this.parent = parent;
    return this.fetch({
      url: "/" + this.belongsTo + "/" + (this.parent.get('id')) + this.url,
      success: (function(_this) {
        return function(collection, models, options) {
          return parentCallback.call(_this, null, models);
        };
      })(this)
    }, {
      group: this.parent
    }, app, this.app, {
      reset: true
    });
  };

  return SoundCollection;

})(Backbone.Collection);

module.exports = SoundCollection;


},{"../models/sound":11}],5:[function(require,module,exports){
'use strict';
window.Beet = window.Beet || require('./views/app');


},{"./views/app":21}],6:[function(require,module,exports){
var $, Backbone, BaseModel, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = $ = require('../vendor/jquery-bootstrap');

Backbone.NestedModel = require('backbone-nested').NestedModel;

_ = require('underscore');

BaseModel = (function(_super) {
  __extends(BaseModel, _super);

  function BaseModel() {
    return BaseModel.__super__.constructor.apply(this, arguments);
  }

  BaseModel.prototype.idAttribute = '_id';

  return BaseModel;

})(Backbone.NestedModel);

module.exports = BaseModel;


},{"../vendor/jquery-bootstrap":19}],7:[function(require,module,exports){
var Backbone, DisplayModel, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

_ = require('underscore');

DisplayModel = (function(_super) {
  __extends(DisplayModel, _super);

  function DisplayModel() {
    return DisplayModel.__super__.constructor.apply(this, arguments);
  }

  DisplayModel.prototype.defaults = {
    one: 'Welcome',
    time: 0
  };

  DisplayModel.prototype.initialize = function(options) {};

  return DisplayModel;

})(Backbone.Model);

module.exports = DisplayModel;


},{}],8:[function(require,module,exports){
var Backbone, GroupModel, PatternCollection, SoundCollection, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = require('jquery');

Backbone.NestedModel = require('backbone-nested').NestedModel;

_ = require('underscore');

SoundCollection = require('../collections/sound');

PatternCollection = require('../collections/pattern');

GroupModel = (function(_super) {
  __extends(GroupModel, _super);

  function GroupModel() {
    return GroupModel.__super__.constructor.apply(this, arguments);
  }

  GroupModel.prototype.initialize = function(attrs, options) {
    var _ref;
    if (attrs == null) {
      attrs = {};
    }
    if (options == null) {
      options = {};
    }
    _ref = options.collection, this.app = _ref.app, this.pads = _ref.pads;
    this.sounds = new SoundCollection(attrs.sounds || [
      {
        pad: 1
      }
    ], {
      group: this
    });
    return this.patterns = new PatternCollection(attrs.patterns || [
      {
        position: 1
      }
    ], {
      group: this
    });
  };

  GroupModel.prototype.url = function() {
    if (this.isNew() && this.get('recipe_id')) {
      return "/recipes/" + (this.get('recipe_id')) + "/groups";
    } else {
      if (this.isNew()) {
        return "/groups";
      } else {
        return "/groups/" + (this.get('id'));
      }
    }
  };

  return GroupModel;

})(Backbone.NestedModel);

module.exports = GroupModel;


},{"../collections/pattern":3,"../collections/sound":4}],9:[function(require,module,exports){
var $, Backbone, PatternGridView, PatternModel, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.NestedModel = require('backbone-nested').NestedModel;

_ = require('underscore');

$ = require('jquery');

PatternGridView = require('../views/pattern.grid');

PatternModel = (function(_super) {
  __extends(PatternModel, _super);

  function PatternModel() {
    return PatternModel.__super__.constructor.apply(this, arguments);
  }

  PatternModel.prototype.defaults = function() {
    var attrs;
    return attrs = {
      triggers: {},
      len: 4,
      position: 1,
      zoom: 2,
      step: 64
    };
  };

  PatternModel.prototype.url = function() {
    if (this.isNew() && this.get('groupId')) {
      return "/groups/" + (this.get('groupId')) + "/patterns";
    } else {
      if (this.isNew()) {
        return "/patterns";
      } else {
        return "/patterns/" + (this.get('id'));
      }
    }
  };

  PatternModel.prototype.initialize = function(attrs, options) {
    if (attrs == null) {
      attrs = {};
    }
    if (options == null) {
      options = {};
    }
    return this.view = new PatternGridView({
      model: this
    });
  };

  PatternModel.prototype.toJSON = function() {
    var attrs;
    attrs = $.extend({}, this.attributes);
    attrs.zoom = parseInt(attrs.zoom, 10) || 2;
    attrs.step = parseInt(attrs.step, 10) || 64;
    return attrs;
  };

  return PatternModel;

})(Backbone.NestedModel);

module.exports = PatternModel;


},{"../views/pattern.grid":26}],10:[function(require,module,exports){
var Backbone, BackboneNested, RecipeModel, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

BackboneNested = require('backbone-nested');

_ = require('underscore');

RecipeModel = (function(_super) {
  __extends(RecipeModel, _super);

  function RecipeModel() {
    return RecipeModel.__super__.constructor.apply(this, arguments);
  }

  RecipeModel.prototype.defaults = {
    name: 'New Recipe'
  };

  RecipeModel.prototype.urlRoot = '/recipes';

  return RecipeModel;

})(Backbone.NestedModel);

module.exports = RecipeModel;


},{}],11:[function(require,module,exports){
var $, BaseModel, SoundModel, T, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = require('../vendor/jquery-bootstrap');

_ = require('underscore');

T = require('../vendor/timbre.dev');

BaseModel = require('./base');

SoundModel = (function(_super) {
  __extends(SoundModel, _super);

  function SoundModel() {
    return SoundModel.__super__.constructor.apply(this, arguments);
  }

  SoundModel.prototype.url = function() {
    if (this.isNew() && this.get('groupId')) {
      return "/groups/" + (this.get('groupId')) + "/sounds";
    } else {
      if (this.isNew()) {
        return "/sounds";
      } else {
        return "/sounds/" + (this.get('_id'));
      }
    }
  };

  SoundModel.prototype.initialize = function(attrs, options) {
    var _ref, _ref1;
    if (attrs == null) {
      attrs = {};
    }
    if (options == null) {
      options = {};
    }
    _.bindAll(this, 'loadSrc');
    if (((_ref = this.collection) != null ? _ref.group.app.pads : void 0) != null) {
      if ((_ref1 = this.collection.group.app.pads.pads[this.get('pad') - 1 % 16]) != null) {
        _ref1.bootstrapWithModel(this);
      }
    }
    this.on('change:src', this.loadSrc);
    return this.on('change:fx', (function(_this) {
      return function() {
        _this.timbreContextAttached = false;
        return _this.rendered = false;
      };
    })(this));
  };

  SoundModel.prototype.play = function() {
    var sound, _ref;
    if (!this.rendered) {
      sound = this.renderEffects();
      if (!this.timbreContextAttached) {
        this.timbreContextAttached = true;
        $(sound.play()).one('ended', this.onEnded);
      } else {
        sound.bang();
      }
    } else {
      if ((_ref = this.T.rendered) != null ? _ref.playbackState : void 0) {
        this.T.rendered.currentTime = 0;
      } else {
        $(this.T.rendered.bang()).one('ended', this.onEnded);
      }
    }
    return this;
  };

  SoundModel.prototype.onEnded = function() {
    return this.pause();
  };

  SoundModel.prototype.renderEffects = function(cb) {
    var sound;
    sound = null;
    if (this.T) {
      delete this.T.rendered;
    }
    this.T.rendered = this.T.raw.clone();
    _.each(this.get('fx'), (function(_this) {
      return function(params, fx) {
        return sound = T(fx, params, sound || _this.T.rendered);
      };
    })(this));
    this.rendered = true;
    return sound || this.T.rendered;
  };

  SoundModel.prototype.loadSrc = function(model, src, options, cb) {
    var _this;
    _this = this;
    if (src || this.get('src')) {
      this.loaded = false;
      return T('audio').load(src || this.get('src'), function() {
        _this.T = {
          raw: this
        };
        _this.loaded = true;
        _this.trigger('loaded');
        if (cb) {
          return cb.call(_this, this);
        }
      });
    }
  };

  return SoundModel;

})(BaseModel);

module.exports = SoundModel;


},{"../vendor/jquery-bootstrap":19,"../vendor/timbre.dev":20,"./base":6}],12:[function(require,module,exports){
var Backbone, TransportModel, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

_ = require('underscore');

TransportModel = (function(_super) {
  __extends(TransportModel, _super);

  function TransportModel() {
    return TransportModel.__super__.constructor.apply(this, arguments);
  }

  TransportModel.prototype.initialize = function(attrs) {
    if (attrs == null) {
      attrs = {};
    }
    if ((attrs.bpm != null) && attrs.step) {
      this.setInterval(attrs.bpm, attrs.step);
    }
    this.on('change:interval', this.setInterval);
    this.on('change:bpm', this.setInterval);
    return this.on('change:step', this.setInterval);
  };

  TransportModel.prototype.setInterval = function(bpm, step) {
    var interval;
    interval = (60 * 1000) / parseInt(bpm || this.get('bpm'), 10) / parseInt(step || this.get('step'), 10);
    return this.set('interval', interval);
  };

  return TransportModel;

})(Backbone.Model);

module.exports = TransportModel;


},{}],13:[function(require,module,exports){
var AppRouter, Backbone, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

_ = require('underscore');

AppRouter = (function(_super) {
  __extends(AppRouter, _super);

  function AppRouter() {
    return AppRouter.__super__.constructor.apply(this, arguments);
  }

  AppRouter.prototype.routes = {
    '': 'main',
    'pad/:num': 'soundEditor',
    'beet/:id': 'open'
  };

  AppRouter.prototype.initialize = function(options) {
    return this.app = options.app, options;
  };

  AppRouter.prototype.main = function() {};

  AppRouter.prototype.soundEditor = function(padNumber) {};

  AppRouter.prototype.open = function(id) {
    return console.log('open ' + id);
  };

  return AppRouter;

})(Backbone.Router);

module.exports = AppRouter;


},{}],14:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="row">\n\t<div class="col-xs-12">\n\t\t<pre class="tiny">\n _               _                        _     _            \n| |__   ___  ___| |_ _ __ ___   __ _  ___| |__ (_)_ __   ___ \n| \'_ \\ / _ \\/ _ \\ __| \'_ ` _ \\ / _` |/ __| \'_ \\| | \'_ \\ / _ \\\n| |_) |  __/  __/ |_| | | | | | (_| | (__| | | | | | | |  __/\n|_.__/ \\___|\\___|\\__|_| |_| |_|\\__,_|\\___|_| |_|_|_| |_|\\___|\n\t\t</pre>\n\t\t<span lg-bind="one">'+
((__t=( one ))==null?'':__t)+
'</span>\n\t</div>\n</div>\n<div class="row">\n\t<div class="col-xs-6">\n\t\t<span class="" style="font-family:Courier" lg-bind="left">00:00:00:00</span>\n\t</div>\n\t<div class="col-xs-6" lg-bind="right">\n\t</div>\n</div>';
}
return __p;
};
},{}],15:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="modal-dialog">\n\t<div class="modal-content">\n\t\t<div class="modal-header">\n\t\t\t<a href="javascript:void(0)" class="close right" data-dismiss="modal" aria-hidden="true">&times;</a>\n\t\t\t<h4 class="modal-title">Sound Editor: <span lg-bind="name"></span></h4>\n\t\t</div>\n\t\t<div class="modal-body">\n\t\t\t<form class="form-horizontal" onsubmit="return false">\n\t\t\t\t<div class="form-group">\n\t\t\t\t\t<div class="col-xs-12">\n\t\t\t\t\t\t<label>Name</label>\n\t\t\t\t\t\t<input class="form-control" type="text" placeholder="" lg-bind="name" />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class="form-group">\n\t\t\t\t\t<div class="col-xs-12">\n\t\t\t\t\t\t<label>Source</label>\n\t\t\t\t\t\t<input class="form-control readonly" readonly type="text" placeholder="" lg-bind="src" />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class="row">\n\t\t\t\t\t<div class="col-xs-12">\n\t\t\t\t\t\t<canvas width="558" height="100" class="waveform" alt="Click to preview">No Pad or Not Rendered Yet</canvas>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class="form-group">\n\t\t\t\t\t<div class="col-xs-6">\n\t\t\t\t\t\t<label>Key Trigger:</label>\n\t\t\t\t\t\t<input class="form-control" type="text" placeholder="" lg-bind="keyCode" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class="col-xs-6">\n\t\t\t\t\t\t<div class="row collapse">\n\t\t\t\t\t\t\t<label>Effects</label>\n\t\t\t\t\t\t\t<div class="col-xs-9">\n\t\t\t\t\t\t\t\t<input class="form-control" type="text" placeholder="" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class="form-group">\n\t\t\t\t\t<div class="col-xs-12">\n\t\t\t\t\t\t<div class="btn-group btn-group-justified">\n\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm active" href="#editor/'+
((__t=( data.pad ))==null?'':__t)+
'-eq" data-behavior="tab" data-tab=".eq">EQ</a>\n\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm" href="#editor/'+
((__t=( data.pad ))==null?'':__t)+
'-reverb" data-behavior="tab" data-tab=".reverb">Reverb</a>\n\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm" href="#editor/'+
((__t=( data.pad ))==null?'':__t)+
'-delay" data-behavior="tab" data-tab=".delay">Delay</a>\n\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm" href="#editor/'+
((__t=( data.pad ))==null?'':__t)+
'-chorus" data-behavior="tab" data-tab=".chorus">Chorus</a>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class="tab-content">\n\t\t\t\t\t\t\t<div class="tab-pane eq" '+
((__t=( !view.show ? 'lg' : '' ))==null?'':__t)+
'>\n\t\t\t\t\t\t\t\t<canvas style="width:100%;height:100px;" class="eqform"></canvas>\n\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t<div class="col-xs-12">\n\t\t\t\t\t\t\t\t\t\t\t<label>hpf</label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" class="eq" data-param="hpf" min="-20" max="20" step="0.5">\n\t\t\t\t\t\t\t\t\t\t\t<label>lf</label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" class="eq" data-param="lf" min="-20" max="20" step="0.5">\n\t\t\t\t\t\t\t\t\t\t\t<label>lmf</label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" class="eq" data-param="lmf" min="-20" max="20" step="0.5">\n\t\t\t\t\t\t\t\t\t\t\t<label>mf</label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" class="eq" data-param="mf" min="-20" max="20" step="0.5">\n\t\t\t\t\t\t\t\t\t\t\t<label>hmf</label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" class="eq" data-param="hmf" min="-20" max="20" step="0.5">\n\t\t\t\t\t\t\t\t\t\t\t<label>hf</label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" class="eq" data-param="hf" min="-20" max="20" step="0.5">\n\t\t\t\t\t\t\t\t\t\t\t<label>lpf</label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" class="eq" data-param="lpf" min="-20" max="20" step="0.5">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class="tab-pane reverb" '+
((__t=( view.show === 'reverb' ? '' : 'hidden' ))==null?'':__t)+
'>\n\t\t\t\t\t\t\t\t';
 if (data.fx && data.fx.reverb) { 
__p+='\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-12 text-right">\n\t\t\t\t\t\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm" data-behavior="toggleEffect" data-effect="reverb">Disable Reverb</a>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Room <span class="label label-default" lg-bind="fx.reverb.room">'+
((__t=( data.fx.reverb.room ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.reverb.room" min="0" max="2" step="0.1">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Wet/Dry <span class="label label-default" lg-bind="fx.reverb.damp">'+
((__t=( data.fx.reverb.damp ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.reverb.damp" min="0" max="1" step="0.1">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Mix <span class="label label-default" lg-bind="fx.reverb.mix">'+
((__t=( data.fx.reverb.mix ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.reverb.mix" min="0" max="1" step="0.01">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t';
 } else { 
__p+='\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-12">\n\t\t\t\t\t\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm" data-behavior="toggleEffect" data-effect="reverb">Enable Reverb</a>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t';
 } 
__p+='\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class="tab-pane delay" '+
((__t=( view.show === 'delay' ? '' : 'hidden' ))==null?'':__t)+
'>\n\t\t\t\t\t\t\t\t';
 if (data.fx && data.fx.delay) { 
__p+='\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-12 text-right">\n\t\t\t\t\t\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm" data-behavior="toggleEffect" data-effect="delay">Disable Delay</a>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Time <span class="label label-default" lg-bind="fx.delay.time">'+
((__t=( data.fx.delay.time ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.delay.time" min="10" max="1250" step="10">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Feedback <span class="label label-default" lg-bind="fx.delay.fb">'+
((__t=( data.fx.delay.fb ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.delay.fb" min="-1" max="1" step="0.1">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-1">\n\t\t\t\t\t\t\t\t\t\t\t<label>Cross Delay <span class="label label-default" lg-bind="fx.delay.cross">'+
((__t=( data.fx.delay.cross ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.delay.cross" min="0" max="1" step="0.01">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-3">\n\t\t\t\t\t\t\t\t\t\t\t<label>Mix <span class="label label-default" lg-bind="fx.delay.mix">'+
((__t=( data.fx.delay.mix ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.delay.mix" min="0" max="1" step="0.01">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t';
 } else { 
__p+='\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-12">\n\t\t\t\t\t\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm" data-behavior="toggleEffect" data-effect="delay">Enable Delay</a>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t';
 } 
__p+='\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class="tab-pane chorus" '+
((__t=( view.show === 'chorus' ? '' : 'hidden' ))==null?'':__t)+
'>\n\t\t\t\t\t\t\t';
 if (data.fx && data.fx.chorus) { 
__p+='\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-12 text-right">\n\t\t\t\t\t\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm" data-behavior="toggleEffect" data-effect="chorus">Disable Chorus</a>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<label>Type <span class="label label-default" lg-bind="fx.chorus.type">'+
((__t=( data.fx.chorus.type ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<select lg-bind="fx.chorus.type" class="form-control">\n\t\t\t\t\t\t\t\t\t\t\t\t<option value="sin">Sin</option>\n\t\t\t\t\t\t\t\t\t\t\t\t<option value="tri">Tri</option>\n\t\t\t\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Delay <span class="label label-default" lg-bind="fx.chorus.delay">'+
((__t=( data.fx.chorus.delay ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.chorus.delay" min="0.5" max="80" step="0.5">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Rate <span class="label label-default" lg-bind="fx.chorus.rate">'+
((__t=( data.fx.chorus.rate ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.chorus.rate" min="0" max="10" step="0.5">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Depth <span class="label label-default" lg-bind="fx.chorus.depth">'+
((__t=( data.fx.chorus.depth ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.chorus.depth" min="0" max="100" step="1">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Feedback <span class="label label-default" lg-bind="fx.chorus.fb">'+
((__t=( data.fx.chorus.fb ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.chorus.fb" min="-1" max="1" step="0.1">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Wet <span class="label label-default" lg-bind="fx.chorus.wet">'+
((__t=( data.fx.chorus.wet ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.chorus.wet" min="0" max="1" step="0.01">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-4">\n\t\t\t\t\t\t\t\t\t\t\t<label>Mix <span class="label label-default" lg-bind="fx.chorus.mix">'+
((__t=( data.fx.chorus.mix ))==null?'':__t)+
'</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type="range" lg-bind="fx.chorus.mix" min="0" max="1" step="0.01">\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t';
 } else { 
__p+='\n\t\t\t\t\t\t\t\t\t<div class="form-group">\n\t\t\t\t\t\t\t\t\t\t<div class="col-xs-12">\n\t\t\t\t\t\t\t\t\t\t\t\t<a class="btn btn-squishy btn-sm" data-behavior="toggleEffect" data-effect="chorus">Enable Chorus</a>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t';
 } 
__p+='\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class="form-group">\n\t\t\t\t\t<div class="col-xs-12">\n\t\t\t\t\t\t<textarea class="form-control" placeholder=""></textarea>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</form>\n\t\t</div>\n\t\t<div class="modal-footer">\n\t\t\t<a data-dismiss="modal" data-behavior="close" class="btn btn-sm btn-squishy">Cancel</a>\n\t\t\t<a data-dismiss="modal" data-behavior="save" class="btn btn-sm btn-squishy">Save</a>\n\t\t</div>\n\t</div>\n</div>';
}
return __p;
};
},{}],16:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="pad-label">\n\t<small lg-bind="name">'+
((__t=( name ))==null?'':_.escape(__t))+
'</small>\n</div>\n<div class="pad btn btn-squishy">&nbsp;</div>\n<div class="progress">\n  <div class="progress-bar"></div>\n</div>';
}
return __p;
};
},{}],17:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='\n\n';
}
return __p;
};
},{}],18:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="btn-group btn-group-justified">\n\t<a href="javascript:void(0)" data-behavior="play" class="btn btn-squishy btn-sm">\n\t\t<span class="glyphicon glyphicon-play"></span><span class="glyphicon glyphicon-pause"></span> Play\n\t</a>\n\t<a href="javascript:void(0)" data-behavior="record" class="btn btn-squishy btn-sm">\n\t\t<span class="glyphicon glyphicon-record"></span> Record\n\t</a>\n\t<a href="javascript:void(0)" data-behavior="stop" class="btn btn-squishy btn-sm">\n\t\t<span class="glyphicon glyphicon-stop"></span> Stop\n\t</a>\n</div>\n<div class="btn-group btn-group-justified">\n\t<a href="javascript:void(0)" data-behavior="restart" class="btn btn-squishy btn-sm">\n\t\t<span class="glyphicon glyphicon-step-backward"></span>\n\t</a>\n\t<a href="javascript:void(0)" data-behavior="end" class="btn btn-squishy btn-sm">\n\t\t<span class="glyphicon glyphicon-step-forward"></span>\n\t</a>\n</div>';
}
return __p;
};
},{}],19:[function(require,module,exports){
$ = require('jquery');

window.$ = window.jQuery = $

require('../../node_modules/twitter-bootstrap/js/bootstrap-alert.js');
require('../../node_modules/twitter-bootstrap/js/bootstrap-button.js');
require('../../node_modules/twitter-bootstrap/js/bootstrap-dropdown.js');
require('../../node_modules/twitter-bootstrap/js/bootstrap-modal.js');
require('../../node_modules/twitter-bootstrap/js/bootstrap-tooltip.js');
require('../../node_modules/twitter-bootstrap/js/bootstrap-popover.js');
require('../../node_modules/twitter-bootstrap/js/bootstrap-transition.js');
require('../../node_modules/twitter-bootstrap/js/bootstrap-typeahead.js');

module.exports = $;
},{"../../node_modules/twitter-bootstrap/js/bootstrap-alert.js":31,"../../node_modules/twitter-bootstrap/js/bootstrap-button.js":32,"../../node_modules/twitter-bootstrap/js/bootstrap-dropdown.js":33,"../../node_modules/twitter-bootstrap/js/bootstrap-modal.js":34,"../../node_modules/twitter-bootstrap/js/bootstrap-popover.js":35,"../../node_modules/twitter-bootstrap/js/bootstrap-tooltip.js":36,"../../node_modules/twitter-bootstrap/js/bootstrap-transition.js":37,"../../node_modules/twitter-bootstrap/js/bootstrap-typeahead.js":38}],20:[function(require,module,exports){
(function (global){
/**
 * T("timbre.js") - A JavaScript library for objective sound programming
 */
(function(undefined) {
    "use strict";

    var timbre = function() {
        return T.apply(null, arguments);
    };

    var slice = Array.prototype.slice;

    var FINISHED_STATE    = 0;
    var PLAYING_STATE     = 1;
    var UNSCHEDULED_STATE = 2; // (not use)
    var SCHEDULED_STATE   = 3; // (not use)

    var ACCEPT_SAMPLERATES = [8000,11025,12000,16000,22050,24000,32000,44100,48000];
    var ACCEPT_CELLSIZES = [32,64,128,256];

    var _ver = "14.05.28";
    var _sys = null;
    var _constructors = {};
    var _factories    = {};
    var _envtype = (typeof window !== "undefined") ? "browser" :
        (typeof module !== "undefined" && module.exports) ? "node" : "unknown";
    var _envmobile = _envtype === "browser" && /(iPhone|iPad|iPod|Android)/i.test(navigator.userAgent);
    var _f64mode = false;
    var _bpm = 120;

    var T = function() {
        var args = slice.call(arguments), key = args[0], t, m;

        switch (typeof key) {
        case "string":
            if (_constructors[key]) {
                t = new _constructors[key](args.slice(1));
            } else if (_factories[key]) {
                t = _factories[key](args.slice(1));
            } else {
                m = /^(.+?)(?:\.(ar|kr))?$/.exec(key);
                if (m) {
                    key = m[1];
                    if (_constructors[key]) {
                        t = new _constructors[key](args.slice(1));
                    } else if (_factories[key]) {
                        t = _factories[key](args.slice(1));
                    }
                    if (t && m[2]) {
                        t[m[2]]();
                    }
                }
            }
            break;
        case "number":
            t = new NumberWrapper(args);
            break;
        case "boolean":
            t = new BooleanWrapper(args);
            break;
        case "function":
            t = new FunctionWrapper(args);
            break;
        case "object":
            if (key !== null) {
                if (key instanceof TimbreObject) {
                    return key;
                } else if (key.context instanceof TimbreObject) {
                    return key.context;
                } else if (isDictionary(key)) {
                    t = new ObjectWrapper(args);
                } else if (isArray(key)) {
                    t = new ArrayWrapper(args);
                }
            }
            break;
        }

        if (t === undefined) {
            t = new AddNode(args.slice(1));
            console.warn("T(\"" + key + "\") is not defined.");
        }

        var _ = t._;
        _.originkey = key;
        _.meta = __buildMetaData(t);
        _.emit("init");

        return t;
    };

    var __buildMetaData = function(instance) {
        var meta = instance._.meta;
        var names, desc;
        var p = instance;
        while (p !== null && p.constructor !== Object) {
            names = Object.getOwnPropertyNames(p);
            for (var i = 0, imax = names.length; i < imax; ++i) {
                if (meta[names[i]]) {
                    continue;
                }
                if (/^(constructor$|process$|_)/.test(names[i])) {
                    meta[names[i]] = "ignore";
                } else {
                    desc = Object.getOwnPropertyDescriptor(p, names[i]);
                    if (typeof desc.value === "function") {
                        meta[names[i]] = "function";
                    } else if (desc.get || desc.set) {
                        meta[names[i]] = "property";
                    }
                }
            }
            p = Object.getPrototypeOf(p);
        }
        return meta;
    };

    // properties
    Object.defineProperties(timbre, {
        version  : { value: _ver },
        envtype  : { value: _envtype },
        envmobile: { value: _envmobile },
        env: {
            get: function() {
                return _sys.impl.env;
            }
        },
        samplerate: {
            get: function() {
                return _sys.samplerate;
            }
        },
        channels: {
            get: function() {
                return _sys.channels;
            }
        },
        cellsize: {
            get: function() {
                return _sys.cellsize;
            }
        },
        currentTime: {
            get: function() {
                return _sys.currentTime;
            }
        },
        isPlaying: {
            get: function() {
                return _sys.status === PLAYING_STATE;
            }
        },
        isRecording: {
            get: function() {
                return _sys.status === SCHEDULED_STATE;
            }
        },
        amp: {
            set: function(value) {
                if (typeof value === "number") {
                    _sys.amp = value;
                }
            },
            get: function() {
                return _sys.amp;
            }
        },
        bpm: {
            set: function(value) {
                if (typeof value === "number") {
                    if (5 <= value && value <= 300) {
                        _bpm = value;
                    }
                }
            },
            get: function() {
                return _bpm;
            }
        }
    });

    timbre.bind = function(Klass, opts) {
        _sys.bind(Klass, opts);
        return timbre;
    };
    timbre.setup = function(opts) {
        _sys.setup(opts);
        return timbre;
    };
    timbre.play = function() {
        _sys.play();
        return timbre;
    };
    timbre.pause = function() {
        _sys.pause();
        return timbre;
    };
    timbre.reset = function() {
        _sys.reset();
        _sys.events.emit("reset");
        return timbre;
    };
    timbre.on = timbre.addListener = function(type, listener) {
        _sys.on(type, listener);
        return timbre;
    };
    timbre.once = function(type, listener) {
        _sys.once(type, listener);
        return timbre;
    };
    timbre.off = timbre.removeListener = function(type, listener) {
        _sys.off(type, listener);
        return timbre;
    };
    timbre.removeAllListeners = function(type) {
        _sys.removeAllListeners(type);
        return timbre;
    };
    timbre.listeners = function(type) {
        return _sys.listeners(type);
    };
    timbre.rec = function() {
        return _sys.rec.apply(_sys, arguments);
    };
    timbre.timevalue = (function() {
        var getbpm = function(str) {
            var m, bpm = _bpm;
            if ((m = /^bpm(\d+(?:\.\d+)?)/i.exec(str))) {
                bpm = Math.max(5, Math.min(300, +(m[1]||0)));
            }
            return bpm;
        };
        return function(str) {
            var m, ms, x;
            if ((m = /^(\d+(?:\.\d+)?)Hz$/i.exec(str))) {
                return +m[1] === 0 ? 0 : 1000 / +m[1];
            }
            if ((m = /L(\d+)?(\.*)$/i.exec(str))) {
                ms = 60 / getbpm(str) * (4 / (m[1]||4)) * 1000;
                ms *= [1, 1.5, 1.75, 1.875][(m[2]||"").length] || 1;
                return ms;
            }
            if ((m = /^(\d+(?:\.\d+)?|\.(?:\d+))(min|sec|m)s?$/i.exec(str))) {
                switch (m[2]) {
                case "min": return +(m[1]||0) * 60 * 1000;
                case "sec": return +(m[1]||0) * 1000;
                case "m"  : return +(m[1]||0);
                }
            }
            if ((m = /^(?:([0-5]?[0-9]):)?(?:([0-5]?[0-9]):)(?:([0-5]?[0-9]))(?:\.([0-9]{1,3}))?$/.exec(str))) {
                x = (m[1]||0) * 3600 + (m[2]||0) * 60 + (m[3]||0);
                x = x * 1000 + ((((m[4]||"")+"00").substr(0, 3))|0);
                return x;
            }
            if ((m = /(\d+)\.(\d+)\.(\d+)$/i.exec(str))) {
                x = (m[1] * 4 + (+m[2])) * 480 + (+m[3]);
                return 60 / getbpm(str) * (x / 480) * 1000;
            }
            if ((m = /(\d+)ticks$/i.exec(str))) {
                return 60 / getbpm(str) * (m[1] / 480) * 1000;
            }
            if ((m = /^(\d+)samples(?:\/(\d+)Hz)?$/i.exec(str))) {
                return m[1] * 1000 / (m[2] || timbre.samplerate);
            }
            return 0;
        };
    })();

    var fn = timbre.fn = {
        SignalArray: Float32Array,
        currentTimeIncr: 0,
        emptycell: null,
        FINISHED_STATE: FINISHED_STATE,
        PLAYING_STATE: PLAYING_STATE,
        UNSCHEDULED_STATE: UNSCHEDULED_STATE,
        SCHEDULED_STATE: SCHEDULED_STATE
    };

    var isArray = fn.isArray = Array.isArray;
    var isDictionary = fn.isDictionary = function(object) {
        return typeof object === "object" && object.constructor === Object;
    };

    fn.nop = function() {
        return this;
    };

    fn.isSignalArray = function(obj) {
        if (obj instanceof fn.SignalArray) {
            return true;
        }
        if (Array.isArray(obj) && obj.__klass && obj.__klass.type === 2) {
            return true;
        }
        return false;
    };

    // borrowed from coffee-script
    fn.extend = function(child, parent) {
        parent = parent || TimbreObject;

        for (var key in parent) {
            if (parent.hasOwnProperty(key)) {
                child[key] = parent[key];
            }
        }
        /*jshint validthis:true */
        function ctor() {
            this.constructor = child;
        }
        /*jshint validthis:false */
        ctor.prototype  = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    };

    fn.constructorof = function(ctor, Klass) {
        var f = ctor && ctor.prototype;
        while (f) {
            if (f === Klass.prototype) {
                return true;
            }
            f = Object.getPrototypeOf(f);
        }
        return false;
    };

    fn.register = function(key, ctor) {
        if (fn.constructorof(ctor, TimbreObject)) {
            _constructors[key] = ctor;
        } else {
            _factories[key] = ctor;
        }
    };

    fn.alias = function(key, alias) {
        if (_constructors[alias]) {
            _constructors[key] = _constructors[alias];
        } else if (_factories[alias]) {
            _factories[key] = _factories[alias];
        }

    };

    fn.getClass = function(key) {
        return _constructors[key];
    };

    fn.pointer = function(src, offset, length) {
        offset = src.byteOffset + offset * src.constructor.BYTES_PER_ELEMENT;
        if (typeof length === "number") {
            return new src.constructor(src.buffer, offset, length);
        } else {
            return new src.constructor(src.buffer, offset);
        }
    };

    fn.nextTick = function(func) {
        _sys.nextTick(func);
        return timbre;
    };

    fn.fixAR = function(self) {
        self._.ar = true;
        self._.aronly = true;
    };

    fn.fixKR = function(self) {
        self._.ar = false;
        self._.kronly = true;
    };

    fn.changeWithValue = function() {
        var _ = this._;
        var x = _.value * _.mul + _.add;
        if (isNaN(x)) {
            x = 0;
        }
        var cell = this.cells[0];
        for (var i = 0, imax = cell.length; i < imax; ++i) {
            cell[i] = x;
        }
    };
    fn.changeWithValue.unremovable = true;

    fn.clone = function(src) {
        var new_instance = new src.constructor([]);
        new_instance._.ar  = src._.ar;
        new_instance._.mul = src._.mul;
        new_instance._.add = src._.add;
        new_instance._.bypassed = src._.bypassed;
        return new_instance;
    };

    fn.timer = (function() {
        var make_onstart = function(self) {
            return function() {
                if (_sys.timers.indexOf(self) === -1) {
                    _sys.timers.push(self);
                    _sys.events.emit("addObject");
                    self._.emit("start");
                    fn.buddies_start(self);
                }
            };
        };
        var make_onstop = function(self) {
            return function() {
                var i = _sys.timers.indexOf(self);
                if (i !== -1) {
                    _sys.timers.splice(i, 1);
                    self._.emit("stop");
                    _sys.events.emit("removeObject");
                    fn.buddies_stop(self);
                }
            };
        };
        return function(self) {
            var onstart = make_onstart(self);
            var onstop  = make_onstop(self);
            self.nodeType = TimbreObject.TIMER;
            self.start = function() {
                _sys.nextTick(onstart);
                return self;
            };
            self.stop = function() {
                _sys.nextTick(onstop);
                return self;
            };
            return self;
        };
    })();

    fn.listener = (function() {
        var make_onlisten = function(self) {
            return function() {
                if (_sys.listeners.indexOf(self) === -1) {
                    _sys.listeners.push(self);
                    _sys.events.emit("addObject");
                    self._.emit("listen");
                    fn.buddies_start(self);
                }
            };
        };
        var make_onunlisten = function(self) {
            return function() {
                var i = _sys.listeners.indexOf(self);
                if (i !== -1) {
                    _sys.listeners.splice(i, 1);
                    self._.emit("unlisten");
                    _sys.events.emit("removeObject");
                    fn.buddies_stop(self);
                }
            };
        };
        return function(self) {
            var onlisten = make_onlisten(self);
            var onunlisten = make_onunlisten(self);
            self.nodeType = TimbreObject.LISTENER;
            self.listen = function(buddies) {
                if (arguments.length) {
                    self.append.apply(self, arguments);
                }
                if (self.nodes.length) {
                    _sys.nextTick(onlisten);
                }
                return self;
            };
            self.unlisten = function() {
                if (arguments.length) {
                    self.remove.apply(self, arguments);
                }
                if (!self.nodes.length) {
                    _sys.nextTick(onunlisten);
                }
                return self;
            };
            return self;
        };
    })();

    fn.make_onended = function(self, lastValue) {
        return function() {
            self.playbackState = FINISHED_STATE;
            if (typeof lastValue === "number") {
                var cell  = self.cells[0];
                var cellL = self.cells[1];
                var cellR = self.cells[2];
                for (var i = 0, imax = cellL.length; i < imax; ++i) {
                    cell[0] = cellL[i] = cellR[i] = lastValue;
                }
            }
            self._.emit("ended");
        };
    };

    fn.inputSignalAR = function(self) {
        var cell  = self.cells[0];
        var cellL = self.cells[1];
        var cellR = self.cells[2];
        var nodes = self.nodes;
        var i, imax = nodes.length;
        var j, jmax = cell.length;
        var tickID  = self.tickID;
        var not_clear, tmp, tmpL, tmpR;

        if (self.numChannels === 2) {
            not_clear = true;
            if (imax !== 0) {
                for (i = 0; i < imax; ++i) {
                    if (nodes[i].playbackState === PLAYING_STATE) {
                        nodes[i].process(tickID);
                        cellL.set(nodes[i].cells[1]);
                        cellR.set(nodes[i].cells[2]);
                        not_clear = false;
                        ++i;
                        break;
                    }
                }
                for (; i < imax; ++i) {
                    if (nodes[i].playbackState === PLAYING_STATE) {
                        nodes[i].process(tickID);
                        tmpL = nodes[i].cells[1];
                        tmpR = nodes[i].cells[2];
                        for (j = jmax; j; ) {
                            j -= 8;
                            cellL[j  ] += tmpL[j  ]; cellR[j  ] += tmpR[j  ];
                            cellL[j+1] += tmpL[j+1]; cellR[j+1] += tmpR[j+1];
                            cellL[j+2] += tmpL[j+2]; cellR[j+2] += tmpR[j+2];
                            cellL[j+3] += tmpL[j+3]; cellR[j+3] += tmpR[j+3];
                            cellL[j+4] += tmpL[j+4]; cellR[j+4] += tmpR[j+4];
                            cellL[j+5] += tmpL[j+5]; cellR[j+5] += tmpR[j+5];
                            cellL[j+6] += tmpL[j+6]; cellR[j+6] += tmpR[j+6];
                            cellL[j+7] += tmpL[j+7]; cellR[j+7] += tmpR[j+7];
                        }
                    }
                }
            }
            if (not_clear) {
                cellL.set(fn.emptycell);
                cellR.set(fn.emptycell);
            }
        } else {
            not_clear = true;
            if (imax !== 0) {
                for (i = 0; i < imax; ++i) {
                    if (nodes[i].playbackState === PLAYING_STATE) {
                        nodes[i].process(tickID);
                        cell.set(nodes[i].cells[0]);
                        not_clear = false;
                        ++i;
                        break;
                    }
                }
                for (; i < imax; ++i) {
                    if (nodes[i].playbackState === PLAYING_STATE) {
                        tmp = nodes[i].process(tickID).cells[0];
                        for (j = jmax; j; ) {
                            j -= 8;
                            cell[j  ] += tmp[j  ];
                            cell[j+1] += tmp[j+1];
                            cell[j+2] += tmp[j+2];
                            cell[j+3] += tmp[j+3];
                            cell[j+4] += tmp[j+4];
                            cell[j+5] += tmp[j+5];
                            cell[j+6] += tmp[j+6];
                            cell[j+7] += tmp[j+7];
                        }
                    }
                }
            }
            if (not_clear) {
                cell.set(fn.emptycell);
            }
        }
    };

    fn.inputSignalKR = function(self) {
        var nodes = self.nodes;
        var i, imax = nodes.length;
        var tickID = self.tickID;
        var tmp = 0;
        for (i = 0; i < imax; ++i) {
            if (nodes[i].playbackState === PLAYING_STATE) {
                tmp += nodes[i].process(tickID).cells[0][0];
            }
        }
        return tmp;
    };

    fn.outputSignalAR = function(self) {
        var cell  = self.cells[0];
        var cellL = self.cells[1];
        var cellR = self.cells[2];
        var mul = self._.mul, add = self._.add;
        var i;

        if (self.numChannels === 2) {
            for (i = cell.length; i; ) {
                i -= 8;
                cellL[i  ] = cellL[i  ] * mul + add; cellR[i  ] = cellR[i  ] * mul + add;
                cellL[i+1] = cellL[i+1] * mul + add; cellR[i+1] = cellR[i+1] * mul + add;
                cellL[i+2] = cellL[i+2] * mul + add; cellR[i+2] = cellR[i+2] * mul + add;
                cellL[i+3] = cellL[i+3] * mul + add; cellR[i+3] = cellR[i+3] * mul + add;
                cellL[i+4] = cellL[i+4] * mul + add; cellR[i+4] = cellR[i+4] * mul + add;
                cellL[i+5] = cellL[i+5] * mul + add; cellR[i+5] = cellR[i+5] * mul + add;
                cellL[i+6] = cellL[i+6] * mul + add; cellR[i+6] = cellR[i+6] * mul + add;
                cellL[i+7] = cellL[i+7] * mul + add; cellR[i+7] = cellR[i+7] * mul + add;
                cell[i  ] = (cellL[i  ] + cellR[i  ]) * 0.5;
                cell[i+1] = (cellL[i+1] + cellR[i+1]) * 0.5;
                cell[i+2] = (cellL[i+2] + cellR[i+2]) * 0.5;
                cell[i+3] = (cellL[i+3] + cellR[i+3]) * 0.5;
                cell[i+4] = (cellL[i+4] + cellR[i+4]) * 0.5;
                cell[i+5] = (cellL[i+5] + cellR[i+5]) * 0.5;
                cell[i+6] = (cellL[i+6] + cellR[i+6]) * 0.5;
                cell[i+7] = (cellL[i+7] + cellR[i+7]) * 0.5;
            }
        } else {
            if (mul !== 1 || add !== 0) {
                for (i = cell.length; i; ) {
                    i -= 8;
                    cell[i  ] = cell[i  ] * mul + add;
                    cell[i+1] = cell[i+1] * mul + add;
                    cell[i+2] = cell[i+2] * mul + add;
                    cell[i+3] = cell[i+3] * mul + add;
                    cell[i+4] = cell[i+4] * mul + add;
                    cell[i+5] = cell[i+5] * mul + add;
                    cell[i+6] = cell[i+6] * mul + add;
                    cell[i+7] = cell[i+7] * mul + add;
                }
            }
        }
    };

    fn.outputSignalKR = function(self) {
        var cell  = self.cells[0];
        var cellL = self.cells[1];
        var cellR = self.cells[2];
        var mul = self._.mul, add = self._.add;
        var value = cell[0] * mul + add;
        var i;

        if (self.numChannels === 2) {
            for (i = cell.length; i; ) {
                i -= 8;
                cell[i] = cell[i+1] = cell[i+2] = cell[i+3] = cell[i+4] = cell[i+5] = cell[i+6] = cell[i+7] = cellL[i] = cellL[i+1] = cellL[i+2] = cellL[i+3] = cellL[i+4] = cellL[i+5] = cellL[i+6] = cellL[i+7] = cellR[i] = cellR[i+1] = cellR[i+2] = cellR[i+3] = cellR[i+4] = cellR[i+5] = cellR[i+6] = cellR[i+7] = value;
            }
        } else {
            for (i = cell.length; i; ) {
                i -= 8;
                cell[i] = cell[i+1] = cell[i+2] = cell[i+3] = cell[i+4] = cell[i+5] = cell[i+6] = cell[i+7] = value;
            }
        }
    };

    fn.buddies_start = function(self) {
        var buddies = self._.buddies;
        var node, i, imax;
        for (i = 0, imax = buddies.length; i < imax; ++i) {
            node = buddies[i];
            switch (node.nodeType) {
            case TimbreObject.DSP:
                node.play();
                break;
            case TimbreObject.TIMER:
                node.start();
                break;
            case TimbreObject.LISTENER:
                node.listen();
                break;
            }
        }
    };

    fn.buddies_stop = function(self) {
        var buddies = self._.buddies;
        var node, i, imax;
        for (i = 0, imax = buddies.length; i < imax; ++i) {
            node = buddies[i];
            switch (node.nodeType) {
            case TimbreObject.DSP:
                node.pause();
                break;
            case TimbreObject.TIMER:
                node.stop();
                break;
            case TimbreObject.LISTENER:
                node.unlisten();
                break;
            }
        }
    };

    fn.fix_iOS6_1_problem = function(flag) {
        _sys.fix_iOS6_1_problem(flag);
    };

    var modules = timbre.modules = {};

    // EventEmitter
    var EventEmitter = modules.EventEmitter = (function() {
        function EventEmitter(context) {
            this.context = context;
            this.events = {};
        }

        var $ = EventEmitter.prototype;

        $.emit = function(type) {
            var handler = this.events[type];
            if (!handler) {
                return false;
            }

            var args;
            if (typeof handler === "function") {
                switch (arguments.length) {
                case 1:
                    handler.call(this.context);
                    break;
                case 2:
                    handler.call(this.context, arguments[1]);
                    break;
                case 3:
                    handler.call(this.context, arguments[1], arguments[2]);
                    break;
                default:
                    args = slice.call(arguments, 1);
                    handler.apply(this.context, args);
                }
                return true;
            } else if (isArray(handler)) {
                args = slice.call(arguments, 1);
                var listeners = handler.slice();
                for (var i = 0, imax = listeners.length; i < imax; ++i) {
                    if (listeners[i] instanceof TimbreObject) {
                        listeners[i].bang.apply(listeners[i], args);
                    } else {
                        listeners[i].apply(this.context, args);
                    }
                }
                return true;
            } else if (handler instanceof TimbreObject) {
                args = slice.call(arguments, 1);
                handler.bang.apply(handler, args);
            } else {
                return false;
            }
        };

        $.on = function(type, listener) {
            if (typeof listener !== "function" && !(listener instanceof TimbreObject)) {
                throw new Error("addListener takes instances of Function or timbre.Object");
            }
            var e = this.events;

            if (!e[type]) {
                e[type] = listener;
            } else if (isArray(e[type])) {
                e[type].push(listener);
            } else {
                e[type] = [e[type], listener];
            }
            return this;
        };

        $.once = function(type, listener) {
            var self = this;
            var g;
            if (typeof listener === "function") {
                g = function () {
                    self.off(type, g);
                    listener.apply(self.context, arguments);
                };
            } else if (listener instanceof TimbreObject) {
                g = function () {
                    self.off(type, g);
                    listener.bang.apply(listener, arguments);
                };
            } else {
                throw new Error("once takes instances of Function or timbre.Object");
            }
            g.listener = listener;

            self.on(type, g);

            return this;
        };

        $.off = function(type, listener) {
            if (typeof listener !== "function" && !(listener instanceof TimbreObject)) {
                throw new Error("removeListener takes instances of Function or timbre.Object");
            }
            var e = this.events;

            if (!e[type]) {
                return this;
            }

            var list = e[type];

            if (isArray(list)) {
                var position = -1;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    if (list[i] === listener ||
                        // once listener
                        (list[i].listener && list[i].listener === listener)) {
                        position = i;
                        break;
                    }
                }

                if (position < 0) {
                    return this;
                }
                list.splice(position, 1);
                if (list.length === 0) {
                    e[type] = null;
                }
            } else if (list === listener ||
                       // once listener
                       (list.listener && list.listener === listener)) {
                e[type] = null;
            }

            return this;
        };

        $.removeAllListeners = function(type) {
            var e = this.events;

            var remain = false;
            var listeners = e[type];
            if (isArray(listeners)) {
                for (var i = listeners.length; i--; ) {
                    var listener = listeners[i];
                    if (listener.unremovable) {
                        remain = true;
                        continue;
                    }
                    this.off(type, listener);
                }
            } else if (listeners) {
                if (!listeners.unremovable) {
                    this.off(type, listeners);
                } else {
                    remain = true;
                }
            }
            if (!remain) {
                e[type] = null;
            }

            return this;
        };

        $.listeners = function(type) {
            var a, e = this.events;
            if (!e[type]) {
                return [];
            }
            e = e[type];
            if (!isArray(e)) {
                return e.unremovable ? [] : [e];
            }
            e = e.slice();
            a = [];
            for (var i = 0, imax = e.length; i < imax; ++i) {
                if (!e[i].unremovable) {
                    a.push(e[i]);
                }
            }
            return a;
        };

        return EventEmitter;
    })();

    var Deferred = modules.Deferred = (function() {
        function Deferred(context) {
            this.context = context || this;
            this._state = "pending";
            this._doneList = [];
            this._failList = [];

            this._promise = new Promise(this);
        }

        var $ = Deferred.prototype;

        var exec = function(statue, list, context, args) {
            if (this._state === "pending") {
                this._state = statue;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    list[i].apply(context, args);
                }
                this._doneList = this._failList = null;
            }
        };

        var isDeferred = function(x) {
            return x && typeof x.promise === "function";
        };

        $.resolve = function() {
            var args = slice.call(arguments, 0);
            exec.call(this, "resolved", this._doneList, this.context || this, args);
            return this;
        };
        $.resolveWith = function(context) {
            var args = slice.call(arguments, 1);
            exec.call(this, "resolved", this._doneList, context, args);
            return this;
        };
        $.reject = function() {
            var args = slice.call(arguments, 0);
            exec.call(this, "rejected", this._failList, this.context || this, args);
            return this;
        };
        $.rejectWith = function(context) {
            var args = slice.call(arguments, 1);
            exec.call(this, "rejected", this._failList, context, args);
            return this;
        };

        $.promise = function() {
            return this._promise;
        };
        $.done = function() {
            var args = slice.call(arguments);
            var isResolved = (this._state === "resolved");
            var isPending  = (this._state === "pending");
            var list = this._doneList;
            for (var i = 0, imax = args.length; i < imax; ++i) {
                if (typeof args[i] === "function") {
                    if (isResolved) {
                        args[i]();
                    } else if (isPending) {
                        list.push(args[i]);
                    }
                }
            }
            return this;
        };
        $.fail = function() {
            var args = slice.call(arguments);
            var isRejected = (this._state === "rejected");
            var isPending  = (this._state === "pending");
            var list = this._failList;
            for (var i = 0, imax = args.length; i < imax; ++i) {
                if (typeof args[i] === "function") {
                    if (isRejected) {
                        args[i]();
                    } else if (isPending) {
                        list.push(args[i]);
                    }
                }
            }
            return this;
        };
        $.always = function() {
            this.done.apply(this, arguments);
            this.fail.apply(this, arguments);
            return this;
        };
        $.then = function then(done, fail) {
            return this.done(done).fail(fail);
        };
        $.pipe = function(done, fail) {
            var self = this;
            var dfd = new Deferred(this.context);

            this.done(function() {
                var res = done.apply(self.context, arguments);
                if (isDeferred(res)) {
                    res.then(function() {
                        var args = slice.call(arguments);
                        dfd.resolveWith.apply(dfd, [res].concat(args));
                    });
                } else {
                    dfd.resolveWith(self, res);
                }
            });
            this.fail(function() {
                if (typeof fail === "function") {
                    var res = fail.apply(self.context, arguments);
                    if (isDeferred(res)) {
                        res.fail(function() {
                            var args = slice.call(arguments);
                            dfd.rejectWith.apply(dfd, [res].concat(args));
                        });
                    }
                } else {
                    dfd.reject.apply(dfd, arguments);
                }
            });

            return dfd.promise();
        };
        // $.then = $.pipe;

        $.isResolved = function() {
            return this._state === "resolved";
        };
        $.isRejected = function() {
            return this._state === "rejected";
        };
        $.state = function() {
            return this._state;
        };

        // TODO: test
        Deferred.when = function(subordinate) {
            var i = 0;
            var resolveValues = slice.call(arguments);
            var length    = resolveValues.length;
            var remaining = length;

            if (length === 1 && !isDeferred(subordinate)) {
                remaining = 0;
            }
            var deferred = (remaining === 1) ? subordinate : new Deferred();

            var updateFunc = function(i, results) {
                return function(value) {
                    results[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (!(--remaining)) {
                        deferred.resolve.apply(deferred, results);
                    }
                };
            };

            if (length > 1) {
                var resolveResults = new Array(length);
                var onfailed = function() {
                    deferred.reject();
                };
                for (; i < length; ++i) {
                    if (resolveValues[i] && isDeferred(resolveValues[i])) {
                        resolveValues[i].promise().done(
                            updateFunc(i, resolveResults)
                        ).fail(onfailed);
                    } else {
                        resolveResults[i] = resolveValues[i];
                        --remaining;
                    }
                }
            }

            if (!remaining) {
                deferred.resolve.apply(deferred, resolveValues);
            }

            return deferred.promise();
        };

        function Promise(object) {
            this.context = object.context;
            this.then = object.then;
            this.done = function() {
                object.done.apply(object, arguments);
                return this;
            };
            this.fail = function() {
                object.fail.apply(object, arguments);
                return this;
            };
            this.pipe = function() {
                return object.pipe.apply(object, arguments);
            };
            this.always = function() {
                object.always.apply(object, arguments);
                return this;
            };
            this.promise = function() {
                return this;
            };
            this.isResolved = function() {
                return object.isResolved();
            };
            this.isRejected = function() {
                return object.isRejected();
            };
        }

        return Deferred;
    })();

    // root object
    var TimbreObject = timbre.Object = (function() {
        function TimbreObject(numChannels, _args) {
            this._ = {}; // private members
            var e = this._.events = new EventEmitter(this);
            this._.emit = function() {
                return e.emit.apply(e, arguments);
            };
            if (isDictionary(_args[0])) {
                var params = _args.shift();
                var _in = params["in"];
                this.once("init", function() {
                    this.set(params);
                    if (_in) {
                        if (isArray(_in)) {
                            this.append.apply(this, _in);
                        } else if (_in instanceof TimbreObject) {
                            this.append(_in);
                        }
                    }
                });
            }

            this.tickID = -1;
            this.nodes  = _args.map(timbre);
            this.cells  = [];
            this.numChannels = numChannels;
            switch (numChannels) {
            case 0:
                this.L = this.R = new ChannelObject(null);
                this.cells[0] = this.cells[1] = this.cells[2] = this.L.cell;
                break;
            case 1:
                this.L = this.R = new ChannelObject(this);
                this.cells[0] = this.cells[1] = this.cells[2] = this.L.cell;
                break;
            case 2:
                this.L = new ChannelObject(this);
                this.R = new ChannelObject(this);
                this.cells[0] = new fn.SignalArray(_sys.cellsize);
                this.cells[1] = this.L.cell;
                this.cells[2] = this.R.cell;
                break;
            }
            this.playbackState = PLAYING_STATE;
            this.nodeType = TimbreObject.DSP;

            this._.ar  = true;
            this._.mul = 1;
            this._.add = 0;
            this._.dac = null;
            this._.bypassed = false;
            this._.meta = {};
            this._.samplerate = _sys.samplerate;
            this._.cellsize   = _sys.cellsize;
            this._.buddies    = [];
        }
        TimbreObject.DSP      = 1;
        TimbreObject.TIMER    = 2;
        TimbreObject.LISTENER = 3;

        var $ = TimbreObject.prototype;

        Object.defineProperties($, {
            isAr: {
                get: function() {
                    return this._.ar;
                }
            },
            isKr: {
                get: function() {
                    return !this._.ar;
                }
            },
            isBypassed: {
                get: function() {
                    return this._.bypassed;
                }
            },
            isEnded: {
                get: function() {
                    return !(this.playbackState & 1);
                }
            },
            mul: {
                set: function(value) {
                    if (typeof value === "number") {
                        this._.mul = value;
                        this._.emit("setMul", value);
                    }
                },
                get: function() {
                    return this._.mul;
                }
            },
            add: {
                set: function(value) {
                    if (typeof value === "number") {
                        this._.add = value;
                        this._.emit("setAdd", value);
                    }
                },
                get: function() {
                    return this._.add;
                }
            },
            buddies: {
                set: function(value) {
                    if (!isArray(value)) {
                        value = [value];
                    }
                    this._.buddies = value.filter(function(node) {
                        return node instanceof TimbreObject;
                    });
                },
                get: function() {
                    return this._.buddies;
                }
            }
        });

        $.toString = function() {
            return this.constructor.name;
        };

        $.valueOf = function() {
            if (_sys.tickID !== this.tickID) {
                this.process(_sys.tickID);
            }
            return this.cells[0][0];
        };

        $.append = function() {
            if (arguments.length > 0) {
                var list = slice.call(arguments).map(timbre);
                this.nodes = this.nodes.concat(list);
                this._.emit("append", list);
            }
            return this;
        };

        $.appendTo = function(object) {
            object.append(this);
            return this;
        };

        $.remove = function() {
            if (arguments.length > 0) {
                var j, nodes = this.nodes, list = [];
                for (var i = 0, imax = arguments.length; i < imax; ++i) {
                    if ((j = nodes.indexOf(arguments[i])) !== -1) {
                        list.push(nodes[j]);
                        nodes.splice(j, 1);
                    }
                }
                if (list.length > 0) {
                    this._.emit("remove", list);
                }
            }
            return this;
        };

        $.removeFrom = function(object) {
            object.remove(this);
            return this;
        };

        $.removeAll = function() {
            var list = this.nodes.slice();
            this.nodes = [];
            if (list.length > 0) {
                this._.emit("remove", list);
            }
            return this;
        };

        $.removeAtIndex = function(index) {
            var item = this.nodes[index];
            if (item) {
                this.nodes.splice(index, 1);
                this._.emit("remove", [item]);
            }
            return this;
        };

        $.postMessage = function(message) {
            this._.emit("message", message);
            return this;
        };

        $.to = function(object) {
            if (object instanceof TimbreObject) {
                object.append(this);
            } else {
                var args = slice.call(arguments);
                if (isDictionary(args[1])) {
                    args.splice(2, 0, this);
                } else {
                    args.splice(1, 0, this);
                }
                object = T.apply(null, args);
            }
            return object;
        };

        $.splice = function(ins, obj, rem) {
            var i;
            if (!obj) {
                if (this._.dac) {
                    if (ins instanceof TimbreObject) {
                        if (rem instanceof TimbreObject) {
                            if (rem._.dac) {
                                rem._.dac._.node = ins;
                                ins._.dac = rem._.dac;
                                rem._.dac = null;
                                ins.nodes.push(this);
                            }
                        } else {
                            if (this._.dac) {
                                this._.dac._.node = ins;
                                ins._.dac = this._.dac;
                                this._.dac = null;
                                ins.nodes.push(this);
                            }
                        }
                    } else if (rem instanceof TimbreObject) {
                        if (rem._.dac) {
                            rem._.dac._.node = this;
                            this._.dac = rem._.dac;
                            rem._.dac = null;
                        }
                    }
                }
            } else {
                if (obj instanceof TimbreObject) {
                    i = obj.nodes.indexOf(rem);
                    if (i !== -1) {
                        obj.nodes.splice(i, 1);
                    }
                    if (ins instanceof TimbreObject) {
                        ins.nodes.push(this);
                        obj.nodes.push(ins);
                    } else {
                        obj.nodes.push(this);
                    }
                }
            }
            return this;
        };

        // EventEmitter
        $.on = $.addListener = function(type, listener) {
            this._.events.on(type, listener);
            return this;
        };

        $.once = function(type, listener) {
            this._.events.once(type, listener);
            return this;
        };

        $.off = $.removeListener = function(type, listener) {
            this._.events.off(type, listener);
            return this;
        };

        $.removeAllListeners = function(type) {
            this._.events.removeAllListeners(type);
            return this;
        };

        $.listeners = function(type) {
            return this._.events.listeners(type);
        };

        $.set = function(key, value) {
            var x, desc, meta = this._.meta;
            switch (typeof key) {
            case "string":
                switch (meta[key]) {
                case "property":
                    this[key] = value;
                    break;
                case "function":
                    this[key](value);
                    break;
                default:
                    x = this;
                    while (x !== null) {
                        desc = Object.getOwnPropertyDescriptor(x, key);
                        if (desc) {
                            if (typeof desc.value === "function") {
                                meta[key] = "function";
                                this[key](value);
                            } else if (desc.get || desc.set) {
                                meta[key] = "property";
                                this[key] = value;
                            }
                        }
                        x = Object.getPrototypeOf(x);
                    }
                }
                break;
            case "object":
                for (x in key) {
                    this.set(x, key[x]);
                }
                break;
            }
            return this;
        };

        $.get = function(key) {
            if (this._.meta[key] === "property") {
                return this[key];
            }
        };

        $.bang = function() {
            this._.emit.apply(this, ["bang"].concat(slice.call(arguments)));
            return this;
        };

        $.process = fn.nop;

        $.bypass = function() {
            this._.bypassed = (arguments.length === 0) ? true : !!arguments[0];
            return this;
        };

        $.play = function() {
            var dac = this._.dac;
            if (dac === null) {
                dac = this._.dac = new SystemInlet(this);
            }
            if (dac.play()) {
                this._.emit.apply(this, ["play"].concat(slice.call(arguments)));
            }
            fn.buddies_start(this);
            return this;
        };

        $.pause = function() {
            var dac = this._.dac;
            if (dac && dac.playbackState === PLAYING_STATE) {
                dac.pause();
                this._.dac = null;
                this._.emit("pause");
            }
            fn.buddies_stop(this);
            return this;
        };

        $.start = $.stop = $.listen = $.unlisten = function() {
            return this;
        };

        $.ar = function() {
            if ((arguments.length === 0) ? true : !!arguments[0]) {
                if (!this._.kronly) {
                    this._.ar = true;
                    this._.emit("ar", true);
                }
            } else {
                this.kr(true);
            }
            return this;
        };

        $.kr = function() {
            if ((arguments.length === 0) ? true : !!arguments[0]) {
                if (!this._.aronly) {
                    this._.ar = false;
                    this._.emit("ar", false);
                }
            } else {
                this.ar(true);
            }
            return this;
        };

        if (_envtype === "browser") {
            $.plot = function(opts) {
                var _ = this._;
                var canvas = opts.target;

                if (!canvas) {
                    return this;
                }

                var width    = opts.width  || canvas.width  || 320;
                var height   = opts.height || canvas.height || 240;
                var offset_x = (opts.x || 0) + 0.5;
                var offset_y = (opts.y || 0);

                var context = canvas.getContext("2d");

                var foreground;
                if (opts.foreground !== undefined) {
                    foreground = opts.foreground;
                } else{
                    foreground = _.plotForeground || "rgb(  0, 128, 255)";
                }
                var background;
                if (opts.background !== undefined) {
                    background = opts.background;
                } else {
                    background = _.plotBackground || "rgb(255, 255, 255)";
                }
                var lineWidth  = opts.lineWidth  || _.plotLineWidth || 1;
                var cyclic     = !!_.plotCyclic;

                var data  = _.plotData || this.cells[0];
                var range = opts.range || _.plotRange || [-1.2, +1.2];
                var rangeMin   = range[0];
                var rangeDelta = height / (range[1] - rangeMin);

                var x, dx = (width / data.length);
                var y, dy, y0;
                var i, imax = data.length;

                context.save();

                context.rect(offset_x, offset_y, width, height);
                // context.clip();

                if (background !== null) {
                    context.fillStyle = background;
                    context.fillRect(offset_x, offset_y, width, height);
                }
                if (_.plotBefore) {
                    _.plotBefore.call(
                        this, context, offset_x, offset_y, width, height
                    );
                }

                if (_.plotBarStyle) {
                    context.fillStyle = foreground;
                    x = 0;
                    for (i = 0; i < imax; ++i) {
                        dy = (data[i] - rangeMin) * rangeDelta;
                        y  = height - dy;
                        context.fillRect(x + offset_x, y + offset_y, dx, dy);
                        x += dx;
                    }
                } else {
                    context.strokeStyle = foreground;
                    context.lineWidth   = lineWidth;

                    context.beginPath();

                    x  = 0;
                    y0 = height - (data[0] - rangeMin) * rangeDelta;
                    context.moveTo(x + offset_x, y0 + offset_y);
                    for (i = 1; i < imax; ++i) {
                        x += dx;
                        y = height - (data[i] - rangeMin) * rangeDelta;
                        context.lineTo(x + offset_x, y + offset_y);
                    }
                    if (cyclic) {
                        context.lineTo(x + dx + offset_x, y0 + offset_y);
                    } else {
                        context.lineTo(x + dx + offset_x, y  + offset_y);
                    }
                    context.stroke();
                }

                if (_.plotAfter) {
                    _.plotAfter.call(
                        this, context, offset_x, offset_y, width, height
                    );
                }
                var border = opts.border || _.plotBorder;
                if (border) {
                    context.strokeStyle =
                        (typeof border === "string") ? border : "#000";
                    context.lineWidth = 1;
                    context.strokeRect(offset_x, offset_y, width, height);
                }

                context.restore();

                return this;
            };
        } else {
            $.plot = fn.nop;
        }

        return TimbreObject;
    })();

    var ChannelObject = timbre.ChannelObject = (function() {
        function ChannelObject(parent) {
            timbre.Object.call(this, -1, []);
            fn.fixAR(this);

            this._.parent = parent;
            this.cell = new fn.SignalArray(_sys.cellsize);

            this.L = this.R = this;
            this.cells[0] = this.cells[1] = this.cells[2] = this.cell;

            this.numChannels = 1;
        }
        fn.extend(ChannelObject);

        ChannelObject.prototype.process = function(tickID) {
            if (this.tickID !== tickID) {
                this.tickID = tickID;
                if (this._.parent) {
                    this._.parent.process(tickID);
                }
            }
            return this;
        };

        return ChannelObject;
    })();

    var AddNode = (function() {
        function AddNode(_args) {
            TimbreObject.call(this, 2, _args);
        }
        fn.extend(AddNode);

        AddNode.prototype.process = function(tickID) {
            var _ = this._;
            if (this.tickID !== tickID) {
                this.tickID = tickID;
                if (_.ar) {
                    fn.inputSignalAR(this);
                    fn.outputSignalAR(this);
                } else {
                    this.cells[0][0] = fn.inputSignalKR(this);
                    fn.outputSignalKR(this);
                }
            }
            return this;
        };
        fn.register("+", AddNode);

        return AddNode;
    })();

    var NumberWrapper = (function() {
        function NumberWrapper(_args) {
            TimbreObject.call(this, 1, []);
            fn.fixKR(this);

            this.value = _args[0];

            if (isDictionary(_args[1])) {
                var params = _args[1];
                this.once("init", function() {
                    this.set(params);
                });
            }
            this.on("setAdd", fn.changeWithValue);
            this.on("setMul", fn.changeWithValue);
        }
        fn.extend(NumberWrapper);

        var $ = NumberWrapper.prototype;

        Object.defineProperties($, {
            value: {
                set: function(value) {
                    if (typeof value === "number") {
                        this._.value = isNaN(value) ? 0 : value;
                        fn.changeWithValue.call(this);
                    }
                },
                get: function() {
                    return this._.value;
                }
            }
        });

        return NumberWrapper;
    })();

    var BooleanWrapper = (function() {
        function BooleanWrapper(_args) {
            TimbreObject.call(this, 1, []);
            fn.fixKR(this);

            this.value = _args[0];

            if (isDictionary(_args[1])) {
                var params = _args[1];
                this.once("init", function() {
                    this.set(params);
                });
            }
            this.on("setAdd", fn.changeWithValue);
            this.on("setMul", fn.changeWithValue);
        }
        fn.extend(BooleanWrapper);

        var $ = BooleanWrapper.prototype;

        Object.defineProperties($, {
            value: {
                set: function(value) {
                    this._.value = value ? 1 : 0;
                    fn.changeWithValue.call(this);
                },
                get: function() {
                    return !!this._.value;
                }
            }
        });

        return BooleanWrapper;
    })();

    var FunctionWrapper = (function() {
        function FunctionWrapper(_args) {
            TimbreObject.call(this, 1, []);
            fn.fixKR(this);

            this.func    = _args[0];
            this._.value = 0;

            if (isDictionary(_args[1])) {
                var params = _args[1];
                this.once("init", function() {
                    this.set(params);
                });
            }
            this.on("setAdd", fn.changeWithValue);
            this.on("setMul", fn.changeWithValue);
        }
        fn.extend(FunctionWrapper);

        var $ = FunctionWrapper.prototype;

        Object.defineProperties($, {
            func: {
                set: function(value) {
                    if (typeof value === "function") {
                        this._.func = value;
                    }
                },
                get: function() {
                    return this._.func;
                }
            },
            args: {
                set: function(value) {
                    if (isArray(value)) {
                        this._.args = value;
                    } else {
                        this._.args = [value];
                    }
                },
                get: function() {
                    return this._.args;
                }
            }
        });

        $.bang = function() {
            var _ = this._;
            var args = slice.call(arguments).concat(_.args);
            var x = _.func.apply(this, args);
            if (typeof x === "number") {
                _.value = x;
                fn.changeWithValue.call(this);
            }
            this._.emit("bang");
            return this;
        };

        return FunctionWrapper;
    })();

    var ArrayWrapper = (function() {
        function ArrayWrapper(_args) {
            TimbreObject.call(this, 1, []);

            var i, imax;
            for (i = 0, imax = _args[0].length; i < imax; ++i) {
              this.append(_args[0][i]);
            }

            if (isDictionary(_args[1])) {
                var params = _args[1];
                this.once("init", function() {
                    this.set(params);
                });
            }
        }
        fn.extend(ArrayWrapper);

        var $ = ArrayWrapper.prototype;

        Object.defineProperties($, {

        });

        $.bang = function() {
            var args = ["bang"].concat(slice.call(arguments));
            var nodes = this.nodes;
            var i, imax;
            for (i = 0, imax = nodes.length; i < imax; ++i) {
                nodes[i].bang.apply(nodes[i], args);
            }
            return this;
        };

        $.postMessage = function(message) {
            var nodes = this.nodes;
            var i, imax;
            for (i = 0, imax = nodes.length; i < imax; ++i) {
                nodes[i].postMessage(message);
            }
            return this;
        };

        $.process = function(tickID) {
            var _ = this._;
            if (this.tickID !== tickID) {
                this.tickID = tickID;
                if (_.ar) {
                    fn.inputSignalAR(this);
                    fn.outputSignalAR(this);
                } else {
                    this.cells[0][0] = fn.inputSignalKR(this);
                    fn.outputSignalKR(this);
                }
            }
            return this;
        };

        return ArrayWrapper;
    })();

    var ObjectWrapper = (function() {
        function ObjectWrapper(_args) {
            TimbreObject.call(this, 1, []);
            fn.fixKR(this);

            if (isDictionary(_args[1])) {
                var params = _args[1];
                this.once("init", function() {
                    this.set(params);
                });
            }
        }
        fn.extend(ObjectWrapper);

        var $ = ObjectWrapper.prototype;

        Object.defineProperties($, {

        });

        return ObjectWrapper;
    })();

    var SystemInlet = (function() {
        function SystemInlet(object) {
            TimbreObject.call(this, 2, []);

            this.playbackState = FINISHED_STATE;
            var _ = this._;
            _.node = object;
            _.onplay  = make_onplay(this);
            _.onpause = make_onpause(this);
        }
        fn.extend(SystemInlet);

        var make_onplay = function(self) {
            return function() {
                if (_sys.inlets.indexOf(self) === -1) {
                    _sys.inlets.push(self);
                    _sys.events.emit("addObject");
                    self.playbackState = PLAYING_STATE;
                    self._.emit("play");
                }
            };
        };

        var make_onpause = function(self) {
            return function() {
                var i = _sys.inlets.indexOf(self);
                if (i !== -1) {
                    _sys.inlets.splice(i, 1);
                    self.playbackState = FINISHED_STATE;
                    self._.emit("pause");
                    _sys.events.emit("removeObject");
                }
            };
        };

        var $ = SystemInlet.prototype;

        $.play = function() {
            _sys.nextTick(this._.onplay);
            return (_sys.inlets.indexOf(this) === -1);
        };

        $.pause = function() {
            _sys.nextTick(this._.onpause);
        };

        $.process = function(tickID) {
            var node = this._.node;
            if (node.playbackState & 1) {
                node.process(tickID);
                this.cells[1].set(node.cells[1]);
                this.cells[2].set(node.cells[2]);
            } else {
                this.cells[1].set(fn.emptycell);
                this.cells[2].set(fn.emptycell);
            }
        };

        return SystemInlet;
    })();

    var SoundSystem = (function() {
        function SoundSystem() {
            this.context = this;
            this.tickID = 0;
            this.impl = null;
            this.amp  = 0.8;
            this.status = FINISHED_STATE;
            this.samplerate = 44100;
            this.channels   = 2;
            this.cellsize   = 64;
            this.streammsec = 20;
            this.streamsize = 0;
            this.currentTime = 0;
            this.nextTicks = [];
            this.inlets    = [];
            this.timers    = [];
            this.listeners = [];

            this.deferred = null;
            this.recStart   = 0;
            this.recBuffers = null;
            this.delayProcess = make_delayProcess(this);

            this.events = null;

            fn.currentTimeIncr = this.cellsize * 1000 / this.samplerate;
            fn.emptycell = new fn.SignalArray(this.cellsize);

            this.reset(true);
        }

        var make_delayProcess = function(self) {
            return function() {
                self.recStart = Date.now();
                self.process();
            };
        };

        var $ = SoundSystem.prototype;

        $.bind = function(Klass, opts) {
            if (typeof Klass === "function") {
                var player = new Klass(this, opts);
                this.impl = player;
                if (this.impl.defaultSamplerate) {
                    this.samplerate = this.impl.defaultSamplerate;
                }
            }
            return this;
        };

        $.setup = function(params) {
            if (typeof params === "object") {
                if (ACCEPT_SAMPLERATES.indexOf(params.samplerate) !== -1) {
                    if (params.samplerate <= this.impl.maxSamplerate) {
                        this.samplerate = params.samplerate;
                    } else {
                        this.samplerate = this.impl.maxSamplerate;
                    }
                }
                if (ACCEPT_CELLSIZES.indexOf(params.cellsize) !== -1) {
                    this.cellsize = params.cellsize;
                }
                if (typeof Float64Array !== "undefined" && typeof params.f64 !== "undefined") {
                    _f64mode = !!params.f64;
                    if (_f64mode) {
                        fn.SignalArray = Float64Array;
                    } else {
                        fn.SignalArray = Float32Array;
                    }
                }
            }
            fn.currentTimeIncr = this.cellsize * 1000 / this.samplerate;
            fn.emptycell = new fn.SignalArray(this.cellsize);
            return this;
        };

        $.getAdjustSamples = function(samplerate) {
            var samples, bits;
            samplerate = samplerate || this.samplerate;
            samples = this.streammsec / 1000 * samplerate;
            bits = Math.ceil(Math.log(samples) * Math.LOG2E);
            bits = (bits < 8) ? 8 : (bits > 14) ? 14 : bits;
            return 1 << bits;
        };

        $.play = function() {
            if (this.status === FINISHED_STATE) {
                this.status = PLAYING_STATE;

                this.streamsize = this.getAdjustSamples();
                this.strmL = new fn.SignalArray(this.streamsize);
                this.strmR = new fn.SignalArray(this.streamsize);

                this.impl.play();
                this.events.emit("play");
            }
            return this;
        };

        $.pause = function() {
            if (this.status === PLAYING_STATE) {
                this.status = FINISHED_STATE;
                this.impl.pause();
                this.events.emit("pause");
            }
            return this;
        };

        $.reset = function(deep) {
            if (deep) {
                this.events = new EventEmitter(this).on("addObject", function() {
                    if (this.status === FINISHED_STATE) {
                        this.play();
                    }
                }).on("removeObject", function() {
                    if (this.status === PLAYING_STATE) {
                        if (this.inlets.length + this.timers.length + this.listeners.length === 0) {
                            this.pause();
                        }
                    }
                });
            }
            this.currentTime = 0;
            this.nextTicks = [];
            this.inlets    = [];
            this.timers    = [];
            this.listeners = [];
            return this;
        };

        $.process = function() {
            var tickID = this.tickID;
            var strmL = this.strmL, strmR = this.strmR;
            var amp = this.amp;
            var x, tmpL, tmpR;
            var i, imax = this.streamsize, saved_i = 0;
            var j, jmax;
            var k, kmax = this.cellsize;
            var n = this.streamsize / this.cellsize;
            var nextTicks;
            var timers    = this.timers;
            var inlets    = this.inlets;
            var listeners = this.listeners;
            var currentTimeIncr = fn.currentTimeIncr;

            for (i = 0; i < imax; ++i) {
                strmL[i] = strmR[i] = 0;
            }

            while (n--) {
                ++tickID;

                for (j = 0, jmax = timers.length; j < jmax; ++j) {
                    if (timers[j].playbackState & 1) {
                        timers[j].process(tickID);
                    }
                }

                for (j = 0, jmax = inlets.length; j < jmax; ++j) {
                    x = inlets[j];
                    x.process(tickID);
                    if (x.playbackState & 1) {
                        tmpL = x.cells[1];
                        tmpR = x.cells[2];
                        for (k = 0, i = saved_i; k < kmax; ++k, ++i) {
                            strmL[i] += tmpL[k];
                            strmR[i] += tmpR[k];
                        }
                    }
                }
                saved_i += kmax;

                for (j = 0, jmax = listeners.length; j < jmax; ++j) {
                    if (listeners[j].playbackState & 1) {
                        listeners[j].process(tickID);
                    }
                }

                this.currentTime += currentTimeIncr;

                nextTicks = this.nextTicks.splice(0);
                for (j = 0, jmax = nextTicks.length; j < jmax; ++j) {
                    nextTicks[j]();
                }
            }

            for (i = 0; i < imax; ++i) {
                x = strmL[i] * amp;
                if (x < -1) {
                    x = -1;
                } else if (x > 1) {
                    x = 1;
                }
                strmL[i] = x;
                x = strmR[i] * amp;
                if (x < -1) {
                    x = -1;
                } else if (x > 1) {
                    x = 1;
                }
                strmR[i] = x;
            }

            this.tickID = tickID;

            var currentTime = this.currentTime;

            if (this.status === SCHEDULED_STATE) {
                if (this.recCh === 2) {
                    this.recBuffers.push(new fn.SignalArray(strmL));
                    this.recBuffers.push(new fn.SignalArray(strmR));
                } else {
                    var strm = new fn.SignalArray(strmL.length);
                    for (i = 0, imax = strm.length; i < imax; ++i) {
                        strm[i] = (strmL[i] + strmR[i]) * 0.5;
                    }
                    this.recBuffers.push(strm);
                }

                if (currentTime >= this.maxDuration) {
                    this.deferred.sub.reject();
                } else if (currentTime >= this.recDuration) {
                    this.deferred.sub.resolve();
                } else {
                    var now = Date.now();
                    if ((now - this.recStart) > 20) {
                        setTimeout(this.delayProcess, 10);
                    } else {
                        this.process();
                    }
                }
            }
        };

        $.nextTick = function(func) {
            if (this.status === FINISHED_STATE) {
                func();
            } else {
                this.nextTicks.push(func);
            }
        };

        $.rec = function() {
            fn.fix_iOS6_1_problem(true);

            var dfd = new Deferred(this);

            if (this.deferred) {
                console.warn("rec deferred is exists??");
                return dfd.reject().promise();
            }

            if (this.status !== FINISHED_STATE) {
                console.log("status is not none", this.status);
                return dfd.reject().promise();
            }

            var i = 0, args = arguments;
            var opts = isDictionary(args[i]) ? args[i++] : {};
            var func = args[i];

            if (typeof func !== "function") {
                // throw error??
                console.warn("no function");
                return dfd.reject().promise();
            }

            this.deferred = dfd;
            this.status = SCHEDULED_STATE;
            this.reset();

            var rec_inlet = new T("+");
            var inlet_dfd = new Deferred(this);

            var outlet = {
                done: function() {
                    inlet_dfd.resolve.apply(inlet_dfd, slice.call(arguments));
                },
                send: function() {
                    rec_inlet.append.apply(rec_inlet, arguments);
                }
            };

            var self = this;
            inlet_dfd.then(recdone, function() {
                fn.fix_iOS6_1_problem(false);
                recdone.call(self, true);
            });

            this.deferred.sub = inlet_dfd;

            this.savedSamplerate = this.samplerate;
            this.samplerate  = opts.samplerate  || this.samplerate;
            this.recDuration = opts.recDuration || Infinity;
            this.maxDuration = opts.maxDuration || 10 * 60 * 1000;
            this.recCh = opts.ch || 1;
            if (this.recCh !== 2) {
                this.recCh = 1;
            }
            this.recBuffers = [];

            this.streamsize = this.getAdjustSamples();
            this.strmL = new fn.SignalArray(this.streamsize);
            this.strmR = new fn.SignalArray(this.streamsize);

            this.inlets.push(rec_inlet);

            func(outlet);

            setTimeout(this.delayProcess, 10);

            return dfd.promise();
        };

        var recdone = function() {
            this.status = FINISHED_STATE;
            this.reset();

            var recBuffers = this.recBuffers;
            var samplerate = this.samplerate;
            var streamsize = this.streamsize;
            var bufferLength;

            this.samplerate = this.savedSamplerate;

            if (this.recDuration !== Infinity) {
                bufferLength = (this.recDuration * samplerate * 0.001)|0;
            } else {
                bufferLength = (recBuffers.length >> (this.recCh-1)) * streamsize;
            }

            var result;
            var i, imax = (bufferLength / streamsize)|0;
            var j = 0, k = 0;
            var remaining = bufferLength;

            if (this.recCh === 2) {
                var L = new fn.SignalArray(bufferLength);
                var R = new fn.SignalArray(bufferLength);
                var mixed = new fn.SignalArray(bufferLength);

                for (i = 0; i < imax; ++i) {
                    L.set(recBuffers[j++], k);
                    R.set(recBuffers[j++], k);
                    k += streamsize;
                    remaining -= streamsize;
                    if (remaining > 0 && remaining < streamsize) {
                        L.set(recBuffers[j++].subarray(0, remaining), k);
                        R.set(recBuffers[j++].subarray(0, remaining), k);
                        break;
                    }
                }
                for (i = 0, imax = bufferLength; i < imax; ++i) {
                    mixed[i] = (L[i] + R[i]) * 0.5;
                }

                result = {
                    samplerate: samplerate,
                    channels  : 2,
                    buffer: [mixed, L, R]
                };

            } else {
                var buffer = new fn.SignalArray(bufferLength);
                for (i = 0; i < imax; ++i) {
                    buffer.set(recBuffers[j++], k);
                    k += streamsize;
                    remaining -= streamsize;
                    if (remaining > 0 && remaining < streamsize) {
                        buffer.set(recBuffers[j++].subarray(0, remaining), k);
                        break;
                    }
                }
                result = {
                    samplerate: samplerate,
                    channels  : 1,
                    buffer: [buffer]
                };
            }

            var args = [].concat.apply([result], arguments);
            this.deferred.resolve.apply(this.deferred, args);
            this.deferred = null;
        };

        // EventEmitter
        $.on = function(type, listeners) {
            this.events.on(type, listeners);
        };
        $.once = function(type, listeners) {
            this.events.once(type, listeners);
        };
        $.off = function(type, listener) {
            this.events.off(type, listener);
        };
        $.removeAllListeners = function(type) {
            this.events.removeListeners(type);
        };
        $.listeners = function(type) {
            return this.events.listeners(type);
        };

        $.fix_iOS6_1_problem = function(flag) {
            if (this.impl.fix_iOS6_1_problem) {
                this.impl.fix_iOS6_1_problem(flag);
            }
        };

        return SoundSystem;
    })();

    // player
    var ImplClass    = null;
    var AudioContext = null;
    if (typeof window !== "undefined") {
      AudioContext = window.AudioContext || window.webkitAudioContext;
    }

    if (typeof AudioContext !== "undefined") {
        ImplClass = function(sys) {
            var context = new AudioContext();
            var jsNode;

            fn._audioContext = context;

            this.maxSamplerate     = context.sampleRate;
            this.defaultSamplerate = context.sampleRate;
            this.env = "webkit";

            var ua = navigator.userAgent;
            if (ua.match(/linux/i)) {
                sys.streammsec *= 8;
            } else if (ua.match(/win(dows)?\s*(nt 5\.1|xp)/i)) {
                sys.streammsec *= 4;
            }

            this.play = function() {
                var onaudioprocess;
                var jsn_streamsize = sys.getAdjustSamples(context.sampleRate);
                var sys_streamsize = sys.streamsize;
                var x, dx;

                if (sys.samplerate === context.sampleRate) {
                    onaudioprocess = function(e) {
                        var outs = e.outputBuffer;
                        sys.process();
                        outs.getChannelData(0).set(sys.strmL);
                        outs.getChannelData(1).set(sys.strmR);
                    };
                } else if (sys.samplerate * 2 === context.sampleRate) {
                    onaudioprocess = function(e) {
                        var inL = sys.strmL;
                        var inR = sys.strmR;
                        var outs = e.outputBuffer;
                        var outL = outs.getChannelData(0);
                        var outR = outs.getChannelData(1);
                        var i, imax = outs.length;
                        var j;

                        sys.process();
                        for (i = j = 0; i < imax; i += 2, ++j) {
                            outL[i] = outL[i+1] = inL[j];
                            outR[i] = outR[i+1] = inR[j];
                        }
                    };
                } else {
                    x  = sys_streamsize;
                    dx = sys.samplerate / context.sampleRate;
                    onaudioprocess = function(e) {
                        var inL = sys.strmL;
                        var inR = sys.strmR;
                        var outs = e.outputBuffer;
                        var outL = outs.getChannelData(0);
                        var outR = outs.getChannelData(1);
                        var i, imax = outs.length;

                        for (i = 0; i < imax; ++i) {
                            if (x >= sys_streamsize) {
                                sys.process();
                                x -= sys_streamsize;
                            }
                            outL[i] = inL[x|0];
                            outR[i] = inR[x|0];
                            x += dx;
                        }
                    };
                }

                jsNode = context.createScriptProcessor(jsn_streamsize, 2, sys.channels);
                jsNode.onaudioprocess = onaudioprocess;
                jsNode.connect(context.destination);
            };

            this.pause = function() {
                jsNode.disconnect();
            };

            if (_envmobile) {
                var n   = 0;
                var buf = context.createBufferSource();
                this.fix_iOS6_1_problem = function(flag) {
                    n += flag ? 1 : -1;
                    if (n === 1) {
                        buf.noteOn(0);
                        buf.connect(context.destination);
                    } else if (n === 0) {
                        buf.disconnect();
                    }
                };
            }
        };
    } else {
        ImplClass = function(sys) {
            this.maxSamplerate     = 48000;
            this.defaultSamplerate = 44100;
            this.env = "nop";
            this.play  = function() {};
            this.pause = function() {};
        };
    }

    _sys = new SoundSystem().bind(ImplClass);

    var exports = timbre;

    if (_envtype === "node" || typeof exports !== 'undefined') {
        module.exports = global.timbre = exports;
    } else if (_envtype === "browser") {
        exports.noConflict = (function() {
           var _t = window.timbre, _T = window.T;
            return function(deep) {
                if (window.T === exports) {
                    window.T = _T;
                }
                if (deep && window.timbre === exports) {
                    window.timbre = _t;
                }
                return exports;
            };
        })();

        window.timbre = window.T = exports;
    }

    // Flash fallback
    (function() {
        if (_sys.impl.env !== "nop" || _envtype !== "browser" || _envmobile) {
            return;
        }
        var nav = navigator;

        /*jshint latedef:true */
        if (getFlashPlayerVersion(0) < 10) {
            return;
        }
        /*jshint latedef:false */

        var swf, PlayerDivID = "TimbreFlashPlayerDiv";
        var src = (function() {
            var scripts = document.getElementsByTagName("script");
            if (scripts && scripts.length) {
                for (var m, i = 0, imax = scripts.length; i < imax; ++i) {
                    if ((m = /^(.*\/)timbre(?:\.dev)?\.js$/i.exec(scripts[i].src))) {
                        return m[1] + "timbre.swf";
                    }
                }
            }
        })();

        window.timbrejs_flashfallback_init = function() {
            function TimbreFlashPlayer(sys) {
                var timerId = 0;

                this.maxSamplerate     = 44100;
                this.defaultSamplerate = 44100;
                this.env = "flash";

                this.play = function() {
                    var onaudioprocess;
                    var interleaved = new Array(sys.streamsize * sys.channels);
                    var streammsec  = sys.streammsec;
                    var written = 0;
                    var writtenIncr = sys.streamsize / sys.samplerate * 1000;
                    var start = Date.now();

                    onaudioprocess = function() {
                        if (written > Date.now() - start) {
                            return;
                        }
                        var inL = sys.strmL;
                        var inR = sys.strmR;
                        var i = interleaved.length;
                        var j = inL.length;
                        sys.process();
                        while (j--) {
                            interleaved[--i] = (inR[j] * 32768)|0;
                            interleaved[--i] = (inL[j] * 32768)|0;
                        }
                        swf.writeAudio(interleaved.join(" "));
                        written += writtenIncr;
                    };

                    if (swf.setup) {
                        swf.setup(sys.channels, sys.samplerate);
                        timerId = setInterval(onaudioprocess, streammsec);
                    } else {
                        console.warn("Cannot find " + src);
                    }
                };

                this.pause = function() {
                    if (timerId !== 0) {
                        swf.cancel();
                        clearInterval(timerId);
                        timerId = 0;
                    }
                };
            }
            _sys.bind(TimbreFlashPlayer);
            delete window.timbrejs_flashfallback_init;
        };

        var o, p;
        var swfSrc  = src;
        var swfName = swfSrc + "?" + (+new Date());
        var swfId   = "TimbreFlashPlayer";
        var div = document.createElement("div");
        div.id = PlayerDivID;
        div.style.display = "inline";
        div.width = div.height = 1;

        if (nav.plugins && nav.mimeTypes && nav.mimeTypes.length) {
            // ns
            o = document.createElement("object");
            o.id = swfId;
            o.classid = "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000";
            o.width = o.height = 1;
            o.setAttribute("data", swfName);
            o.setAttribute("type", "application/x-shockwave-flash");
            p = document.createElement("param");
            p.setAttribute("name", "allowScriptAccess");
            p.setAttribute("value", "always");
            o.appendChild(p);
            div.appendChild(o);
        } else {
            // ie
            /*jshint quotmark:single */
            div.innerHTML = '<object id="' + swfId + '" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="1" height="1"><param name="movie" value="' + swfName + '" /><param name="bgcolor" value="#FFFFFF" /><param name="quality" value="high" /><param name="allowScriptAccess" value="always" /></object>';
            /*jshint quotmark:double */
        }
        window.addEventListener("load", function() {
            document.body.appendChild(div);
            swf = document[swfId];
        });

        function getFlashPlayerVersion(subs) {
            /*global ActiveXObject:true */
            try {
                if (nav.plugins && nav.mimeTypes && nav.mimeTypes.length) {
                    return nav.plugins["Shockwave Flash"].description.match(/([0-9]+)/)[subs];
                }
                return (new ActiveXObject("ShockwaveFlash.ShockwaveFlash")).GetVariable("$version").match(/([0-9]+)/)[subs];
            } catch (e) {
                return -1;
            }
            /*global ActiveXObject:false */
        }
    })();

})();
(function(T) {
    "use strict";

    function Biquad(samplerate) {
        this.samplerate = samplerate;
        this.frequency = 340;
        this.Q         = 1;
        this.gain      = 0;

        this.x1L = this.x2L = this.y1L = this.y2L = 0;
        this.x1R = this.x2R = this.y1R = this.y2R = 0;
        this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0;

        this.setType("lpf");
    }

    var $ = Biquad.prototype;

    $.process = function(cellL, cellR) {
        var xL, xR, yL, yR;
        var x1L = this.x1L, x2L = this.x2L, y1L = this.y1L, y2L = this.y2L;
        var x1R = this.x1R, x2R = this.x2R, y1R = this.y1R, y2R = this.y2R;
        var b0 = this.b0, b1 = this.b1, b2 = this.b2, a1 = this.a1, a2 = this.a2;
        var i, imax;

        for (i = 0, imax = cellL.length; i < imax; ++i) {
            xL = cellL[i];
            yL = b0 * xL + b1 * x1L + b2 * x2L - a1 * y1L - a2 * y2L;
            x2L = x1L; x1L = xL; y2L = y1L; y1L = yL;

            xR = cellR[i];
            yR = b0 * xR + b1 * x1R + b2 * x2R - a1 * y1R - a2 * y2R;
            x2R = x1R; x1R = xR; y2R = y1R; y1R = yR;

            cellL[i] = yL;
            cellR[i] = yR;
        }
        this.x1L = x1L; this.x2L = x2L; this.y1L = y1L; this.y2L = y2L;
        this.x1R = x1R; this.x2R = x2R; this.y1R = y1R; this.y2R = y2R;
    };

    $.setType = function(type) {
        var f;
        if ((f = setParams[type])) {
            this.type = type;
            f.call(this, this.frequency, this.Q, this.gain);
        }
    };

    $.setParams = function(frequency, Q, dbGain) {
        this.frequency = frequency;
        this.Q = Q;
        this.gain = dbGain;

        var f = setParams[this.type];
        if (f) {
            f.call(this, frequency, Q, dbGain);
        }

        return this;
    };


    var setParams = {
        lowpass: function(cutoff, resonance) {
            cutoff /= (this.samplerate * 0.5);

            if (cutoff >= 1) {
                this.b0 = 1;
                this.b1 = this.b2 = this.a1 = this.a2 = 0;
            } else if (cutoff <= 0) {
                this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0;
            } else {
                resonance = (resonance < 0) ? 0 : resonance;
                var g = Math.pow(10.0, 0.05 * resonance);
                var d = Math.sqrt((4 - Math.sqrt(16 - 16 / (g * g))) * 0.5);

                var theta = Math.PI * cutoff;
                var sn = 0.5 * d * Math.sin(theta);
                var beta = 0.5 * (1 - sn) / (1 + sn);
                var gamma = (0.5 + beta) * Math.cos(theta);
                var alpha = 0.25 * (0.5 + beta - gamma);

                this.b0 = 2 * alpha;
                this.b1 = 4 * alpha;
                this.b2 = this.b0; // 2 * alpha;
                this.a1 = 2 * -gamma;
                this.a2 = 2 * beta;
            }
        },
        highpass: function(cutoff, resonance) {
            cutoff /= (this.samplerate * 0.5);
            if (cutoff >= 1) {
                this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0;
            } else if (cutoff <= 0) {
                this.b0 = 1;
                this.b1 = this.b2 = this.a1 = this.a2 = 0;
            } else {
                resonance = (resonance < 0) ? 0 : resonance;

                var g = Math.pow(10.0, 0.05 * resonance);
                var d = Math.sqrt((4 - Math.sqrt(16 - 16 / (g * g))) / 2);

                var theta = Math.PI * cutoff;
                var sn = 0.5 * d * Math.sin(theta);
                var beta = 0.5 * (1 - sn) / (1 + sn);
                var gamma = (0.5 + beta) * Math.cos(theta);
                var alpha = 0.25 * (0.5 + beta + gamma);

                this.b0 = 2 * alpha;
                this.b1 = -4 * alpha;
                this.b2 = this.b0; // 2 * alpha;
                this.a1 = 2 * -gamma;
                this.a2 = 2 * beta;
            }
        },
        bandpass: function(frequency, Q) {
            frequency /= (this.samplerate * 0.5);
            if (frequency > 0 && frequency < 1) {
                if (Q > 0) {
                    var w0 = Math.PI * frequency;

                    var alpha = Math.sin(w0) / (2 * Q);
                    var k = Math.cos(w0);

                    var ia0 = 1 / (1 + alpha);

                    this.b0 = alpha * ia0;
                    this.b1 = 0;
                    this.b2 = -alpha * ia0;
                    this.a1 = -2 * k * ia0;
                    this.a2 = (1 - alpha) * ia0;
                } else {
                    this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0;
                }
            } else {
                this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0;
            }
        },
        lowshelf: function(frequency, _dummy_, dbGain) {
            frequency /= (this.samplerate * 0.5);

            var A = Math.pow(10.0, dbGain / 40);

            if (frequency >= 1) {
                this.b0 = A* A;
                this.b1 = this.b2 = this.a1 = this.a2 = 0;
            } else if (frequency <= 0) {
                this.b0 = 1;
                this.b1 = this.b2 = this.a1 = this.a2 = 0;
            } else {
                var w0 = Math.PI * frequency;
                var S = 1; // filter slope (1 is max value)
                var alpha = 0.5 * Math.sin(w0) * Math.sqrt((A + 1 / A) * (1 / S - 1) + 2);
                var k = Math.cos(w0);
                var k2 = 2 * Math.sqrt(A) * alpha;
                var aPlusOne = A + 1;
                var aMinusOne = A - 1;

                var ia0 = 1 / (aPlusOne + aMinusOne * k + k2);

                this.b0 = (A * (aPlusOne - aMinusOne * k + k2)) * ia0;
                this.b1 = (2 * A * (aMinusOne - aPlusOne * k)) * ia0;
                this.b2 = (A * (aPlusOne - aMinusOne * k - k2)) * ia0;
                this.a1 = (-2 * (aMinusOne + aPlusOne * k)) * ia0;
                this.a2 = (aPlusOne + aMinusOne * k - k2) * ia0;
            }
        },
        highshelf: function(frequency, _dummy_, dbGain) {
            frequency /= (this.samplerate * 0.5);

            var A = Math.pow(10.0, dbGain / 40);

            if (frequency >= 1) {
                this.b0 = 1;
                this.b1 = this.b2 = this.a1 = this.a2 = 0;
            } else if (frequency <= 0) {
                this.b0 = A * A;
                this.b1 = this.b2 = this.a1 = this.a2 = 0;
            } else {
                var w0 = Math.PI * frequency;
                var S = 1; // filter slope (1 is max value)
                var alpha = 0.5 * Math.sin(w0) * Math.sqrt((A + 1 / A) * (1 / S - 1) + 2);
                var k = Math.cos(w0);
                var k2 = 2 * Math.sqrt(A) * alpha;
                var aPlusOne = A + 1;
                var aMinusOne = A - 1;

                var ia0 = 1 / (aPlusOne - aMinusOne * k + k2);

                this.b0 = (A * (aPlusOne + aMinusOne * k + k2)) * ia0;
                this.b1 = (-2 * A * (aMinusOne + aPlusOne * k)) * ia0;
                this.b2 = (A * (aPlusOne + aMinusOne * k - k2)) * ia0;
                this.a1 = (2 * (aMinusOne - aPlusOne * k)) * ia0;
                this.a2 = (aPlusOne - aMinusOne * k - k2) * ia0;
            }
        },
        peaking: function(frequency, Q, dbGain) {
            frequency /= (this.samplerate * 0.5);

            if (frequency > 0 && frequency < 1) {
                var A = Math.pow(10.0, dbGain / 40);
                if (Q > 0) {
                    var w0 = Math.PI * frequency;
                    var alpha = Math.sin(w0) / (2 * Q);
                    var k = Math.cos(w0);
                    var ia0 = 1 / (1 + alpha / A);

                    this.b0 = (1 + alpha * A) * ia0;
                    this.b1 = (-2 * k) * ia0;
                    this.b2 = (1 - alpha * A) * ia0;
                    this.a1 = this.b1; // (-2 * k) * ia0;
                    this.a2 = (1 - alpha / A) * ia0;
                } else {
                    this.b0 = A * A;
                    this.b1 = this.b2 = this.a1 = this.a2 = 0;
                }
            } else {
                this.b0 = 1;
                this.b1 = this.b2 = this.a1 = this.a2 = 0;
            }
        },
        notch: function(frequency, Q) {
            frequency /= (this.samplerate * 0.5);

            if (frequency > 0 && frequency < 1) {
                if (Q > 0) {
                    var w0 = Math.PI * frequency;
                    var alpha = Math.sin(w0) / (2 * Q);
                    var k = Math.cos(w0);
                    var ia0 = 1 / (1 + alpha);

                    this.b0 = ia0;
                    this.b1 = (-2 * k) * ia0;
                    this.b2 = ia0;
                    this.a1 = this.b1; // (-2 * k) * ia0;
                    this.a2 = (1 - alpha) * ia0;
                } else {
                    this.b0 = this.b1 = this.b2 = this.a1 = this.a2 = 0;
                }
            } else {
                this.b0 = 1;
                this.b1 = this.b2 = this.a1 = this.a2 = 0;
            }
        },
        allpass: function(frequency, Q) {
            frequency /= (this.samplerate * 0.5);

            if (frequency > 0 && frequency < 1) {
                if (Q > 0) {
                    var w0 = Math.PI * frequency;
                    var alpha = Math.sin(w0) / (2 * Q);
                    var k = Math.cos(w0);
                    var ia0 = 1 / (1 + alpha);

                    this.b0 = (1 - alpha) * ia0;
                    this.b1 = (-2 * k) * ia0;
                    this.b2 = (1 + alpha) * ia0;
                    this.a1 = this.b1; // (-2 * k) * ia0;
                    this.a2 = this.b0; // (1 - alpha) * ia0;
                } else {
                    this.b0 = -1;
                    this.b1 = this.b2 = this.a1 = this.a2 = 0;
                }
            } else {
                this.b0 = 1;
                this.b1 = this.b2 = this.a1 = this.a2 = 0;
            }
        }
    };

    setParams.lpf = setParams.lowpass;
    setParams.hpf = setParams.highpass;
    setParams.bpf = setParams.bandpass;
    setParams.bef = setParams.notch;
    setParams.brf = setParams.notch;
    setParams.apf = setParams.allpass;

    T.modules.Biquad = Biquad;

})(timbre);
(function(T) {
    "use strict";

    function Chorus(samplerate) {
        this.samplerate = samplerate;

        var bits = Math.round(Math.log(samplerate * 0.1) * Math.LOG2E);
        this.buffersize = 1 << bits;
        this.bufferL = new T.fn.SignalArray(this.buffersize + 1);
        this.bufferR = new T.fn.SignalArray(this.buffersize + 1);

        this.wave       = null;
        this._wave      = null;
        this.writeIndex = this.buffersize >> 1;
        this.readIndex  = 0;
        this.delayTime  = 20;
        this.rate       = 4;
        this.depth      = 20;
        this.feedback   = 0.2;
        this.wet        = 0.5;
        this.phase      = 0;
        this.phaseIncr  = 0;
        this.phaseStep  = 4;

        this.setWaveType("sin");
        this.setDelayTime(this.delayTime);
        this.setRate(this.rate);
    }

    var $ = Chorus.prototype;

    var waves = [];
    waves[0] = (function() {
        var wave = new Float32Array(512);
        for (var i = 0; i < 512; ++i) {
            wave[i] = Math.sin(2 * Math.PI * (i/512));
        }
        return wave;
    })();
    waves[1] = (function() {
        var wave = new Float32Array(512);
        for (var x, i = 0; i < 512; ++i) {
            x = (i / 512) - 0.25;
            wave[i] = 1.0 - 4.0 * Math.abs(Math.round(x) - x);
        }
        return wave;
    })();

    $.setWaveType = function(waveType) {
        if (waveType === "sin") {
            this.wave = waveType;
            this._wave = waves[0];
        } else if (waveType === "tri") {
            this.wave = waveType;
            this._wave = waves[1];
        }
    };

    $.setDelayTime = function(delayTime) {
        this.delayTime = delayTime;
        var readIndex = this.writeIndex - ((delayTime * this.samplerate * 0.001)|0);
        while (readIndex < 0) {
            readIndex += this.buffersize;
        }
        this.readIndex = readIndex;
    };

    $.setRate = function(rate) {
        this.rate      = rate;
        this.phaseIncr = (512 * this.rate / this.samplerate) * this.phaseStep;
    };

    $.process = function(cellL, cellR) {
        var bufferL = this.bufferL;
        var bufferR = this.bufferR;
        var size = this.buffersize;
        var mask = size - 1;
        var wave       = this._wave;
        var phase      = this.phase;
        var phaseIncr  = this.phaseIncr;
        var writeIndex = this.writeIndex;
        var readIndex  = this.readIndex;
        var depth      = this.depth;
        var feedback   = this.feedback;
        var x, index, mod;
        var wet = this.wet, dry = 1 - wet;
        var i, imax = cellL.length;
        var j, jmax = this.phaseStep;

        for (i = 0; i < imax; ) {
            mod = wave[phase|0] * depth;
            phase += phaseIncr;
            while (phase > 512) {
                phase -= 512;
            }
            for (j = 0; j < jmax; ++j, ++i) {
                index = (readIndex + size + mod) & mask;

                x = (bufferL[index] + bufferL[index + 1]) * 0.5;
                bufferL[writeIndex] = cellL[i] - x * feedback;
                cellL[i] = (cellL[i] * dry) + (x * wet);

                x = (bufferR[index] + bufferR[index + 1]) * 0.5;
                bufferR[writeIndex] = cellR[i] - x * feedback;
                cellR[i] = (cellR[i] * dry) + (x * wet);

                writeIndex = (writeIndex + 1) & mask;
                readIndex  = (readIndex  + 1) & mask;
            }
        }

        this.phase = phase;
        this.writeIndex = writeIndex;
        this.readIndex  = readIndex;
    };

    T.modules.Chorus = Chorus;

})(timbre);
(function(T) {
    "use strict";

    var MaxPreDelayFrames     = 1024;
    var MaxPreDelayFramesMask = MaxPreDelayFrames - 1;
    var DefaultPreDelayFrames = 256;
    var kSpacingDb = 5;

    function Compressor(samplerate, channels) {
        this.samplerate = samplerate;
        this.channels = channels;

        this.lastPreDelayFrames = 0;
        this.preDelayReadIndex  = 0;
        this.preDelayWriteIndex = DefaultPreDelayFrames;
        this.ratio       = -1;
        this.slope       = -1;
        this.linearThreshold = -1;
        this.dbThreshold = -1;
        this.dbKnee      = -1;
        this.kneeThreshold    = -1;
        this.kneeThresholdDb  = -1;
        this.ykneeThresholdDb = -1;
        this.K = -1;

        this.attackTime  = 0.003;
        this.releaseTime = 0.25;

        this.preDelayTime = 0.006;
        this.dbPostGain   = 0;
        this.effectBlend  = 1;
        this.releaseZone1 = 0.09;
        this.releaseZone2 = 0.16;
        this.releaseZone3 = 0.42;
        this.releaseZone4 = 0.98;

        this.detectorAverage = 0;
        this.compressorGain  = 1;
        this.meteringGain    = 1;

        this.delayBufferL = new T.fn.SignalArray(MaxPreDelayFrames);
        if (channels === 2) {
            this.delayBufferR = new T.fn.SignalArray(MaxPreDelayFrames);
        } else {
            this.delayBufferR = this.delayBufferL;
        }
        this.preDelayTime = 6;
        this.preDelayReadIndex = 0;
        this.preDelayWriteIndex = DefaultPreDelayFrames;
        this.maxAttackCompressionDiffDb = -1;
        this.meteringReleaseK = 1 - Math.exp(-1 / (this.samplerate * 0.325));

        this.setAttackTime(this.attackTime);
        this.setReleaseTime(this.releaseTime);
        this.setPreDelayTime(this.preDelayTime);
        this.setParams(-24, 30, 12);
    }

    var $ = Compressor.prototype;

    $.clone = function() {
        var new_instance = new Compressor(this.samplerate, this.channels);
        new_instance.setAttackTime(this.attackTime);
        new_instance.setReleaseTime(this.releaseTime);
        new_instance.setPreDelayTime(this.preDelayTime);
        new_instance.setParams(this.dbThreshold, this.dbKnee, this.ratio);
        return new_instance;
    };

    $.setAttackTime = function(value) {
        this.attackTime = Math.max(0.001, value);
        this._attackFrames = this.attackTime * this.samplerate;
    };

    $.setReleaseTime = function(value) {
        this.releaseTime = Math.max(0.001, value);
        var releaseFrames = this.releaseTime * this.samplerate;

        var satReleaseTime = 0.0025;
        this._satReleaseFrames = satReleaseTime * this.samplerate;

        var y1 = releaseFrames * this.releaseZone1;
        var y2 = releaseFrames * this.releaseZone2;
        var y3 = releaseFrames * this.releaseZone3;
        var y4 = releaseFrames * this.releaseZone4;

        this._kA = 0.9999999999999998*y1 + 1.8432219684323923e-16*y2 - 1.9373394351676423e-16*y3 + 8.824516011816245e-18*y4;
        this._kB = -1.5788320352845888*y1 + 2.3305837032074286*y2 - 0.9141194204840429*y3 + 0.1623677525612032*y4;
        this._kC = 0.5334142869106424*y1 - 1.272736789213631*y2 + 0.9258856042207512*y3 - 0.18656310191776226*y4;
        this._kD = 0.08783463138207234*y1 - 0.1694162967925622*y2 + 0.08588057951595272*y3 - 0.00429891410546283*y4;
        this._kE = -0.042416883008123074*y1 + 0.1115693827987602*y2 - 0.09764676325265872*y3 + 0.028494263462021576*y4;
    };

    $.setPreDelayTime = function(preDelayTime) {
        this.preDelayTime = preDelayTime;
        var preDelayFrames = preDelayTime * this.samplerate;
        if (preDelayFrames > MaxPreDelayFrames - 1) {
            preDelayFrames = MaxPreDelayFrames - 1;
        }
        if (this.lastPreDelayFrames !== preDelayFrames) {
            this.lastPreDelayFrames = preDelayFrames;
            for (var i = 0, imax = this.delayBufferL.length; i < imax; ++i) {
                this.delayBufferL[i] = this.delayBufferR[i] = 0;
            }
            this.preDelayReadIndex = 0;
            this.preDelayWriteIndex = preDelayFrames;
        }
    };

    $.setParams = function(dbThreshold, dbKnee, ratio) {
        this._k = this.updateStaticCurveParameters(dbThreshold, dbKnee, ratio);

        var fullRangeGain = this.saturate(1, this._k);
        var fullRangeMakeupGain = 1 / fullRangeGain;

        fullRangeMakeupGain = Math.pow(fullRangeMakeupGain, 0.6);

        this._masterLinearGain = Math.pow(10, 0.05 * this.dbPostGain) * fullRangeMakeupGain;
    };

    $.kneeCurve = function(x, k) {
        if (x < this.linearThreshold) {
            return x;
        }
        return this.linearThreshold + (1 - Math.exp(-k * (x - this.linearThreshold))) / k;
    };

    $.saturate = function(x, k) {
        var y;
        if (x < this.kneeThreshold) {
            y = this.kneeCurve(x, k);
        } else {
            var xDb = (x) ? 20 * Math.log(x) * Math.LOG10E : -1000;
            var yDb = this.ykneeThresholdDb + this.slope * (xDb - this.kneeThresholdDb);
            y = Math.pow(10, 0.05 * yDb);
        }
        return y;
    };

    $.slopeAt = function(x, k) {
        if (x < this.linearThreshold) {
            return 1;
        }

        var x2   = x * 1.001;
        var xDb  = (x ) ? 20 * Math.log(x ) * Math.LOG10E : -1000;
        var x2Db = (x2) ? 20 * Math.log(x2) * Math.LOG10E : -1000;
        var y  = this.kneeCurve(x , k);
        var y2 = this.kneeCurve(x2, k);
        var yDb  = (y ) ? 20 * Math.log(y ) * Math.LOG10E : -1000;
        var y2Db = (y2) ? 20 * Math.log(y2) * Math.LOG10E : -1000;

        return (y2Db - yDb) / (x2Db - xDb);
    };

    $.kAtSlope = function(desiredSlope) {
        var xDb = this.dbThreshold + this.dbKnee;
        var x   = Math.pow(10, 0.05 * xDb);

        var minK = 0.1;
        var maxK = 10000;
        var k = 5;

        for (var i = 0; i < 15; ++i) {
            var slope = this.slopeAt(x, k);
            if (slope < desiredSlope) {
                maxK = k;
            } else {
                minK = k;
            }
            k = Math.sqrt(minK * maxK);
        }
        return k;
    };

    $.updateStaticCurveParameters = function(dbThreshold, dbKnee, ratio) {
        this.dbThreshold     = dbThreshold;
        this.linearThreshold = Math.pow(10, 0.05 * dbThreshold);
        this.dbKnee          = dbKnee;

        this.ratio = ratio;
        this.slope = 1 / this.ratio;

        this.kneeThresholdDb = dbThreshold + dbKnee;
        this.kneeThreshold   = Math.pow(10, 0.05 * this.kneeThresholdDb);

        var k = this.kAtSlope(1 / this.ratio);
        var y = this.kneeCurve(this.kneeThreshold, k);
        this.ykneeThresholdDb = (y) ? 20 * Math.log(y) * Math.LOG10E : -1000;

        this._k = k;

        return this._k;
    };

    $.process = function(cellL, cellR) {
        var dryMix = 1 - this.effectBlend;
        var wetMix = this.effectBlend;
        var k = this._k;
        var masterLinearGain = this._masterLinearGain;
        var satReleaseFrames = this._satReleaseFrames;
        var kA = this._kA;
        var kB = this._kB;
        var kC = this._kC;
        var kD = this._kD;
        var kE = this._kE;
        var nDivisionFrames = 64;
        var nDivisions = cellL.length / nDivisionFrames;
        var frameIndex = 0;
        var desiredGain = this.detectorAverage;
        var compressorGain = this.compressorGain;
        var maxAttackCompressionDiffDb = this.maxAttackCompressionDiffDb;
        var i_attackFrames = 1 / this._attackFrames;
        var preDelayReadIndex = this.preDelayReadIndex;
        var preDelayWriteIndex = this.preDelayWriteIndex;
        var detectorAverage = this.detectorAverage;
        var delayBufferL = this.delayBufferL;
        var delayBufferR = this.delayBufferR;
        var meteringGain = this.meteringGain;
        var meteringReleaseK = this.meteringReleaseK;

        for (var i = 0; i < nDivisions; ++i) {
            var scaledDesiredGain = Math.asin(desiredGain) / (0.5 * Math.PI);
            var envelopeRate;
            var isReleasing = scaledDesiredGain > compressorGain;
            var x = compressorGain / scaledDesiredGain;

            var compressionDiffDb = (x) ? 20 * Math.log(x) * Math.LOG10E : -1000;
            if (compressionDiffDb === Infinity || isNaN(compressionDiffDb)) {
                compressionDiffDb = -1;
            }

            if (isReleasing) {
                maxAttackCompressionDiffDb = -1;

                x = compressionDiffDb;
                if (x < -12) {
                    x = 0;
                } else if (x > 0) {
                    x = 3;
                } else {
                    x = 0.25 * (x + 12);
                }

                var x2 = x * x;
                var x3 = x2 * x;
                var x4 = x2 * x2;
                var _releaseFrames = kA + kB * x + kC * x2 + kD * x3 + kE * x4;

                var _dbPerFrame = kSpacingDb / _releaseFrames;

                envelopeRate = Math.pow(10, 0.05 * _dbPerFrame);
            } else {
                if (maxAttackCompressionDiffDb === -1 || maxAttackCompressionDiffDb < compressionDiffDb) {
                    maxAttackCompressionDiffDb = compressionDiffDb;
                }

                var effAttenDiffDb = Math.max(0.5, maxAttackCompressionDiffDb);

                x = 0.25 / effAttenDiffDb;
                envelopeRate = 1 - Math.pow(x, i_attackFrames);
            }

            var loopFrames = nDivisionFrames;
            while (loopFrames--) {
                var compressorInput = 0;

                var absUndelayedSource = (cellL[frameIndex] + cellR[frameIndex]) * 0.5;
                delayBufferL[preDelayWriteIndex] = cellL[frameIndex];
                delayBufferR[preDelayWriteIndex] = cellR[frameIndex];

                if (absUndelayedSource < 0) {
                    absUndelayedSource *= -1;
                }
                if (compressorInput < absUndelayedSource) {
                    compressorInput = absUndelayedSource;
                }

                var absInput = compressorInput;
                if (absInput < 0) {
                    absInput *= -1;
                }

                var shapedInput = this.saturate(absInput, k);
                var attenuation = absInput <= 0.0001 ? 1 : shapedInput / absInput;
                var attenuationDb = (attenuation) ? -20 * Math.log(attenuation) * Math.LOG10E : 1000;
                if (attenuationDb < 2) {
                    attenuationDb = 2;
                }

                var dbPerFrame = attenuationDb / satReleaseFrames;
                var satReleaseRate = Math.pow(10, 0.05 * dbPerFrame) - 1;
                var isRelease = (attenuation > detectorAverage);
                var rate = isRelease ? satReleaseRate : 1;

                detectorAverage += (attenuation - detectorAverage) * rate;
                if (detectorAverage > 1) {
                    detectorAverage = 1;
                }

                if (envelopeRate < 1) {
                    compressorGain += (scaledDesiredGain - compressorGain) * envelopeRate;
                } else {
                    compressorGain *= envelopeRate;
                    if (compressorGain > 1) {
                        compressorGain = 1;
                    }
                }

                var postWarpCompressorGain = Math.sin(0.5 * Math.PI * compressorGain);
                var totalGain = dryMix + wetMix * masterLinearGain * postWarpCompressorGain;

                var dbRealGain = 20 * Math.log(postWarpCompressorGain) * Math.LOG10E;
                if (dbRealGain < meteringGain)  {
                    meteringGain = dbRealGain;
                } else {
                    meteringGain += (dbRealGain - meteringGain) * meteringReleaseK;
                }
                cellL[frameIndex] = delayBufferL[preDelayReadIndex] * totalGain;
                cellR[frameIndex] = delayBufferR[preDelayReadIndex] * totalGain;

                frameIndex++;
                preDelayReadIndex  = (preDelayReadIndex  + 1) & MaxPreDelayFramesMask;
                preDelayWriteIndex = (preDelayWriteIndex + 1) & MaxPreDelayFramesMask;
            }

            if (detectorAverage < 1e-6) {
                detectorAverage = 1e-6;
            }
            if (compressorGain < 1e-6) {
                compressorGain = 1e-6;
            }
        }
        this.preDelayReadIndex  = preDelayReadIndex;
        this.preDelayWriteIndex = preDelayWriteIndex;
        this.detectorAverage    = detectorAverage;
        this.compressorGain = compressorGain;
        this.maxAttackCompressionDiffDb = maxAttackCompressionDiffDb;
        this.meteringGain = meteringGain;
    };

    $.reset = function() {
        this.detectorAverage = 0;
        this.compressorGain = 1;
        this.meteringGain = 1;

        for (var i = 0, imax = this.delayBufferL.length; i < imax; ++i) {
            this.delayBufferL[i] = this.delayBufferR[i] = 0;
        }

        this.preDelayReadIndex = 0;
        this.preDelayWriteIndex = DefaultPreDelayFrames;

        this.maxAttackCompressionDiffDb = -1;
    };

    T.modules.Compressor = Compressor;

})(timbre);
(function(T) {
    "use strict";

    function Decoder() {}

    Decoder.prototype.decode = function(src, onloadedmetadata, onloadeddata) {
        if (typeof src === "string") {
            if (/\.wav$/.test(src)) {
                return Decoder.wav_decode(src, onloadedmetadata, onloadeddata);
            } else if (Decoder.ogg_decode && /\.ogg$/.test(src)) {
                return Decoder.ogg_decode(src, onloadedmetadata, onloadeddata);
            } else if (Decoder.mp3_decode && /\.mp3$/.test(src)) {
                return Decoder.mp3_decode(src, onloadedmetadata, onloadeddata);
            }
        } else if (typeof src === "object") {
            if (src.type === "wav") {
                return Decoder.wav_decode(src.data, onloadedmetadata, onloadeddata);
            } else if (Decoder.ogg_decode && src.type === "ogg") {
                return Decoder.ogg_decode(src.data, onloadedmetadata, onloadeddata);
            } else if (Decoder.mp3_decode && src.type === "mp3") {
                return Decoder.mp3_decode(src.data, onloadedmetadata, onloadeddata);
            }
        }
        if (Decoder.webkit_decode) {
            if (typeof src === "object") {
                return Decoder.webkit_decode(src.data||src, onloadedmetadata, onloadeddata);
            } else {
                return Decoder.webkit_decode(src, onloadedmetadata, onloadeddata);
            }
        } else if (Decoder.moz_decode) {
            return Decoder.moz_decode(src, onloadedmetadata, onloadeddata);
        }
        onloadedmetadata(false);
    };
    T.modules.Decoder = Decoder;

    if (T.envtype === "browser") {
        Decoder.getBinaryWithPath = function(path, callback) {
            T.fn.fix_iOS6_1_problem(true);

            var xhr = new XMLHttpRequest();
            xhr.open("GET", path);
            xhr.responseType = "arraybuffer";
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    if (xhr.response) {
                        callback(new Uint8Array(xhr.response));
                    } else if (xhr.responseBody !== undefined) {
                        /*global VBArray:true */
                        callback(new Uint8Array(VBArray(xhr.responseBody).toArray()));
                        /*global VBArray:false */
                    }
                    T.fn.fix_iOS6_1_problem(false);
                }
            };
            xhr.send();
        };
    } else {
        Decoder.getBinaryWithPath = function(path, callback) {
            callback("no support");
        };
    }

    var _24bit_to_32bit = function(uint8) {
        var b0, b1, b2, bb, x;
        var int32 = new Int32Array(uint8.length / 3);
        for (var i = 0, imax = uint8.length, j = 0; i < imax; ) {
            b0 = uint8[i++] ,b1 = uint8[i++], b2 = uint8[i++];
            bb = b0 + (b1 << 8) + (b2 << 16);
            x = (bb & 0x800000) ? bb - 16777216 : bb;
            int32[j++] = x;
        }
        return int32;
    };

    Decoder.wav_decode = (function() {
        var _decode = function(data, onloadedmetadata, onloadeddata) {
            if (String.fromCharCode(data[0], data[1], data[2], data[3]) !== "RIFF") {
                return onloadedmetadata(false);
            }

            var l1 = data[4] + (data[5]<<8) + (data[6]<<16) + (data[7]<<24);
            if (l1 + 8 !== data.length) {
                return onloadedmetadata(false);
            }

            if (String.fromCharCode(data[8], data[9], data[10], data[11]) !== "WAVE") {
                return onloadedmetadata(false);
            }

            if (String.fromCharCode(data[12], data[13], data[14], data[15]) !== "fmt ") {
                return onloadedmetadata(false);
            }

            var channels   = data[22] + (data[23]<<8);
            var samplerate = data[24] + (data[25]<<8) + (data[26]<<16) + (data[27]<<24);
            var bitSize    = data[34] + (data[35]<<8);

            var i = 36;
            while (i < data.length) {
                if (String.fromCharCode(data[i], data[i+1], data[i+2], data[i+3]) === "data") {
                    break;
                }
                i += 1;
            }
            if (i >= data.length) {
                return onloadedmetadata(false);
            }
            i += 4;

            var l2 = data[i] + (data[i+1]<<8) + (data[i+2]<<16) + (data[i+3]<<24);
            var duration = ((l2 / channels) >> 1) / samplerate;
            i += 4;

            if (l2 > data.length - i) {
                return onloadedmetadata(false);
            }

            var mixdown, bufferL, bufferR;
            mixdown = new Float32Array((duration * samplerate)|0);
            if (channels === 2) {
                bufferL = new Float32Array(mixdown.length);
                bufferR = new Float32Array(mixdown.length);
            }

            onloadedmetadata({
                samplerate: samplerate,
                channels  : channels,
                buffer    : [mixdown, bufferL, bufferR],
                duration  : duration
            });

            if (bitSize === 8) {
                data = new Int8Array(data.buffer, i);
            } else if (bitSize === 16) {
                data = new Int16Array(data.buffer, i);
            } else if (bitSize === 32) {
                data = new Int32Array(data.buffer, i);
            } else if (bitSize === 24) {
                data = _24bit_to_32bit(new Uint8Array(data.buffer, i));
            }

            var imax, j, k = 1 / ((1 << (bitSize-1)) - 1), x;
            if (channels === 2) {
                for (i = j = 0, imax = mixdown.length; i < imax; ++i) {
                    x =  bufferL[i] = data[j++] * k;
                    x += bufferR[i] = data[j++] * k;
                    mixdown[i] = x * 0.5;
                }
            } else {
                for (i = 0, imax = mixdown.length; i < imax; ++i) {
                    mixdown[i] = data[i] * k;
                }
            }

            onloadeddata();
        };

        return function(src, onloadedmetadata, onloadeddata) {
            if (typeof src === "string") {
                Decoder.getBinaryWithPath(src, function(data) {
                    _decode(data, onloadedmetadata, onloadeddata);
                });
            } else {
                _decode(src, onloadedmetadata, onloadeddata);
            }
        };
    })();

    Decoder.webkit_decode = (function() {
        if (typeof T.fn._audioContext !== "undefined") {
            var ctx = T.fn._audioContext;
            var _decode = function(data, onloadedmetadata, onloadeddata) {
                var samplerate, channels, bufferL, bufferR, duration;

                if (typeof data === "string") {
                    return onloadeddata(false);
                }

                var buffer;
                try {
                    buffer = ctx.createBuffer(data.buffer, false);
                } catch (e) {
                    return onloadedmetadata(false);
                }

                samplerate = ctx.sampleRate;
                channels   = buffer.numberOfChannels;
                if (channels === 2) {
                    bufferL = buffer.getChannelData(0);
                    bufferR = buffer.getChannelData(1);
                } else {
                    bufferL = bufferR = buffer.getChannelData(0);
                }
                duration = bufferL.length / samplerate;

                var mixdown = new Float32Array(bufferL);
                for (var i = 0, imax = mixdown.length; i < imax; ++i) {
                    mixdown[i] = (mixdown[i] + bufferR[i]) * 0.5;
                }

                onloadedmetadata({
                    samplerate: samplerate,
                    channels  : channels,
                    buffer    : [mixdown, bufferL, bufferR],
                    duration  : duration
                });

                onloadeddata();
            };

            return function(src, onloadedmetadata, onloadeddata) {
                /*global File:true */
                if (src instanceof File) {
                    var reader = new FileReader();
                    reader.onload = function(e) {
                        _decode(new Uint8Array(e.target.result),
                                onloadedmetadata, onloadeddata);
                    };
                    reader.readAsArrayBuffer(src);
                } else if (typeof src === "string") {
                    Decoder.getBinaryWithPath(src, function(data) {
                        _decode(data, onloadedmetadata, onloadeddata);
                    });
                } else {
                    _decode(src, onloadedmetadata, onloadeddata);
                }
                /*global File:false */
            };
        }
    })();

    Decoder.moz_decode = (function() {
        if (typeof Audio === "function" && typeof new Audio().mozSetup === "function") {
            return function(src, onloadedmetadata, onloadeddata) {
                var samplerate, channels, mixdown, bufferL, bufferR, duration;
                var writeIndex = 0;

                var audio = new Audio(src);
                audio.volume = 0.0;
                audio.addEventListener("loadedmetadata", function() {
                    samplerate = audio.mozSampleRate;
                    channels   = audio.mozChannels;
                    duration   = audio.duration;
                    mixdown = new Float32Array((audio.duration * samplerate)|0);
                    if (channels === 2) {
                        bufferL = new Float32Array((audio.duration * samplerate)|0);
                        bufferR = new Float32Array((audio.duration * samplerate)|0);
                    }
                    if (channels === 2) {
                        audio.addEventListener("MozAudioAvailable", function(e) {
                            var x, samples = e.frameBuffer;
                            for (var i = 0, imax = samples.length; i < imax; i += 2) {
                                x =  bufferL[writeIndex] = samples[i  ];
                                x += bufferR[writeIndex] = samples[i+1];
                                mixdown[writeIndex] = x * 0.5;
                                writeIndex += 1;
                            }
                        }, false);
                    } else {
                        audio.addEventListener("MozAudioAvailable", function(e) {
                            var samples = e.frameBuffer;
                            for (var i = 0, imax = samples.length; i < imax; ++i) {
                                mixdown[i] = samples[i];
                                writeIndex += 1;
                            }
                        }, false);
                    }
                    audio.play();
                    setTimeout(function() {
                        onloadedmetadata({
                            samplerate: samplerate,
                            channels  : channels,
                            buffer    : [mixdown, bufferL, bufferR],
                            duration  : duration
                        });
                    }, 1000);
                }, false);
                audio.addEventListener("ended", function() {
                    onloadeddata();
                }, false);
                audio.load();
            };
        }
    })();
})(timbre);
(function(T) {
    "use strict";

    function Envelope(samplerate) {
        this.samplerate = samplerate || 44100;
        this.value  = ZERO;
        this.status = StatusWait;
        this.curve  = "linear";
        this.step   = 1;
        this.releaseNode = null;
        this.loopNode    = null;
        this.emit = null;

        this._envValue = new EnvelopeValue(samplerate);

        this._table  = [];
        this._initValue  = ZERO;
        this._curveValue = 0;
        this._defaultCurveType = CurveTypeLin;
        this._index   = 0;
        this._counter = 0;
    }

    var ZERO           = Envelope.ZERO = 1e-6;
    var CurveTypeSet   = Envelope.CurveTypeSet   = 0;
    var CurveTypeLin   = Envelope.CurveTypeLin   = 1;
    var CurveTypeExp   = Envelope.CurveTypeExp   = 2;
    var CurveTypeSin   = Envelope.CurveTypeSin   = 3;
    var CurveTypeWel   = Envelope.CurveTypeWel   = 4;
    var CurveTypeCurve = Envelope.CurveTypeCurve = 5;
    var CurveTypeSqr   = Envelope.CurveTypeSqr   = 6;
    var CurveTypeCub   = Envelope.CurveTypeCub   = 7;

    var StatusWait    = Envelope.StatusWait    = 0;
    var StatusGate    = Envelope.StatusGate    = 1;
    var StatusSustain = Envelope.StatusSustain = 2;
    var StatusRelease = Envelope.StatusRelease = 3;
    var StatusEnd     = Envelope.StatusEnd     = 4;

    var CurveTypeDict = {
        set:CurveTypeSet,
        lin:CurveTypeLin, linear     :CurveTypeLin,
        exp:CurveTypeExp, exponential:CurveTypeExp,
        sin:CurveTypeSin, sine       :CurveTypeSin,
        wel:CurveTypeWel, welch      :CurveTypeWel,
        sqr:CurveTypeSqr, squared    :CurveTypeSqr,
        cub:CurveTypeCub, cubed      :CurveTypeCub
    };
    Envelope.CurveTypeDict = CurveTypeDict;

    var $ = Envelope.prototype;

    $.clone = function() {
        var new_instance = new Envelope(this.samplerate);
        new_instance._table = this._table;
        new_instance._initValue = this._initValue;
        new_instance.setCurve(this.curve);
        if (this.releaseNode !== null) {
            new_instance.setReleaseNode(this.releaseNode + 1);
        }
        if (this.loopNode !== null) {
            new_instance.setLoopNode(this.loopNode + 1);
        }
        new_instance.setStep(this.step);
        new_instance.reset();
        return new_instance;
    };
    $.setTable = function(value) {
        this._initValue = value[0];
        this._table = value.slice(1);
        this.value = this._envValue.value = this._initValue;
        this._index   = 0;
        this._counter = 0;
        this.status = StatusWait;
    };
    $.setCurve = function(value) {
        if (typeof value === "number")  {
            this._defaultCurveType = CurveTypeCurve;
            this._curveValue = value;
            this.curve = value;
        } else {
            this._defaultCurveType = CurveTypeDict[value] || null;
            this.curve = value;
        }
    };
    $.setReleaseNode = function(value) {
        if (typeof value === "number" && value > 0) {
            this.releaseNode = value - 1;
        }
    };
    $.setLoopNode = function(value) {
        if (typeof value === "number" && value > 0) {
            this.loopNode = value - 1;
        }
    };
    $.setStep = function(step) {
        this.step = this._envValue.step = step;
    };
    $.reset = function() {
        this.value = this._envValue.value = this._initValue;
        this._index   = 0;
        this._counter = 0;
        this.status = StatusWait;
    };
    $.release = function() {
        if (this.releaseNode !== null) {
            this._counter = 0;
            this.status = StatusRelease;
        }
    };
    $.getInfo = function(sustainTime) {
        var table = this._table;
        var i, imax;
        var totalDuration    = 0;
        var loopBeginTime    = Infinity;
        var releaseBeginTime = Infinity;
        var isEndlessLoop    = false;
        for (i = 0, imax = table.length; i < imax; ++i) {
            if (this.loopNode === i) {
                loopBeginTime = totalDuration;
            }
            if (this.releaseNode === i) {
                if (totalDuration < sustainTime) {
                    totalDuration += sustainTime;
                } else {
                    totalDuration  = sustainTime;
                }
                releaseBeginTime = totalDuration;
            }

            var items = table[i];
            if (Array.isArray(items)) {
                totalDuration += items[1];
            }
        }
        if (loopBeginTime !== Infinity && releaseBeginTime === Infinity) {
            totalDuration += sustainTime;
            isEndlessLoop = true;
        }

        return {
            totalDuration   : totalDuration,
            loopBeginTime   : loopBeginTime,
            releaseBeginTime: releaseBeginTime,
            isEndlessLoop   : isEndlessLoop
        };
    };

    $.calcStatus = function() {
        var status  = this.status;
        var table   = this._table;
        var index   = this._index;
        var counter = this._counter;

        var curveValue = this._curveValue;
        var defaultCurveType = this._defaultCurveType;
        var loopNode    = this.loopNode;
        var releaseNode = this.releaseNode;
        var envValue = this._envValue;
        var items, endValue, time, curveType, emit = null;

        switch (status) {
        case StatusWait:
        case StatusEnd:
            break;
        case StatusGate:
        case StatusRelease:
            while (counter <= 0) {
                if (index >= table.length) {
                    if (status === StatusGate && loopNode !== null) {
                        index = loopNode;
                        continue;
                    }
                    status    = StatusEnd;
                    counter   = Infinity;
                    curveType = CurveTypeSet;
                    emit      = "ended";
                    continue;
                } else if (status === StatusGate && index === releaseNode) {
                    if (loopNode !== null && loopNode < releaseNode) {
                        index = loopNode;
                        continue;
                    }
                    status    = StatusSustain;
                    counter   = Infinity;
                    curveType = CurveTypeSet;
                    emit      = "sustained";
                    continue;
                }
                items = table[index++];

                endValue = items[0];
                if (items[2] === null) {
                    curveType = defaultCurveType;
                } else {
                    curveType = items[2];
                }
                if (curveType === CurveTypeCurve) {
                    curveValue = items[3];
                    if (Math.abs(curveValue) < 0.001) {
                        curveType = CurveTypeLin;
                    }
                }
                time = items[1];

                counter = envValue.setNext(endValue, time, curveType, curveValue);
            }
            break;
        }

        this.status = status;
        this.emit   = emit;
        this._index = index;
        this._counter = counter;

        return status;
    };

    $.next = function() {
        if (this.calcStatus() & 1) {
            this.value  = this._envValue.next() || ZERO;
        }
        this._counter -= 1;
        return this.value;
    };

    $.process = function(cell) {
        var envValue = this._envValue;
        var i, imax = cell.length;

        if (this.calcStatus() & 1) {
            for (i = 0; i < imax; ++i) {
                cell[i] = envValue.next() || ZERO;
            }
        } else {
            var value = this.value || ZERO;
            for (i = 0; i < imax; ++i) {
                cell[i] = value;
            }
        }
        this.value = cell[imax-1];

        this._counter -= cell.length;
    };


    function EnvelopeValue(samplerate) {
        this.samplerate = samplerate;
        this.value = ZERO;
        this.step  = 1;

        this._curveType  = CurveTypeLin;
        this._curveValue = 0;

        this._grow = 0;

        this._a2 = 0;
        this._b1 = 0;
        this._y1 = 0;
        this._y2 = 0;
    }
    EnvelopeValue.prototype.setNext = function(endValue, time, curveType, curveValue) {
        var n = this.step;
        var value = this.value;
        var grow, w, a1, a2, b1, y1, y2;

        var counter = ((time * 0.001 * this.samplerate) / n)|0;
        if (counter < 1) {
            counter   = 1;
            curveType = CurveTypeSet;
        }

        switch (curveType) {
        case CurveTypeSet:
            this.value = endValue;
            break;
        case CurveTypeLin:
            grow = (endValue - value) / counter;
            break;
        case CurveTypeExp:
            if (value !== 0) {
                grow = Math.pow(
                    endValue / value, 1 / counter
                );
            } else {
                grow = 0;
            }
            break;
        case CurveTypeSin:
            w = Math.PI / counter;
            a2 = (endValue + value) * 0.5;
            b1 = 2 * Math.cos(w);
            y1 = (endValue - value) * 0.5;
            y2 = y1 * Math.sin(Math.PI * 0.5 - w);
            value = a2 - y1;
            break;
        case CurveTypeWel:
            w = (Math.PI * 0.5) / counter;
            b1 = 2 * Math.cos(w);
            if (endValue >= value) {
                a2 = value;
                y1 = 0;
                y2 = -Math.sin(w) * (endValue - value);
            } else {
                a2 = endValue;
                y1 = value - endValue;
                y2 = Math.cos(w) * (value - endValue);
            }
            value = a2 + y1;
            break;
        case CurveTypeCurve:
            a1 = (endValue - value) / (1.0 - Math.exp(curveValue));
            a2 = value + a1;
            b1 = a1;
            grow = Math.exp(curveValue / counter);
            break;
        case CurveTypeSqr:
            y1 = Math.sqrt(value);
            y2 = Math.sqrt(endValue);
            grow = (y2 - y1) / counter;
            break;
        case CurveTypeCub:
            y1 = Math.pow(value   , 0.33333333);
            y2 = Math.pow(endValue, 0.33333333);
            grow = (y2 - y1) / counter;
            break;
        }

        this.next = NextFunctions[curveType];
        this._grow = grow;
        this._a2 = a2;
        this._b1 = b1;
        this._y1 = y1;
        this._y2 = y2;

        return counter;
    };

    var NextFunctions = [];
    NextFunctions[CurveTypeSet] = function() {
        return this.value;
    };
    NextFunctions[CurveTypeLin] = function() {
        this.value += this._grow;
        return this.value;
    };
    NextFunctions[CurveTypeExp] = function() {
        this.value *= this._grow;
        return this.value;
    };
    NextFunctions[CurveTypeSin] = function() {
        var y0 = this._b1 * this._y1 - this._y2;
        this.value = this._a2 - y0;
        this._y2 = this._y1;
        this._y1 = y0;
        return this.value;
    };
    NextFunctions[CurveTypeWel] = function() {
        var y0 = this._b1 * this._y1 - this._y2;
        this.value = this._a2 + y0;
        this._y2 = this._y1;
        this._y1 = y0;
        return this.value;
    };
    NextFunctions[CurveTypeCurve] = function() {
        this._b1 *= this._grow;
        this.value = this._a2 - this._b1;
        return this.value;
    };
    NextFunctions[CurveTypeSqr] = function() {
        this._y1 += this._grow;
        this.value = this._y1 * this._y1;
        return this.value;
    };
    NextFunctions[CurveTypeCub] = function() {
        this._y1 += this._grow;
        this.value = this._y1 * this._y1 * this._y1;
        return this.value;
    };

    EnvelopeValue.prototype.next = NextFunctions[CurveTypeSet];

    T.modules.Envelope      = Envelope;
    T.modules.EnvelopeValue = EnvelopeValue;

})(timbre);
(function(T) {
    "use strict";

    function FFT(n) {
        n = (typeof n === "number") ? n : 512;
        n = 1 << Math.ceil(Math.log(n) * Math.LOG2E);

        this.length  = n;
        this.buffer  = new T.fn.SignalArray(n);
        this.real    = new T.fn.SignalArray(n);
        this.imag    = new T.fn.SignalArray(n);
        this._real   = new T.fn.SignalArray(n);
        this._imag   = new T.fn.SignalArray(n);
        this.mag     = new T.fn.SignalArray(n>>1);

        this.minDecibels =  -30;
        this.maxDecibels = -100;

        var params = FFTParams.get(n);
        this._bitrev   = params.bitrev;
        this._sintable = params.sintable;
        this._costable = params.costable;
    }

    var $ = FFT.prototype;

    $.setWindow = function(key) {
        if (typeof key === "string") {
            var m = /([A-Za-z]+)(?:\(([01]\.?\d*)\))?/.exec(key);
            if (m !== null) {
                var name = m[1].toLowerCase(), a = m[2] !== undefined ? +m[2] : 0.25;
                var f = WindowFunctions[name];
                if (f) {
                    if (!this._window) {
                        this._window = new T.fn.SignalArray(this.length);
                    }
                    var w = this._window, n = 0, N = this.length;
                    a = (a < 0) ? 0 : (a > 1) ? 1 : a;
                    for (; n < N; ++n) {
                        w[n] = f(n, N, a);
                    }
                    this.windowName = key;
                }
            }
        }
    };

    $.forward = function(_buffer) {
        var buffer   = this.buffer;
        var real   = this.real;
        var imag   = this.imag;
        var window = this._window;
        var bitrev = this._bitrev;
        var sintable = this._sintable;
        var costable = this._costable;
        var n = buffer.length;
        var i, j, k, k2, h, d, c, s, ik, dx, dy;

        if (window) {
            for (i = 0; i < n; ++i) {
                buffer[i] = _buffer[i] * window[i];
            }
        } else {
            buffer.set(_buffer);
        }

        for (i = 0; i < n; ++i) {
            real[i] = buffer[bitrev[i]];
            imag[i] = 0.0;
        }

        for (k = 1; k < n; k = k2) {
            h = 0; k2 = k + k; d = n / k2;
            for (j = 0; j < k; j++) {
                c = costable[h];
                s = sintable[h];
                for (i = j; i < n; i += k2) {
                    ik = i + k;
                    dx = s * imag[ik] + c * real[ik];
                    dy = c * imag[ik] - s * real[ik];
                    real[ik] = real[i] - dx; real[i] += dx;
                    imag[ik] = imag[i] - dy; imag[i] += dy;
                }
                h += d;
            }
        }

        var mag = this.mag;
        var rval, ival;
        for (i = 0; i < n; ++i) {
            rval = real[i];
            ival = imag[i];
            mag[i] = Math.sqrt(rval * rval + ival * ival);
        }

        return {real:real, imag:imag};
    };

    $.inverse = function(_real, _imag) {
        var buffer = this.buffer;
        var real   = this._real;
        var imag   = this._imag;
        var bitrev = this._bitrev;
        var sintable = this._sintable;
        var costable = this._costable;
        var n = buffer.length;
        var i, j, k, k2, h, d, c, s, ik, dx, dy;

        for (i = 0; i < n; ++i) {
            j = bitrev[i];
            real[i] = +_real[j];
            imag[i] = -_imag[j];
        }

        for (k = 1; k < n; k = k2) {
            h = 0; k2 = k + k; d = n / k2;
            for (j = 0; j < k; j++) {
                c = costable[h];
                s = sintable[h];
                for (i = j; i < n; i += k2) {
                    ik = i + k;
                    dx = s * imag[ik] + c * real[ik];
                    dy = c * imag[ik] - s * real[ik];
                    real[ik] = real[i] - dx; real[i] += dx;
                    imag[ik] = imag[i] - dy; imag[i] += dy;
                }
                h += d;
            }
        }

        for (i = 0; i < n; ++i) {
            buffer[i] = real[i] / n;
        }
        return buffer;
    };

    $.getFrequencyData = function(array) {
        var minDecibels  = this.minDecibels;
        var i, imax = Math.min(this.mag.length, array.length);
        if (imax) {
            var x, mag = this.mag;
            var peak = 0;
            for (i = 0; i < imax; ++i) {
                x  = mag[i];
                array[i] = !x ? minDecibels : 20 * Math.log(x) * Math.LOG10E;
                if (peak < array[i]) {
                    peak = array[i];
                }
            }
        }
        return array;
    };

    var FFTParams = {
        get: function(n) {
            return FFTParams[n] || (function() {
                var bitrev = (function() {
                    var x, i, j, k, n2;
                    x = new Int16Array(n);
                    n2 = n >> 1;
                    i = j = 0;
                    for (;;) {
                        x[i] = j;
                        if (++i >= n) {
                            break;
                        }
                        k = n2;
                        while (k <= j) {
                            j -= k;
                            k >>= 1;
                        }
                        j += k;
                    }
                    return x;
                }());
                var i, imax, k = Math.floor(Math.log(n) / Math.LN2);
                var sintable = new T.fn.SignalArray((1<<k)-1);
                var costable = new T.fn.SignalArray((1<<k)-1);
                var PI2 = Math.PI * 2;

                for (i = 0, imax = sintable.length; i < imax; ++i) {
                    sintable[i] = Math.sin(PI2 * (i / n));
                    costable[i] = Math.cos(PI2 * (i / n));
                }
                FFTParams[n] = {
                    bitrev: bitrev, sintable:sintable, costable:costable
                };
                return FFTParams[n];
            }());
        }
    };

    var WindowFunctions = (function() {
        var PI   = Math.PI;
        var PI2  = Math.PI * 2;
        var abs  = Math.abs;
        var pow  = Math.pow;
        var cos  = Math.cos;
        var sin  = Math.sin;
        var sinc = function(x) { return sin(PI*x) / (PI*x); };
        var E    = Math.E;

        return {
            rectangular: function() {
                return 1;
            },
            hann: function(n, N) {
                return 0.5 * (1 - cos((PI2*n) / (N-1)));
            },
            hamming: function(n, N) {
                return 0.54 - 0.46 * cos((PI2*n) / (N-1));
            },
            tukery: function(n, N, a) {
                if ( n < (a * (N-1))/2 ) {
                    return 0.5 * ( 1 + cos(PI * (((2*n)/(a*(N-1))) - 1)) );
                } else if ( (N-1)*(1-(a/2)) < n ) {
                    return 0.5 * ( 1 + cos(PI * (((2*n)/(a*(N-1))) - (2/a) + 1)) );
                } else {
                    return 1;
                }
            },
            cosine: function(n, N) {
                return sin((PI*n) / (N-1));
            },
            lanczos: function(n, N) {
                return sinc(((2*n) / (N-1)) - 1);
            },
            triangular: function(n, N) {
                return (2/(N+1)) * (((N+1)/2) - abs(n - ((N-1)/2)));
            },
            bartlett: function(n, N) {
                return (2/(N-1)) * (((N-1)/2) - abs(n - ((N-1)/2)));
            },
            gaussian: function(n, N, a) {
                return pow(E, -0.5 * pow((n - (N-1) / 2) / (a * (N-1) / 2), 2));
            },
            bartlettHann: function(n, N) {
                return 0.62 - 0.48 * abs((n / (N-1)) - 0.5) - 0.38 * cos((PI2*n) / (N-1));
            },
            blackman: function(n, N, a) {
                var a0 = (1 - a) / 2, a1 = 0.5, a2 = a / 2;
                return a0 - a1 * cos((PI2*n) / (N-1)) + a2 * cos((4*PI*n) / (N-1));
            }
        };
    }());

    T.modules.FFT = FFT;

})(timbre);
(function(T) {
    "use strict";

    function Oscillator(samplerate) {
        this.samplerate = samplerate || 44100;

        this.wave = null;
        this.step = 1;
        this.frequency = 0;
        this.value = 0;
        this.phase = 0;
        this.feedback = false;

        this._x = 0;
        this._lastouts = 0;
        this._coeff = TABLE_SIZE / this.samplerate;
        this._radtoinc = TABLE_SIZE / (Math.PI * 2);
    }

    var TABLE_SIZE = 1024;
    var TABLE_MASK = TABLE_SIZE - 1;

    var $ = Oscillator.prototype;

    $.setWave = function(value) {
        var i, dx, wave = this.wave;
        if (!this.wave) {
            this.wave = new Float32Array(TABLE_SIZE + 1);
        }
        if (typeof value === "function") {
            for (i = 0; i < TABLE_SIZE; ++i) {
                wave[i] = value(i / TABLE_SIZE);
            }
        } else if (T.fn.isSignalArray(value)) {
            if (value.length === wave.length) {
                wave.set(value);
            } else {
                dx = value.length / TABLE_SIZE;
                for (i = 0; i < TABLE_SIZE; ++i) {
                    wave[i] = value[(i * dx)|0];
                }
            }
        } else if (typeof value === "string") {
            if ((dx = getWavetable(value)) !== undefined) {
                this.wave.set(dx);
            }
        }
        this.wave[TABLE_SIZE] = this.wave[0];
    };

    $.clone = function() {
        var new_instance = new Oscillator(this.samplerate);
        new_instance.wave      = this.wave;
        new_instance.step      = this.step;
        new_instance.frequency = this.frequency;
        new_instance.value     = this.value;
        new_instance.phase     = this.phase;
        new_instance.feedback  = this.feedback;
        return new_instance;
    };

    $.reset = function() {
        this._x = 0;
    };

    $.next = function() {
        var x = this._x;
        var index = (x + this.phase * this._radtoinc)|0;
        this.value = this.wave[index & TABLE_MASK];
        x += this.frequency * this._coeff * this.step;
        if (x > TABLE_SIZE) {
            x -= TABLE_SIZE;
        }
        this._x = x;
        return this.value;
    };

    $.process = function(cell) {
        var wave = this.wave;
        var radtoinc = this._radtoinc;
        var phase, x = this._x;
        var index, frac, x0, x1, dx = this.frequency * this._coeff;
        var i, imax = this.step;

        if (this.feedback) {
            var lastouts = this._lastouts;
            radtoinc *= this.phase;
            for (i = 0; i < imax; ++i) {
                phase = x + lastouts * radtoinc;
                index = phase|0;
                frac  = phase - index;
                index = index & TABLE_MASK;
                x0 = wave[index  ];
                x1 = wave[index+1];
                cell[i] = lastouts = x0 + frac * (x1 - x0);
                x += dx;
            }
            this._lastouts = lastouts;
        } else {
            var phaseoffset = this.phase * radtoinc;
            for (i = 0; i < imax; ++i) {
                phase = x + phaseoffset;
                index = phase|0;
                frac  = phase - index;
                index = index & TABLE_MASK;
                x0 = wave[index  ];
                x1 = wave[index+1];
                cell[i] = x0 + frac * (x1 - x0);
                x += dx;
            }
        }
        if (x > TABLE_SIZE) {
            x -= TABLE_SIZE;
        }
        this._x = x;
        this.value = cell[cell.length - 1];
    };

    $.processWithFreqArray = function(cell, freqs) {
        var wave = this.wave;
        var radtoinc = this._radtoinc;
        var phase, x = this._x;
        var index, frac, x0, x1, dx = this._coeff;
        var i, imax = this.step;

        if (this.feedback) {
            var lastouts = this._lastouts;
            radtoinc *= this.phase;
            for (i = 0; i < imax; ++i) {
                phase = x + lastouts * radtoinc;
                index = phase|0;
                frac  = phase - index;
                index = index & TABLE_MASK;
                x0 = wave[index  ];
                x1 = wave[index+1];
                cell[i] = lastouts = x0 + frac * (x1 - x0);
                x += freqs[i] * dx;
            }
            this._lastouts = lastouts;
        } else {
            var phaseoffset = this.phase * this._radtoinc;
            for (i = 0; i < imax; ++i) {
                phase = x + phaseoffset;
                index = phase|0;
                frac  = phase - index;
                index = index & TABLE_MASK;
                x0 = wave[index  ];
                x1 = wave[index+1];
                cell[i] = x0 + frac * (x1 - x0);
                x += freqs[i] * dx;
            }
        }
        if (x > TABLE_SIZE) {
            x -= TABLE_SIZE;
        }
        this._x = x;
        this.value = cell[cell.length - 1];
    };

    $.processWithPhaseArray = function(cell, phases) {
        var wave = this.wave;
        var radtoinc = this._radtoinc;
        var phase, x = this._x;
        var index, frac, x0, x1, dx = this.frequency * this._coeff;
        var i, imax = this.step;

        if (this.feedback) {
            var lastouts = this._lastouts;
            radtoinc *= this.phase;
            for (i = 0; i < imax; ++i) {
                phase = x + lastouts * radtoinc;
                index = phase|0;
                frac  = phase - index;
                index = index & TABLE_MASK;
                x0 = wave[index  ];
                x1 = wave[index+1];
                cell[i] = lastouts = x0 + frac * (x1 - x0);
                x += dx;
            }
            this._lastouts = lastouts;
        } else {
            for (i = 0; i < imax; ++i) {
                phase = x + phases[i] * radtoinc;
                index = phase|0;
                frac  = phase - index;
                index = index & TABLE_MASK;
                x0 = wave[index  ];
                x1 = wave[index+1];
                cell[i] = x0 + frac * (x1 - x0);
                x += dx;
            }
        }
        if (x > TABLE_SIZE) {
            x -= TABLE_SIZE;
        }
        this._x = x;
        this.value = cell[cell.length - 1];
    };

    $.processWithFreqAndPhaseArray = function(cell, freqs, phases) {
        var wave = this.wave;
        var radtoinc = this._radtoinc;
        var phase, x = this._x;
        var index, frac, x0, x1, dx = this._coeff;
        var i, imax = this.step;

        if (this.feedback) {
            var lastouts = this._lastouts;
            radtoinc *= this.phase;
            for (i = 0; i < imax; ++i) {
                phase = x + lastouts * radtoinc;
                index = phase|0;
                frac  = phase - index;
                index = index & TABLE_MASK;
                x0 = wave[index  ];
                x1 = wave[index+1];
                cell[i] = lastouts = x0 + frac * (x1 - x0);
                x += freqs[i] * dx;
            }
            this._lastouts = lastouts;
        } else {
            for (i = 0; i < imax; ++i) {
                phase = x + phases[i] * TABLE_SIZE;
                index = phase|0;
                frac  = phase - index;
                index = index & TABLE_MASK;
                x0 = wave[index  ];
                x1 = wave[index+1];
                cell[i] = x0 + frac * (x1 - x0);
                x += freqs[i] * dx;
            }
        }
        if (x > TABLE_SIZE) {
            x -= TABLE_SIZE;
        }
        this._x = x;
        this.value = cell[cell.length - 1];
    };


    function waveshape(sign, name, shape, width) {
        var wave = Wavetables[name];
        var _wave;
        var i, imax, j, jmax;

        if (wave === undefined) {
            return;
        }

        if (typeof wave === "function") {
            wave = wave();
        }

        switch (shape) {
        case "@1":
            for (i = 512; i < 1024; ++i) {
                wave[i] = 0;
            }
            break;
        case "@2":
            for (i = 512; i < 1024; ++i) {
                wave[i] = Math.abs(wave[i]);
            }
            break;
        case "@3":
            for (i = 256; i <  512; ++i) {
                wave[i] = 0;
            }
            for (i = 512; i <  768; ++i) {
                wave[i] = Math.abs(wave[i]);
            }
            for (i = 768; i < 1024; ++i) {
                wave[i] = 0;
            }
            break;
        case "@4":
            _wave = new Float32Array(1024);
            for (i = 0; i < 512; ++i) {
                _wave[i] = wave[i<<1];
            }
            wave = _wave;
            break;
        case "@5":
            _wave = new Float32Array(1024);
            for (i = 0; i < 512; ++i) {
                _wave[i] = Math.abs(wave[i<<1]);
            }
            wave = _wave;
            break;
        }

        // duty-cycle
        if (width !== undefined && width !== 50) {
            width *= 0.01;
            width = (width < 0) ? 0 : (width > 1) ? 1 : width;

            _wave = new Float32Array(1024);
            imax = (1024 * width)|0;
            for (i = 0; i < imax; ++i) {
                _wave[i] = wave[(i / imax * 512)|0];
            }
            jmax = (1024 - imax);
            for (j = 0; i < 1024; ++i, ++j) {
                _wave[i] = wave[(j / jmax * 512 + 512)|0];
            }
            wave = _wave;
        }

        if (sign === "+") {
            for (i = 0; i < 1024; ++i) {
                wave[i] = wave[i] * 0.5 + 0.5;
            }
        } else if (sign === "-") {
            for (i = 0; i < 1024; ++i) {
                wave[i] *= -1;
            }
        }
        return wave;
    }

    function wavb(src) {
        var wave = new Float32Array(1024);
        var n = src.length >> 1;
        if ([2,4,8,16,32,64,128,256,512,1024].indexOf(n) !== -1) {

            for (var i = 0, k = 0; i < n; ++i) {
                var x = parseInt(src.substr(i * 2, 2), 16);

                x = (x & 0x80) ? (x-256) / 128.0 : x / 127.0;
                for (var j = 0, jmax = 1024 / n; j < jmax; ++j) {
                    wave[k++] = x;
                }
            }
        }
        return wave;
    }

    function wavc(src) {
        var wave = new Float32Array(1024);
        if (src.length === 8) {
            var color = parseInt(src, 16);
            var bar   = new Float32Array(8);
            var i, j;

            bar[0] = 1;
            for (i = 0; i < 7; ++i) {
                bar[i+1] = (color & 0x0f) * 0.0625; // 0.0625 = 1/16
                color >>= 4;
            }

            for (i = 0; i < 8; ++i) {
                var x = 0, dx = (i + 1) / 1024;
                for (j = 0; j < 1024; ++j) {
                    wave[j] += Math.sin(2 * Math.PI * x) * bar[i];
                    x += dx;
                }
            }

            var maxx = 0, absx;
            for (i = 0; i < 1024; ++i) {
                if (maxx < (absx = Math.abs(wave[i]))) {
                    maxx = absx;
                }
            }
            if (maxx > 0) {
                for (i = 0; i < 1024; ++i) {
                    wave[i] /= maxx;
                }
            }
        }
        return wave;
    }

    var getWavetable = function(key) {
        var wave = Wavetables[key];
        if (wave !== undefined) {
            if (typeof wave === "function") {
                wave = wave();
            }
            return wave;
        }

        var m;
        // wave shaping
        m = /^([\-+]?)(\w+)(?:\((@[0-7])?:?(\d+)?\))?$/.exec(key);
        if (m !== null) {
            var sign = m[1], name = m[2], shape = m[3], width = m[4];
            wave = waveshape(sign, name, shape, width);
            if (wave !== undefined) {
                Wavetables[key] = wave;
                return wave;
            }
        }

        // wave bytes
        m = /^wavb\(((?:[0-9a-fA-F][0-9a-fA-F])+)\)$/.exec(key);
        if (m !== null) {
            return wavb(m[1]);
        }

        // wave color
        m = /^wavc\(([0-9a-fA-F]{8})\)$/.exec(key);
        if (m !== null) {
            return wavc(m[1]);
        }

        // warn message
    };
    Oscillator.getWavetable = getWavetable;

    var setWavetable = function(name, value) {
        var dx, wave = new Float32Array(1024);
        var i;
        if (typeof value === "function") {
            for (i = 0; i < 1024; ++i) {
                wave[i] = value(i / 1024);
            }
        } else if (T.fn.isSignalArray(value)) {
            if (value.length === wave.length) {
                wave.set(value);
            } else {
                dx = value.length / 1024;
                for (i = 0; i < 1024; ++i) {
                    wave[i] = value[(i * dx)|0];
                }
            }
        }
        Wavetables[name] = wave;
    };
    Oscillator.setWavetable = setWavetable;

    var Wavetables = {
        sin: function() {
            var wave = new Float32Array(1024);
            for (var i = 0; i < 1024; ++i) {
                wave[i] = Math.sin(2 * Math.PI * (i/1024));
            }
            return wave;
        },
        cos: function() {
            var wave = new Float32Array(1024);
            for (var i = 0; i < 1024; ++i) {
                wave[i] = Math.cos(2 * Math.PI * (i/1024));
            }
            return wave;
        },
        pulse: function() {
            var wave = new Float32Array(1024);
            for (var i = 0; i < 1024; ++i) {
                wave[i] = (i < 512) ? +1 : -1;
            }
            return wave;
        },
        tri: function() {
            var wave = new Float32Array(1024);
            for (var x, i = 0; i < 1024; ++i) {
                x = (i / 1024) - 0.25;
                wave[i] = 1.0 - 4.0 * Math.abs(Math.round(x) - x);
            }
            return wave;
        },
        saw: function() {
            var wave = new Float32Array(1024);
            for (var x, i = 0; i < 1024; ++i) {
                x = (i / 1024);
                wave[i] = +2.0 * (x - Math.round(x));
            }
            return wave;
        },
        fami: function() {
            var d = [ +0.000, +0.125, +0.250, +0.375, +0.500, +0.625, +0.750, +0.875,
                      +0.875, +0.750, +0.625, +0.500, +0.375, +0.250, +0.125, +0.000,
                      -0.125, -0.250, -0.375, -0.500, -0.625, -0.750, -0.875, -1.000,
                      -1.000, -0.875, -0.750, -0.625, -0.500, -0.375, -0.250, -0.125 ];
            var wave = new Float32Array(1024);
            for (var i = 0; i < 1024; ++i) {
                wave[i] = d[(i / 1024 * d.length)|0];
            }
            return wave;
        },
        konami: function() {
            var d = [-0.625, -0.875, -0.125, +0.750, + 0.500, +0.125, +0.500, +0.750,
                     +0.250, -0.125, +0.500, +0.875, + 0.625, +0.000, +0.250, +0.375,
                     -0.125, -0.750, +0.000, +0.625, + 0.125, -0.500, -0.375, -0.125,
                     -0.750, -1.000, -0.625, +0.000, - 0.375, -0.875, -0.625, -0.250 ];
            var wave = new Float32Array(1024);
            for (var i = 0; i < 1024; ++i) {
                wave[i] = d[(i / 1024 * d.length)|0];
            }
            return wave;
        }
    };

    T.modules.Oscillator = Oscillator;

})(timbre);
/**
 * Port of the Freeverb Schrodoer/Moorer reverb model.
 * https://ccrma.stanford.edu/~jos/pasp/Freeverb.html
*/
(function(T) {
    "use strict";

    var CombParams    = [1116,1188,1277,1356,1422,1491,1557,1617];
    var AllpassParams = [225,556,441,341];

    function Reverb(samplerate, buffersize) {
        this.samplerate = samplerate;

        var i, imax;
        var k = samplerate / 44100;

        imax = CombParams.length * 2;
        this.comb = new Array(imax);
        this.combout = new Array(imax);
        for (i = 0; i < imax; ++i) {
            this.comb[i]    = new CombFilter(CombParams[i % CombParams.length] * k);
            this.combout[i] = new T.fn.SignalArray(buffersize);
        }

        imax = AllpassParams.length * 2;
        this.allpass = new Array(imax);
        for (i = 0; i < imax; ++i) {
            this.allpass[i] = new AllpassFilter(AllpassParams[i % AllpassParams.length] * k);
        }
        this.outputs = [ new T.fn.SignalArray(buffersize),
                         new T.fn.SignalArray(buffersize) ];
        this.damp = 0;
        this.wet  = 0.33;

        this.setRoomSize(0.5);
        this.setDamp(0.5);
    }

    var $ = Reverb.prototype;

    $.setRoomSize = function(roomsize) {
        var comb = this.comb;
        var value = (roomsize * 0.28) + 0.7;
        this.roomsize = roomsize;
        comb[0].feedback = comb[1].feedback = comb[2].feedback = comb[3].feedback = comb[4].feedback = comb[5].feedback = comb[6].feedback = comb[7].feedback = comb[8].feedback = comb[9].feedback = comb[10].feedback = comb[11].feedback = comb[12].feedback = comb[13].feedback = comb[14].feedback = comb[15].feedback = value;
    };
    $.setDamp = function(damp) {
        var comb = this.comb;
        var value = damp * 0.4;
        this.damp = damp;
        comb[0].damp = comb[1].damp = comb[2].damp = comb[3].damp = comb[4].damp = comb[5].damp = comb[6].damp = comb[7].damp = comb[8].damp = comb[9].damp = comb[10].damp = comb[11].damp = comb[12].damp = comb[13].damp = comb[14].damp = comb[15].damp = value;

    };
    $.process = function(cellL, cellR) {
        var comb = this.comb;
        var combout = this.combout;
        var allpass = this.allpass;
        var output0 = this.outputs[0];
        var output1 = this.outputs[1];
        var wet = this.wet, dry = 1 - wet;
        var i, imax = cellL.length;

        comb[0].process(cellL, combout[0]);
        comb[1].process(cellL, combout[1]);
        comb[2].process(cellL, combout[2]);
        comb[3].process(cellL, combout[3]);
        comb[4].process(cellL, combout[4]);
        comb[5].process(cellL, combout[5]);
        comb[6].process(cellL, combout[6]);
        comb[7].process(cellL, combout[7]);

        comb[ 8].process(cellR, combout[ 8]);
        comb[ 9].process(cellR, combout[ 9]);
        comb[10].process(cellR, combout[10]);
        comb[11].process(cellR, combout[11]);
        comb[12].process(cellR, combout[12]);
        comb[13].process(cellR, combout[13]);
        comb[14].process(cellR, combout[14]);
        comb[15].process(cellR, combout[15]);

        for (i = 0; i < imax; ++i) {
            output0[i] = combout[0][i] + combout[1][i] + combout[2][i] + combout[3][i] + combout[4][i] + combout[5][i] + combout[6][i] + combout[7][i];
            output1[i] = combout[8][i] + combout[9][i] + combout[10][i] + combout[11][i] + combout[12][i] + combout[13][i] + combout[14][i] + combout[15][i];
        }
        allpass[0].process(output0, output0);
        allpass[1].process(output0, output0);
        allpass[2].process(output0, output0);
        allpass[3].process(output0, output0);

        allpass[4].process(output1, output1);
        allpass[5].process(output1, output1);
        allpass[6].process(output1, output1);
        allpass[7].process(output1, output1);

        for (i = 0; i < imax; ++i) {
            cellL[i] = output0[i] * wet + cellL[i] * dry;
            cellR[i] = output1[i] * wet + cellR[i] * dry;
        }
    };

    function CombFilter(buffersize) {
        this.buffer = new T.fn.SignalArray(buffersize|0);
        this.buffersize = this.buffer.length;
        this.bufidx = 0;
        this.feedback =  0;
        this.filterstore = 0;
        this.damp = 0;
    }

    CombFilter.prototype.process = function(input, output) {
        var ins, outs;
        var buffer = this.buffer;
        var buffersize = this.buffersize;
        var bufidx = this.bufidx;
        var filterstore = this.filterstore;
        var feedback = this.feedback;
        var damp1 = this.damp, damp2 = 1 - damp1;
        var i, imax = input.length;

        for (i = 0; i < imax; ++i) {
            ins = input[i] * 0.015;
            outs = buffer[bufidx];

            filterstore = (outs * damp2) + (filterstore * damp1);

            buffer[bufidx] = ins + (filterstore * feedback);

            if (++bufidx >= buffersize) {
                bufidx = 0;
            }

            output[i] = outs;
        }

        this.bufidx = bufidx;
        this.filterstore = filterstore;
    };

    function AllpassFilter(buffersize) {
        this.buffer = new T.fn.SignalArray(buffersize|0);
        this.buffersize = this.buffer.length;
        this.bufidx = 0;
    }

    AllpassFilter.prototype.process = function(input, output) {
        var ins, outs, bufout;
        var buffer = this.buffer;
        var buffersize = this.buffersize;
        var bufidx = this.bufidx;
        var i, imax = input.length;

        for (i = 0; i < imax; ++i) {
            ins = input[i];

            bufout = buffer[bufidx];

            outs = -ins + bufout;
            buffer[bufidx] = ins + (bufout * 0.5);

            if (++bufidx >= buffersize) {
                bufidx = 0;
            }

            output[i] = outs;
        }

        this.bufidx = bufidx;
    };

    T.modules.Reverb = Reverb;

})(timbre);
(function(T) {
    "use strict";

    var DummyBuffer = new Float32Array(60);

    function Scissor(soundbuffer) {
        return new Tape(soundbuffer);
    }

    var silencebuffer = {
        buffer:DummyBuffer, samplerate:1
    };

    Scissor.silence = function(duration) {
        return new Scissor(silencebuffer).slice(0, 1).fill(duration);
    };

    Scissor.join = function(tapes) {
        var new_instance = new Tape();

        for (var i = 0; i < tapes.length; i++) {
            if (tapes[i] instanceof Tape) {
                new_instance.add_fragments(tapes[i].fragments);
            }
        }

        return new_instance;
    };

    function Tape(soundbuffer) {
        this.fragments = [];
        if (soundbuffer) {
            var samplerate = soundbuffer.samplerate || 44100;
            var duration   = soundbuffer.buffer[0].length / samplerate;
            this.fragments.push(
                new Fragment(soundbuffer, 0, duration)
            );
        }
    }
    Scissor.Tape = Tape;

    Tape.prototype.add_fragment = function(fragment) {
        this.fragments.push(fragment);
        return this;
    };

    Tape.prototype.add_fragments = function(fragments) {
        for (var i = 0; i < fragments.length; i++) {
            this.fragments.push(fragments[i]);
        }
        return this;
    };

    Tape.prototype.duration = function() {
        var result = 0;
        for (var i = 0; i < this.fragments.length; i++) {
            result += this.fragments[i].duration();
        }
        return result;
    };

    Tape.prototype.slice = function(start, length) {
        var duration = this.duration();
        if (start + length > duration) {
            length = duration - start;
        }

        var new_instance  = new Tape();
        var remainingstart  = start;
        var remaininglength = length;

        for (var i = 0; i < this.fragments.length; i++) {
            var fragment = this.fragments[i];
            var items = fragment.create(remainingstart, remaininglength);
            var new_fragment = items[0];
            remainingstart  = items[1];
            remaininglength = items[2];
            if (new_fragment) {
                new_instance.add_fragment(new_fragment);
            }
            if (remaininglength === 0) {
                break;
            }
        }

        return new_instance;
    };
    Tape.prototype.cut = Tape.prototype.slice;

    Tape.prototype.concat = function(other) {
        var new_instance = new Tape();
        new_instance.add_fragments(this.fragments);
        new_instance.add_fragments(other.fragments);
        return new_instance;
    };

    Tape.prototype.loop = function(count) {
        var i;
        var orig_fragments = [];
        for (i = 0; i < this.fragments.length; i++) {
            orig_fragments.push(this.fragments[i].clone());
        }
        var new_instance = new Tape();
        for (i = 0; i < count; i++ ) {
            new_instance.add_fragments(orig_fragments);
        }
        return new_instance;
    };

    Tape.prototype.times = Tape.prototype.loop;

    Tape.prototype.split = function(count) {
        var splitted_duration = this.duration() / count;
        var results = [];
        for (var i = 0; i < count; i++) {
            results.push(this.slice(i * splitted_duration, splitted_duration));
        }
        return results;
    };

    Tape.prototype.fill = function(filled_duration) {
        var duration = this.duration();
        if (duration === 0) {
            throw "EmptyFragment";
        }
        var loop_count = (filled_duration / duration)|0;
        var remain = filled_duration % duration;

        return this.loop(loop_count).plus(this.slice(0, remain));
    };

    Tape.prototype.replace = function(start, length, replaced) {
        var new_instance = new Tape();
        var offset = start + length;

        new_instance = new_instance.plus(this.slice(0, start));

        var new_instance_duration = new_instance.duration();
        if (new_instance_duration < start) {
            new_instance = new_instance.plus(Scissor.silence(start-new_instance_duration));
        }

        new_instance = new_instance.plus(replaced);

        var duration = this.duration();
        if (duration > offset) {
            new_instance = new_instance.plus(this.slice(offset, duration - offset));
        }

        return new_instance;
    };

    Tape.prototype.reverse = function() {
        var new_instance = new Tape();

        for (var i = this.fragments.length; i--; ) {
            var fragment = this.fragments[i].clone();
            fragment.reverse = !fragment.isReversed();
            new_instance.add_fragment(fragment);
        }

        return new_instance;
    };

    Tape.prototype.pitch = function(pitch, stretch) {
        var new_instance = new Tape();

        stretch = stretch || false;
        for (var i = 0; i < this.fragments.length; i++) {
            var fragment = this.fragments[i].clone();
            fragment.pitch  *= pitch * 0.01;
            fragment.stretch = stretch;
            new_instance.add_fragment(fragment);
        }

        return new_instance;
    };

    Tape.prototype.stretch = function(factor) {
        var factor_for_pitch = 1 / (factor * 0.01) * 100;
        return this.pitch(factor_for_pitch, true);
    };

    Tape.prototype.pan = function(right_percent) {
        var new_instance = new Tape();
        if (right_percent > 100) {
            right_percent = 100;
        } else if (right_percent < 0) {
            right_percent = 0;
        }
        for (var i = 0; i < this.fragments.length; i++) {
            var fragment = this.fragments[i].clone();
            fragment.pan = right_percent;
            new_instance.add_fragment(fragment);
        }

        return new_instance;
    };

    Tape.prototype.silence = function() {
        return Scissor.silence(this.duration());
    };

    Tape.prototype.join = function(tapes) {
        var new_instance = new Tape();

        for (var i = 0; i < tapes.length; i++) {
            if (tapes[i] instanceof Tape) {
                new_instance.add_fragments(tapes[i].fragments);
            }
        }

        return new_instance;
    };

    Tape.prototype.getBuffer = function() {
        var samplerate = 44100;
        if (this.fragments.length > 0) {
            samplerate = this.fragments[0].samplerate;
        }
        var stream = new TapeStream(this, samplerate);
        var total_samples = (this.duration() * samplerate)|0;
        return {
            samplerate: samplerate,
            buffer    : stream.fetch(total_samples)
        };
    };

    function Fragment(soundbuffer, start, duration, reverse, pitch, stretch, pan) {
        if (!soundbuffer) {
            soundbuffer = silencebuffer;
        }
        this.buffer     = soundbuffer.buffer[0];
        this.samplerate = soundbuffer.samplerate || 44100;
        this.start     = start;
        this._duration = duration;
        this.reverse = reverse || false;
        this.pitch   = pitch   || 100;
        this.stretch = stretch || false;
        this.pan     = pan     || 50;
    }

    Fragment.prototype.duration = function() {
        return this._duration * (100 / this.pitch);
    };
    Fragment.prototype.original_duration = function() {
        return this._duration;
    };
    Fragment.prototype.isReversed = function() {
        return this.reverse;
    };
    Fragment.prototype.isStretched = function() {
        return this.stretched;
    };
    Fragment.prototype.create = function(remaining_start, remaining_length) {
        var duration = this.duration();
        if (remaining_start >= duration) {
            return [null, remaining_start - duration, remaining_length];
        }

        var have_remain_to_retuen = (remaining_start + remaining_length) >= duration;

        var new_length;
        if (have_remain_to_retuen) {
            new_length = duration - remaining_start;
            remaining_length -= new_length;
        } else {
            new_length = remaining_length;
            remaining_length = 0;
        }

        var new_fragment = this.clone();
        new_fragment.start     = this.start + remaining_start * this.pitch * 0.01;
        new_fragment._duration = new_length * this.pitch * 0.01;
        new_fragment.reverse   = false;
        return [new_fragment, 0, remaining_length];
    };

    Fragment.prototype.clone = function() {
        var new_instance = new Fragment();
        new_instance.buffer     = this.buffer;
        new_instance.samplerate = this.samplerate;
        new_instance.start     = this.start;
        new_instance._duration = this._duration;
        new_instance.reverse   = this.reverse;
        new_instance.pitch     = this.pitch;
        new_instance.stretch   = this.stretch;
        new_instance.pan       = this.pan;
        return new_instance;
    };
    Scissor.Fragment = Fragment;


    function TapeStream(tape, samplerate) {
        this.tape = tape;
        this.fragments  = tape.fragments;
        this.samplerate = samplerate || 44100;

        this.isEnded = false;
        this.buffer  = null;
        this.bufferIndex = 0;
        this.bufferIndexIncr  = 0;
        this.bufferBeginIndex = 0;
        this.bufferEndIndex   = 0;
        this.fragment      = null;
        this.fragmentIndex = 0;
        this.panL = 0.5;
        this.panR = 0.5;
    }
    Scissor.TapeStream = TapeStream;

    TapeStream.prototype.reset = function() {
        this.isEnded = false;
        this.buffer  = null;
        this.bufferIndex = 0;
        this.bufferIndexIncr  = 0;
        this.bufferBeginIndex = 0;
        this.bufferEndIndex   = 0;
        this.fragment      = null;
        this.fragmentIndex = 0;
        this.panL = 0.5;
        this.panR = 0.5;
        this.isLooped = false;
        return this;
    };

    TapeStream.prototype.fetch = function(n) {
        var cellL = new T.fn.SignalArray(n);
        var cellR = new T.fn.SignalArray(n);
        var fragments     = this.fragments;

        if (fragments.length === 0) {
            return [cellL, cellR];
        }

        var samplerate  = this.samplerate * 100;
        var buffer      = this.buffer;
        var bufferIndex = this.bufferIndex;
        var bufferIndexIncr = this.bufferIndexIncr;
        var bufferBeginIndex = this.bufferBeginIndex;
        var bufferEndIndex   = this.bufferEndIndex;
        var fragment      = this.fragment;
        var fragmentIndex = this.fragmentIndex;
        var pan;
        var panL = this.panL;
        var panR = this.panR;

        for (var i = 0; i < n; i++) {
            while (!buffer ||
                   bufferIndex < bufferBeginIndex || bufferIndex >= bufferEndIndex) {
                if (!fragment || fragmentIndex < fragments.length) {
                    fragment = fragments[fragmentIndex++];
                    buffer   = fragment.buffer;
                    bufferIndexIncr = fragment.samplerate / samplerate * fragment.pitch;
                    bufferBeginIndex = fragment.start * fragment.samplerate;
                    bufferEndIndex   = bufferBeginIndex + fragment.original_duration() * fragment.samplerate;

                    pan = (fragment.pan * 0.01);
                    panL = 1 - pan;
                    panR = pan;

                    if (fragment.reverse) {
                        bufferIndexIncr *= -1;
                        bufferIndex = bufferEndIndex + bufferIndexIncr;
                    } else {
                        bufferIndex = bufferBeginIndex;
                    }
                } else {
                    if (this.isLooped) {
                        buffer  = null;
                        bufferIndex = 0;
                        bufferIndexIncr  = 0;
                        bufferBeginIndex = 0;
                        bufferEndIndex   = 0;
                        fragment      = null;
                        fragmentIndex = 0;
                    } else {
                        this.isEnded = true;
                        buffer   = DummyBuffer;
                        bufferIndexIncr = 0;
                        bufferIndex = 0;
                        break;
                    }
                }
            }
            cellL[i] = buffer[bufferIndex|0] * panL;
            cellR[i] = buffer[bufferIndex|0] * panR;
            bufferIndex += bufferIndexIncr;
        }
        this.buffer      = buffer;
        this.bufferIndex = bufferIndex;
        this.bufferIndexIncr  = bufferIndexIncr;
        this.bufferBeginIndex = bufferBeginIndex;
        this.bufferEndIndex   = bufferEndIndex;
        this.fragment      = fragment;
        this.fragmentIndex = fragmentIndex;
        this.panL = panL;
        this.panR = panR;

        return [cellL, cellR];
    };

    T.modules.Scissor = Scissor;

})(timbre);
(function(T) {
    "use strict";

    function StereoDelay(samplerate) {
        this.samplerate = samplerate;

        var bits = Math.ceil(Math.log(samplerate * 1.5) * Math.LOG2E);

        this.buffersize = 1 << bits;
        this.buffermask = this.buffersize - 1;
        this.writeBufferL = new T.fn.SignalArray(this.buffersize);
        this.writeBufferR = new T.fn.SignalArray(this.buffersize);
        this.readBufferL = this.writeBufferL;
        this.readBufferR = this.writeBufferR;
        this.delaytime = null;
        this.feedback  = null;
        this.cross = null;
        this.mix   = null;
        this.prevL = 0;
        this.prevR = 0;

        this.readIndex  = 0;
        this.writeIndex = 0;

        this.setParams(125, 0.25, false, 0.45);
    }

    var $ = StereoDelay.prototype;

    $.setParams = function(delaytime, feedback, cross ,mix) {
        if (this.delaytime !== delaytime) {
            this.delaytime = delaytime;
            var offset = (delaytime * 0.001 * this.samplerate)|0;
            if (offset > this.buffermask) {
                offset = this.buffermask;
            }
            this.writeIndex = (this.readIndex + offset) & this.buffermask;
        }
        if (this.feedback !== feedback) {
            this.feedback = feedback;
        }
        if (this.cross !== cross) {
            this.cross = cross;
            if (cross) {
                this.readBufferL = this.writeBufferR;
                this.readBufferR = this.writeBufferL;
            } else {
                this.readBufferL = this.writeBufferL;
                this.readBufferR = this.writeBufferR;
            }
        }
        if (this.mix !== mix) {
            this.mix = mix;
        }
    };

    $.process = function(cellL, cellR) {
        var readBufferL = this.readBufferL;
        var readBufferR = this.readBufferR;
        var writeBufferL = this.writeBufferL;
        var writeBufferR = this.writeBufferR;
        var readIndex  = this.readIndex;
        var writeIndex = this.writeIndex;
        var mask = this.buffermask;
        var fb = this.feedback;
        var wet = this.mix, dry = 1 - wet;
        var prevL = this.prevL;
        var prevR = this.prevR;

        var x;
        var i, imax = cellL.length;

        for (i = 0; i < imax; ++i) {
            x = readBufferL[readIndex];
            writeBufferL[writeIndex] = cellL[i] - x * fb;
            cellL[i] = prevL = ((cellL[i] * dry) + (x * wet) + prevL) * 0.5;

            x = readBufferR[readIndex];
            writeBufferR[writeIndex] = cellR[i] - x * fb;
            cellR[i] = prevR = ((cellR[i] * dry) + (x * wet) + prevR) * 0.5;

            readIndex  += 1;
            writeIndex = (writeIndex + 1) & mask;
        }

        this.readIndex  = readIndex  & this.buffermask;
        this.writeIndex = writeIndex;
        this.prevL = prevL;
        this.prevR = prevR;
    };

    T.modules.StereoDelay = StereoDelay;

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var modules = T.modules;

    fn.register("audio", function(_args) {
        var BufferNode = fn.getClass("buffer");
        var instance = new BufferNode(_args);

        instance.playbackState = fn.FINISHED_STATE;
        instance._.isLoaded = false;

        Object.defineProperties(instance, {
            isLoaded: {
                get: function() {
                    return this._.isLoaded;
                }
            }
        });

        instance.load     = load;
        instance.loadthis = loadthis;

        return instance;
    });

    var load = function(src) {
        var self = this, _ = this._;
        var dfd = new modules.Deferred(this);

        var args = arguments, i = 1;

        dfd.done(function() {
            self._.emit("done");
        });

        if (typeof args[i] === "function") {
            dfd.done(args[i++]);
            if (typeof args[i] === "function") {
                dfd.fail(args[i++]);
            }
        }

        _.loadedTime = 0;

        var onloadedmetadata = function(result, msg) {
            var _ = self._;
            if (result) {
                self.playbackState = fn.PLAYING_STATE;
                _.samplerate = result.samplerate;
                _.channels   = result.channels;
                _.bufferMix  = null;
                _.buffer     = result.buffer;
                _.phase      = 0;
                _.phaseIncr  = result.samplerate / T.samplerate;
                _.duration   = result.duration * 1000;
                _.currentTime = 0;
                if (_.isReversed) {
                    _.phaseIncr *= -1;
                    _.phase = result.buffer[0].length + _.phaseIncr;
                }
                self._.emit("loadedmetadata");
            } else {
                dfd.reject(msg);
            }
        };

        var onloadeddata = function() {
            self._.isLoaded  = true;
            self._.plotFlush = true;
            self._.emit("loadeddata");
            dfd.resolveWith(self);
        };

        new modules.Decoder().decode(src, onloadedmetadata, onloadeddata);

        return dfd.promise();
    };

    var loadthis = function() {
        load.apply(this, arguments);
        return this;
    };

})(timbre);
(function(T) {
    "use strict";

    var fn  = T.fn;
    var FFT = T.modules.FFT;
    var Biquad = T.modules.Biquad;
    var PLOT_LOW_FREQ = 20;

    function BiquadNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.biquad = new Biquad(_.samplerate);
        _.freq = T(340);
        _.band = T(1);
        _.gain = T(0);

        _.plotBefore = plotBefore;
        _.plotRange  = [-18, 18];
        _.plotFlush  = true;
    }
    fn.extend(BiquadNode);

    var plotBefore = function(context, x, y, width, height) {
        context.lineWidth = 1;
        context.strokeStyle = "rgb(192, 192, 192)";
        var nyquist = this._.samplerate * 0.5;
        for (var i = 1; i <= 10; ++i) {
            for (var j = 1; j <= 4; j++) {
                var f = i * Math.pow(10, j);
                if (f <= PLOT_LOW_FREQ || nyquist <= f) {
                    continue;
                }
                context.beginPath();
                var _x = (Math.log(f/PLOT_LOW_FREQ)) / (Math.log(nyquist/PLOT_LOW_FREQ));
                _x = ((_x * width + x)|0) + 0.5;
                context.moveTo(_x, y);
                context.lineTo(_x, y + height);
                context.stroke();
            }
        }

        var h = height / 6;
        for (i = 1; i < 6; i++) {
            context.beginPath();
            var _y = ((y + (i * h))|0) + 0.5;
            context.moveTo(x, _y);
            context.lineTo(x + width, _y);
            context.stroke();
        }
    };

    var $ = BiquadNode.prototype;

    Object.defineProperties($, {
        type: {
            set: function(value) {
                var _ = this._;
                if (value !== _.biquad.type) {
                    _.biquad.setType(value);
                    _.plotFlush = true;
                }
            },
            get: function() {
                return this._.biquad.type;
            }
        },
        freq: {
            set: function(value) {
                this._.freq = T(value);
            },
            get: function() {
                return this._.freq;
            }
        },
        cutoff: {
            set: function(value) {
                this._.freq = T(value);
            },
            get: function() {
                return this._.freq;
            }
        },
        res: {
            set: function(value) {
                this._.band = T(value);
            },
            get: function() {
                return this._.band;
            }
        },
        Q: {
            set: function(value) {
                this._.band = T(value);
            },
            get: function() {
                return this._.band;
            }
        },
        band: {
            set: function(value) {
                this._.band = T(value);
            },
            get: function() {
                return this._.band;
            }
        },
        gain: {
            set: function(value) {
                this._.gain = T(value);
            },
            get: function() {
                return this._.gain;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            var freq = _.freq.process(tickID).cells[0][0];
            var band = _.band.process(tickID).cells[0][0];
            var gain = _.gain.process(tickID).cells[0][0];
            if (_.prevFreq !== freq || _.prevband !== band || _.prevGain !== gain) {
                _.prevFreq = freq;
                _.prevband = band;
                _.prevGain = gain;
                _.biquad.setParams(freq, band, gain);
                _.plotFlush = true;
            }

            if (!_.bypassed) {
                _.biquad.process(this.cells[1], this.cells[2]);
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    var fft = new FFT(2048);
    var super_plot = T.Object.prototype.plot;

    $.plot = function(opts) {
        if (this._.plotFlush) {
            var biquad = new Biquad(this._.samplerate);
            biquad.setType(this.type);
            biquad.setParams(this.freq.valueOf(), this.band.valueOf(), this.gain.valueOf());

            var impluse = new Float32Array(fft.length);
            impluse[0] = 1;

            biquad.process(impluse, impluse);
            fft.forward(impluse);

            var size = 512;
            var data = new Float32Array(size);
            var nyquist  = this._.samplerate * 0.5;
            var spectrum = new Float32Array(size);
            var i, j, f, index, delta, x0, x1, xx;

            fft.getFrequencyData(spectrum);
            for (i = 0; i < size; ++i) {
                f = Math.pow(nyquist / PLOT_LOW_FREQ, i / size) * PLOT_LOW_FREQ;
                j = f / (nyquist / spectrum.length);
                index = j|0;
                delta = j - index;
                if (index === 0) {
                    x1 = x0 = xx = spectrum[index];
                } else {
                    x0 = spectrum[index - 1];
                    x1 = spectrum[index];
                    xx = ((1.0 - delta) * x0 + delta * x1);
                }
                data[i] = xx;
            }
            this._.plotData  = data;
            this._.plotFlush = null;
        }
        return super_plot.call(this, opts);
    };

    fn.register("biquad", BiquadNode);
    fn.register("lowpass", function(_args) {
        return new BiquadNode(_args).set("type", "lowpass");
    });
    fn.register("highpass", function(_args) {
        return new BiquadNode(_args).set("type", "highpass");
    });
    fn.register("bandpass", function(_args) {
        return new BiquadNode(_args).set("type", "bandpass");
    });
    fn.register("lowshelf", function(_args) {
        return new BiquadNode(_args).set("type", "lowshelf");
    });
    fn.register("highshelf", function(_args) {
        return new BiquadNode(_args).set("type", "highshelf");
    });
    fn.register("peaking", function(_args) {
        return new BiquadNode(_args).set("type", "peaking");
    });
    fn.register("notch", function(_args) {
        return new BiquadNode(_args).set("type", "notch");
    });
    fn.register("allpass", function(_args) {
        return new BiquadNode(_args).set("type", "allpass");
    });

    fn.alias("lpf", "lowpass");
    fn.alias("hpf", "highpass");
    fn.alias("bpf", "bandpass");
    fn.alias("bef", "notch");
    fn.alias("brf", "notch");
    fn.alias("apf", "allpass");

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var Tape = T.modules.Scissor.Tape;
    var isSignalArray = function(obj) {
        return fn.isSignalArray(obj) || obj instanceof Float32Array;
    };

    function BufferNode(_args) {
        T.Object.call(this, 1, _args);
        fn.fixAR(this);

        var _ = this._;
        _.pitch      = T(1);
        _.samplerate = 44100;
        _.channels   = 0;
        _.bufferMix  = null;
        _.buffer     = [];
        _.isLooped   = false;
        _.isReversed = false;
        _.duration    = 0;
        _.currentTime = 0;
        _.currentTimeObj = null;
        _.phase = 0;
        _.phaseIncr = 0;
        _.onended  = fn.make_onended(this, 0);
        _.onlooped = make_onlooped(this);
    }
    fn.extend(BufferNode);

    var make_onlooped = function(self) {
        return function() {
            var _ = self._;
            if (_.phase >= _.buffer[0].length) {
                _.phase = 0;
            } else if (_.phase < 0) {
                _.phase = _.buffer[0].length + _.phaseIncr;
            }
            self._.emit("looped");
        };
    };

    var $ = BufferNode.prototype;

    var setBuffer = function(value) {
        var _ = this._;
        if (typeof value === "object") {
            var buffer = [], samplerate, channels;

            if (isSignalArray(value)) {
                buffer[0] = value;
                channels = 1;
            } else if (typeof value === "object") {
                if (value instanceof T.Object) {
                    value = value.buffer;
                } else if (value instanceof Tape) {
                    value = value.getBuffer();
                }
                if (Array.isArray(value.buffer)) {
                    if (isSignalArray(value.buffer[0])) {
                        if (isSignalArray(value.buffer[1]) &&
                            isSignalArray(value.buffer[2])) {
                            channels = 2;
                            buffer = value.buffer;
                        } else {
                            channels = 1;
                            buffer = [value.buffer[0]];
                        }
                    }
                } else if (isSignalArray(value.buffer)) {
                    channels = 1;
                    buffer = [value.buffer];
                }
                if (typeof value.samplerate === "number") {
                    samplerate = value.samplerate;
                }
            }
            if (buffer.length) {
                if (samplerate > 0) {
                    _.samplerate = value.samplerate;
                }
                _.bufferMix = null;
                _.buffer  = buffer;
                _.phase     = 0;
                _.phaseIncr = _.samplerate / T.samplerate;
                _.duration  = _.buffer[0].length * 1000 / _.samplerate;
                _.currentTime = 0;
                _.plotFlush = true;
                this.reverse(_.isReversed);
            }
        }
    };

    Object.defineProperties($, {
        buffer: {
            set: setBuffer,
            get: function() {
                var _ = this._;
                return {
                    samplerate: _.samplerate,
                    channels  : _.channels,
                    buffer    : _.buffer
                };
            }
        },
        pitch: {
            set: function(value) {
                this._.pitch = T(value);
            },
            get: function() {
                return this._.pitch;
            }
        },
        isLooped: {
            get: function() {
                return this._.isLooped;
            }
        },
        isReversed: {
            get: function() {
                return this._.isReversed;
            }
        },
        samplerate: {
            get: function() {
                return this._.samplerate;
            }
        },
        duration: {
            get: function() {
                return this._.duration;
            }
        },
        currentTime: {
            set: function(value) {
                if (typeof value === "number") {
                    var _ = this._;
                    if (0 <= value && value <= _.duration) {
                        _.phase = (value / 1000) * _.samplerate;
                        _.currentTime = value;
                    }
                } else if (value instanceof T.Object) {
                    this._.currentTimeObj = value;
                } else if (value === null) {
                    this._.currentTimeObj = null;
                }
            },
            get: function() {
                if (this._.currentTimeObj) {
                    return this._.currentTimeObj;
                } else {
                    return this._.currentTime;
                }
            }
        }
    });

    $.clone = function() {
        var _ = this._;
        var instance = fn.clone(this);

        if (_.buffer.length) {
            setBuffer.call(instance, {
                buffer    : _.buffer,
                samplerate: _.samplerate,
                channels  : _.channels
            });
        }
        instance.loop(_.isLooped);
        instance.reverse(_.isReversed);

        return instance;
    };

    $.slice = function(begin, end) {
        var _ = this._;
        var instance = T(_.originkey);
        var isReversed = _.isReversed;

        if (_.buffer.length) {
            if (typeof begin === "number" ){
                begin = (begin * 0.001 * _.samplerate)|0;
            } else {
                begin = 0;
            }
            if (typeof end === "number") {
                end   = (end   * 0.001 * _.samplerate)|0;
            } else {
                end = _.buffer[0].length;
            }
            if (begin > end) {
                var tmp = begin;
                begin = end;
                end   = tmp;
                isReversed = !isReversed;
            }

            if (_.channels === 2) {
                setBuffer.call(instance, {
                    buffer   : [ fn.pointer(_.buffer[0], begin, end-begin),
                                 fn.pointer(_.buffer[1], begin, end-begin),
                                 fn.pointer(_.buffer[2], begin, end-begin) ],
                    samplerate: _.samplerate
                });
            } else {
                setBuffer.call(instance, {
                    buffer: fn.pointer(_.buffer[0], begin, end-begin),
                    samplerate: _.samplerate
                });
            }
            instance.playbackState = fn.PLAYING_STATE;
        }
        instance.loop(_.isLooped);
        instance.reverse(_.isReversed);

        return instance;
    };

    $.reverse = function(value) {
        var _ = this._;

        _.isReversed = !!value;
        if (_.isReversed) {
            if (_.phaseIncr > 0) {
                _.phaseIncr *= -1;
            }
            if (_.phase === 0 && _.buffer.length) {
                _.phase = _.buffer[0].length + _.phaseIncr;
            }
        } else {
            if (_.phaseIncr < 0) {
                _.phaseIncr *= -1;
            }
        }

        return this;
    };

    $.loop = function(value) {
        this._.isLooped = !!value;
        return this;
    };

    $.bang = function(value) {
        this.playbackState = (value === false ? fn.FINISHED_STATE : fn.PLAYING_STATE);
        this._.phase = 0;
        this._.emit("bang");
        return this;
    };

    $.process = function(tickID) {
        var _ = this._;

        if (!_.buffer.length) {
            return this;
        }

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var cellL = this.cells[1];
            var cellR = this.cells[2];
            var phase  = _.phase;
            var i, imax = _.cellsize;

            var bufferL, bufferR;
            if (_.channels === 2) {
                bufferL = _.buffer[1];
                bufferR = _.buffer[2];
            } else {
                bufferL = bufferR = _.buffer[0];
            }

            if (_.currentTimeObj) {
                var pos = _.currentTimeObj.process(tickID).cells[0];
                var t, sr = _.samplerate * 0.001;
                for (i = 0; i < imax; ++i) {
                    t = pos[i];
                    phase = t * sr;
                    cellL[i] = (bufferL[phase|0] || 0);
                    cellR[i] = (bufferR[phase|0] || 0);
                }
                _.phase = phase;
                _.currentTime = t;
            } else {
                var pitch  = _.pitch.process(tickID).cells[0][0];
                var phaseIncr = _.phaseIncr * pitch;

                for (i = 0; i < imax; ++i) {
                    cellL[i] = (bufferL[phase|0] || 0);
                    cellR[i] = (bufferR[phase|0] || 0);
                    phase += phaseIncr;
                }

                if (phase >= bufferL.length) {
                    if (_.isLooped) {
                        fn.nextTick(_.onlooped);
                    } else {
                        fn.nextTick(_.onended);
                    }
                } else if (phase < 0) {
                    if (_.isLooped) {
                        fn.nextTick(_.onlooped);
                    } else {
                        fn.nextTick(_.onended);
                    }
                }
                _.phase = phase;
                _.currentTime += fn.currentTimeIncr;
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    var super_plot = T.Object.prototype.plot;

    $.plot = function(opts) {
        var _ = this._;
        var bufferL, bufferR;
        if (_.plotFlush) {
            if (_.channels === 2) {
                bufferL = _.buffer[1];
                bufferR = _.buffer[2];
            } else {
                bufferL = bufferR = _.buffer[0];
            }
            var data = new Float32Array(2048);
            var x = 0, xIncr = bufferL.length / 2048;
            for (var i = 0; i < 2048; i++) {
                data[i] = (bufferL[x|0] + bufferR[x|0]) * 0.5;
                x += xIncr;
            }
            _.plotData  = data;
            _.plotFlush = null;
        }
        return super_plot.call(this, opts);
    };

    fn.register("buffer", BufferNode);

})(timbre);
(function(T) {
    "use strict";

    var fn  = T.fn;
    var Chorus = T.modules.Chorus;

    function ChorusNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var chorus = new Chorus(this._.samplerate);
        chorus.setDelayTime(20);
        chorus.setRate(4);
        chorus.depth = 20;
        chorus.feedback = 0.2;
        chorus.mix = 0.33;
        this._.chorus = chorus;
    }
    fn.extend(ChorusNode);

    var $ = ChorusNode.prototype;

    Object.defineProperties($, {
        type: {
            set: function(value) {
                this._.chorus.setDelayTime(value);
            },
            get: function() {
                return this._.chorus.wave;
            }
        },
        delay: {
            set: function(value) {
                if (0.5 <= value && value <= 80) {
                    this._.chorus.setDelayTime(value);
                }
            },
            get: function() {
                return this._.chorus.delayTime;
            }
        },
        rate: {
            set: function(value) {
                if (typeof value === "number" && value > 0) {
                    this._.chorus.setRate(value);
                }
            },
            get: function() {
                return this._.chorus.rate;
            }
        },
        depth: {
            set: function(value) {
                if (typeof value === "number") {
                    if (0 <= value && value <= 100) {
                        value *= this._.samplerate / 44100;
                        this._.chorus.depth = value;
                    }
                }
            },
            get: function() {
                return this._.chorus.depth;
            }
        },
        fb: {
            set: function(value) {
                if (typeof value === "number") {
                    if (-1 <= value && value <= 1) {
                        this._.chorus.feedback = value * 0.99996;
                    }
                }
            },
            get: function() {
                return this._.chorus.feedback;
            }
        },
        mix: {
            set: function(value) {
                this._.mix = T(value);
            },
            get: function() {
                return this._.mix;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            if (!_.bypassed) {
                _.chorus.process(this.cells[1], this.cells[2]);
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("chorus", ChorusNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function ClipNode(_args) {
        T.Object.call(this, 2, _args);

        var _ = this._;
        _.min = -0.8;
        _.max = +0.8;
    }
    fn.extend(ClipNode);

    var $ = ClipNode.prototype;

    Object.defineProperties($, {
        minmax: {
            set: function(value) {
                var _ = this._;
                if (typeof value === "number") {
                    _.min = -Math.abs(value);
                    _.max = -_.min;
                }
            },
            get: function() {
                return this._.max;
            }
        },
        min: {
            set: function(value) {
                var _ = this._;
                if (typeof value === "number") {
                    if (_.max < value) {
                        _.max = value;
                    } else {
                        _.min = value;
                    }
                }
            },
            get: function() {
                return this._.min;
            }
        },
        max: {
            set: function(value) {
                var _ = this._;
                if (typeof value === "number") {
                    if (value < _.min) {
                        _.min = value;
                    } else {
                        _.max = value;
                    }
                }
            },
            get: function() {
                return this._.max;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var cellL = this.cells[1];
            var cellR = this.cells[2];
            var i, imax = cellL.length;
            var min = _.min, max = _.max;
            var value;

            if (_.ar) {
                fn.inputSignalAR(this);
                for (i = 0; i < imax; ++i) {
                    value = cellL[i];
                    if (value < min) {
                        value = min;
                    } else if (value > max) {
                        value = max;
                    }
                    cellL[i] = value;
                    value = cellR[i];
                    if (value < min) {
                        value = min;
                    } else if (value > max) {
                        value = max;
                    }
                    cellR[i] = value;
                }
                fn.outputSignalAR(this);
            } else {
                value = fn.inputSignalKR(this);
                if (value < min) {
                    value = min;
                } else if (value > max) {
                    value = max;
                }
                this.cells[0][0] = value;
                fn.outputSignalKR(this);
            }
        }
        return this;
    };

    fn.register("clip", ClipNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;
    var Compressor = T.modules.Compressor;

    function CompressorNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.prevThresh = -24;
        _.prevKnee   =  30;
        _.prevRatio  =  12;
        _.thresh = T(_.prevThresh);
        _.knee   = T(_.prevKnee);
        _.ratio  = T(_.prevRatio);
        _.postGain  = 6;
        _.reduction = 0;
        _.attack = 3;
        _.release = 25;

        _.comp = new Compressor(_.samplerate);
        _.comp.dbPostGain = _.postGain;
        _.comp.setAttackTime(_.attack * 0.001);
        _.comp.setReleaseTime(_.release * 0.001);
        _.comp.setPreDelayTime(6);
        _.comp.setParams(_.prevThresh, _.prevKnee, _.prevRatio);
    }
    fn.extend(CompressorNode);

    var $ = CompressorNode.prototype;

    Object.defineProperties($, {
        thresh: {
            set: function(value) {
                this._.thresh = T(value);
            },
            get: function() {
                return this._.thresh;
            }
        },
        thre: {
            set: function(value) {
                this._.thresh = T(value);
            },
            get: function() {
                return this._.thre;
            }
        },
        knee: {
            set: function(value) {
                this._.kne = T(value);
            },
            get: function() {
                return this._.knee;
            }
        },
        ratio: {
            set: function(value) {
                this._.ratio = T(value);
            },
            get: function() {
                return this._.ratio;
            }
        },
        gain: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.comp.dbPostGain = value;
                }
            },
            get: function() {
                return this._.comp.dbPostGain;
            }
        },
        attack: {
            set: function(value) {
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                if (typeof value === "number") {
                    value = (value < 0) ? 0 : (1000 < value) ? 1000 : value;
                    this._.attack = value;
                    this._.comp.setAttackTime(value * 0.001);
                }
            },
            get: function() {
                return this._.attack;
            }
        },
        release: {
            set: function(value) {
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                if (typeof value === "number") {
                    value = (value < 0) ? 0 : (1000 < value) ? 1000 : value;
                    this._.release = value;
                    this._.comp.setReleaseTime(value * 0.001);
                }
            },
            get: function() {
                return this._.release;
            }
        },
        reduction: {
            get: function() {
                return this._.reduction;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            var thresh = _.thresh.process(tickID).cells[0][0];
            var knee   = _.knee.process(tickID).cells[0][0];
            var ratio  = _.ratio.process(tickID).cells[0][0];
            if (_.prevThresh !== thresh || _.prevKnee !== knee || _.prevRatio !== ratio) {
                _.prevThresh = thresh;
                _.prevKnee   = knee;
                _.prevRatio  = ratio;
                _.comp.setParams(thresh, knee, ratio);
            }

            if (!_.bypassed) {
                _.comp.process(this.cells[1], this.cells[2]);
                _.reduction = _.comp.meteringGain;
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("comp", CompressorNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;
    var StereoDelay = T.modules.StereoDelay;

    function DelayNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.time  = T(100);
        _.fb    = T(0.2);
        _.cross = T(false);
        _.mix   = 0.33;

        _.delay = new StereoDelay(_.samplerate);
    }
    fn.extend(DelayNode);

    var $ = DelayNode.prototype;

    Object.defineProperties($, {
        time: {
            set: function(value) {
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                this._.time = T(value);
            },
            get: function() {
                return this._.time;
            }
        },
        fb: {
            set: function(value) {
                this._.fb = T(value);
            },
            get: function() {
                return this._.fb;
            }
        },
        cross: {
            set: function(value) {
                this._.cross = T(value);
            },
            get: function() {
                return this._.cross;
            }
        },
        mix: {
            set: function(value) {
                if (typeof value === "number") {
                    value = (value > 1) ? 1 : (value < 0) ? 0 : value;
                    this._.mix = value;
                }
            },
            get: function() {
                return this._.mix;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var time  = _.time.process(tickID).cells[0][0];
            var fb    = _.fb.process(tickID).cells[0][0];
            var cross = _.cross.process(tickID).cells[0][0] !== 0;
            var mix   = _.mix;

            if (_.prevTime !== time || _.prevFb !== fb || _.prevCross !== cross || _.prevMix !== mix) {
                _.prevTime  = time;
                _.prevFb    = fb;
                _.prevCross = cross;
                _.prevMix   = mix;
                _.delay.setParams(time, fb, cross, mix);
            }

            fn.inputSignalAR(this);

            if (!_.bypassed) {
                _.delay.process(this.cells[1], this.cells[2]);
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("delay", DelayNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function DistNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.pre  = T( 60);
        _.post = T(-18);
        _.x1L = _.x2L = _.y1L = _.y2L = 0;
        _.x1R = _.x2R = _.y1R = _.y2R = 0;
        _.b0 = _.b1 = _.b2 = _.a1 = _.a2 = 0;
        _.cutoff = 0;
        _.Q = 1;
        _.preScale = 0;
        _.postScale = 0;
    }
    fn.extend(DistNode);

    var $ = DistNode.prototype;

    Object.defineProperties($, {
        cutoff: {
            set: function(value) {
                if (typeof value === "number" && value > 0) {
                    this._.cutoff = value;
                }
            },
            get: function() {
                return this._.cutoff;
            }
        },
        pre: {
            set: function(value) {
                this._.pre = T(value);
            },
            get: function() {
                return this._.pre;
            }
        },
        post: {
            set: function(value) {
                this._.post = T(value);
            },
            get: function() {
                return this._.post;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            var preGain  = -_.pre.process(tickID).cells[0][0];
            var postGain = -_.post.process(tickID).cells[0][0];

            if (_.prevPreGain !== preGain || _.prevPostGain !== postGain) {
                _.prevPreGain  = preGain;
                _.prevPostGain = postGain;
                _.preScale  = Math.pow(10, -preGain  * 0.05);
                _.postScale = Math.pow(10, -postGain * 0.05);
            }

            if (!_.bypassed) {
                var cellL = this.cells[1];
                var cellR = this.cells[2];
                var preScale  = _.preScale;
                var postScale = _.postScale;
                var i, imax, value, x0, y0;

                if (_.cutoff) {
                    if (_.prevCutoff !== _.cutoff) {
                        _.prevCutoff = _.cutoff;
                        lowpass_params(_);
                    }

                    var x1L = _.x1L, x2L = _.x2L, y1L = _.y1L, y2L = _.y2L;
                    var x1R = _.x1R, x2R = _.x2R, y1R = _.y1R, y2R = _.y2R;
                    var b0 = _.b0, b1 = _.b1, b2 = _.b2, a1 = _.a1, a2 = _.a2;

                    for (i = 0, imax = cellL.length; i < imax; ++i) {
                        x0 = cellL[i] * preScale;
                        y0 = b0 * x0 + b1 * x1L + b2 * x2L - a1 * y1L - a2 * y2L;
                        value = y0 * postScale;
                        if (value < -1) {
                            value = -1;
                        } else if (value > 1) {
                            value = 1;
                        }
                        cellL[i] = value;
                        x2L = x1L; x1L = x0; y2L = y1L; y1L = y0;

                        x0 = cellR[i] * preScale;
                        y0 = b0 * x0 + b1 * x1R + b2 * x2R - a1 * y1R - a2 * y2R;
                        value = y0 * postScale;
                        if (value < -1) {
                            value = -1;
                        } else if (value > 1) {
                            value = 1;
                        }
                        cellR[i] = value;
                        x2R = x1R; x1R = x0; y2R = y1R; y1R = y0;
                    }

                    _.x1L = x1L; _.x2L = x2L; _.y1L = y1L; _.y2L = y2L;
                    _.x1R = x1R; _.x2R = x2R; _.y1R = y1R; _.y2R = y2R;
                } else {
                    for (i = 0, imax = cellL.length; i < imax; ++i) {
                        value = cellL[i] * preScale * postScale;
                        if (value < -1) {
                            value = -1;
                        } else if (value > 1) {
                            value = 1;
                        }
                        cellL[i] = value;

                        value = cellR[i] * preScale * postScale;
                        if (value < -1) {
                            value = -1;
                        } else if (value > 1) {
                            value = 1;
                        }
                        cellR[i] = value;
                    }
                }
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    var lowpass_params = function(_) {
        var w0 = 2 * Math.PI * _.cutoff / _.samplerate;
        var cos = Math.cos(w0);
        var sin = Math.sin(w0);
        var alpha = sin / (2 * _.Q);

        var ia0 = 1 / (1 + alpha);
        _.b0 =  (1 - cos) * 0.5 * ia0;
        _.b1 =   1 - cos * ia0;
        _.b2 =  (1 - cos) * 0.5 * ia0;
        _.a1 =  -2 * cos * ia0;
        _.a2 =   1 - alpha * ia0;
    };

    fn.register("dist", DistNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function DivNode(_args) {
        T.Object.call(this, 2, _args);
        this._.ar = false;
    }
    fn.extend(DivNode);

    var $ = DivNode.prototype;

    $.process = function(tickID) {
            var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var nodes = this.nodes;
            var cell  = this.cells[0];
            var cellL = this.cells[1];
            var cellR = this.cells[2];
            var i, imax = nodes.length;
            var j, jmax = cell.length;
            var tmp, tmpL, tmpR, div;

            if (_.ar) {
                if (nodes.length > 0) {
                    nodes[0].process(tickID);
                    tmpL = nodes[0].cells[1];
                    tmpR = nodes[0].cells[2];
                    cellL.set(tmpL);
                    cellR.set(tmpR);
                    for (i = 1; i < imax; ++i) {
                        nodes[i].process(tickID);
                        tmpL = nodes[i].cells[1];
                        tmpR = nodes[i].cells[2];
                        for (j = 0; j < jmax; ++j) {
                            div = tmpL[j];
                            cellL[j] = (div === 0) ? 0 : cellL[j] / div;
                            div = tmpR[j];
                            cellR[j] = (div === 0) ? 0 : cellR[j] / div;
                        }
                    }
                } else {
                    for (j = 0; j < jmax; ++j) {
                        cellL[j] = cellR[i] = 0;
                    }
                }
                fn.outputSignalAR(this);
            } else {
                if (nodes.length > 0) {
                    tmp = nodes[0].process(tickID).cells[0][0];
                    for (i = 1; i < imax; ++i) {
                        div = nodes[i].process(tickID).cells[0][0];
                        tmp = (div === 0) ? 0 : tmp / div;
                    }
                } else {
                    tmp = 0;
                }
                cell[0] = tmp;
                fn.outputSignalKR(this);
            }
        }

        return this;
    };

    fn.register("/", DivNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;
    var Envelope  = T.modules.Envelope;
    var isDictionary = fn.isDictionary;

    function EnvNode(_args) {
        T.Object.call(this, 2, _args);
        var _ = this._;
        _.env = new Envelope(_.samplerate);
        _.env.setStep(_.cellsize);
        _.tmp = new fn.SignalArray(_.cellsize);
        _.ar = false;
        _.plotFlush = true;
        _.onended = make_onended(this);
        this.on("ar", onar);
    }
    fn.extend(EnvNode);

    var onar = function(value) {
        this._.env.setStep((value) ? 1 : this._.cellsize);
    };

    var make_onended = function(self) {
        return function() {
            self._.emit("ended");
        };
    };

    var $ = EnvNode.prototype;

    Object.defineProperties($, {
        table: {
            set: function(value) {
                if (Array.isArray(value)) {
                    setTable.call(this, value);
                    this._.plotFlush = true;
                }
            },
            get: function() {
                return this._.env.table;
            }
        },
        curve: {
            set: function(value) {
                this._.env.setCurve(value);
            },
            get: function() {
                return this._.env.curve;
            }
        },
        releaseNode: {
            set: function(value) {
                this._.env.setReleaseNode(value);
                this._.plotFlush = true;
            },
            get: function() {
                return this._.env.releaseNode + 1;
            }
        },
        loopNode: {
            set: function(value) {
                this._.env.setLoopNode(value);
                this._.plotFlush = true;
            },
            get: function() {
                return this._.env.loopNode + 1;
            }
        }
    });

    $.clone = function() {
        var instance = fn.clone(this);
        instance._.env = this._.env.clone();
        return instance;
    };

    $.reset = function() {
        this._.env.reset();
        return this;
    };

    $.release = function() {
        var _ = this._;
        _.env.release();
        _.emit("released");
        return this;
    };

    $.bang = function() {
        var _ = this._;
        _.env.reset();
        _.env.status = Envelope.StatusGate;
        _.emit("bang");
        return this;
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var cellL = this.cells[1];
            var cellR = this.cells[2];
            var i, imax = _.cellsize;

            if (this.nodes.length) {
                fn.inputSignalAR(this);
            } else {
                for (i = 0; i < imax; ++i) {
                    cellL[i] = cellR[i] = 1;
                }
            }

            var value, emit = null;
            if (_.ar) {
                var tmp = _.tmp;
                _.env.process(tmp);
                for (i = 0; i < imax; ++i) {
                    cellL[i] *= tmp[i];
                    cellR[i] *= tmp[i];
                }
                emit = _.env.emit;
            } else {
                value = _.env.next();
                for (i = 0; i < imax; ++i) {
                    cellL[i] *= value;
                    cellR[i] *= value;
                }
                emit = _.env.emit;
            }

            fn.outputSignalAR(this);

            if (emit) {
                if (emit === "ended") {
                    fn.nextTick(_.onended);
                } else {
                    this._.emit(emit, _.value);
                }
            }
        }

        return this;
    };

    var setTable = function(list) {
        var env = this._.env;

        var table = [list[0] || ZERO];

        var value, time, curveType, curveValue;
        for (var i = 1, imax = list.length; i < imax; ++i) {
            value = list[i][0] || ZERO;
            time  = list[i][1];
            curveType = list[i][2];

            if (typeof time !== "number") {
                if (typeof time === "string") {
                    time = timevalue(time);
                } else {
                    time = 10;
                }
            }
            if (time < 10) {
                time = 10;
            }

            if (typeof curveType === "number") {
                curveValue = curveType;
                curveType  = Envelope.CurveTypeCurve;
            } else {
                curveType  = Envelope.CurveTypeDict[curveType] || null;
                curveValue = 0;
            }
            table.push([value, time, curveType, curveValue]);
        }

        env.setTable(table);
    };

    var super_plot = T.Object.prototype.plot;

    $.plot = function(opts) {
        if (this._.plotFlush) {
            var env = this._.env.clone();
            var info = env.getInfo(1000);

            var totalDuration    = info.totalDuration;
            var loopBeginTime    = info.loopBeginTime;
            var releaseBeginTime = info.releaseBeginTime;
            var data = new Float32Array(256);
            var duration = 0;
            var durationIncr = totalDuration / data.length;
            var isReleased   = false;
            var samples = (totalDuration * 0.001 * this._.samplerate)|0;
            var i, imax;

            samples /= data.length;
            env.setStep(samples);
            env.status = Envelope.StatusGate;
            for (i = 0, imax = data.length; i < imax; ++i) {
                data[i] = env.next();
                duration += durationIncr;
                if (!isReleased && duration >= releaseBeginTime) {
                    env.release();
                    isReleased = true;
                }
            }
            this._.plotData = data;

            this._.plotBefore = function(context, x, y, width, height) {
                var x1, w;
                if (loopBeginTime !== Infinity && releaseBeginTime !== Infinity) {
                    x1 = x + (width * (loopBeginTime    / totalDuration));
                    w  = x + (width * (releaseBeginTime / totalDuration));
                    w  = w - x1;
                    context.fillStyle = "rgba(224, 224, 224, 0.8)";
                    context.fillRect(x1, 0, w, height);
                }
                if (releaseBeginTime !== Infinity) {
                    x1 = x + (width * (releaseBeginTime / totalDuration));
                    w  = width - x1;
                    context.fillStyle = "rgba(212, 212, 212, 0.8)";
                    context.fillRect(x1, 0, w, height);
                }
            };

            // y-range
            var minValue = Infinity, maxValue = -Infinity;
            for (i = 0; i < imax; ++i) {
                if (data[i] < minValue) {
                    minValue = data[i];
                } else if (data[i] > maxValue) {
                    maxValue = data[i];
                }
            }
            if (maxValue < 1) {
                maxValue = 1;
            }
            this._.plotRange = [minValue, maxValue];

            this._.plotData  = data;
            this._.plotFlush = null;
        }
        return super_plot.call(this, opts);
    };
    fn.register("env", EnvNode);


    function envValue(opts, min, def, name1, name2, func) {
        var x = def;
        if (typeof opts[name1] === "number") {
            x = opts[name1];
        } else if (typeof opts[name2] === "number") {
            x = opts[name2];
        } else if (func) {
            if (typeof opts[name1] === "string") {
                x = func(opts[name1]);
            } else if (typeof opts[name2] === "string") {
                x = func(opts[name2]);
            }
        }
        if (x < min) {
            x = min;
        }
        return x;
    }

    var ZERO = Envelope.ZERO;

    fn.register("perc", function(_args) {
        if (!isDictionary(_args[0])) {
            _args.unshift({});
        }

        var opts = _args[0];
        var a  = envValue(opts,   10,   10, "a" , "attackTime" , timevalue);
        var r  = envValue(opts,   10, 1000, "r" , "releaseTime", timevalue);
        var lv = envValue(opts, ZERO,    1, "lv", "level"     );

        opts.table = [ZERO, [lv, a], [ZERO, r]];

        return new EnvNode(_args);
    });

    fn.register("adsr", function(_args) {
        if (!isDictionary(_args[0])) {
            _args.unshift({});
        }

        var opts = _args[0];
        var a  = envValue(opts,   10,   10, "a" , "attackTime"  , timevalue);
        var d  = envValue(opts,   10,  300, "d" , "decayTime"   , timevalue);
        var s  = envValue(opts, ZERO,  0.5, "s" , "sustainLevel");
        var r  = envValue(opts,   10, 1000, "r" , "decayTime"   , timevalue);
        var lv = envValue(opts, ZERO,    1, "lv", "level"       );

        opts.table = [ZERO, [lv, a], [s, d], [ZERO, r]];
        opts.releaseNode = 3;

        return new EnvNode(_args);
    });

    fn.register("adshr", function(_args) {
        if (!isDictionary(_args[0])) {
            _args.unshift({});
        }

        var opts = _args[0];
        var a  = envValue(opts,   10,   10, "a" , "attackTime"  , timevalue);
        var d  = envValue(opts,   10,  300, "d" , "decayTime"   , timevalue);
        var s  = envValue(opts, ZERO,  0.5, "s" , "sustainLevel");
        var h  = envValue(opts,   10,  500, "h" , "holdTime"    , timevalue);
        var r  = envValue(opts,   10, 1000, "r" , "decayTime"   , timevalue);
        var lv = envValue(opts, ZERO,    1, "lv", "level"       );

        opts.table = [ZERO, [lv, a], [s, d], [s, h], [ZERO, r]];

        return new EnvNode(_args);
    });

    fn.register("asr", function(_args) {
        if (!isDictionary(_args[0])) {
            _args.unshift({});
        }

        var opts = _args[0];
        var a  = envValue(opts,   10,   10, "a" , "attackTime"  , timevalue);
        var s  = envValue(opts, ZERO,  0.5, "s" , "sustainLevel");
        var r  = envValue(opts,   10, 1000, "r" , "releaseTime" , timevalue);

        opts.table = [ZERO, [s, a], [ZERO, r]];
        opts.releaseNode = 2;

        return new EnvNode(_args);
    });

    fn.register("dadsr", function(_args) {
        if (!isDictionary(_args[0])) {
            _args.unshift({});
        }

        var opts = _args[0];
        var dl = envValue(opts,   10,  100, "dl", "delayTime"   , timevalue);
        var a  = envValue(opts,   10,   10, "a" , "attackTime"  , timevalue);
        var d  = envValue(opts,   10,  300, "d" , "decayTime"   , timevalue);
        var s  = envValue(opts, ZERO,  0.5, "s" , "sustainLevel");
        var r  = envValue(opts,   10, 1000, "r" , "relaseTime"  , timevalue);
        var lv = envValue(opts, ZERO,    1, "lv", "level"       );

        opts.table = [ZERO, [ZERO, dl], [lv, a], [s, d], [ZERO, r]];
        opts.releaseNode = 4;

        return new EnvNode(_args);
    });

    fn.register("ahdsfr", function(_args) {
        if (!isDictionary(_args[0])) {
            _args.unshift({});
        }

        var opts = _args[0];
        var a  = envValue(opts,   10,   10, "a" , "attackTime"  , timevalue);
        var h  = envValue(opts,   10,   10, "h" , "holdTime"    , timevalue);
        var d  = envValue(opts,   10,  300, "d" , "decayTime"   , timevalue);
        var s  = envValue(opts, ZERO,  0.5, "s" , "sustainLevel");
        var f  = envValue(opts,   10, 5000, "f" , "fadeTime"    , timevalue);
        var r  = envValue(opts,   10, 1000, "r" , "relaseTime"  , timevalue);
        var lv = envValue(opts, ZERO,    1, "lv", "level"       );

        opts.table = [ZERO, [lv, a], [lv, h], [s, d], [ZERO, f], [ZERO, r]];
        opts.releaseNode = 5;

        return new EnvNode(_args);
    });

    fn.register("linen", function(_args) {
        if (!isDictionary(_args[0])) {
            _args.unshift({});
        }

        var opts = _args[0];
        var a  = envValue(opts,   10,   10, "a" , "attackTime" , timevalue);
        var s  = envValue(opts,   10, 1000, "s" , "sustainTime", timevalue);
        var r  = envValue(opts,   10, 1000, "r" , "releaseTime", timevalue);
        var lv = envValue(opts, ZERO,    1, "lv", "level"      );

        opts.table = [ZERO, [lv, a], [lv, s], [ZERO, r]];

        return new EnvNode(_args);
    });

    fn.register("env.tri", function(_args) {
        if (!isDictionary(_args[0])) {
            _args.unshift({});
        }

        var opts = _args[0];
        var dur = envValue(opts,   20, 1000, "dur", "duration", timevalue);
        var lv  = envValue(opts, ZERO,    1, "lv" , "level"   );

        dur *= 0.5;
        opts.table = [ZERO, [lv, dur], [ZERO, dur]];

        return new EnvNode(_args);
    });

    fn.register("env.cutoff", function(_args) {
        if (!isDictionary(_args[0])) {
            _args.unshift({});
        }

        var opts = _args[0];
        var r  = envValue(opts,   10, 100, "r" , "relaseTime", timevalue);
        var lv = envValue(opts, ZERO,   1, "lv", "level"    );

        opts.table = [lv, [ZERO, r]];

        return new EnvNode(_args);
    });

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var FFT = T.modules.FFT;
    var Biquad = T.modules.Biquad;
    var PLOT_LOW_FREQ = 20;
    var PARAM_NAMES = {
        hpf:0, lf:1, lmf:2, mf:3, hmf:4, hf:5, lpf:6
    };

    function EQNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.biquads = new Array(7);

        _.plotBefore = plotBefore;
        _.plotRange  = [-18, 18];
        _.plotFlush  = true;
    }
    fn.extend(EQNode);

    var plotBefore = function(context, x, y, width, height) {
        context.lineWidth = 1;
        context.strokeStyle = "rgb(192, 192, 192)";
        var nyquist = this._.samplerate * 0.5;
        for (var i = 1; i <= 10; ++i) {
            for (var j = 1; j <= 4; j++) {
                var f = i * Math.pow(10, j);
                if (f <= PLOT_LOW_FREQ || nyquist <= f) {
                    continue;
                }
                context.beginPath();
                var _x = (Math.log(f/PLOT_LOW_FREQ)) / (Math.log(nyquist/PLOT_LOW_FREQ));
                _x = ((_x * width + x)|0) + 0.5;
                context.moveTo(_x, y);
                context.lineTo(_x, y + height);
                context.stroke();
            }
        }

        var h = height / 6;
        for (i = 1; i < 6; i++) {
            context.beginPath();
            var _y = ((y + (i * h))|0) + 0.5;
            context.moveTo(x, _y);
            context.lineTo(x + width, _y);
            context.stroke();
        }
    };

    var $ = EQNode.prototype;

    Object.defineProperties($, {
        params: {
            set: function(value) {
                if (typeof value === "object") {
                    var keys = Object.keys(value);
                    for (var i = 0, imax = keys.length; i < imax; ++i) {
                        var items = value[keys[i]];
                        if (Array.isArray(items)) {
                            this.setParams(keys[i], items[0], items[1], items[2]);
                        } else {
                            this.setParams(keys[i]);
                        }
                    }
                }
            }
        }
    });

    $.setParams = function(index, freq, Q, gain) {
        var _ = this._;
        if (typeof index === "string") {
            index = PARAM_NAMES[index];
        }
        if (0 <= index && index < _.biquads.length) {
            index |= 0;
            if (typeof freq === "number" && typeof Q === "number") {
                if (typeof gain !== "number") {
                    gain = 0;
                }
                var biquad = _.biquads[index];
                if (!biquad) {
                    biquad = _.biquads[index] = new Biquad(_.samplerate);
                    switch (index) {
                    case 0:
                        biquad.setType("highpass");
                        break;
                    case _.biquads.length - 1:
                        biquad.setType("lowpass");
                        break;
                    default:
                        biquad.setType("peaking");
                        break;
                    }
                }
                biquad.setParams(freq, Q, gain);
            } else {
                _.biquads[index] = undefined;
            }
            _.plotFlush = true;
        }
        return this;
    };

    $.getParams = function(index) {
        var _ = this._;
        var biquad = _.biquads[index|0];
        if (biquad) {
            return {freq:biquad.frequency, Q:biquad.Q, gain:biquad.gain};
        }
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            if (!_.bypassed) {
                var cellL = this.cells[1];
                var cellR = this.cells[2];
                var biquads = _.biquads;
                for (var i = 0, imax = biquads.length; i < imax; ++i) {
                    if (biquads[i]) {
                        biquads[i].process(cellL, cellR);
                    }
                }
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    var fft = new FFT(2048);
    var super_plot = T.Object.prototype.plot;

    $.plot = function(opts) {
        if (this._.plotFlush) {
            var _ = this._;
            var impluse = new Float32Array(fft.length);
            impluse[0] = 1;
            for (var i = 0, imax = _.biquads.length; i < imax; ++i) {
                var params = this.getParams(i);
                if (params) {
                    var biquad = new Biquad(_.samplerate);
                    if (i === 0) {
                        biquad.setType("highpass");
                    } else if (i === imax - 1) {
                        biquad.setType("lowpass");
                    } else {
                        biquad.setType("peaking");
                    }
                    biquad.setParams(params.freq, params.Q, params.gain);
                    biquad.process(impluse, impluse);
                }
            }

            fft.forward(impluse);

            var size = 512;
            var data = new Float32Array(size);
            var nyquist  = _.samplerate * 0.5;
            var spectrum = new Float32Array(size);
            var j, f, index, delta, x0, x1, xx;

            fft.getFrequencyData(spectrum);
            for (i = 0; i < size; ++i) {
                f = Math.pow(nyquist / PLOT_LOW_FREQ, i / size) * PLOT_LOW_FREQ;
                j = f / (nyquist / spectrum.length);
                index = j|0;
                delta = j - index;
                if (index === 0) {
                    x1 = x0 = xx = spectrum[index];
                } else {
                    x0 = spectrum[index - 1];
                    x1 = spectrum[index];
                    xx = ((1.0 - delta) * x0 + delta * x1);
                }
                data[i] = xx;
            }
            this._.plotData  = data;
            this._.plotFlush = null;
        }
        return super_plot.call(this, opts);
    };

    fn.register("eq", EQNode);

})(timbre);
(function(T) {
    "use strict";

    var fn  = T.fn;
    var FFT = T.modules.FFT;

    function FFTNode(_args) {
        T.Object.call(this, 2, _args);
        fn.listener(this);
        fn.fixAR(this);

        this.real = new T.ChannelObject(this);
        this.imag = new T.ChannelObject(this);
        this.cells[3] = this.real.cell;
        this.cells[4] = this.imag.cell;

        var _ = this._;
        _.fft = new FFT(_.cellsize * 2);
        _.fftCell  = new fn.SignalArray(_.fft.length);
        _.prevCell = new fn.SignalArray(_.cellsize);
        _.freqs    = new fn.SignalArray(_.fft.length>>1);

        _.plotFlush = true;
        _.plotRange = [0, 32];
        _.plotBarStyle = true;
    }
    fn.extend(FFTNode);

    var $ = FFTNode.prototype;

    Object.defineProperties($, {
        window: {
            set: function(value) {
                this._.fft.setWindow(value);
            },
            get: function() {
                return this._.fft.windowName;
            }
        },
        spectrum: {
            get: function() {
                return this._.fft.getFrequencyData(this._.freqs);
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);
            fn.outputSignalAR(this);

            var cell = this.cells[0];
            var cellsize = _.cellsize;

            _.fftCell.set(_.prevCell);
            _.fftCell.set(cell, cellsize);
            _.fft.forward(_.fftCell);
            _.prevCell.set(cell);
            _.plotFlush = true;

            this.cells[3].set(_.fft.real.subarray(0, cellsize));
            this.cells[4].set(_.fft.imag.subarray(0, cellsize));
        }

        return this;
    };

    var super_plot = T.Object.prototype.plot;

    $.plot = function(opts) {
        if (this._.plotFlush) {
            this._.plotData  = this.spectrum;
            this._.plotFlush = null;
        }
        return super_plot.call(this, opts);
    };

    fn.register("fft", FFTNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function FNoiseNode(_args) {
        T.Object.call(this, 1, _args);
        fn.fixAR(this);

        var _ = this._;
        _.freq = T(440);
        _.reg = 0x8000;
        _.shortFlag = false;
        _.phase     = 0;
        _.lastValue = 0;
    }
    fn.extend(FNoiseNode);

    var $ = FNoiseNode.prototype;

    Object.defineProperties($, {
        shortFlag: {
            set: function(value) {
                this._.shortFlag = !!value;
            },
            get: function() {
                return this._.shortFlag;
            }
        },
        freq: {
            set: function(value) {
                this._.freq = T(value);
            },
            get: function() {
                return this._.freq;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;
        var cell = this.cells[0];

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var lastValue = _.lastValue;
            var phase     = _.phase;
            var phaseStep = _.freq.process(tickID).cells[0][0] / _.samplerate;
            var reg = _.reg;
            var mul = _.mul, add = _.add;
            var i, imax;

            if (_.shortFlag) {
                for (i = 0, imax = cell.length; i < imax; ++i) {
                    if (phase >= 1) {
                        reg >>= 1;
                        reg |= ((reg ^ (reg >> 6)) & 1) << 15;
                        lastValue = ((reg & 1) - 0.5);
                        phase -= 1;
                    }
                    cell[i] = lastValue * mul + add;
                    phase += phaseStep;
                }
            } else {
                for (i = 0, imax = cell.length; i < imax; ++i) {
                    if (phase >= 1) {
                        reg >>= 1;
                        reg |= ((reg ^ (reg >> 1)) & 1) << 15;
                        lastValue = ((reg & 1) - 0.5);
                        phase -= 1;
                    }
                    cell[i] = lastValue * mul + add;
                    phase += phaseStep;
                }
            }
            _.reg       = reg;
            _.phase     = phase;
            _.lastValue = lastValue;
        }

        return this;
    };

    fn.register("fnoise", FNoiseNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    var GateChannelNode = (function() {
        function GateChannelNode(parent) {
            T.Object.call(this, 2, []);
            fn.fixAR(this);
            this._.parent = parent;
        }
        fn.extend(GateChannelNode);

        GateChannelNode.prototype.process = function(tickID) {
            if (this.tickID !== tickID) {
                this.tickID = tickID;
                this._.parent.process(tickID);
            }
            return this;
        };

        return GateChannelNode;
    })();

    function GateNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        this._.selected = 0;
        this._.outputs  = [];
    }
    fn.extend(GateNode);

    var $ = GateNode.prototype;

    Object.defineProperties($, {
        selected: {
            set: function(value) {
                var _ = this._;
                if (typeof value === "number") {
                    _.selected = value;
                    var outputs = _.outputs;
                    for (var i = 0, imax = outputs.length; i < imax; ++i) {
                        if (outputs[i]) {
                            outputs[i].cells[0].set(fn.emptycell);
                            outputs[i].cells[1].set(fn.emptycell);
                            outputs[i].cells[2].set(fn.emptycell);
                        }
                    }
                }
            },
            get: function() {
                return this._.selected;
            }
        }
    });

    $.at = function(index) {
        var _ = this._;
        var output = _.outputs[index];
        if (!output) {
            _.outputs[index] = output = new GateChannelNode(this);
        }
        return output;
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);
            fn.outputSignalAR(this);

            var output = _.outputs[_.selected];
            if (output) {
                output.cells[0].set(this.cells[0]);
                output.cells[1].set(this.cells[1]);
                output.cells[2].set(this.cells[2]);
            }
        }

        return this;
    };

    fn.register("gate", GateNode);

})(timbre);
(function(T) {
    "use strict";

    var fn  = T.fn;
    var FFT = T.modules.FFT;

    function IFFTNode(_args) {
        T.Object.call(this, 1, _args);
        fn.fixAR(this);

        var _ = this._;
        _.fft = new FFT(_.cellsize * 2);
        _.fftCell    = new fn.SignalArray(this._.fft.length);
        _.realBuffer = new fn.SignalArray(this._.fft.length);
        _.imagBuffer = new fn.SignalArray(this._.fft.length);
    }
    fn.extend(IFFTNode);

    var $ = IFFTNode.prototype;

    Object.defineProperties($, {
        real: {
            set: function(value) {
                this._.real = T(value);
            },
            get: function() {
                return this._.real;
            }
        },
        imag: {
            set: function(value) {
                this._.imag = T(value);
            },
            get: function() {
                return this._.imag;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            if (_.real && _.imag) {
                var cell = this.cells[0];
                var real = _.realBuffer;
                var imag = _.imagBuffer;
                var _real = _.real.process(tickID).cells[0];
                var _imag = _.imag.process(tickID).cells[0];

                real.set(_real);
                imag.set(_imag);

                cell.set(_.fft.inverse(real, imag).subarray(0, _.cellsize));

                fn.outputSignalAR(this);
            }
        }

        return this;
    };

    fn.register("ifft", IFFTNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;

    function IntervalNode(_args) {
        T.Object.call(this, 1, _args);
        fn.timer(this);
        fn.fixKR(this);

        var _ = this._;
        _.interval = T(1000);
        _.count = 0;
        _.delay   = 0;
        _.timeout = Infinity;
        _.currentTime = 0;
        _.delaySamples = 0;
        _.countSamples = 0;
        _.onended = fn.make_onended(this);

        this.on("start", onstart);
    }
    fn.extend(IntervalNode);

    var onstart = function() {
        var _ = this._;
        this.playbackState = fn.PLAYING_STATE;
        _.delaySamples = (_.samplerate * (_.delay * 0.001))|0;
        _.countSamples = _.count = _.currentTime = 0;
    };
    Object.defineProperty(onstart, "unremovable", {
        value:true, writable:false
    });

    var $ = IntervalNode.prototype;

    Object.defineProperties($, {
        interval: {
            set: function(value) {
                if (typeof value === "string") {
                    value = timevalue(value);
                    if (value <= 0) {
                        value = 0;
                    }
                }
                this._.interval = T(value);
            },
            get: function() {
                return this._.interval;
            }
        },
        delay: {
            set: function(value) {
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                if (typeof value === "number" && value >= 0) {
                    this._.delay = value;
                    this._.delaySamples = (this._.samplerate * (value * 0.001))|0;
                }
            },
            get: function() {
                return this._.delay;
            }
        },
        count: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.count = value;
                }
            },
            get: function() {
                return this._.count;
            }
        },
        timeout: {
            set: function(value) {
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                if (typeof value === "number" && value >= 0) {
                    this._.timeout = value;
                }
            },
            get: function() {
                return this._.timeout;
            }
        },
        currentTime: {
            get: function() {
                return this._.currentTime;
            }
        }
    });

    $.bang = function() {
        var _ = this._;
        this.playbackState = fn.PLAYING_STATE;
        _.delaySamples = (_.samplerate * (_.delay * 0.001))|0;
        _.countSamples = _.count = _.currentTime = 0;
        _.emit("bang");
        return this;
    };

    $.process = function(tickID) {
        var cell = this.cells[0];

        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            if (_.delaySamples > 0) {
                _.delaySamples -= cell.length;
            }

            var interval = _.interval.process(tickID).cells[0][0];

            if (_.delaySamples <= 0) {
                _.countSamples -= cell.length;
                if (_.countSamples <= 0) {
                    _.countSamples += (_.samplerate * interval * 0.001)|0;
                    var nodes = this.nodes;
                    var count  = _.count;
                    var x = count * _.mul + _.add;
                    for (var j = 0, jmax = cell.length; j < jmax; ++j) {
                        cell[j] = x;
                    }
                    for (var i = 0, imax = nodes.length; i < imax; ++i) {
                        nodes[i].bang(count);
                    }
                    _.count += 1;
                }
            }
            _.currentTime += fn.currentTimeIncr;

            if (_.currentTime >= _.timeout) {
                fn.nextTick(_.onended);
            }
        }
        return this;
    };

    fn.register("interval", IntervalNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;

    function LagNode(_args) {
        T.Object.call(this, 1, _args);
        fn.fixAR(this);

        var _ = this._;
        var bits = Math.ceil(Math.log(_.samplerate) * Math.LOG2E);
        _.buffersize = 1 << bits;
        _.buffermask = _.buffersize - 1;
        _.buffer = new fn.SignalArray(_.buffersize);
        _.time = 0;
        _.readIndex  = 0;
        _.writeIndex = 0;
    }
    fn.extend(LagNode);

    var $ = LagNode.prototype;

    Object.defineProperties($, {
        time: {
            set: function(value) {
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                if (typeof value === "number" && value > 0) {
                    var _ = this._;
                    _.time = value;
                    var offset = (value * 0.001 * _.samplerate)|0;
                    if (offset > _.buffermask) {
                        offset = _.buffermask;
                    }
                    _.writeIndex = (_.readIndex + offset) & _.buffermask;
                }
            },
            get: function() {
                return this._.time;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            var cell = this.cells[0];
            var buffer = _.buffer;
            var mask   = _.buffermask;
            var readIndex  = _.readIndex;
            var writeIndex = _.writeIndex;
            var i, imax = cell.length;

            for (i = 0; i < imax; ++i) {
                buffer[writeIndex] = cell[i];
                cell[i] = buffer[readIndex];

                readIndex  += 1;
                writeIndex = (writeIndex + 1) & mask;
            }

            _.readIndex  = readIndex & mask;
            _.writeIndex = writeIndex;

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("lag", LagNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function MapNode(_args) {
        T.Object.call(this, 1, _args);
        var _ = this._;
        _.input  = 0;
        _.value = 0;
        _.prev   = null;
        _.ar     = false;
        _.map    = defaultFunction;
    }
    fn.extend(MapNode);

    var defaultFunction = function(x) {
        return x;
    };

    var $ = MapNode.prototype;

    Object.defineProperties($, {
        input: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.input = value;
                }
            },
            get: function() {
                return this._.input;
            }
        },
        map: {
            set: function(value) {
                if (typeof value === "function") {
                    this._.map = value;
                }
            },
            get: function() {
                return this._.map;
            }
        }
    });

    $.bang = function() {
        this._.prev = null;
        this._.emit("bang");
        return this;
    };

    $.at = function(input) {
        return (this._.map) ? this._.map(input) : 0;
    };

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var len = this.nodes.length;
            var i, imax = cell.length;

            if (_.ar && len) {
                fn.inputSignalAR(this);
                var map = _.map;
                if (map) {
                    for (i = 0; i < imax; ++i) {
                        cell[i] = map(cell[i]);
                    }
                }
                _.value = cell[imax-1];
                fn.outputSignalAR(this);
            } else {
                var input = len ? fn.inputSignalKR(this) : _.input;
                if (_.map && _.prev !== input) {
                    _.prev = input;
                    _.value = _.map(input);
                }
                var value = _.value * _.mul + _.add;
                for (i = 0; i < imax; ++i) {
                    cell[i] = value;
                }
            }
        }

        return this;
    };

    fn.register("map", MapNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function MaxNode(_args) {
        T.Object.call(this, 1, _args);
    }
    fn.extend(MaxNode);

    var $ = MaxNode.prototype;

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var nodes = this.nodes;
            var i, imax = nodes.length;
            var j, jmax = cell.length;
            var tmp, val;

            if (_.ar) {
                if (nodes.length > 0) {
                    tmp = nodes[0].process(tickID).cells[0];
                    cell.set(tmp);
                    for (i = 1; i < imax; ++i) {
                        tmp = nodes[i].process(tickID).cells[0];
                        for (j = 0; j < jmax; ++j) {
                            val = tmp[j];
                            if (cell[j] < val) {
                                cell[j] = val;
                            }
                        }
                    }
                } else {
                    for (j = 0; j < jmax; ++j) {
                        cell[j] = 0;
                    }
                }
                fn.outputSignalAR(this);
            } else {
                if (nodes.length > 0) {
                    tmp = nodes[0].process(tickID).cells[0][0];
                    for (i = 1; i < imax; ++i) {
                        val = nodes[i].process(tickID).cells[0][0];
                        if (tmp < val) {
                            tmp = val;
                        }
                    }
                } else {
                    tmp = 0;
                }
                cell[0] = tmp;
                fn.outputSignalKR(this);
            }
        }

        return this;
    };

    fn.register("max", MaxNode);

})(timbre);
(function(T) {
    "use strict";

    if (T.envtype !== "browser") {
        return;
    }

    var fn = T.fn;
    var BUFFER_SIZE = 4096;
    var BUFFER_MASK = BUFFER_SIZE - 1;

    function MediaStreamNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.src = _.func = null;
        _.bufferL = new fn.SignalArray(BUFFER_SIZE);
        _.bufferR = new fn.SignalArray(BUFFER_SIZE);
        _.readIndex  = 0;
        _.writeIndex = 0;
        _.totalRead  = 0;
        _.totalWrite = 0;
    }
    fn.extend(MediaStreamNode);

    var $ = MediaStreamNode.prototype;

    $.listen = function(audio) {
        var _impl = impl[T.env];
        if (_impl) {
            _impl.set.call(this, audio);
            _impl.listen.call(this);
        }
    };

    $.unlisten = function() {
        var _impl = impl[T.env];
        if (_impl) {
            _impl.unlisten.call(this);
        }

        this.cells[0].set(fn.emptycell);
        this.cells[1].set(fn.emptycell);
        this.cells[2].set(fn.emptycell);

        var _ = this._;
        var bufferL = _.bufferL, bufferR = _.bufferR;
        for (var i = 0, imax = bufferL.length; i < imax; ++i) {
            bufferL[i] = bufferR[i] = 0;
        }
    };

    $.process = function(tickID) {
        var _ = this._;

        if (_.src === null) {
            return this;
        }

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var cellsize = _.cellsize;
            if (_.totalWrite > _.totalRead + cellsize) {
                var begin = _.readIndex;
                var end   = begin + cellsize;
                this.cells[1].set(_.bufferL.subarray(begin, end));
                this.cells[2].set(_.bufferR.subarray(begin, end));
                _.readIndex = end & BUFFER_MASK;
                _.totalRead += cellsize;
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    var impl = {};
    impl.webkit = {
        set: function(src) {
            var _ = this._;
            /*global HTMLMediaElement:true */
            if (src instanceof HTMLMediaElement) {
                var context = fn._audioContext;
                _.src = context.createMediaElementSource(src);
            }
            /*global HTMLMediaElement:false */
        },
        listen: function() {
            var _ = this._;
            var context = fn._audioContext;
            _.gain = context.createGainNode();
            _.gain.gain.value = 0;
            _.node = context.createJavaScriptNode(1024, 2, 2);
            _.node.onaudioprocess = onaudioprocess(this);
            _.src.connect(_.node);
            _.node.connect(_.gain);
            _.gain.connect(context.destination);
        },
        unlisten: function() {
            var _ = this._;
            if (_.src) {
                _.src.disconnect();
            }
            if (_.gain) {
                _.gain.disconnect();
            }
            if (_.node) {
                _.node.disconnect();
            }
        }
    };
    var onaudioprocess = function(self) {
        return function(e) {
            var _ = self._;
            var ins = e.inputBuffer;
            var length = ins.length;
            var writeIndex = _.writeIndex;

            _.bufferL.set(ins.getChannelData(0), writeIndex);
            _.bufferR.set(ins.getChannelData(1), writeIndex);
            _.writeIndex = (writeIndex + length) & BUFFER_MASK;
            _.totalWrite += length;
        };
    };

    impl.moz = {
        set: function(src) {
            var _ = this._;
            /*global HTMLAudioElement:true */
            if (src instanceof HTMLAudioElement) {
                _.src = src;
                _.istep = _.samplerate / src.mozSampleRate;
            }
            /*global HTMLAudioElement:false */
        },
        listen: function() {
            var _ = this._;
            var o0 = _.bufferL;
            var o1 = _.bufferR;
            var prev0 = 0, prev1 = 0;
            if (_.src.mozChannels === 2) {
                _.x = 0;
                _.func = function(e) {
                    var writeIndex = _.writeIndex;
                    var totalWrite = _.totalWrite;
                    var samples = e.frameBuffer;
                    var x, istep = _.istep;
                    var i, imax = samples.length;
                    x = _.x;
                    for (i = 0; i < imax; i+= 2) {
                        x += istep;
                        while (x > 0) {
                            o0[writeIndex] = (samples[i  ] + prev0) * 0.5;
                            o1[writeIndex] = (samples[i+1] + prev1) * 0.5;
                            writeIndex = (writeIndex + 1) & BUFFER_MASK;
                            ++totalWrite;
                            x -= 1;
                        }
                        prev0 = samples[i  ];
                        prev1 = samples[i+1];
                    }
                    _.x = x;
                    _.writeIndex = writeIndex;
                    _.totalWrite = totalWrite;
                };
            } else {
                _.x = 0;
                _.func = function(e) {
                    var writeIndex = _.writeIndex;
                    var totalWrite = _.totalWrite;
                    var samples = e.frameBuffer;
                    var x, istep = _.istep;
                    var i, imax = samples.length;
                    x = _.x;
                    for (i = 0; i < imax; ++i) {
                        x += istep;
                        while (x >= 0) {
                            o0[writeIndex] = o1[writeIndex] = (samples[i] + prev0) * 0.5;
                            writeIndex = (writeIndex + 1) & BUFFER_MASK;
                            ++totalWrite;
                            x -= 1;
                        }
                        prev0 = samples[i];
                    }
                    _.x = x;
                    _.writeIndex = writeIndex;
                    _.totalWrite = totalWrite;
                };
            }
            _.src.addEventListener("MozAudioAvailable", _.func);
        },
        unlisten: function() {
            var _ = this._;
            if (_.func) {
                _.src.removeEventListener("MozAudioAvailable", _.func);
                _.func = null;
            }
        }
    };

    fn.register("mediastream", MediaStreamNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function MidiCpsNode(_args) {
        T.Object.call(this, 1, _args);
        var _ = this._;
        _.midi = 0;
        _.value = 0;
        _.prev  = null;
        _.a4    = 440;
        _.ar    = false;
    }
    fn.extend(MidiCpsNode);

    var $ = MidiCpsNode.prototype;

    Object.defineProperties($, {
        midi: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.midi = value;
                }
            },
            get: function() {
                return this._.midi;
            }
        },
        a4: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.a4   = value;
                    this._.prev = null;
                }
            },
            get: function() {
                return this._.a4;
            }
        }
    });

    $.bang = function() {
        this._.prev = null;
        this._.emit("bang");
        return this;
    };

    $.at = function(midi) {
        var _ = this._;
        return _.a4 * Math.pow(2, (midi - 69) / 12);
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var cell = this.cells[0];
            var len  = this.nodes.length;
            var i, imax = cell.length;

            if (_.ar && len) {
                fn.inputSignalAR(this);
                var a4 = _.a4;
                for (i = 0; i < imax; ++i) {
                    cell[i] = a4 * Math.pow(2, (cell[i] - 69) / 12);
                }
                _.value = cell[imax-1];
                fn.outputSignalAR(this);
            } else {
                var input = (len) ? fn.inputSignalKR(this) : _.midi;
                if (_.prev !== input) {
                    _.prev = input;
                    _.value = _.a4 * Math.pow(2, (input - 69) / 12);
                }
                cell[0] = _.value;
                fn.outputSignalKR(this);
            }
        }

        return this;
    };

    fn.register("midicps", MidiCpsNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function MidiRatioNode(_args) {
        T.Object.call(this, 1, _args);
        var _ = this._;
        _.midi = 0;
        _.value = 0;
        _.prev  = null;
        _.range = 12;
        _.ar    = false;
    }
    fn.extend(MidiRatioNode);

    var $ = MidiRatioNode.prototype;

    Object.defineProperties($, {
        midi: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.midi = value;
                }
            },
            get: function() {
                return this._.midi;
            }
        },
        range: {
            set: function(value) {
                if (typeof value === "number" && value > 0) {
                    this._.range = value;
                }
            },
            get: function() {
                return this._.range;
            }
        }
    });

    $.bang = function() {
        this._.prev = null;
        this._.emit("bang");
        return this;
    };

    $.at = function(midi) {
        var _ = this._;
        return Math.pow(2, midi / _.range);
    };

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var len = this.nodes.length;
            var i, imax = cell.length;

            if (_.ar && len) {
                fn.inputSignalAR(this);
                var range = _.range;
                for (i = 0; i < imax; ++i) {
                    cell[i] = Math.pow(2, cell[i] / range);
                }
                _.value = cell[imax-1];
                fn.outputSignalAR(this);
            } else {
                var input = (this.nodes.length) ? fn.inputSignalKR(this) : _.midi;
                if (_.prev !== input) {
                    _.prev = input;
                    _.value = Math.pow(2, input / _.range);
                }
                var value = _.value * _.mul + _.add;
                for (i = 0; i < imax; ++i) {
                    cell[i] = value;
                }
            }
        }

        return this;
    };

    fn.register("midiratio", MidiRatioNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function MinNode(_args) {
        T.Object.call(this, 1, _args);
    }
    fn.extend(MinNode);

    var $ = MinNode.prototype;

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var nodes = this.nodes;
            var i, imax = nodes.length;
            var j, jmax = cell.length;
            var tmp, val;

            if (_.ar) {
                if (nodes.length > 0) {
                    tmp = nodes[0].process(tickID).cells[0];
                    cell.set(tmp);
                    for (i = 1; i < imax; ++i) {
                        tmp = nodes[i].process(tickID).cells[0];
                        for (j = 0; j < jmax; ++j) {
                            val = tmp[j];
                            if (cell[j] > val) {
                                cell[j] = val;
                            }
                        }
                    }
                } else {
                    for (j = 0; j < jmax; ++j) {
                        cell[j] = 0;
                    }
                }
                fn.outputSignalAR(this);
            } else {
                if (nodes.length > 0) {
                    tmp = nodes[0].process(tickID).cells[0][0];
                    for (i = 1; i < imax; ++i) {
                        val = nodes[i].process(tickID).cells[0][0];
                        if (tmp > val) {
                            tmp = val;
                        }
                    }
                } else {
                    tmp = 0;
                }
                cell[0] = tmp;
                fn.outputSignalKR(this);
            }
        }

        return this;
    };

    fn.register("min", MinNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function MML(_args) {
        T.Object.call(this, 0, _args);
        fn.timer(this);
        fn.fixKR(this);

        var _ = this._;
        _.tracks  = [];
        _.onended = fn.make_onended(this);
        _.currentTime = 0;

        this.on("start", onstart);
    }
    fn.extend(MML);

    var onstart = function() {
        var self = this, _ = this._;
        var mml  = _.mml;
        if (typeof mml === "string") {
            mml = [mml];
        }
        _.tracks = mml.map(function(mml, i) {
            return new MMLTrack(self, i, mml);
        });
        _.currentTime = 0;
        this.playbackState = fn.PLAYING_STATE;
    };
    Object.defineProperty(onstart, "unremoved", {
        value:true, writable:false
    });

    var $ = MML.prototype;

    Object.defineProperties($, {
        mml: {
            set: function(value) {
                var _ = this._;
                if (typeof value === "string" || Array.isArray(value)) {
                    _.mml = value;
                }
            },
            get: function() {
                return this._.mml;
            }
        },
        currentTime: {
            get: function() {
                return this._.currentTime;
            }
        }
    });

    $.on = $.addListener = function(type, listener) {
        if (type === "mml") {
            type = "data";
            console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener.");
        }
        this._.events.on(type, listener);
        return this;
    };

    $.once = function(type, listener) {
        if (type === "mml") {
            type = "data";
            console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener.");
        }
        this._.events.once(type, listener);
        return this;
    };

    $.off = $.removeListener = function(type, listener) {
        if (type === "mml") {
            type = "data";
            console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener.");
        }
        this._.events.off(type, listener);
        return this;
    };

    $.removeAllListeners = function(type) {
        if (type === "mml") {
            console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener.");
            type = "data";
        }
        this._.events.removeAllListeners(type);
        return this;
    };

    $.listeners = function(type) {
        if (type === "mml") {
            console.warn("A 'mml' event listener was deprecated in ~v13.03.01. use 'data' event listener.");
            type = "data";
        }
        return this._.events.listeners(type);
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var i, imax;
            var tracks = _.tracks;

            for (i = 0, imax = tracks.length; i < imax; ++i) {
                tracks[i].process();
            }
            while (i--) {
                if (tracks[i].ended) {
                    tracks.splice(i, 1);
                }
            }
            if (tracks.length === 0) {
                fn.nextTick(_.onended);
            }
            _.currentTime += fn.currentTimeIncr;
        }

        return this;
    };

    fn.register("mml", MML);

    var MMLTrack = (function() {
        function MMLTrack(sequencer, trackNum, mml) {
            var _ = this._ = {};
            _.sequencer = sequencer;
            _.trackNum  = trackNum;
            _.commands  = compile(mml);
            _.status = {t:120, l:4, o:4, v:12, q:6, dot:0, tie:false};
            _.index    = 0;
            _.queue    = [];
            _.currentTime = 0;
            _.queueTime   = 0;
            _.segnoIndex  = -1;
            _.loopStack   = [];
            _.prevNote = 0;
            _.remain   = Infinity;
            this.ended = false;
            sched(this);
        }

        var EOF     = 0;
        var NOTEON  = 1;
        var NOTEOFF = 2;
        var COMMAND = 3;

        MMLTrack.prototype.process = function() {
            var _ = this._;
            var sequencer = _.sequencer;
            var trackNum  = _.trackNum;
            var queue  = _.queue;
            var eof = false;

            if (queue.length) {
                while (queue[0][0] <= _.currentTime) {
                    var nextItem = _.queue.shift();
                    switch (nextItem[1]) {
                    case NOTEON:
                        noteOn(sequencer, trackNum, nextItem[2], nextItem[3]);
                        _.remain = nextItem[4];
                        sched(this);
                        break;
                    case NOTEOFF:
                        noteOff(sequencer, trackNum, nextItem[2], nextItem[3]);
                        break;
                    case COMMAND:
                        command(sequencer, nextItem[2]);
                        break;
                    case EOF:
                        eof = true;
                        break;
                    }
                    if (queue.length === 0) {
                        break;
                    }
                }
            }
            _.remain -= fn.currentTimeIncr;
            if (eof) {
                this.ended = true;
            }
            _.currentTime += fn.currentTimeIncr;
        };

        var noteOn = function(sequencer, trackNum, noteNum, velocity) {
            var gen, i, imax;
            var nodes = sequencer.nodes;
            for (i = 0, imax = nodes.length; i < imax; ++i) {
                gen = nodes[i];
                if (gen.noteOn) {
                    gen.noteOn(noteNum, velocity);
                } else {
                    gen.bang();
                }
            }
            sequencer._.emit("data", "noteOn", {
                trackNum:trackNum, noteNum:noteNum, velocity:velocity
            });
        };

        var noteOff = function(sequencer, trackNum, noteNum, velocity) {
            var gen, i, imax;
            var nodes = sequencer.nodes;
            for (i = 0, imax = nodes.length; i < imax; ++i) {
                gen = nodes[i];
                if (gen.noteOff) {
                    gen.noteOff(noteNum, velocity);
                } else if (gen.release) {
                    gen.release();
                }
            }
            sequencer._.emit("data", "noteOff", {
                trackNum:trackNum, noteNum:noteNum, velocity:velocity
            });
        };

        var command = function(sequencer, cmd) {
            sequencer._.emit("data", "command", {
                command: cmd
            });
        };

        var sched = function(self) {
            var _ = self._;

            var sequencer = _.sequencer;
            var cmd, commands = _.commands;
            var queue  = _.queue;
            var index  = _.index;
            var status = _.status;
            var queueTime = _.queueTime;
            var loopStack = _.loopStack;
            var tempo, val, len, dot, vel;
            var duration, quantize, pending, _queueTime;
            var peek;
            var i, imax;

            pending = [];

            outer:
            while (true) {
                if (commands.length <= index) {
                    if (_.segnoIndex >= 0) {
                        index = _.segnoIndex;
                    } else {
                        break;
                    }
                }
                cmd = commands[index++];

                switch (cmd.name) {
                case "@":
                    queue.push([queueTime, COMMAND, cmd.val]);
                    break;
                case "n":
                    tempo = status.t || 120;
                    if (cmd.len !== null) {
                        len = cmd.len;
                        dot = cmd.dot || 0;
                    } else {
                        len = status.l;
                        dot = cmd.dot || status.dot;
                    }
                    duration = (60 / tempo) * (4 / len) * 1000;
                    duration *= [1, 1.5, 1.75, 1.875][dot] || 1;

                    vel = status.v << 3;
                    if (status.tie) {
                        for (i = queue.length; i--; ) {
                            if (queue[i][2]) {
                                queue.splice(i, 1);
                                break;
                            }
                        }
                        val = _.prevNote;
                    } else {
                        val = _.prevNote = (cmd.val) + (status.o + 1) * 12;
                        queue.push([queueTime, NOTEON, val, vel, duration]);
                    }

                    if (len > 0) {
                        quantize = status.q / 8;
                        // noteOff
                        if (quantize < 1) {
                            _queueTime = queueTime + (duration * quantize);
                            queue.push([_queueTime, NOTEOFF, val, vel]);
                            for (i = 0, imax = pending.length; i < imax; ++i) {
                                queue.push([_queueTime, NOTEOFF, pending[i], vel]);
                            }
                        }
                        pending = [];
                        queueTime += duration;
                        if (!status.tie) {
                            break outer;
                        }
                    } else {
                        pending.push(val);
                    }
                    status.tie = false;
                    break;
                case "r":
                    tempo = status.t || 120;
                    if (cmd.len !== null) {
                        len = cmd.len;
                        dot = cmd.dot || 0;
                    } else {
                        len = status.l;
                        dot = cmd.dot || status.dot;
                    }
                    if (len > 0) {
                        duration = (60 / tempo) * (4 / len) * 1000;
                        duration *= [1, 1.5, 1.75, 1.875][dot] || 1;
                        queueTime += duration;
                    }
                    break;
                case "l":
                    status.l   = cmd.val;
                    status.dot = cmd.dot;
                    break;
                case "o":
                    status.o = cmd.val;
                    break;
                case "<":
                    if (status.o < 9) {
                        status.o += 1;
                    }
                    break;
                case ">":
                    if (status.o > 0) {
                        status.o -= 1;
                    }
                    break;
                case "v":
                    status.v = cmd.val;
                    break;
                case "(":
                    if (status.v < 15) {
                        status.v += 1;
                    }
                    break;
                case ")":
                    if (status.v > 0) {
                        status.v -= 1;
                    }
                    break;
                case "q":
                    status.q = cmd.val;
                    break;
                case "&":
                    status.tie = true;
                    break;
                case "$":
                    _.segnoIndex = index;
                    break;
                case "[":
                    loopStack.push([index, null, null]);
                    break;
                case "|":
                    peek = loopStack[loopStack.length - 1];
                    if (peek) {
                        if (peek[1] === 1) {
                            loopStack.pop();
                            index = peek[2];
                        }
                    }
                    break;
                case "]":
                    peek = loopStack[loopStack.length - 1];
                    if (peek) {
                        if (peek[1] === null) {
                            peek[1] = cmd.count;
                            peek[2] = index;
                        }
                        peek[1] -= 1;
                        if (peek[1] === 0) {
                            loopStack.pop();
                        } else {
                            index = peek[0];
                        }
                    }
                    break;
                case "t":
                    status.t = (cmd.val === null) ? 120 : cmd.val;
                    break;
                case "EOF":
                    queue.push([queueTime, EOF]);
                    break;
                }
            }
            _.index = index;
            _.queueTime = queueTime;
        };

        var compile = function(mml) {
            var def, re, m, cmd;
            var i, imax, j, jmax;
            var checked = new Array(mml.length);
            var commands = [];

            for (i = 0, imax = MMLCommands.length; i < imax; ++i) {
                def = MMLCommands[i];
                re  = def.re;
                while ((m = re.exec(mml))) {
                    if (!checked[m.index]) {
                        for (j = 0, jmax = m[0].length; j < jmax; ++j) {
                            checked[m.index + j] = true;
                        }
                        if (def.func) {
                            cmd = def.func(m);
                        } else {
                            cmd = {name:m[0]};
                        }
                        if (cmd) {
                            cmd.index = m.index;
                            cmd.origin = m[0];
                            commands.push(cmd);
                        }
                    }
                    while (re.lastIndex < mml.length) {
                        if (!checked[re.lastIndex]) {
                            break;
                        }
                        ++re.lastIndex;
                    }
                }
            }
            commands.sort(function(a, b) {
                return a.index - b.index;
            });
            commands.push({name:"EOF"});
            return commands;
        };

        var MMLCommands = [
            { re:/@(\d*)/g, func: function(m) {
                return {
                    name: "@",
                    val: m[1] || null
                };
            }},
            { re:/([cdefgab])([\-+]?)(\d*)(\.*)/g, func: function(m) {
                return {
                    name: "n",
                    val : {c:0,d:2,e:4,f:5,g:7,a:9,b:11}[m[1]] + ({"-":-1,"+":+1}[m[2]]||0),
                    len : (m[3] === "") ? null : Math.min(m[3]|0, 64),
                    dot : m[4].length
                };
            }},
            { re:/r(\d*)(\.*)/g, func: function(m) {
                return {
                    name: "r",
                    len : (m[1] === "") ? null : Math.max(1, Math.min(m[1]|0, 64)),
                    dot : m[2].length
                };
            }},
            { re:/&/g },
            { re:/l(\d*)(\.*)/g, func: function(m) {
                return {
                    name: "l",
                    val : (m[1] === "") ? 4 : Math.min(m[1]|0, 64),
                    dot : m[2].length
                };
            }},
            { re:/o([0-9])/g, func: function(m) {
                return {
                    name: "o",
                    val : (m[1] === "") ? 4 : m[1]|0
                };
            }},
            { re:/[<>]/g },
            { re:/v(\d*)/g, func: function(m) {
                return {
                    name: "v",
                    val : (m[1] === "") ? 12 : Math.min(m[1]|0, 15)
                };
            }},
            { re:/[()]/g },
            { re:/q([0-8])/g, func: function(m) {
                return {
                    name: "q",
                    val : (m[1] === "") ? 6 : Math.min(m[1]|0, 8)
                };
            }},
            { re:/\[/g },
            { re:/\|/g },
            { re:/\](\d*)/g, func: function(m) {
                return {
                    name: "]",
                    count: (m[1]|0)||2
                };
            }},
            { re:/t(\d*)/g, func: function(m) {
                return {
                    name: "t",
                    val : (m[1] === "") ? null : Math.max(5, Math.min(m[1]|0, 300))
                };
            }},
            { re:/\$/g }
        ];

        return MMLTrack;
    })();

})(timbre);
(function(T) {
    "use strict";

    var fn  = T.fn;

    function MonoNode(_args) {
        T.Object.call(this, 1, _args);
    }
    fn.extend(MonoNode);

    MonoNode.prototype.process = function(tickID) {
        var _ = this._;
        if (this.tickID !== tickID) {
            this.tickID = tickID;
            if (_.ar) {
                fn.inputSignalAR(this);
                fn.outputSignalAR(this);
            } else {
                this.cells[0][0] = fn.inputSignalKR(this);
                fn.outputSignalKR(this);
            }
        }
        return this;
    };
    fn.register("mono", MonoNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function MulNode(_args) {
        T.Object.call(this, 2, _args);
    }
    fn.extend(MulNode);

    var $ = MulNode.prototype;

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var nodes = this.nodes;
            var cell  = this.cells[0];
            var cellL = this.cells[1];
            var cellR = this.cells[2];
            var i, imax = nodes.length;
            var j, jmax = cell.length;
            var tmp, tmpL, tmpR;

            if (_.ar) {
                if (nodes.length > 0) {
                    nodes[0].process(tickID);
                    tmpL = nodes[0].cells[1];
                    tmpR = nodes[0].cells[2];
                    cellL.set(tmpL);
                    cellR.set(tmpR);
                    for (i = 1; i < imax; ++i) {
                        nodes[i].process(tickID);
                        tmpL = nodes[i].cells[1];
                        tmpR = nodes[i].cells[2];
                        for (j = 0; j < jmax; ++j) {
                            cellL[j] *= tmpL[j];
                            cellR[j] *= tmpR[j];
                        }
                    }
                } else {
                    for (j = 0; j < jmax; ++j) {
                        cellL[j] = cellR[j] = 0;
                    }
                }
                fn.outputSignalAR(this);
            } else {
                if (nodes.length > 0) {
                    tmp = nodes[0].process(tickID).cells[0][0];
                    for (i = 1; i < imax; ++i) {
                        tmp *= nodes[i].process(tickID).cells[0][0];
                    }
                } else {
                    tmp = 0;
                }
                cell[0] = tmp;
                fn.outputSignalKR(this);
            }
        }

        return this;
    };

    fn.register("*", MulNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function NDictNode(_args) {
        T.Object.call(this, 1, _args);

        var _ = this._;
        _.defaultValue = 0;
        _.index = 0;
        _.dict  = {};
        _.ar    = false;
    }
    fn.extend(NDictNode);

    var $ = NDictNode.prototype;

    Object.defineProperties($, {
        dict: {
            set: function(value) {
                if (typeof value === "object") {
                    this._.dict = value;
                } else if (typeof value === "function") {
                    var dict = {};
                    for (var i = 0; i < 128; ++i) {
                        dict[i] = value(i);
                    }
                    this._.dict = dict;
                }
            },
            get: function() {
                return this._.dict;
            }
        },
        defaultValue: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.defaultValue = value;
                }
            },
            get: function() {
                return this._.defaultValue;
            }
        },
        index: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.index = value;
                }
            },
            get: function() {
                return this._.index;
            }
        }
    });

    $.at = function(index) {
        var _ = this._;
        return (_.dict[index|0] || _.defaultValue) * _.mul + _.add;
    };

    $.clear = function() {
        this._.dict = {};
        return this;
    };

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var len = this.nodes.length;
            var index, value;
            var dict = _.dict, defaultValue = _.defaultValue;
            var mul = _.mul, add = _.add;
            var i, imax = cell.length;

            if (_.ar && len) {

                fn.inputSignalAR(this);
                for (i = 0; i < imax; ++i) {
                    index = cell[i];
                    if (index < 0) {
                        index = (index - 0.5)|0;
                    } else {
                        index = (index + 0.5)|0;
                    }
                    cell[i] = (dict[index] || defaultValue) * mul + add;
                }
                fn.outputSignalAR(this);
            } else {
                index = (this.nodes.length) ? fn.inputSignalKR(this) : _.index;
                if (index < 0) {
                    index = (index - 0.5)|0;
                } else {
                    index = (index + 0.5)|0;
                }
                value = (dict[index] || defaultValue) * mul + add;
                for (i = 0; i < imax; ++i) {
                    cell[i] = value;
                }
            }
        }

        return this;
    };

    fn.register("ndict", NDictNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function NoiseNode(_args) {
        T.Object.call(this, 1, _args);
    }
    fn.extend(NoiseNode);

    var $ = NoiseNode.prototype;

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var mul = _.mul, add = _.add;
            var i, imax, x;

            if (_.ar) { // audio-rate
                for (i = 0, imax = cell.length; i < imax; ++i) {
                    cell[i] = (Math.random() * 2 - 1) * mul + add;
                }
            } else {    // control-rate
                x = (Math.random() * 2 + 1) * mul + add;
                for (i = 0, imax = cell.length; i < imax; ++i) {
                    cell[i] = x;
                }
            }
        }
        return this;
    };

    fn.register("noise", NoiseNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue  = T.timevalue;
    var Oscillator = T.modules.Oscillator;

    function OscNode(_args) {
        T.Object.call(this, 2, _args);

        var _ = this._;
        _.freq  = T(440);
        _.phase = T(0);
        _.osc = new Oscillator(_.samplerate);
        _.tmp = new fn.SignalArray(_.cellsize);
        _.osc.step = _.cellsize;

        this.once("init", oninit);
    }
    fn.extend(OscNode);

    var oninit = function() {
        var _ = this._;
        if (!this.wave) {
            this.wave = "sin";
        }
        _.plotData = _.osc.wave;
        _.plotLineWidth = 2;
        _.plotCyclic = true;
        _.plotBefore = plotBefore;
    };

    var $ = OscNode.prototype;

    Object.defineProperties($, {
        wave: {
            set: function(value) {
                this._.osc.setWave(value);
            },
            get: function() {
                return this._.osc.wave;
            }
        },
        freq: {
            set: function(value) {
                if (typeof value === "string") {
                    value = timevalue(value);
                    if (value <= 0) {
                        value = 0;
                    } else {
                        value = 1000 / value;
                    }
                }
                this._.freq = T(value);
            },
            get: function() {
                return this._.freq;
            }
        },
        phase: {
            set: function(value) {
                this._.phase = T(value);
                this._.osc.feedback = false;
            },
            get: function() {
                return this._.phase;
            }
        },
        fb: {
            set: function(value) {
                this._.phase = T(value);
                this._.osc.feedback = true;
            },
            get: function() {
                return this._.phase;
            }
        }
    });

    $.clone = function() {
        var instance = fn.clone(this);
        instance._.osc = this._.osc.clone();
        instance._.freq  = this._.freq;
        instance._.phase = this._.phase;
        return instance;
    };

    $.bang = function() {
        this._.osc.reset();
        this._.emit("bang");
        return this;
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var cellL = this.cells[1];
            var cellR = this.cells[2];
            var i, imax = _.cellsize;

            if (this.nodes.length) {
                fn.inputSignalAR(this);
            } else {
                for (i = 0; i < imax; ++i) {
                    cellL[i] = cellR[i] = 1;
                }
            }

            var osc = _.osc;
            var freq  = _.freq.process(tickID).cells[0];
            var phase = _.phase.process(tickID).cells[0];

            osc.frequency = freq[0];
            osc.phase     = phase[0];

            if (_.ar) {
                var tmp  = _.tmp;
                if (_.freq.isAr) {
                    if (_.phase.isAr) {
                        osc.processWithFreqAndPhaseArray(tmp, freq, phase);
                    } else {
                        osc.processWithFreqArray(tmp, freq);
                    }
                } else {
                    if (_.phase.isAr) {
                        osc.processWithPhaseArray(tmp, phase);
                    } else {
                        osc.process(tmp);
                    }
                }
                for (i = 0; i < imax; ++i) {
                    cellL[i] *= tmp[i];
                    cellR[i] *= tmp[i];
                }
            } else {
                var value = osc.next();
                for (i = 0; i < imax; ++i) {
                    cellL[i] *= value;
                    cellR[i] *= value;
                }
            }
            fn.outputSignalAR(this);
        }

        return this;
    };

    var plotBefore;
    if (T.envtype === "browser") {
        plotBefore = function(context, offset_x, offset_y, width, height) {
            var y = (height >> 1) + 0.5;
            context.strokeStyle = "#ccc";
            context.lineWidth   = 1;
            context.beginPath();
            context.moveTo(offset_x, y + offset_y);
            context.lineTo(offset_x + width, y + offset_y);
            context.stroke();
        };
    }

    fn.register("osc", OscNode);

    fn.register("sin", function(_args) {
        return new OscNode(_args).set("wave", "sin");
    });
    fn.register("cos", function(_args) {
        return new OscNode(_args).set("wave", "cos");
    });
    fn.register("pulse", function(_args) {
        return new OscNode(_args).set("wave", "pulse");
    });
    fn.register("tri", function(_args) {
        return new OscNode(_args).set("wave", "tri");
    });
    fn.register("saw", function(_args) {
        return new OscNode(_args).set("wave", "saw");
    });
    fn.register("fami", function(_args) {
        return new OscNode(_args).set("wave", "fami");
    });
    fn.register("konami", function(_args) {
        return new OscNode(_args).set("wave", "konami");
    });
    fn.register("+sin", function(_args) {
        return new OscNode(_args).set("wave", "+sin").kr();
    });
    fn.register("+pulse", function(_args) {
        return new OscNode(_args).set("wave", "+pulse").kr();
    });
    fn.register("+tri", function(_args) {
        return new OscNode(_args).set("wave", "+tri").kr();
    });
    fn.register("+saw", function(_args) {
        return new OscNode(_args).set("wave", "+saw").kr();
    });

    fn.alias("square", "pulse");

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function PanNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.pos  = T(0);
        _.panL = 0.5;
        _.panR = 0.5;
    }
    fn.extend(PanNode);

    var $ = PanNode.prototype;

    Object.defineProperties($, {
        pos: {
            set: function(value) {
                this._.pos = T(value);
            },
            get: function() {
                return this._.pos;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var pos = _.pos.process(tickID).cells[0][0];
            if (_.prevPos !== pos) {
                var index = pos * 0.5 + 0.5;
                _.panL = 1 - pos;
                _.panR = _.prevPos = pos;
            }

            var nodes = this.nodes;
            var cellL = this.cells[1];
            var cellR = this.cells[2];
            var i, imax = nodes.length;
            var j, jmax = cellL.length;
            var tmp;

            if (imax) {
                tmp = nodes[0].process(tickID).cells[0];
                for (j = 0; j < jmax; ++j) {
                    cellL[j] = cellR[j] = tmp[j];
                }
                for (i = 1; i < imax; ++i) {
                    tmp = nodes[i].process(tickID).cells[0];
                    for (j = 0; j < jmax; ++j) {
                        cellL[j] = (cellR[j] += tmp[j]);
                    }
                }

                var panL = _.panL;
                var panR = _.panR;
                for (j = 0; j < jmax; ++j) {
                    cellL[j] = cellL[j] * panL;
                    cellR[j] = cellR[j] * panR;
                }

            } else {
                cellL.set(fn.emptycell);
                cellR.set(fn.emptycell);
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("pan", PanNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;
    var Envelope      = T.modules.Envelope;
    var EnvelopeValue = T.modules.EnvelopeValue;

    function ParamNode(_args) {
        T.Object.call(this, 2, _args);

        var _ = this._;
        _.value = 0;
        _.env = new EnvelopeValue(_.samplerate);
        _.env.step = _.cellsize;
        _.curve   = "lin";
        _.counter = 0;
        _.ar = false;
        _.onended = make_onended(this);

        this.on("ar", onar);
    }
    fn.extend(ParamNode);

    var make_onended = function(self, lastValue) {
        return function() {
            if (typeof lastValue === "number") {
                var cell  = self.cells[0];
                var cellL = self.cells[1];
                var cellR = self.cells[2];
                var value = self._.env.value;
                for (var i = 0, imax = cellL.length; i < imax; ++i) {
                    cell[0] = cellL[i] = cellR[i] = value;
                }
            }
            self._.emit("ended");
        };
    };

    var onar = function(value) {
        this._.env.step = (value) ? 1 : this._.cellsize;
    };

    var $ = ParamNode.prototype;

    Object.defineProperties($, {
        value: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.env.value = value;
                }
            },
            get: function() {
                return this._.env.value;
            }
        }
    });

    $.to = function(nextValue, time, curve) {
        var _ = this._;
        var env = _.env;
        if (typeof time === "string") {
            time = timevalue(time);
        } else if (typeof time === "undefined") {
            time = 0;
        }
        if (typeof curve === "undefined") {
            _.counter = env.setNext(nextValue, time, Envelope.CurveTypeLin);
            _.curve = "lin";
        } else {
            var _curve = Envelope.CurveTypeDict[curve];
            if (typeof _curve === "undefined") {
                _.counter = env.setNext(nextValue, time, Envelope.CurveTypeCurve, curve);
            } else {
                _.counter = env.setNext(nextValue, time, _curve);
            }
            _.curve = curve;
        }
        _.plotFlush = true;
        return this;
    };

    $.setAt = function(nextValue, time) {
        var _ = this._;
        this.to(_.env.value, time, "set");
        _.atValue = nextValue;
        return this;
    };

    $.linTo = function(nextValue, time) {
        return this.to(nextValue, time, "lin");
    };

    $.expTo = function(nextValue, time) {
        return this.to(nextValue, time, "exp");
    };

    $.sinTo = function(nextValue, time) {
        return this.to(nextValue, time, "sin");
    };

    $.welTo = function(nextValue, time) {
        return this.to(nextValue, time, "wel");
    };

    $.sqrTo = function(nextValue, time) {
        return this.to(nextValue, time, "sqr");
    };

    $.cubTo = function(nextValue, time) {
        return this.to(nextValue, time, "cub");
    };

    $.cancel = function() {
        var _ = this._;
        _.counter = _.env.setNext(_.env.value, 0, Envelope.CurveTypeSet);
        return this;
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var cellL = this.cells[1];
            var cellR = this.cells[2];
            var i, imax = _.cellsize;
            var env = _.env;
            var counter = _.counter;
            var value;

            if (this.nodes.length) {
                fn.inputSignalAR(this);
            } else {
                for (i = 0; i < imax; ++i) {
                    cellL[i] = cellR[i] = 1;
                }
            }

            if (counter <= 0) {
                if (_.curve === "set") {
                    env.setNext(_.atValue, 0, Envelope.CurveTypeSet);
                } else {
                    env.setNext(env.value, 0, Envelope.CurveTypeSet);
                }
                fn.nextTick(_.onended);
                _.counter = Infinity;
            }

            if (_.ar) {
                for (i = 0; i < imax; ++i) {
                    value = env.next();
                    cellL[i] *= value;
                    cellR[i] *= value;
                }
                _.counter -= _.cellsize;
            } else {
                value = env.next();
                for (i = 0; i < imax; ++i) {
                    cellL[i] *= value;
                    cellR[i] *= value;
                }
                _.counter -= 1;
            }

            fn.outputSignalAR(this);

            _.value = value;
        }

        return this;
    };

    var super_plot = T.Object.prototype.plot;

    $.plot = function(opts) {
        var _ = this._;
        if (_.plotFlush) {
            var env  = new EnvelopeValue(128);
            var data = new Float32Array(128);
            var curve, i, imax;
            if (_.curve === "set") {
                for (i = 100, imax = data.length; i < imax; ++i) {
                    data[i] = 1;
                }
            } else {
                curve = Envelope.CurveTypeDict[_.curve];
                if (typeof curve === "undefined") {
                    env.setNext(1, 1000, Envelope.CurveTypeCurve, _.curve);
                } else {
                    env.setNext(1, 1000, curve);
                }

                for (i = 0, imax = data.length; i < imax; ++i) {
                    data[i] = env.next();
                }
            }
            _.plotData  = data;
            _.plotRange = [0, 1];
            _.plotFlush = null;
        }
        return super_plot.call(this, opts);
    };

    fn.register("param", ParamNode);

})(timbre);
(function(T) {
    "use strict";

    var fn  = T.fn;
    var Biquad = T.modules.Biquad;

    function PhaserNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.freq = T("sin", {freq:1, add:1000, mul:250}).kr();
        _.Q    = T(1);
        _.allpass  = [];

        this.steps = 2;
    }
    fn.extend(PhaserNode);

    var $ = PhaserNode.prototype;

    Object.defineProperties($, {
        freq: {
            set: function(value) {
                this._.freq = value;
            },
            get: function() {
                return this._.freq;
            }
        },
        Q: {
            set: function(value) {
                this._.Q = T(value);
            },
            get: function() {
                return this._.Q;
            }
        },
        steps: {
            set: function(value) {
                if (typeof value === "number") {
                    value |= 0;
                    if (value === 2 || value === 4 || value === 8 || value === 12) {
                        var allpass = this._.allpass;
                        if (allpass.length < value) {
                            for (var i = allpass.length; i < value; ++i) {
                                allpass[i] = new Biquad(this._.samplerate);
                                allpass[i].setType("allpass");
                            }
                        }
                    }
                    this._.steps = value;
                }
            },
            get: function() {
                return this._.steps;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            if (!_.bypassed) {
                var cellL = this.cells[1];
                var cellR = this.cells[2];
                var freq  = _.freq.process(tickID).cells[0][0];
                var Q     = _.Q.process(tickID).cells[0][0];
                var steps = _.steps;
                var i;

                for (i = 0; i < steps; i += 2) {
                    _.allpass[i  ].setParams(freq, Q, 0);
                    _.allpass[i  ].process(cellL, cellR);
                    _.allpass[i+1].setParams(freq, Q, 0);
                    _.allpass[i+1].process(cellL, cellR);
                }
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("phaser", PhaserNode);

})(timbre);
(function(T) {
    "use strict";

    // Voss algorithm
    // http://www.firstpr.com.au/dsp/pink-noise/

    var MAX_KEY = 31;
    var fn = T.fn;

    function PinkNoiseNode(_args) {
        T.Object.call(this, 1, _args);
        fn.fixAR(this);

        var whites = new Uint8Array(5);
        for (var i = 0; i < 5; ++i) {
            whites[i] = ((Math.random() * (1<<30))|0) % 25;
        }
        this._.whites = whites;
        this._.key = 0;
    }
    fn.extend(PinkNoiseNode);

    var $ = PinkNoiseNode.prototype;

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var i, imax, j;
            var key = _.key, whites = _.whites;
            var mul = _.mul, add = _.add;
            var last_key, sum, diff;

            for (i = 0, imax = cell.length; i < imax; ++i) {
                last_key = key++;
                if (key > MAX_KEY) {
                    key = 0;
                }
                diff = last_key ^ key;
                for (j = sum = 0; j < 5; ++j) {
                    if (diff & (1 << j)) {
                        whites[j] = ((Math.random() * (1<<30))|0) % 25;
                    }
                    sum += whites[j];
                }
                cell[i] = ((sum * 0.01666666) - 1) * mul + add;
            }
            _.key = key;
        }
        return this;
    };

    fn.register("pink", PinkNoiseNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function PluckNode(_args) {
        T.Object.call(this, 1, _args);

        this._.freq   = 440;
        this._.buffer = null;
        this._.index  = 0;
    }
    fn.extend(PluckNode);

    var $ = PluckNode.prototype;

    Object.defineProperties($, {
        freq: {
            set: function(value) {
                if (typeof value === "number") {
                    if (value < 0) {
                        value = 0;
                    }
                    this._.freq = value;
                }
            },
            get: function() {
                return this._.freq;
            }
        }
    });

    $.bang = function() {
        var _ = this._;
        var freq   = _.freq;
        var size   = (_.samplerate / freq + 0.5)|0;
        var buffer = _.buffer = new fn.SignalArray(size);
        for (var i = 0; i < size; ++i) {
            buffer[i] = Math.random() * 2 - 1;
        }
        _.index = 0;
        _.emit("bang");
        return this;
    };

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var buffer = _.buffer;
            if (buffer) {
                var bufferLength = buffer.length;
                var index = _.index, write;
                var mul = _.mul, add = _.add;
                var x, i, imax = cell.length;

                for (i = 0; i < imax; ++i) {
                    write = index;
                    x = buffer[index++];
                    if (index >= bufferLength) {
                        index = 0;
                    }
                    x = (x + buffer[index]) * 0.5;
                    buffer[write] = x;
                    cell[i] = x * mul + add;
                }
                _.index = index;
            }
        }

        return this;
    };

    fn.register("pluck", PluckNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;

    var STATUS_WAIT = 0;
    var STATUS_REC  = 1;

    function RecNode(_args) {
        T.Object.call(this, 1, _args);
        fn.listener(this);
        fn.fixAR(this);

        var _ = this._;
        _.timeout    = 5000;
        _.status     = STATUS_WAIT;
        _.writeIndex = 0;
        _.writeIndexIncr  = 1;
        _.currentTime     = 0;
        _.currentTimeIncr = 1000 / _.samplerate;
        _.onended = make_onended(this);
    }
    fn.extend(RecNode);

    var make_onended = function(self) {
        return function() {
            var _ = self._;

            var buffer = new fn.SignalArray(_.buffer.subarray(0, _.writeIndex|0));

            _.status      = STATUS_WAIT;
            _.writeIndex  = 0;
            _.currentTime = 0;

            _.emit("ended", {
                buffer:buffer, samplerate:_.samplerate
            });
        };
    };

    var $ = RecNode.prototype;

    Object.defineProperties($, {
        timeout: {
            set: function(value) {
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                if (typeof value === "number" && value > 0) {
                    this._.timeout = value;
                }
            },
            get: function() {
                return this._.timeout;
            }
        },
        samplerate: {
            set: function(value) {
                if (typeof value === "number") {
                    if (0 < value && value <= this._.samplerate) {
                        this._.samplerate = value;
                    }
                }
            },
            get: function() {
                return this._.samplerate;
            }
        },
        currentTime: {
            get: function() {
                return this._.currentTime;
            }
        }
    });

    $.start = function() {
        var _ = this._, len;
        if (_.status === STATUS_WAIT) {
            len = (_.timeout * 0.01 * _.samplerate)|0;
            if (!_.buffer || _.buffer.length < len) {
                _.buffer = new fn.SignalArray(len);
            }
            _.writeIndex = 0;
            _.writeIndexIncr = _.samplerate / T.samplerate;
            _.currentTime = 0;
            _.status = STATUS_REC;
            _.emit("start");
            this.listen();
        }
        return this;
    };

    $.stop = function() {
        var _ = this._;
        if (_.status === STATUS_REC) {
            _.status = STATUS_WAIT;
            _.emit("stop");
            fn.nextTick(_.onended);
            this.unlisten();
        }
        return this;
    };

    $.bang = function() {
        if (this._.status === STATUS_WAIT) {
            this.srart();
        } else if (this._.status === STATUS_REC) {
            this.stop();
        }
        this._.emit("bang");
        return this;
    };

    $.process = function(tickID) {
        var _ = this._;
        var cell = this.cells[0];

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            if (_.status === STATUS_REC) {
                var i, imax = cell.length;
                var buffer  = _.buffer;
                var timeout = _.timeout;
                var writeIndex      = _.writeIndex;
                var writeIndexIncr  = _.writeIndexIncr;
                var currentTime     = _.currentTime;
                var currentTimeIncr = _.currentTimeIncr;

                for (i = 0; i < imax; ++i) {
                    buffer[writeIndex|0] = cell[i];
                    writeIndex += writeIndexIncr;

                    currentTime += currentTimeIncr;
                    if (timeout <= currentTime) {
                        fn.nextTick(_.onended);
                    }
                }
                _.writeIndex  = writeIndex;
                _.currentTime = currentTime;
            }

            fn.outputSignalAR(this);
        }
        return this;
    };

    fn.register("record", RecNode);
    fn.alias("rec", "record");

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var Reverb = T.modules.Reverb;

    function ReverbNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        this._.reverb = new Reverb(this._.samplerate, this._.cellsize);
    }
    fn.extend(ReverbNode);

    var $ = ReverbNode.prototype;

    Object.defineProperties($, {
        room: {
            set: function(value) {
                if (typeof value === "number") {
                    value = (value > 1) ? 1 : (value < 0) ? 0 : value;
                    this._.reverb.setRoomSize(value);
                }
            },
            get: function() {
                return this._.reverb.roomsize;
            }
        },
        damp: {
            set: function(value) {
                if (typeof value === "number") {
                    value = (value > 1) ? 1 : (value < 0) ? 0 : value;
                    this._.reverb.setDamp(value);
                }
            },
            get: function() {
                return this._.reverb.damp;
            }
        },
        mix: {
            set: function(value) {
                if (typeof value === "number") {
                    value = (value > 1) ? 1 : (value < 0) ? 0 : value;
                    this._.reverb.wet = value;
                }
            },
            get: function() {
                return this._.reverb.wet;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            if (!_.bypassed) {
                _.reverb.process(this.cells[1], this.cells[2]);
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("reverb", ReverbNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;

    function ScheduleNode(_args) {
        T.Object.call(this, 0, _args);
        fn.timer(this);
        fn.fixKR(this);

        var _ = this._;
        _.queue = [];
        _.currentTime = 0;
        _.maxRemain   = 1000;
    }
    fn.extend(ScheduleNode);

    var $ = ScheduleNode.prototype;

    Object.defineProperties($, {
        queue: {
            get: function() {
                return this._.queue;
            }
        },
        remain: {
            get: function() {
                return this._.queue.length;
            }
        },
        maxRemain: {
            set: function(value) {
                if (typeof value === "number" && value > 0) {
                    this._.maxRemain = value;
                }
            },
            get: function() {
                return this._.maxRemain;
            }
        },
        isEmpty: {
            get: function() {
                return this._.queue.length === 0;
            }
        },
        currentTime: {
            get: function() {
                return this._.currentTime;
            }
        }
    });

    $.sched = function(delta, item, args) {
        if (typeof delta === "string") {
            delta = timevalue(delta);
        }
        if (typeof delta === "number") {
            this.schedAbs(this._.currentTime + delta, item, args);
        }
        return this;
    };

    $.schedAbs = function(time, item, args) {
        if (typeof time === "string") {
            time = timevalue(time);
        }
        if (typeof time === "number") {
            var _ = this._;
            var queue = _.queue;
            if (queue.length >= _.maxRemain) {
                return this;
            }
            for (var i = queue.length; i--; ) {
                if (queue[i][0] < time) {
                    break;
                }
            }
            queue.splice(i + 1, 0, [time, T(item), args]);
        }
        return this;
    };

    $.advance = function(delta) {
        if (typeof delta === "string") {
            delta = timevalue(delta);
        }
        if (typeof delta === "number") {
            this._.currentTime += delta;
        }
        return this;
    };

    $.clear = function() {
        this._.queue.splice(0);
        return this;
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var emit = null;
            var queue = _.queue;

            if (queue.length) {
                while (queue[0][0] < _.currentTime) {
                    var nextItem = _.queue.shift();
                    nextItem[1].bang(nextItem[2]);
                    emit = "sched";
                    if (queue.length === 0) {
                        emit = "empty";
                        break;
                    }
                }
            }
            _.currentTime += fn.currentTimeIncr;
            if (emit) {
                _.emit(emit);
            }
        }
        return this;
    };

    fn.register("schedule", ScheduleNode);
    fn.alias("sched", "schedule");

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;

    function ScopeNode(_args) {
        T.Object.call(this, 2, _args);
        fn.listener(this);
        fn.fixAR(this);

        var _ = this._;
        _.samples    = 0;
        _.writeIndex = 0;
        _.plotFlush = true;

        this.once("init", oninit);
    }
    fn.extend(ScopeNode);

    var oninit = function() {
        if (!this._.buffer) {
            this.size = 1024;
        }
        if (!this._.interval) {
            this.interval = 1000;
        }
    };

    var $ = ScopeNode.prototype;

    Object.defineProperties($, {
        size: {
            set: function(value) {
                var _ = this._;
                if (!_.buffer) {
                    if (typeof value === "number") {
                        var n = (value < 64) ? 64 : (value > 2048) ? 2048 : value;
                        _.buffer = new fn.SignalArray(n);
                        if (_.reservedinterval) {
                            this.interval = _.reservedinterval;
                            _.reservedinterval = null;
                        }
                    }
                }
            },
            get: function() {
                return this._.buffer.length;
            }
        },
        interval: {
            set: function(value) {
                var _ = this._;
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                if (typeof value === "number" && value > 0) {
                    if (!_.buffer) {
                        _.reservedinterval = value;
                    } else {
                        _.interval    = value;
                        _.samplesIncr = value * 0.001 * _.samplerate / _.buffer.length;
                        if (_.samplesIncr < 1) {
                            _.samplesIncr = 1;
                        }
                    }
                }
            },
            get: function() {
                return this._.interval;
            }
        },
        buffer: {
            get: function() {
                return this._.buffer;
            }
        }
    });

    $.bang = function() {
        var _ = this._;
        var buffer = _.buffer;

        for (var i = 0, imax = buffer.length; i < imax; ++i) {
            buffer[i] = 0;
        }
        _.samples    = 0;
        _.writeIndex = 0;
        this._.emit("bang");
        return this;
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);
            fn.outputSignalAR(this);

            var cell = this.cells[0];
            var i, imax = _.cellsize;
            var samples     = _.samples;
            var samplesIncr = _.samplesIncr;
            var buffer      = _.buffer;
            var writeIndex  = _.writeIndex;
            var emit = false;
            var bufferlength = buffer.length;

            for (i = 0; i < imax; ++i) {
                if (samples <= 0) {
                    buffer[writeIndex++] = cell[i];
                    if (writeIndex >= bufferlength) {
                        writeIndex = 0;
                    }
                    emit = _.plotFlush = true;
                    samples += samplesIncr;
                }
                --samples;
            }
            _.samples    = samples;
            _.writeIndex = writeIndex;

            if (emit) {
                this._.emit("data");
            }
        }

        return this;
    };

    var super_plot = T.Object.prototype.plot;

    $.plot = function(opts) {
        var _ = this._;
        if (_.plotFlush) {
            var buffer = _.buffer;
            var mask   = buffer.length - 1;
            var data   = new Float32Array(buffer.length);
            var j = _.writeIndex;
            for (var i = 0, imax = buffer.length; i < imax; i++) {
                data[i] = buffer[++j & mask];
            }
            _.plotData  = data;
            _.plotFlush = null;
        }
        return super_plot.call(this, opts);
    };

    fn.register("scope", ScopeNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function ScriptProcessorNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.numberOfInputs = 0;
        _.numberOfOutputs = 0;
        _.bufferSize = 0;
        _.bufferMask = 0;
        _.duration   = 0;
        _.inputBufferL = null;
        _.inputBufferR = null;
        _.outputBufferL = null;
        _.outputBufferR = null;
        _.onaudioprocess = null;
        _.index = 0;
        this.once("init", oninit);
    }
    fn.extend(ScriptProcessorNode);

    var oninit = function() {
        var _ = this._;
        if (_.numberOfInputs === 0) {
            this.numberOfInputs = 1;
        }
        if (_.numberOfOutputs === 0) {
            this.numberOfOutputs = 1;
        }
        if (_.bufferSize === 0) {
            this.bufferSize = 1024;
        }
    };

    var $ = ScriptProcessorNode.prototype;

    Object.defineProperties($, {
        numberOfInputs: {
            set: function(value) {
                var _ = this._;
                if (_.numberOfInputs === 0) {
                    _.numberOfInputs = (value === 2) ? 2 : 1;
                }
            },
            get: function() {
                return this._.numberOfInputs;
            }
        },
        numberOfOutputs: {
            set: function(value) {
                var _ = this._;
                if (_.numberOfOutputs === 0) {
                    _.numberOfOutputs = (value === 2) ? 2 : 1;
                }
            },
            get: function() {
                return this._.numberOfOutputs;
            }
        },
        bufferSize: {
            set: function(value) {
                var _ = this._;
                if (_.bufferSize === 0) {
                    if ([256, 512, 1024, 2048, 4096, 8192, 16384].indexOf(value) !== -1) {
                        _.bufferSize = value;
                        _.bufferMask = value - 1;
                        _.duration = value / _.samplerate;
                        _.inputBufferL  = new fn.SignalArray(value);
                        _.inputBufferR  = new fn.SignalArray(value);
                        _.outputBufferL = new fn.SignalArray(value);
                        _.outputBufferR = new fn.SignalArray(value);
                    }
                }
            },
            get: function() {
                return this._.bufferSize;
            }
        },
        onaudioprocess: {
            set: function(value) {
                if (typeof value === "function") {
                    this._.onaudioprocess = value;
                }
            },
            get: function() {
                return this._.onaudioprocess;
            }
        }
    });

    function AudioBuffer(self, buffers) {
        this.samplerate = self._.samplerate;
        this.length     = self._.bufferSize;
        this.duration   = self._.duration;
        this.numberOfChannels = buffers.length;
        this.getChannelData = function(n) {
            return buffers[n];
        };
    }

    function AudioProcessingEvent(self) {
        var _ = self._;
        this.node = self;
        this.playbackTime = T.currentTime;
        if (_.numberOfInputs === 2) {
            this.inputBuffer  = new AudioBuffer(self, [_.inputBufferL, _.inputBufferR]);
        } else {
            this.inputBuffer  = new AudioBuffer(self, [_.inputBufferL]);
        }
        if (_.numberOfOutputs === 2) {
            this.outputBuffer = new AudioBuffer(self, [_.outputBufferL, _.outputBufferR]);
        } else {
            this.outputBuffer = new AudioBuffer(self, [_.outputBufferL]);
        }
    }

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var cellsize   = _.cellsize;
            var bufferMask = _.bufferMask;
            var begin = _.index;
            var end   = begin + cellsize;
            var buffer;
            var cellL  = this.cells[1];
            var cellR  = this.cells[2];

            fn.inputSignalAR(this);

            if (_.numberOfInputs === 2) {
                _.inputBufferL.set(cellL, begin);
                _.inputBufferR.set(cellR, begin);
            } else {
                buffer = _.inputBufferL;
                for (var i = 0; i < cellsize; i++) {
                    buffer[begin + i] = (cellL[i] + cellR[i]) * 0.5;
                }
            }

            cellL.set(_.outputBufferL.subarray(begin, end));
            cellR.set(_.outputBufferR.subarray(begin, end));

            _.index = end & bufferMask;

            if (_.index === 0 && _.onaudioprocess) {
                _.onaudioprocess(new AudioProcessingEvent(this));
                if (_.numberOfOutputs === 1) {
                    _.outputBufferR.set(_.outputBufferL);
                }
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("script", ScriptProcessorNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function SelectorNode(_args) {
        T.Object.call(this, 2, _args);

        this._.selected   = 0;
        this._.background = false;
    }
    fn.extend(SelectorNode);

    var $ = SelectorNode.prototype;

    Object.defineProperties($, {
        selected: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.selected = value;
                    this.cells[1].set(fn.emptycell);
                    this.cells[2].set(fn.emptycell);
                }
            },
            get: function() {
                return this._.selected;
            }
        },
        background: {
            set: function(value) {
                this._.background = !!value;
            },
            get: function() {
                return this._.background;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var nodes = this.nodes;
            var i, imax = nodes.length;

            if (_.background) {
                for (i = 0; i < imax; ++i) {
                    nodes[i].process(tickID);
                }
            }

            var tmp = nodes[_.selected];
            if (tmp) {
                if (!_.background) {
                    tmp.process(tickID);
                }
                this.cells[1].set(tmp.cells[1]);
                this.cells[2].set(tmp.cells[2]);
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("selector", SelectorNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;
    var FFT = T.modules.FFT;

    var WAIT_STATE = 0;
    var EXEC_STATE = 1;

    function SpectrumNode(_args) {
        T.Object.call(this, 2, _args);
        fn.listener(this);
        fn.fixAR(this);

        var _ = this._;
        _.status  = WAIT_STATE;
        _.samples = 0;
        _.samplesIncr = 0;
        _.writeIndex  = 0;

        _.plotFlush = true;
        _.plotRange = [0, 32];
        _.plotBarStyle = true;

        this.once("init", oninit);
    }
    fn.extend(SpectrumNode);

    var oninit = function() {
        var _ = this._;
        if (!_.fft) {
            this.size = 512;
        }
        if (!_.interval) {
            this.interval = 500;
        }
    };

    var $ = SpectrumNode.prototype;

    Object.defineProperties($, {
        size: {
            set: function(value) {
                var _ = this._;
                if (!_.fft) {
                    if (typeof value === "number") {
                        var n = (value < 256) ? 256 : (value > 2048) ? 2048 : value;
                        _.fft    = new FFT(n);
                        _.buffer = new fn.SignalArray(_.fft.length);
                        _.freqs  = new fn.SignalArray(_.fft.length>>1);
                        if (_.reservedwindow) {
                            _.fft.setWindow(_.reservedwindow);
                            _.reservedwindow = null;
                        }
                        if (_.reservedinterval) {
                            this.interval = _.reservedinterval;
                            _.reservedinterval = null;
                        }
                    }
                }
            },
            get: function() {
                return this._.buffer.length;
            }
        },
        window: {
            set: function(value) {
                this._.fft.setWindow(value);
            },
            get: function() {
                return this._.fft.windowName;
            }
        },
        interval: {
            set: function(value) {
                var _ = this._;
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                if (typeof value === "number" && value > 0) {
                    if (!_.buffer) {
                        _.reservedinterval = value;
                    } else {
                        _.interval = value;
                        _.samplesIncr = (value * 0.001 * _.samplerate);
                        if (_.samplesIncr < _.buffer.length) {
                            _.samplesIncr = _.buffer.length;
                            _.interval = _.samplesIncr * 1000 / _.samplerate;
                        }
                    }
                }
            },
            get: function() {
                return this._.interval;
            }
        },
        spectrum: {
            get: function() {
                return this._.fft.getFrequencyData(this._.freqs);
            }
        },
        real: {
            get: function() {
                return this._.fft.real;
            }
        },
        imag: {
            get: function() {
                return this._.fft.imag;
            }
        }
    });

    $.bang = function() {
        this._.samples    = 0;
        this._.writeIndex = 0;
        this._.emit("bang");
        return this;
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);
            fn.outputSignalAR(this);

            var cell = this.cells[0];
            var i, imax = cell.length;
            var status  = _.status;
            var samples = _.samples;
            var samplesIncr = _.samplesIncr;
            var writeIndex  = _.writeIndex;
            var buffer = _.buffer;
            var bufferLength = buffer.length;
            var emit;

            for (i = 0; i < imax; ++i) {
                if (samples <= 0) {
                    if (status === WAIT_STATE) {
                        status = EXEC_STATE;
                        writeIndex = 0;
                        samples += samplesIncr;
                    }
                }
                if (status === EXEC_STATE) {
                    buffer[writeIndex++] = cell[i];
                    if (bufferLength <= writeIndex) {
                        _.fft.forward(buffer);
                        emit = _.plotFlush = true;
                        status = WAIT_STATE;
                    }
                }
                --samples;
            }

            _.samples = samples;
            _.status  = status;
            _.writeIndex = writeIndex;

            if (emit) {
                this._.emit("data");
            }
        }
        return this;
    };

    var super_plot = T.Object.prototype.plot;

    $.plot = function(opts) {
        if (this._.plotFlush) {
            this._.plotData  = this.spectrum;
            this._.plotFlush = null;
        }
        return super_plot.call(this, opts);
    };

    fn.register("spectrum", SpectrumNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function SubtractNode(_args) {
        T.Object.call(this, 2, _args);
        this._.ar = false;
    }
    fn.extend(SubtractNode);

    var $ = SubtractNode.prototype;

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var nodes = this.nodes;
            var cell  = this.cells[0];
            var cellL = this.cells[1];
            var cellR = this.cells[2];
            var i, imax = nodes.length;
            var j, jmax = cell.length;
            var tmp, tmpL, tmpR;

            if (_.ar) {
                if (nodes.length > 0) {
                    nodes[0].process(tickID);
                    tmpL = nodes[0].cells[1];
                    tmpR = nodes[0].cells[2];
                    cellL.set(tmpL);
                    cellR.set(tmpR);
                    for (i = 1; i < imax; ++i) {
                        nodes[i].process(tickID);
                        tmpL = nodes[i].cells[1];
                        tmpR = nodes[i].cells[2];
                        for (j = 0; j < jmax; ++j) {
                            cellL[j] -= tmpL[j];
                            cellR[j] -= tmpR[j];
                        }
                    }
                } else {
                    for (j = 0; j < jmax; ++j) {
                        cellL[j] = cellR[i] = 0;
                    }
                }
                fn.outputSignalAR(this);
            } else {
                if (nodes.length > 0) {
                    tmp = nodes[0].process(tickID).cells[0][0];
                    for (i = 1; i < imax; ++i) {
                        tmp -= nodes[i].process(tickID).cells[0][0];
                    }
                } else {
                    tmp = 0;
                }
                cell[0] = tmp;
                fn.outputSignalKR(this);
            }
        }

        return this;
    };

    fn.register("-", SubtractNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function SynthDefNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        this.playbackState = fn.FINISHED_STATE;
        _.poly     = 4;
        _.genList  = [];
        _.genDict  = {};
        _.synthdef = null;
        _.remGen = make_remGen(this);
        _.onended = fn.make_onended(this);
    }
    fn.extend(SynthDefNode);

    var $ = SynthDefNode.prototype;

    Object.defineProperties($, {
        def: {
            set: function(value) {
                if (typeof value === "function") {
                    this._.synthdef = value;
                }
            },
            get: function() {
                return this._.synthdef;
            }
        },
        poly: {
            set: function(value) {
                if (typeof value === "number") {
                    if (0 < value && value <= 64) {
                        this._.poly = value;
                    }
                }
            },
            get: function() {
                return this._.poly;
            }
        }
    });

    var make_doneAction = function(self, opts) {
        return function() {
            self._.remGen(opts.gen);
        };
    };

    var make_remGen = function(self) {
        return function(gen) {
            var _ = self._;
            var i = _.genList.indexOf(gen);
            if (i !== -1) {
                _.genList.splice(i, 1);
            }
            if (typeof gen.noteNum !== "undefined") {
                _.genDict[gen.noteNum] = null;
            }
        };
    };

    var noteOn = function(noteNum, freq, velocity, _opts) {
        velocity |= 0;
        if (velocity <= 0) {
            this.noteOff(this, noteNum);
        } else if (velocity > 127) {
            velocity = 127;
        }
        var _ = this._;
        var list = _.genList, dict = _.genDict;
        var gen = dict[noteNum];
        if (gen) {
            _.remGen(gen);
        }

        var opts = {
            freq    : freq,
            noteNum : noteNum,
            velocity: velocity,
            mul     : velocity * 0.0078125
        };
        if (_opts) {
            for (var key in _opts) {
                opts[key] = _opts[key];
            }
        }
        opts.doneAction = make_doneAction(this, opts);

        gen = _.synthdef.call(this, opts);

        if (gen instanceof T.Object) {
            gen.noteNum = noteNum;
            list.push(gen);
            dict[noteNum] = opts.gen = gen;

            this.playbackState = fn.PLAYING_STATE;

            if (list.length > _.poly) {
                _.remGen(list[0]);
            }
        }
    };

    var midicps = (function() {
        var table = new Float32Array(128);
        for (var i = 0; i < 128; ++i) {
            table[i] = 440 * Math.pow(2, (i - 69) * 1 / 12);
        }
        return table;
    })();

    var cpsmidi = function(cps) {
        if (cps > 0) {
            return Math.log(cps * 1 / 440) * Math.LOG2E * 12 + 69;
        } else {
            return 0;
        }
    };

    $.noteOn = function(noteNum, velocity, _opts) {
        var freq = midicps[noteNum] || (440 * Math.pow(2, (noteNum - 69) / 12));
        noteOn.call(this, (noteNum + 0.5)|0, freq, velocity, _opts);
        return this;
    };

    $.noteOff = function(noteNum) {
        var gen = this._.genDict[noteNum];
        if (gen && gen.release) {
            gen.release();
        }
        return this;
    };

    $.noteOnWithFreq = function(freq, velocity, _opts) {
        var noteNum = cpsmidi(freq);
        noteOn.call(this, (noteNum + 0.5)|0, freq, velocity, _opts);
        return this;
    };

    $.noteOffWithFreq = function(freq) {
        var noteNum = cpsmidi(freq);
        return this.noteOff((noteNum + 0.5)|0);
    };

    $.allNoteOff = function() {
        var list = this._.genList;
        for (var i = 0, imax = list.length; i < imax; ++i) {
            if (list[i].release) {
                list[i].release();
            }
        }
    };

    $.allSoundOff = function() {
        var _ = this._;
        var list = _.genList;
        var dict = _.genDict;
        while (list.length) {
            delete dict[list.shift().noteNum];
        }
    };

    $.synth = function(_opts) {
        var _ = this._;
        var list = _.genList;
        var gen, opts = {};

        if (_opts) {
            for (var key in _opts) {
                opts[key] = _opts[key];
            }
        }
        opts.doneAction = make_doneAction(this, opts);

        gen = _.synthdef.call(this, opts);

        if (gen instanceof T.Object) {
            list.push(gen);
            opts.gen = gen;
            this.playbackState = fn.PLAYING_STATE;

            if (list.length > _.poly) {
                _.remGen(list[0]);
            }
        }

        return this;
    };

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            if (this.playbackState === fn.PLAYING_STATE) {
                var list = _.genList;
                var gen;
                var cellL = this.cells[1];
                var cellR = this.cells[2];
                var i, imax;
                var j, jmax = cell.length;
                var tmpL, tmpR;

                if (list.length) {
                    gen = list[0];
                    gen.process(tickID);
                    cellL.set(gen.cells[1]);
                    cellR.set(gen.cells[2]);
                    for (i = 1, imax = list.length; i < imax; ++i) {
                        gen = list[i];
                        gen.process(tickID);
                        tmpL = gen.cells[1];
                        tmpR = gen.cells[2];
                        for (j = 0; j < jmax; ++j) {
                            cellL[j] += tmpL[j];
                            cellR[j] += tmpR[j];
                        }
                    }
                } else {
                    fn.nextTick(_.onended);
                }
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("SynthDef", SynthDefNode);


    var env_desc = {
        set: function(value) {
            if (fn.isDictionary(value)) {
                if (typeof value.type === "string") {
                    this._.env = value;
                }
            } else if (value instanceof T.Object) {
                this._.env = value;
            }
        },
        get: function() {
            return this._.env;
        }
    };

    fn.register("OscGen", (function() {

        var osc_desc = {
            set: function(value) {
                if (value instanceof T.Object) {
                    this._.osc = value;
                }
            },
            get: function() {
                return this._.osc;
            }
        };

        var wave_desc = {
            set: function(value) {
                if (typeof value === "string") {
                    this._.wave = value;
                }
            },
            get: function() {
                return this._.wave;
            }
        };

        var synthdef = function(opts) {
            var _ = this._;
            var synth, osc, env, envtype;

            osc = _.osc || null;
            env = _.env || {};
            envtype = env.type || "perc";

            if (osc instanceof T.Object) {
                if (typeof osc.clone === "function") {
                    osc = osc.clone();
                }
            }
            if (!osc) {
                osc = T("osc", {wave:_.wave});
            }
            osc.freq = opts.freq;
            osc.mul  = osc.mul * opts.velocity/128;

            synth = osc;
            if (env instanceof T.Object) {
                if (typeof env.clone === "function") {
                    synth = env.clone().append(synth);
                }
            } else {
                synth = T(envtype, env, synth);
            }
            synth.on("ended", opts.doneAction).bang();

            return synth;
        };

        return function(_args) {
            var instance = new SynthDefNode(_args);

            instance._.wave = "sin";

            Object.defineProperties(instance, {
                env: env_desc, osc: osc_desc, wave: wave_desc
            });

            instance.def = synthdef;

            return instance;
        };
    })());

    fn.register("PluckGen", (function() {

        var synthdef = function(opts) {
            var _ = this._;
            var synth, env, envtype;

            env = _.env || {};
            envtype = env.type || "perc";

            synth = T("pluck", {freq:opts.freq, mul:opts.velocity/128}).bang();
            if (env instanceof T.Object) {
                if (typeof env.clone === "function") {
                    synth = env.clone().append(synth);
                }
            } else {
                synth = T(envtype, env, synth);
            }
            synth.on("ended", opts.doneAction).bang();

            return synth;
        };

        return function(_args) {
            var instance = new SynthDefNode(_args);

            Object.defineProperties(instance, {
                env: env_desc
            });

            instance.def = synthdef;

            return instance;
        };
    })());

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var Scissor    = T.modules.Scissor;
    var Tape       = Scissor.Tape;
    var TapeStream = Scissor.TapeStream;
    var isSignalArray = fn.isSignalArray;

    function ScissorNode(_args) {
        T.Object.call(this, 2, _args);
        fn.fixAR(this);

        var _ = this._;
        _.isLooped = false;
        _.onended  = fn.make_onended(this, 0);
    }
    fn.extend(ScissorNode);

    var $ = ScissorNode.prototype;

    Object.defineProperties($, {
        tape: {
            set: function(tape) {
                if (tape instanceof Tape) {
                    this.playbackState = fn.PLAYING_STATE;
                    this._.tape = tape;
                    this._.tapeStream = new TapeStream(tape, this._.samplerate);
                    this._.tapeStream.isLooped = this._.isLooped;
                } else {
                    if (tape instanceof T.Object) {
                        if (tape.buffer) {
                            tape = tape.buffer;
                        }
                    }
                    if (typeof tape === "object") {
                        if (Array.isArray(tape.buffer) && isSignalArray(tape.buffer[0])) {
                            this.playbackState = fn.PLAYING_STATE;
                            this._.tape = new Scissor(tape);
                            this._.tapeStream = new TapeStream(this._.tape, this._.samplerate);
                            this._.tapeStream.isLooped = this._.isLooped;
                        }
                    }
                }
            },
            get: function() {
                return this._.tape;
            }
        },
        isLooped: {
            get: function() {
                return this._.isLooped;
            }
        },
        buffer: {
            get: function() {
                if (this._.tape) {
                    return this._.tape.getBuffer();
                }
            }
        }
    });

    $.loop = function(value) {
        this._.isLooped = !!value;
        if (this._.tapeStream) {
            this._.tapeStream.isLooped = this._.isLooped;
        }
        return this;
    };

    $.bang = function() {
        this.playbackState = fn.PLAYING_STATE;
        if (this._.tapeStream) {
            this._.tapeStream.reset();
        }
        this._.emit("bang");
        return this;
    };

    $.getBuffer = function() {
        if (this._.tape) {
            return this._.tape.getBuffer();
        }
    };

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var tapeStream = _.tapeStream;

            if (tapeStream) {
                var cellL = this.cells[1];
                var cellR = this.cells[2];
                var tmp  = tapeStream.fetch(cellL.length);
                cellL.set(tmp[0]);
                cellR.set(tmp[1]);
                if (this.playbackState === fn.PLAYING_STATE && tapeStream.isEnded) {
                    fn.nextTick(_.onended);
                }
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("tape", ScissorNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;
    var FunctionWrapper = T(function(){}).constructor;

    function TaskNode(_args) {
        T.Object.call(this, 1, _args);
        fn.timer(this);

        var _ = this._;
        this.playbackState = fn.FINISHED_STATE;
        _.task = [];
        _.i     = 0;
        _.j     = 0;
        _.imax  = 0;
        _.jmax  = 0;
        _.wait  = 0;
        _.count = 0;
        _.args  = {};
        _.doNum = 1;
        _.initFunc = fn.nop;
        _.onended = make_onended(this);

        this.on("start", onstart);
    }
    fn.extend(TaskNode);

    var onstart = function() {
        var _ = this._, args;
        this.playbackState = fn.PLAYING_STATE;
        _.task = this.nodes.map(function(x) {
            return x instanceof FunctionWrapper ? x.func : false;
        }).filter(function(x) {
            return !!x;
        });
        _.i = _.j = 0;
        _.imax = _.doNum;
        _.jmax = _.task.length;
        args = _.initFunc();
        if (!fn.isDictionary(args)) {
            args = {param:args};
        }
        _.args = args;
    };

    var make_onended = function(self) {
        return function() {
            self.playbackState = fn.FINISHED_STATE;
            var _ = self._;
            var cell  = self.cells[0];
            var cellL = self.cells[1];
            var cellR = self.cells[2];
            var lastValue = _.args;
            if (typeof lastValue === "number") {
                for (var i = 0, imax = cellL.length; i < imax; ++i) {
                    cell[0] = cellL[i] = cellR[i] = lastValue;
                }
            }
            _.emit("ended", _.args);
        };
    };

    var $ = TaskNode.prototype;

    Object.defineProperties($, {
        "do": {
            set: function(value) {
                if (typeof value === "number" && value > 0) {
                    this._.doNum = value === Infinity ? Infinity : value|0;
                }
            },
            get: function() {
                return this._.doNum;
            }
        },
        init: {
            set: function(value) {
                if (typeof value === "function") {
                    this._.initFunc = value;
                }
            },
            get: function() {
                return this._.initFunc;
            }
        }
    });

    $.bang = function() {
        var _ = this._;
        _.count  = 0;
        _.emit("bang");
        return this;
    };

    $.wait = function(time) {
        if (typeof time === "string") {
            time = timevalue(time);
        }
        if (typeof time === "number" && time > 0) {
            this._.count += (this._.samplerate * time * 0.001)|0;
        }
        return this;
    };

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;
        var args, func;

        if (this.tickID !== tickID) {
            this.tickID = tickID;
            if (_.i < _.imax) {
                while (_.count <= 0) {
                    if (_.j >= _.jmax) {
                        ++_.i;
                        if (_.i >= _.imax) {
                            fn.nextTick(_.onended);
                            break;
                        }
                        _.j = 0;
                    }
                    func = _.task[_.j++];
                    if (func) {
                        func.call(this, _.i, _.args);
                    }
                }
                _.count -= cell.length;
            }
        }

        return this;
    };

    fn.register("task", TaskNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;
    var timevalue = T.timevalue;

    function TimeoutNode(_args) {
        T.Object.call(this, 0, _args);
        fn.timer(this);
        fn.fixKR(this);

        var _ = this._;
        this.playbackState = fn.FINISHED_STATE;
        _.currentTime = 0;
        _.samplesMax = 0;
        _.samples    = 0;
        _.onended = fn.make_onended(this);

        this.once("init", oninit);
        this.on("start", onstart);
    }

    fn.extend(TimeoutNode);

    var oninit = function() {
        if (!this._.timeout) {
            this.timeout = 1000;
        }
    };

    var onstart = function() {
        this.playbackState = fn.PLAYING_STATE;
    };
    Object.defineProperty(onstart, "unremovable", {
        value:true, writable:false
    });

    var $ = TimeoutNode.prototype;

    Object.defineProperties($, {
        timeout: {
            set: function(value) {
                var _ = this._;
                if (typeof value === "string") {
                    value = timevalue(value);
                }
                if (typeof value === "number" && value >= 0) {
                    this.playbackState = fn.PLAYING_STATE;
                    _.timeout = value;
                    _.samplesMax = (_.samplerate * (value * 0.001))|0;
                    _.samples = _.samplesMax;
                }
            },
            get: function() {
                return this._.timeout;
            }
        },
        currentTime: {
            get: function() {
                return this._.currentTime;
            }
        }
    });

    $.bang = function() {
        var _ = this._;
        this.playbackState = fn.PLAYING_STATE;
        _.samples = _.samplesMax;
        _.currentTime = 0;
        _.emit("bang");
        return this;
    };

    $.process = function(tickID) {
        var cell = this.cells[0];
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            if (_.samples > 0) {
                _.samples -= cell.length;
            }

            if (_.samples <= 0) {
                var nodes = this.nodes;
                for (var i = 0, imax = nodes.length; i < imax; ++i) {
                    nodes[i].bang();
                }
                fn.nextTick(_.onended);
            }
            _.currentTime += fn.currentTimeIncr;
        }
        return this;
    };

    fn.register("timeout", TimeoutNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function WaveShaperNode(_args) {
        T.Object.call(this, 1, _args);
        fn.fixAR(this);

        this._.curve = null;
    }
    fn.extend(WaveShaperNode);

    var $ = WaveShaperNode.prototype;

    Object.defineProperties($, {
        curve: {
            set: function(value) {
                if (fn.isSignalArray(value)) {
                    this._.curve = value;
                }
            },
            get: function() {
                return this._.curve;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            fn.inputSignalAR(this);

            if (_.curve) {
                var cell = this.cells[0];
                var curve = _.curve;
                var len    = curve.length;
                var x, i, imax = _.cellsize;
                for (i = 0; i < imax; ++i) {
                    x = (((cell[i] + 1) * 0.5) * len + 0.5)|0;
                    if (x < 0) {
                        x = 0;
                    } else if (x >= len - 1) {
                        x = len - 1;
                    }
                    cell[i] = curve[x];
                }
            }

            fn.outputSignalAR(this);
        }

        return this;
    };

    fn.register("waveshaper", WaveShaperNode);

})(timbre);
(function(T) {
    "use strict";

    var fn = T.fn;

    function ZMapNode(_args) {
        T.Object.call(this, 1, _args);

        var _ = this._;
        _.inMin  = 0;
        _.inMax  = 1;
        _.outMin = 0;
        _.outMax = 1;
        _.ar     = false;

        this.once("init", oninit);
    }
    fn.extend(ZMapNode);

    var oninit = function() {
        if (!this._.warp) {
            this.warp = "linlin";
        }
    };

    var $ = ZMapNode.prototype;

    Object.defineProperties($, {
        inMin: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.inMin = value;
                }
            },
            get: function() {
                return this._.inMin;
            }
        },
        inMax: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.inMax = value;
                }
            },
            get: function() {
                return this._.inMax;
            }
        },
        outMin: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.outMin = value;
                }
            },
            get: function() {
                return this._.outMin;
            }
        },
        outMax: {
            set: function(value) {
                if (typeof value === "number") {
                    this._.outMax = value;
                }
            },
            get: function() {
                return this._.outMax;
            }
        },
        warp: {
            set: function(value) {
                if (typeof value === "string") {
                    var f = WarpFunctions[value];
                    if (f) {
                        this._.warp = f;
                        this._.warpName = value;
                    }
                }
            },
            get: function() {
                return this._.warpName;
            }
        }
    });

    $.process = function(tickID) {
        var _ = this._;
        var cell = this.cells[0];

        if (this.tickID !== tickID) {
            this.tickID = tickID;

            var inMin  = _.inMin, inMax   = _.inMax;
            var outMin = _.outMin, outMax = _.outMax;
            var warp   = _.warp;

            var len = this.nodes.length;
            var mul = _.mul, add = _.add;
            var i, imax = cell.length;

            if (_.ar && len) {
                fn.inputSignalAR(this);
                for (i = 0; i < imax; ++i) {
                    cell[i] = warp(cell[i], inMin, inMax, outMin, outMax) * mul + add;
                }
                fn.outputSignalAR(this);
            } else {
                var input = (this.nodes.length) ? fn.inputSignalKR(this) : 0;
                var value = warp(input, inMin, inMax, outMin, outMax) * mul + add;
                for (i = 0; i < imax; ++i) {
                    cell[i] = value;
                }
            }
        }

        return this;
    };

    var WarpFunctions = {
        linlin: function(x, inMin, inMax, outMin, outMax) {
            if (x < inMin) {
                return outMin;
            } else if (x > inMax) {
                return outMax;
            }
            if (inMax === inMin) {
                return outMin;
            }
            return (x-inMin) / (inMax-inMin) * (outMax-outMin) + outMin;
        },
        linexp: function(x, inMin, inMax, outMin, outMax) {
            if (x < inMin) {
                return outMin;
            } else if (x > inMax) {
                return outMax;
            }
            if (outMin === 0) {
                return 0;
            }
            if (inMax === inMin) {
                return outMax;
            }
            return Math.pow(outMax/outMin, (x-inMin)/(inMax-inMin)) * outMin;
        },
        explin: function(x, inMin, inMax, outMin, outMax) {
            if (x < inMin) {
                return outMin;
            } else if (x > inMax) {
                return outMax;
            }
            if (inMin === 0) {
                return outMax;
            }
            return Math.log(x/inMin) / Math.log(inMax/inMin) * (outMax-outMin) + outMin;
        },
        expexp: function(x, inMin, inMax, outMin, outMax) {
            if (x < inMin) {
                return outMin;
            } else if (x > inMax) {
                return outMax;
            }
            if (inMin === 0 || outMin === 0) {
                return 0;
            }
            return Math.pow(outMax/outMin, Math.log(x/inMin) / Math.log(inMax/inMin)) * outMin;
        }
    };

    fn.register("zmap", ZMapNode);

})(timbre);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],21:[function(require,module,exports){
var $, APP_EL_SELECTOR, AppView, Backbone, DEFAULT_KEYCODES, Display, GroupCollection, PLAYPAUSE_CHAR, Pads, PatternUIView, RECORD_CHAR, RecipeModel, Router, Sequence, Transport, async, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = $ = require('jquery');

Backbone.NestedModel = require('backbone-nested').NestedModel;

_ = require('underscore');

async = require('async');

Router = require('../routes/app');

Pads = require('./pads');

Display = require('./display');

Transport = require('./transport');

Sequence = require('./sequence');

PatternUIView = require('./pattern.ui');

RecipeModel = require('../models/recipe');

GroupCollection = require('../collections/group');

DEFAULT_KEYCODES = [54, 55, 56, 57, 89, 85, 73, 79, 72, 74, 75, 76, 78, 77, 188, 190];

RECORD_CHAR = 82;

PLAYPAUSE_CHAR = 32;

APP_EL_SELECTOR = 'body';

AppView = (function(_super) {
  __extends(AppView, _super);

  function AppView() {
    return AppView.__super__.constructor.apply(this, arguments);
  }

  AppView.prototype.el = APP_EL_SELECTOR;

  AppView.prototype.initialize = function() {
    var i, keyCode, _i, _len;
    Backbone.history.start({
      pushState: true
    });
    this.current = {};
    this.keyMap = {};
    this.recipe = new RecipeModel();
    this.router = new Router({
      app: this
    });
    (this.display = new Display({
      app: this
    })).log('Please Wait...');
    this.transport = new Transport({
      app: this
    });
    this.pattern = new PatternUIView({
      app: this
    });
    this.groups = new GroupCollection({
      position: 1
    }, {
      app: this
    });
    this.pads = new Pads({
      app: this
    });
    this.sequence = new Sequence({
      app: this
    });
    this.UIModel = new (Backbone.NestedModel.extend());
    async.series([
      (function(_this) {
        return function(callback) {
          if (_this.recipe.get('id')) {
            return _this.open(_this.recipe, function() {
              return callback(null, true);
            });
          } else {
            return callback(null, false);
          }
        };
      })(this)
    ], (function(_this) {
      return function(err, opened) {
        _this._selectGroupAt(0);
        return _this.pattern._selectPatternAt(0);
      };
    })(this));
    for (i = _i = 0, _len = DEFAULT_KEYCODES.length; _i < _len; i = ++_i) {
      keyCode = DEFAULT_KEYCODES[i];
      this.keyMap[keyCode] = i;
    }
    return this.display.log('Ready');
  };

  AppView.prototype.events = {
    'click [data-behavior]': 'delegateBehavior',
    'keypress': 'keyPressDelegate',
    'keydown': 'keyDownDelegate',
    'keyup': 'keyUpDelegate'
  };

  AppView.prototype.delegateBehavior = function(e) {
    var behavior, meta;
    behavior = $(e.currentTarget).data('behavior');
    meta = $(e.currentTarget).data('meta');
    if ((behavior != null) && _.isFunction(this[behavior])) {
      return this[behavior].call(this, e, meta);
    }
  };

  AppView.prototype.selectGroup = function(e, number) {
    return this._selectGroup(number);
  };

  AppView.prototype._selectGroupAt = function(idx) {
    return this._selectGroup(this.groups.at(0).get('position'));
  };

  AppView.prototype._selectGroup = function(groupNumber) {
    this.current.group = this.groups.findWhere({
      position: groupNumber
    });
    return this.pads.render(groupNumber);
  };

  AppView.prototype.open = function(recipe, callback) {
    var _this;
    _this = this;
    this.display.log("Loading " + (this.recipe.get('name')) + "...");
    return this.groups.fetchRecursive(this, this.recipe, (function(_this) {
      return function(err, fetched) {
        callback.call(_this);
        return _this.display.log("Recipe \"" + (_this.recipe.get('name')) + "\" Loaded");
      };
    })(this));
  };

  AppView.prototype.save = function(e) {
    var _this;
    _this = this;
    return async.waterfall([
      (function(_this) {
        return function(recipeSavedCallback) {
          return _this.recipe.save({}, {
            success: function(savedRecipe) {
              return async.each(_this.groups.models, function(group, eachGroupSavedCallback) {
                return group.save({
                  recipe_id: savedRecipe.id
                }, {
                  success: (function(_this) {
                    return function(savedGroup) {
                      return async.parallel([
                        function(cbSound) {
                          return async.each(group.sounds.models, function(sound, eachSoundSavedCallback) {
                            return sound.save({
                              groupId: group.id
                            }, {
                              success: function(savedSound) {
                                return eachSoundSavedCallback(null, savedSound);
                              },
                              error: function(err) {
                                return eachSoundSavedCallback(err);
                              }
                            });
                          }, function(err) {
                            if (err) {
                              cbSound(err);
                            }
                            return cbSound(null);
                          });
                        }, function(cbPattern) {
                          return async.each(group.patterns.models, function(pattern, eachPatternSavedCallback) {
                            return pattern.save({
                              groupId: group.id
                            }, {
                              success: function(savedPattern) {
                                return eachPatternSavedCallback(null, savedPattern);
                              },
                              error: function(err) {
                                return eachPatternSavedCallback(err);
                              }
                            });
                          }, function(err) {
                            if (err) {
                              cbPattern(err);
                            }
                            return cbPattern(null);
                          });
                        }
                      ], function(err) {
                        if (err) {
                          eachGroupSavedCallback(err);
                        }
                        return eachGroupSavedCallback(null);
                      });
                    };
                  })(this)
                });
              }, function(err) {
                return recipeSavedCallback(null);
              });
            },
            error: function(err) {
              return recipeSavedCallback(err);
            }
          });
        };
      })(this)
    ], (function(_this) {
      return function(err, results) {
        if (err) {
          throw new Error(err);
        }
        _this.router.navigate("recipe/" + (_this.recipe.get('id')), {
          silent: true
        });
        return _this.display.log("Recipe \"" + (_this.recipe.get('name')) + "\" Saved");
      };
    })(this));
  };

  AppView.prototype.toJSON = function(e) {
    var recipe;
    recipe = this.recipe.toJSON();
    recipe.groups = [];
    this.groups.each((function(_this) {
      return function(group) {
        var groupAttributes;
        groupAttributes = group.toJSON();
        groupAttributes.sounds = [];
        group.sounds.each(function(sound) {
          return groupAttributes.sounds.push(sound.toJSON());
        });
        groupAttributes.patterns = [];
        group.patterns.each(function(pattern) {
          return groupAttributes.patterns.push(pattern.toJSON());
        });
        return recipe.groups.push(groupAttributes);
      };
    })(this));
    return console.log(recipe);
  };

  AppView.prototype.keyDownDelegate = function(e) {
    var char, prevent;
    char = String.fromCharCode(e.keyCode);
    if (char === RECORD_CHAR && e.ctrlKey) {
      this.transport.record();
      prevent = true;
    } else if (char === PLAYPAUSE_CHAR) {
      this.transport.play();
      prevent = true;
    } else if (_.indexOf([1, '1', '2', '3', '4', '5', '6', '7', '8'], char) > 0 && e.ctrlKey) {
      prevent = true;
      this.pads.render(char);
    }
    if (prevent) {
      return e.preventDefault();
    }
  };

  AppView.prototype.keyPressDelegate = function(e) {
    var pad, _ref;
    if (this.keyMap[e.which] != null) {
      this.pressing = e.which;
      return pad = (_ref = this.current.pads[this.keyMap[e.which]]) != null ? _ref.trigger('press') : void 0;
    }
  };

  AppView.prototype.keyUpDelegate = function(e) {
    var pad, _ref;
    if (e.which === this.pressing) {
      return pad = (_ref = this.current.pads[this.keyMap[e.which]]) != null ? _ref.trigger('release') : void 0;
    }
  };

  return AppView;

})(Backbone.View);

module.exports = new AppView();


},{"../collections/group":2,"../models/recipe":10,"../routes/app":13,"./display":22,"./pads":25,"./pattern.ui":27,"./sequence":28,"./transport":29}],22:[function(require,module,exports){
var Backbone, DisplayModel, DisplayView, Ligament, displayTemplate, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = require('jquery');

Ligament = require('backbone-ligaments');

_ = require('underscore');

DisplayModel = require('../models/display');

displayTemplate = require('../templates/display.tpl');

DisplayView = (function(_super) {
  __extends(DisplayView, _super);

  function DisplayView() {
    return DisplayView.__super__.constructor.apply(this, arguments);
  }

  DisplayView.prototype.el = '.display';

  DisplayView.prototype.template = displayTemplate;

  DisplayView.prototype.initialize = function(options) {
    this.app = options.app;
    this.model = new DisplayModel();
    this.render();
    this.$canvas = this.$('#waveform');
    return new Ligament({
      model: this.model,
      view: this
    });
  };

  DisplayView.prototype.log = function(options) {
    var message;
    if (typeof options === 'string') {
      message = options;
    } else {
      message = options.message;
    }
    this.model.set('one', message);
    return this.render();
  };

  DisplayView.prototype.render = function() {
    return this.el.innerHTML = this.template(this.model.toJSON());
  };

  return DisplayView;

})(Backbone.View);

module.exports = DisplayView;


},{"../models/display":7,"../templates/display.tpl":14}],23:[function(require,module,exports){
var Backbone, Display, EditorView, Ligament, ORANGE, editorTemplate, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = require('../vendor/jquery-bootstrap.js');

Ligament = require('backbone-ligaments');

_ = require('underscore');

Display = require('./display');

editorTemplate = require('../templates/editor.tpl');

ORANGE = '#f08a24';

EditorView = (function(_super) {
  __extends(EditorView, _super);

  function EditorView() {
    return EditorView.__super__.constructor.apply(this, arguments);
  }

  EditorView.prototype.template = editorTemplate;

  EditorView.prototype.attributes = {
    'class': 'modal fade'
  };

  EditorView.prototype.initialize = function(options) {
    this.viewVars = {};
    this.model = options.model, this.pad = options.pad;
    _.bindAll(this, 'drawCanvas');
    this.render();
    this.ligament = new Ligament({
      model: this.model,
      view: this
    });
    return this.listenTo(this.model, 'change', this.drawCanvas);
  };

  EditorView.prototype.events = {
    'click [data-behavior]': 'delegateBehavior',
    'click canvas': 'play',
    'change input.eq': 'eq'
  };

  EditorView.prototype.delegateBehavior = function(e) {
    var behavior;
    behavior = $(e.currentTarget).data('behavior');
    if ((behavior != null) && _.isFunction(this[behavior])) {
      return this[behavior].call(this, e);
    }
  };

  EditorView.prototype.save = function(e) {
    return this.pad.model.save();
  };

  EditorView.prototype.eq = function(e) {
    var freq, param;
    param = e.currentTarget.getAttribute('data-param');
    freq = this.model.get('fx.eq.params.' + param);
    freq[2] = parseInt($(e.currentTarget).val(), 10);
    this.model.set('fx.eq.params.' + param, freq);
    return console.log(freq);
  };

  EditorView.prototype.tab = function(e) {
    var tabClass;
    tabClass = $(e.currentTarget).data('tab');
    $(e.currentTarget).addClass('active').siblings().removeClass('active');
    this.$('.tab-pane').hide();
    return this.$('.tab-pane' + tabClass).show();
  };

  EditorView.prototype.toggleEffect = function(e) {
    var effect;
    effect = $(e.currentTarget).data('effect');
    if (!this.model.get("fx." + effect)) {
      this.viewVars.show = effect;
      return this.addEffect(effect);
    } else {
      delete this.viewVars.show;
      return this.removeEffect(effect);
    }
  };

  EditorView.prototype.addEffect = function(effect) {
    var fx;
    switch (effect) {
      case 'reverb':
        fx = {
          room: 0,
          damp: 0,
          mix: 0.5
        };
        break;
      case 'delay':
        fx = {
          time: 100,
          fb: 0.2,
          mix: 0.33
        };
        break;
      case 'chorus':
        fx = {
          type: 'sin',
          delay: 20,
          rate: 4,
          depth: 20,
          fb: 0.2,
          wet: 0.33
        };
    }
    this.model.set("fx." + effect, fx);
    return this.drawCanvas();
  };

  EditorView.prototype.removeEffect = function(effect) {
    this.model.unset("fx." + effect);
    return this.drawCanvas();
  };

  EditorView.prototype.play = function(e) {
    e.preventDefault();
    return this.pad.trigger('press');
  };

  EditorView.prototype.show = function() {
    this.drawCanvas();
    return this.$el.modal('show');
  };

  EditorView.prototype.hide = function() {
    return this.$el.modal('hide');
  };

  EditorView.prototype.render = function() {
    this.el.innerHTML = this.template({
      data: this.model.toJSON(),
      view: this.viewVars
    });
    return this.drawCanvas();
  };

  EditorView.prototype.drawCanvas = function() {
    var renderOptions, _ref, _ref1, _ref2, _ref3;
    if (!this.$canvas) {
      this.$canvas = this.$('.waveform');
    }
    renderOptions = {
      width: 558,
      height: 100,
      target: this.$canvas.get(0),
      lineWidth: 0.5,
      background: '#222',
      foreground: ORANGE
    };
    if (((_ref = this.pad.model) != null ? (_ref1 = _ref.T) != null ? _ref1.rendered : void 0 : void 0) != null) {
      return this.pad.model.T.rendered.plot(renderOptions);
    } else if (((_ref2 = this.pad.model) != null ? (_ref3 = _ref2.T) != null ? _ref3.raw : void 0 : void 0) != null) {
      return this.pad.model.T.raw.plot(renderOptions);
    }
  };

  return EditorView;

})(Backbone.View);

module.exports = EditorView;


},{"../templates/editor.tpl":15,"../vendor/jquery-bootstrap.js":19,"./display":22}],24:[function(require,module,exports){
var Backbone, Ligament, PadView, SoundEditor, SoundModel, padTemplate, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = require('jquery');

Ligament = require('backbone-ligaments');

_ = require('underscore');

SoundModel = require('../models/sound');

SoundEditor = require('./editor');

padTemplate = require('../templates/pad.tpl');

PadView = (function(_super) {
  __extends(PadView, _super);

  function PadView() {
    return PadView.__super__.constructor.apply(this, arguments);
  }

  PadView.PAD_CLASSES = 'small-3 columns pad-container';

  PadView.PAD_RELEASE_TIMEOUT_MS = 50;

  PadView.prototype.attributes = {
    "class": PadView.PAD_CLASSES
  };

  PadView.prototype.template = padTemplate;

  PadView.prototype.initialize = function(options) {
    this.parent = options.parent, this.name = options.name, this.number = options.number;
    _.bindAll(this, 'listenToModelEvents', 'press');
    this.on('press', this.press);
    return this.render();
  };

  PadView.prototype.events = {
    'contextmenu .pad': 'edit',
    'mousedown .pad': 'press',
    'mouseup .pad': 'release',
    'dragover': 'prevent',
    'dragenter': 'prevent',
    'drop': 'uploadSound'
  };

  PadView.prototype.listenToModelEvents = function() {
    this.stopListening(this.model, 'press');
    this.listenTo(this.model, 'press', this.press);
    this.stopListening(this.model, 'loaded');
    return this.listenTo(this.model, 'loaded', (function(_this) {
      return function() {
        _this.$('.pad').addClass('mapped');
        return _this.parent.app.display.log((_this.model.get('name') || _this.name) + ' loaded');
      };
    })(this));
  };

  PadView.prototype.bootstrapWithModel = function(soundModel) {
    var keyCode;
    if (!soundModel && !soundModel instanceof SoundModel) {
      throw new Error('Must provide a SoundModel instance when mapping a pad.');
    }
    (this.model = soundModel).pad = this;
    this.listenToModelEvents();
    if ((keyCode = this.model.get('keyCode'))) {
      this.model.set('key', keyCode);
    }
    return this.ligament = new Ligament({
      model: this.model,
      view: this
    });
  };

  PadView.prototype.prevent = function(e) {
    e.preventDefault();
    return e.stopPropagation();
  };

  PadView.prototype.press = function(e) {
    var _ref;
    if (e == null) {
      e = {};
    }
    if ((e != null) && e.button === 2) {
      return true;
    }
    this.$('.pad').addClass('active');
    setTimeout((function(_this) {
      return function() {
        return _this.$('.pad').removeClass('active');
      };
    })(this), this.PAD_RELEASE_TIMEOUT_MS);
    if ((_ref = this.model) != null ? _ref.loaded : void 0) {
      if (!e.silent) {
        this.parent.trigger('press', this);
      }
      return this.model.play();
    }
  };

  PadView.prototype.release = function(e) {};


  /*
    * creates a new model if one doesn't exist for this pad
    * Adds itself to the current group's SoundCollection
   */

  PadView.prototype.createOrFindModel = function(attrs) {
    if (attrs == null) {
      attrs = {};
    }
    if (!(this.model = this.parent.app.groups.findWhere({
      position: this.groupNumber
    }).sounds.findWhere({
      pad: this.number
    }))) {
      this.model = new SoundModel(_.extend({
        pad: this.$el.index() + 1
      }, attrs));
      this.parent.app.current.group.sounds.add(this.model);
      this.bootstrapWithModel(this.model);
    }
    return this.model;
  };

  PadView.prototype.uploadSound = function(e) {
    var objectUrl, _ref, _ref1, _ref2;
    e = e.originalEvent;
    e.preventDefault();
    e.stopPropagation();
    if (!this.model) {
      this.createOrFindModel();
    }
    objectUrl = (_ref = window.URL) != null ? typeof _ref.createObjectURL === "function" ? _ref.createObjectURL((_ref1 = e.dataTransfer) != null ? (_ref2 = _ref1.files) != null ? _ref2[0] : void 0 : void 0) : void 0 : void 0;
    this.sendFile(e.dataTransfer.files[0], (function(_this) {
      return function(model, attrs) {
        debugger;
        if (!objectUrl) {
          return model.set('src', model.url());
        }
      };
    })(this));
    if (objectUrl) {
      this.model.set('src', objectUrl);
      return this.parent.app.display.log("File: " + e.dataTransfer.files[0].name + " set on pad " + this.name);
    } else {
      return this.parent.app.display.log("Uploading: " + e.dataTransfer.files[0].name);
    }
  };

  PadView.prototype.sendFile = function(file, cb) {
    this.formData = new FormData();
    this.xhr = new XMLHttpRequest();
    this.xhr.open('POST', '/sounds', true);
    this.formData.append('sound', file);
    this.xhr.upload.onprogress = (function(_this) {
      return function(e) {
        var completed;
        if (e.lengthComputable) {
          completed = (e.loaded / e.total) * 100;
          return _this.$('.progress-bar').css({
            width: "" + (completed.toFixed(0)) + "%"
          });
        }
      };
    })(this);
    this.xhr.onerror = (function(_this) {
      return function(e) {
        return _this.parent.app.display.log("Upload failed");
      };
    })(this);
    this.xhr.onload = (function(_this) {
      return function(e) {
        var data;
        data = JSON.parse(e.target.responseText);
        debugger;
        _this.model.set(data);
        _this.parent.app.display.log("Upload Completed: " + data.filename);
        cb && cb(_this.model, data);
        try {

        } catch (_error) {
          e = _error;
          _this.parent.app.display.log("Upload failed");
          return alert("An error occurred " + e.message + " with response " + e.responseText);
        }
      };
    })(this);
    this.xhr.send(this.formData);
    delete this.xhr;
    return delete this.formData;
  };

  PadView.prototype.edit = function(e) {
    e.preventDefault();
    if (!this.editor) {
      this.editor = new SoundEditor({
        model: this.model || this.createOrFindModel(),
        pad: this
      });
    }
    return this.editor.show();
  };

  PadView.prototype.render = function() {
    return this.el.innerHTML = this.template({
      name: this.name
    });
  };

  return PadView;

})(Backbone.View);

module.exports = PadView;


},{"../models/sound":11,"../templates/pad.tpl":16,"./editor":23}],25:[function(require,module,exports){
var Backbone, PADLABEL_PREFIX, PadView, PadsView, padsTemplate, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = require('jquery');

_ = require('underscore');

PadView = require('./pad');

padsTemplate = require('../templates/pad.tpl');

PADLABEL_PREFIX = 'c';

PadsView = (function(_super) {
  __extends(PadsView, _super);

  function PadsView() {
    return PadsView.__super__.constructor.apply(this, arguments);
  }

  PadsView.prototype.el = '.pads';

  PadsView.prototype.template = padsTemplate;

  PadsView.prototype.colorMap = {
    '1': '#ADD5FF',
    '2': '#FF8D8D',
    '3': '#BBBBD4',
    '4': '#EBECF2',
    '5': '#FFE97F'
  };

  PadsView.prototype.initialize = function(options) {
    this.app = options.app;
    this.createPads();
    this.render();
    this.listenTo(this.app.groups, 'fetch', (function(_this) {
      return function(collection) {
        collection.each(function(model) {
          return _this.bootstrapGroupPads(model);
        });
        return _this.render();
      };
    })(this));
    return this.listenTo(this.app.groups, 'add', (function(_this) {
      return function(model) {
        return _this.bootstrapGroupPads(model);
      };
    })(this));
  };

  PadsView.prototype.createPads = function() {
    var i, options, padView, z, _i, _results;
    this.pads = [];
    z = 0;
    _results = [];
    for (i = _i = 1; _i <= 128; i = ++_i) {
      options = {
        name: "" + (PADLABEL_PREFIX + (i - z * 16)),
        parent: this,
        number: i - z * 16
      };
      this.pads.push((padView = new PadView(options)));
      padView.groupNumber = z + 1;
      if (i % 16 === 0) {
        _results.push(z++);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  PadsView.prototype.bootstrapGroupPads = function(group) {
    var i, pad, pads, pos, _i, _len, _results;
    pos = group.get('position') - 1 > -1 ? group.get('position') - 1 : 0;
    pads = this.pads.slice(pos * 16, pos * 16 + 16);
    if (group.sounds.at(i) != null) {
      _results = [];
      for (i = _i = 0, _len = pads.length; _i < _len; i = ++_i) {
        pad = pads[i];
        _results.push(pad.bootstrapWithModel(group.sounds.at(i)));
      }
      return _results;
    }
  };

  PadsView.prototype.toggleGroupSelectButtons = function(group) {
    return this.app.$('[data-behavior="selectGroup"]').removeClass('active').filter("[data-meta=\"" + group + "\"]").addClass('active');
  };

  PadsView.prototype.render = function(groupNumber) {
    var zeroedIndex, _ref;
    if (groupNumber == null) {
      groupNumber = 1;
    }
    this.$('.pad-container').detach();
    groupNumber = groupNumber * 1;
    this.toggleGroupSelectButtons(groupNumber);
    zeroedIndex = groupNumber - 1;
    this.app.current.group = this.app.groups.findWhere({
      position: groupNumber
    });
    if (!this.app.current.group) {
      this.app.groups.add({
        position: groupNumber
      });
      this.app.current.group = this.app.groups.findWhere({
        position: groupNumber
      });
    }
    this.app.$('.patterns .grid').hide();
    this.app.pattern._selectPattern(((_ref = this.app.current.group.lastActivePattern) != null ? _ref.get('position') : void 0) || 1);
    this.app.current.pads = this.pads.slice(zeroedIndex * 16, zeroedIndex * 16 + 16);
    this.app.display.model.set('right', "Group " + groupNumber);
    return this.$el.append(_.pluck(this.app.current.pads, 'el'));
  };

  return PadsView;

})(Backbone.View);

module.exports = PadsView;


},{"../templates/pad.tpl":16,"./pad":24}],26:[function(require,module,exports){
var $, Backbone, HAS_TRIGGER_CLASS, PATTERN_LENGTH, PatternCollection, PatternGridView, paper, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Backbone = require('backbone');

Backbone.$ = $ = require('jquery');

_ = require('underscore');

PatternCollection = require('../collections/pattern');

paper = require('../bower_components/paper/dist/paper-full');

HAS_TRIGGER_CLASS = 'has-trigger';

PATTERN_LENGTH = '4';

PatternGridView = (function(_super) {
  __extends(PatternGridView, _super);

  function PatternGridView() {
    return PatternGridView.__super__.constructor.apply(this, arguments);
  }

  PatternGridView.prototype.attributes = {
    "class": 'grid',
    style: 'display:none;'
  };

  PatternGridView.prototype.initialize = function(options) {
    if (options == null) {
      options = {};
    }
    this.model = options.model;
    _.bindAll(this, 'drawGrid', 'addTrigger', 'removeTrigger', 'onTick');
    this.app = this.model.collection.group.app;
    this.ui = this.app.pattern;
    this.ui.$('.patterns').append(this.$el);
    if (!this.model.get('len')) {
      this.model.set('len', PATTERN_LENGTH);
    }
    this.render();
    this.listenTo(this.model, 'change:len', this.drawGrid);
    this.listenTo(this.model, 'change:zoom', this.drawGrid);
    this.listenTo(this.model, 'change:step', this.drawGrid);
    this.listenTo(this.model, 'remove', this.remove);
    return this.listenTo(this.ui, 'tick', this.onTick);
  };

  PatternGridView.prototype.events = {
    'contextmenu .trigger': 'clickDeleteTrigger',
    'dblclick': 'clickAddTrigger'
  };


  /*
   * UI delegate.
   * adds a trigger where the user double-clicks
   */

  PatternGridView.prototype.clickAddTrigger = function(e) {
    e.preventDefault();
    return this.addTrigger(this.offsetToPadNumber(e.offsetY), this.offsetToTick(e.offsetX));
  };


  /*
   * UI delegate.
   * removes the right-clicked trigger from the pattern
   */

  PatternGridView.prototype.clickDeleteTrigger = function(e) {
    var data;
    e.preventDefault();
    data = $(e.target).data();
    this.removeTrigger(data.padNumber, data.tick);
    return $(e.target).remove();
  };

  PatternGridView.prototype.onTick = function(tick) {
    var normalizedTick, triggers;
    normalizedTick = this.getNormalizedTick(tick);
    if (this.app.transport._playing && (triggers = this.model.get("triggers." + normalizedTick))) {
      return _.each(triggers, (function(_this) {
        return function(padNumber) {
          var _ref;
          console.log(_this.model.collection.group.sounds.findWhere({
            pad: padNumber
          }));
          return (_ref = _this.model.collection.group.sounds.findWhere({
            pad: padNumber
          })) != null ? _ref.trigger('press', {
            silent: true
          }) : void 0;
        };
      })(this));
    }
  };

  PatternGridView.prototype.drawTriggers = function() {
    var padNumber, tick, triggers, _ref, _results;
    _ref = this.model.get('triggers');
    _results = [];
    for (tick in _ref) {
      if (!__hasProp.call(_ref, tick)) continue;
      triggers = _ref[tick];
      _results.push((function() {
        var _i, _len, _results1;
        _results1 = [];
        for (_i = 0, _len = triggers.length; _i < _len; _i++) {
          padNumber = triggers[_i];
          _results1.push(this.drawTrigger(padNumber, tick));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  PatternGridView.prototype.drawTrigger = function(padNumber, tick) {
    var $trigger, left, totalTicks;
    totalTicks = this.getTotalTicks();
    left = (100 / this.getTotalTicks()) * this.getNormalizedTick(tick);
    $trigger = $('<div class="trigger">').css({
      top: (padNumber - 1) * this.ui.$('.slot').eq(0).outerHeight() + "px",
      height: "" + (this.ui.$('.slot').eq(0).outerHeight()) + "px",
      width: "" + ((this.w / totalTicks) / this.w * 100) + "%",
      left: "" + left + "%"
    }).data('tick', tick).data('padNumber', padNumber);
    return this.$el.append($trigger);
  };

  PatternGridView.prototype.removeTrigger = function(padNumber, normalizedTick) {
    var removed, triggers;
    if ((triggers = this.model.get("triggers." + normalizedTick))) {
      this.app.current.pattern.view.drawTrigger(normalizedTick, padNumber);
      removed = triggers.splice(_.indexOf(triggers, padNumber), 1);
      this.model.set("triggers." + normalizedTick, triggers);
      return removed;
    } else {
      return false;
    }
  };

  PatternGridView.prototype.addTrigger = function(padNumber, normalizedTick) {
    var triggers;
    triggers = this.model.get("triggers." + normalizedTick) || [];
    if (!(triggers.indexOf(padNumber) > -1)) {
      triggers.push(padNumber);
      this.app.current.pattern.view.drawTrigger(padNumber, normalizedTick);
      this.model.set("triggers." + normalizedTick, triggers);
    }
    return padNumber;
  };

  PatternGridView.prototype.getTotalTicks = function() {
    var totalTicks;
    return totalTicks = this.model.get('len') * this.model.get('step');
  };

  PatternGridView.prototype.getNormalizedTick = function(tick, asPercentage) {
    var normal, totalTicks;
    if (asPercentage == null) {
      asPercentage = false;
    }
    tick || (tick = this.app.transport.getTick());
    totalTicks = this.getTotalTicks();
    if (tick <= totalTicks) {
      normal = tick;
    } else {
      normal = tick % this.getTotalTicks();
    }
    if (asPercentage) {
      return (100 / totalTicks) * normal;
    } else {
      return normal;
    }
  };

  PatternGridView.prototype.offsetToPadNumber = function(offset, isPercentage) {
    var padNumber;
    if (isPercentage == null) {
      isPercentage = false;
    }
    if (!isPercentage) {
      offset = offset / this.$el.outerHeight();
    }
    return padNumber = Math.ceil(offset * 16);
  };

  PatternGridView.prototype.offsetToTick = function(offset, isPercentage) {
    var tick;
    if (isPercentage == null) {
      isPercentage = false;
    }
    if (!isPercentage) {
      offset = offset / this.w;
    }
    return tick = Math.floor(this.getTotalTicks() * offset);
  };

  PatternGridView.prototype.tickToOffset = function() {};

  PatternGridView.prototype.drawGrid = function() {
    var $patternWindow, bar, bars, currentTick, h, i, len, path, slotHeight, step, totalTicks, w, x, xInterval, y, zoom, _i, _j, _ref;
    zoom = this.model.get('zoom') || 2;
    $patternWindow = this.ui.$('.patterns');
    w = this.w = $patternWindow.width() * this.model.get('zoom') * 0.9;
    h = 310;
    this.$el.width(w);
    this.$el.height(h);
    len = parseInt(this.model.get('len'), 10);
    step = parseInt(this.model.get('step'), 10);
    totalTicks = step * len;
    xInterval = w / totalTicks;
    currentTick = 0;
    bar = Math.ceil(totalTicks / len);
    for (i = _i = 0, _ref = len + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      (bars || (bars = [])).push(i * bar || 0);
    }
    this.paper = paper.setup(this.$canvas.get(0));
    this.paper.view.viewSize = new this.paper.Size(w, h);
    path = new this.paper.Path();
    while (currentTick <= totalTicks) {
      x = currentTick * xInterval;
      path = new this.paper.Path();
      path.strokeWidth = 1;
      path.strokeColor = __indexOf.call(bars, currentTick) >= 0 ? '#ddd' : '#444';
      path.moveTo(new this.paper.Point(x - 0.5, 0));
      path.lineTo(new this.paper.Point(x - 0.5, h));
      currentTick++;
    }
    slotHeight = this.ui.$('.slot').eq(0).outerHeight();
    for (i = _j = 0; _j <= 16; i = ++_j) {
      x = w;
      y = i * slotHeight;
      path = new this.paper.Path();
      path.strokeWidth = 0.2;
      path.strokeColor = "#aaa";
      path.moveTo(0, y);
      path.lineTo(x, y);
    }
    this.paper.view.draw();
    this.$el.find('.trigger').remove();
    return this.drawTriggers();
  };

  PatternGridView.prototype.render = function() {
    this.$el.empty();
    this.$canvas = $('<canvas>').appendTo(this.$el);
    this.$playHead = $('<div class="playHead">').appendTo(this.$el);
    return this.drawGrid();
  };

  return PatternGridView;

})(Backbone.View);

module.exports = PatternGridView;


},{"../bower_components/paper/dist/paper-full":1,"../collections/pattern":3}],27:[function(require,module,exports){
var $, Backbone, Ligament, PatternCollection, PatternUIView, TRIGGER_CLASS, Transport, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = $ = require('jquery');

Backbone.NestedModel = require('backbone-nested').NestedModel;

Ligament = require('backbone-ligaments');

_ = require('underscore');

PatternCollection = require('../collections/pattern');

Transport = require('./transport');

TRIGGER_CLASS = 'trigger';

PatternUIView = (function(_super) {
  __extends(PatternUIView, _super);

  function PatternUIView() {
    return PatternUIView.__super__.constructor.apply(this, arguments);
  }

  PatternUIView.prototype.el = '.pattern';

  PatternUIView.prototype.initialize = function(options) {
    if (options == null) {
      options = {};
    }
    this.app = options.app;
    _.bindAll(this, 'updatePlayHead', 'recordTrigger');
    this.UIModel = new (Backbone.NestedModel.extend({}));
    this.ligament = new Ligament({
      model: this.UIModel,
      view: this,
      bindings: {
        'pattern.zoom': {
          cast: [parseFloat, 10]
        },
        'pattern.len': {
          cast: [parseInt, 10]
        },
        'pattern.step': {
          cast: [parseInt, 10]
        }
      }
    });
    this.listenTo(this.UIModel, 'change:pattern', (function(_this) {
      return function(model, changed) {
        return _this.app.current.pattern.set(changed);
      };
    })(this));
    this.app.transport.on('tick', this.updatePlayHead);
    return this.waitForPads = setInterval((function(_this) {
      return function() {
        clearTimeout(_this.waitForPads);
        if (_this.app.pads) {
          return _this.app.pads.on('press', _this.recordTrigger);
        }
      };
    })(this), 100);
  };

  PatternUIView.prototype.events = {
    'click [data-behavior]': 'delegateBehavior'
  };

  PatternUIView.prototype.delegateBehavior = function(e) {
    var behavior, delegate, meta;
    behavior = $(e.target).data('behavior');
    if (behavior && (delegate = this[behavior])) {
      meta = $(e.target).data('meta');
      return delegate.call(this, e, meta);
    }
  };


  /*
  	 * updates the position of the playhead
  	 * when transport is in play/record
   */

  PatternUIView.prototype.updatePlayHead = function(tick) {
    var playHeadPosition;
    tick || (tick = this.app.transport.getTick());
    playHeadPosition = this.app.current.pattern.view.getNormalizedTick(tick, true);
    this.app.current.pattern.view.$playHead.css({
      left: "" + playHeadPosition + "%"
    });
    this.trigger('tick', tick);
    return playHeadPosition;
  };


  /*
  	 *
  	 *
   */

  PatternUIView.prototype.engagePlayHeadScrub = function(e) {
    return null;
  };


  /*
  	 *wefw
  	 *
   */

  PatternUIView.prototype.disengagePlayHeadScrub = function(e) {
    return null;
  };


  /*
  	 * checks if the transport is recording, records a trigger on 
  	 * currentPattern in the correct slot.
   */

  PatternUIView.prototype.recordTrigger = function(pad) {
    var normalizedTick;
    if (this.app.transport._recording) {
      normalizedTick = this.app.current.pattern.view.getNormalizedTick();
      return this.app.current.pattern.view.addTrigger(pad.number, normalizedTick);
    }
  };

  PatternUIView.prototype.togglePatternSelectButtons = function(patternNumber) {
    return this.$('[data-behavior="selectPattern"]').removeClass('active').filter("[data-meta=\"" + patternNumber + "\"]").addClass('active');
  };

  PatternUIView.prototype.selectPattern = function(e, number) {
    return this._selectPattern(number);
  };

  PatternUIView.prototype._selectPatternAt = function(idx) {
    return this._selectPattern(this.app.current.group.patterns.at(0).get('position'));
  };

  PatternUIView.prototype._selectPattern = function(patternNumber) {
    var left;
    this.app.current.group.patterns.findWhere({
      position: patternNumber
    }) || this.app.current.group.patterns.add({
      position: patternNumber
    });
    this.app.current.pattern = this.app.current.group.patterns.findWhere({
      position: patternNumber
    });
    this.app.current.group.lastActivePattern = this.app.current.pattern;
    this.togglePatternSelectButtons(patternNumber);
    this.$(".grid").hide();
    this.app.current.pattern.view.$el.show();
    this.UIModel.set('pattern.zoom', this.app.current.pattern.get('zoom'));
    left = this.updatePlayHead();
    this.$('.patterns').prop('scrollLeft', (left / 95) * this.app.current.pattern.view.$el.width());
    return this.trigger('changePattern', this.app.current.pattern);
  };

  return PatternUIView;

})(Backbone.View);

module.exports = PatternUIView;


},{"../collections/pattern":3,"./transport":29}],28:[function(require,module,exports){
var $, Backbone, SLOT_CLASSES, SLOT_COL_CLASSES, SLOT_LABEL_CLASSES, SequenceView, sequenceTemplate, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = $ = require('jquery');

_ = require('underscore');

sequenceTemplate = require('../templates/sequence.tpl');

SLOT_LABEL_CLASSES = 'slot slot-label';

SLOT_COL_CLASSES = 'col col-1';

SLOT_CLASSES = 'slot';

SequenceView = (function(_super) {
  __extends(SequenceView, _super);

  function SequenceView() {
    return SequenceView.__super__.constructor.apply(this, arguments);
  }

  SequenceView.prototype.template = sequenceTemplate;

  SequenceView.prototype.el = '.sequence';

  SequenceView.prototype.initialize = function(options) {
    this.app = options.app;
    return this.buildSequence();
  };

  SequenceView.prototype.buildSequence = function() {
    var cols, column, html, row, rows;
    column = 0;
    cols = [];
    while (column < 13) {
      row = 0;
      cols[column] = $("<div class=\"" + SLOT_COL_CLASSES + "\">");
      rows = [];
      while (row < 8) {
        if (column === 0) {
          html = "<div class=\"" + SLOT_CLASSES + "\">Group " + (row + 1) + "</div>";
        } else {
          html = "<div class=\"" + SLOT_CLASSES + "\">&nbsp;</div>";
        }
        rows.push($(html));
        row++;
      }
      cols[column].append(rows);
      column++;
    }
    return this.$el.append(cols);
  };

  return SequenceView;

})(Backbone.View);

module.exports = SequenceView;


},{"../templates/sequence.tpl":17}],29:[function(require,module,exports){
var $, Backbone, TransportModel, TransportView, transportTemplate, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = require('backbone');

Backbone.$ = $ = require('jquery');

_ = require('underscore');

TransportModel = require('../models/transport');

transportTemplate = require('../templates/transport.tpl');

TransportView = (function(_super) {
  __extends(TransportView, _super);

  function TransportView() {
    return TransportView.__super__.constructor.apply(this, arguments);
  }

  TransportView.prototype.el = '.transport';

  TransportView.prototype.template = transportTemplate;

  TransportView.prototype.initialize = function(options) {
    if (options == null) {
      options = {};
    }
    this.app = options.app;
    _.bindAll(this, '_start', '_stop', '_tick', 'recalculate');
    this.model = new TransportModel({
      bpm: 80,
      step: 64
    });
    this._currentTime = this._currentTick = 0;
    this._playing = this._recording = false;
    return this.render();
  };

  TransportView.prototype.events = {
    'click [data-behavior]': 'delegateAction'
  };

  TransportView.prototype.render = function() {
    return this.el.innerHTML = this.template();
  };

  TransportView.prototype.delegateAction = function(e) {
    var behavior;
    behavior = $(e.currentTarget).data('behavior');
    if (this[behavior]) {
      e.preventDefault();
      return this[behavior].call(this, e);
    }
  };

  TransportView.prototype.stop = function(e) {
    this._stop();
    return this.$('[data-behavior="record"], [data-behavior="play"]').removeClass('active');
  };


  /*
   * pause/play
   */

  TransportView.prototype.play = function(e) {
    if (this._playing) {
      return this._stop();
    } else {
      return this._start();
    }
  };


  /*
   * sets recording property to true so that the pads UI
   * can detect that it should be recording triggers
   */

  TransportView.prototype.record = function(e) {
    if (!this._playing) {
      this._start();
    }
    this._recording = !this._recording;
    return this.$('[data-behavior="record"]').toggleClass('active');
  };


  /*
   * restarts playhead tick to 0
   */

  TransportView.prototype.restart = function(e) {
    return this.setTick(0);
  };

  TransportView.prototype.end = function(e) {
    debugger;
  };


  /*
   * private start method to start the playhead and sequence/pattern
   */

  TransportView.prototype._start = function() {
    this._playing = true;
    this.clock = setInterval(this._tick, parseInt(this.model.get('interval'), 10));
    return this.$('[data-behavior="play"]').addClass('active');
  };


  /*
   * private stop method to stop the playhead and sequence/pattern
   */

  TransportView.prototype._stop = function() {
    clearInterval(this.clock);
    this._recording = false;
    this._playing = false;
    return this.$('[data-behavior="play"], [data-behavior="record"]').removeClass('active');
  };

  TransportView.prototype._tick = function() {
    return this.setTick(this._currentTick + 1);
  };

  TransportView.prototype.getTick = function() {
    return this._currentTick;
  };

  TransportView.prototype.getTime = function(humanReadable) {
    var formatted, time;
    if (humanReadable == null) {
      humanReadable = false;
    }
    if (!humanReadable) {
      return this._currentTime;
    } else {
      time = ('' + (this._currentTime / 1000 * 100)).split('.')[0];
      formatted = '';
      while (time.length < 8) {
        time = '0' + time;
      }
      time = time.split('');
      while (true) {
        formatted += time.splice(0, 2).join('');
        if (time.length >= 2) {
          formatted += ':';
        }
        if (!time.length) {
          break;
        }
      }
      return formatted;
    }
  };


  /*
   * Setter for the desired tick
   * calls necessary update methods to keep the UI and time in sync
   */

  TransportView.prototype.setTick = function(value) {
    this.trigger('tick', value);
    this._currentTick = value;
    this._currentTime = value * parseInt(this.model.get('interval'), 10);
    return this.app.display.model.set('left', this.getTime(true));
  };


  /*
   * setter for the desired playhead time
   * calls necessary update methods to keep the UI and tick in sync
   */

  TransportView.prototype.setTime = function(value) {
    this._currentTime = value;
    this._currentTick = value / this.model.get('interval');
    return this.app.display.model.set('left', this.getTime(true));
  };


  /*
   * recalulate the interval when the bpm changes
   */

  TransportView.prototype.recalculate = function(model, changed) {
    if (changed.bpm) {
      this.model.set('interval', this.calculateInterval(changed.bpm));
    }
    this._stop();
    return this._start();
  };

  return TransportView;

})(Backbone.View);

module.exports = TransportView;


},{"../models/transport":12,"../templates/transport.tpl":18}],30:[function(require,module,exports){

},{}],31:[function(require,module,exports){
/* ==========================================================
 * bootstrap-alert.js v2.1.1
 * http://twitter.github.com/bootstrap/javascript.html#alerts
 * ==========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* ALERT CLASS DEFINITION
  * ====================== */

  var dismiss = '[data-dismiss="alert"]'
    , Alert = function (el) {
        $(el).on('click', dismiss, this.close)
      }

  Alert.prototype.close = function (e) {
    var $this = $(this)
      , selector = $this.attr('data-target')
      , $parent

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    $parent = $(selector)

    e && e.preventDefault()

    $parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())

    $parent.trigger(e = $.Event('close'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      $parent
        .trigger('closed')
        .remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent.on($.support.transition.end, removeElement) :
      removeElement()
  }


 /* ALERT PLUGIN DEFINITION
  * ======================= */

  $.fn.alert = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('alert')
      if (!data) $this.data('alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.alert.Constructor = Alert


 /* ALERT DATA-API
  * ============== */

  $(function () {
    $('body').on('click.alert.data-api', dismiss, Alert.prototype.close)
  })

}(window.jQuery);
},{}],32:[function(require,module,exports){
/* ============================================================
 * bootstrap-button.js v2.1.1
 * http://twitter.github.com/bootstrap/javascript.html#buttons
 * ============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

  "use strict"; // jshint ;_;


 /* BUTTON PUBLIC CLASS DEFINITION
  * ============================== */

  var Button = function (element, options) {
    this.$element = $(element)
    this.options = $.extend({}, $.fn.button.defaults, options)
  }

  Button.prototype.setState = function (state) {
    var d = 'disabled'
      , $el = this.$element
      , data = $el.data()
      , val = $el.is('input') ? 'val' : 'html'

    state = state + 'Text'
    data.resetText || $el.data('resetText', $el[val]())

    $el[val](data[state] || this.options[state])

    // push to event loop to allow forms to submit
    setTimeout(function () {
      state == 'loadingText' ?
        $el.addClass(d).attr(d, d) :
        $el.removeClass(d).removeAttr(d)
    }, 0)
  }

  Button.prototype.toggle = function () {
    var $parent = this.$element.closest('[data-toggle="buttons-radio"]')

    $parent && $parent
      .find('.active')
      .removeClass('active')

    this.$element.toggleClass('active')
  }


 /* BUTTON PLUGIN DEFINITION
  * ======================== */

  $.fn.button = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('button')
        , options = typeof option == 'object' && option
      if (!data) $this.data('button', (data = new Button(this, options)))
      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  $.fn.button.defaults = {
    loadingText: 'loading...'
  }

  $.fn.button.Constructor = Button


 /* BUTTON DATA-API
  * =============== */

  $(function () {
    $('body').on('click.button.data-api', '[data-toggle^=button]', function ( e ) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      $btn.button('toggle')
    })
  })

}(window.jQuery);
},{}],33:[function(require,module,exports){
/* ============================================================
 * bootstrap-dropdown.js v2.1.1
 * http://twitter.github.com/bootstrap/javascript.html#dropdowns
 * ============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

  "use strict"; // jshint ;_;


 /* DROPDOWN CLASS DEFINITION
  * ========================= */

  var toggle = '[data-toggle=dropdown]'
    , Dropdown = function (element) {
        var $el = $(element).on('click.dropdown.data-api', this.toggle)
        $('html').on('click.dropdown.data-api', function () {
          $el.parent().removeClass('open')
        })
      }

  Dropdown.prototype = {

    constructor: Dropdown

  , toggle: function (e) {
      var $this = $(this)
        , $parent
        , isActive

      if ($this.is('.disabled, :disabled')) return

      $parent = getParent($this)

      isActive = $parent.hasClass('open')

      clearMenus()

      if (!isActive) {
        $parent.toggleClass('open')
        $this.focus()
      }

      return false
    }

  , keydown: function (e) {
      var $this
        , $items
        , $active
        , $parent
        , isActive
        , index

      if (!/(38|40|27)/.test(e.keyCode)) return

      $this = $(this)

      e.preventDefault()
      e.stopPropagation()

      if ($this.is('.disabled, :disabled')) return

      $parent = getParent($this)

      isActive = $parent.hasClass('open')

      if (!isActive || (isActive && e.keyCode == 27)) return $this.click()

      $items = $('[role=menu] li:not(.divider) a', $parent)

      if (!$items.length) return

      index = $items.index($items.filter(':focus'))

      if (e.keyCode == 38 && index > 0) index--                                        // up
      if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
      if (!~index) index = 0

      $items
        .eq(index)
        .focus()
    }

  }

  function clearMenus() {
    getParent($(toggle))
      .removeClass('open')
  }

  function getParent($this) {
    var selector = $this.attr('data-target')
      , $parent

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    $parent = $(selector)
    $parent.length || ($parent = $this.parent())

    return $parent
  }


  /* DROPDOWN PLUGIN DEFINITION
   * ========================== */

  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('dropdown')
      if (!data) $this.data('dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.dropdown.Constructor = Dropdown


  /* APPLY TO STANDARD DROPDOWN ELEMENTS
   * =================================== */

  $(function () {
    $('html')
      .on('click.dropdown.data-api touchstart.dropdown.data-api', clearMenus)
    $('body')
      .on('click.dropdown touchstart.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
      .on('click.dropdown.data-api touchstart.dropdown.data-api'  , toggle, Dropdown.prototype.toggle)
      .on('keydown.dropdown.data-api touchstart.dropdown.data-api', toggle + ', [role=menu]' , Dropdown.prototype.keydown)
  })

}(window.jQuery);
},{}],34:[function(require,module,exports){
/* =========================================================
 * bootstrap-modal.js v2.1.1
 * http://twitter.github.com/bootstrap/javascript.html#modals
 * =========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */


!function ($) {

  "use strict"; // jshint ;_;


 /* MODAL CLASS DEFINITION
  * ====================== */

  var Modal = function (element, options) {
    this.options = options
    this.$element = $(element)
      .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote)
  }

  Modal.prototype = {

      constructor: Modal

    , toggle: function () {
        return this[!this.isShown ? 'show' : 'hide']()
      }

    , show: function () {
        var that = this
          , e = $.Event('show')

        this.$element.trigger(e)

        if (this.isShown || e.isDefaultPrevented()) return

        $('body').addClass('modal-open')

        this.isShown = true

        this.escape()

        this.backdrop(function () {
          var transition = $.support.transition && that.$element.hasClass('fade')

          if (!that.$element.parent().length) {
            that.$element.appendTo(document.body) //don't move modals dom position
          }

          that.$element
            .show()

          if (transition) {
            that.$element[0].offsetWidth // force reflow
          }

          that.$element
            .addClass('in')
            .attr('aria-hidden', false)
            .focus()

          that.enforceFocus()

          transition ?
            that.$element.one($.support.transition.end, function () { that.$element.trigger('shown') }) :
            that.$element.trigger('shown')

        })
      }

    , hide: function (e) {
        e && e.preventDefault()

        var that = this

        e = $.Event('hide')

        this.$element.trigger(e)

        if (!this.isShown || e.isDefaultPrevented()) return

        this.isShown = false

        $('body').removeClass('modal-open')

        this.escape()

        $(document).off('focusin.modal')

        this.$element
          .removeClass('in')
          .attr('aria-hidden', true)

        $.support.transition && this.$element.hasClass('fade') ?
          this.hideWithTransition() :
          this.hideModal()
      }

    , enforceFocus: function () {
        var that = this
        $(document).on('focusin.modal', function (e) {
          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
            that.$element.focus()
          }
        })
      }

    , escape: function () {
        var that = this
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keyup.dismiss.modal', function ( e ) {
            e.which == 27 && that.hide()
          })
        } else if (!this.isShown) {
          this.$element.off('keyup.dismiss.modal')
        }
      }

    , hideWithTransition: function () {
        var that = this
          , timeout = setTimeout(function () {
              that.$element.off($.support.transition.end)
              that.hideModal()
            }, 500)

        this.$element.one($.support.transition.end, function () {
          clearTimeout(timeout)
          that.hideModal()
        })
      }

    , hideModal: function (that) {
        this.$element
          .hide()
          .trigger('hidden')

        this.backdrop()
      }

    , removeBackdrop: function () {
        this.$backdrop.remove()
        this.$backdrop = null
      }

    , backdrop: function (callback) {
        var that = this
          , animate = this.$element.hasClass('fade') ? 'fade' : ''

        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate

          this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
            .appendTo(document.body)

          if (this.options.backdrop != 'static') {
            this.$backdrop.click($.proxy(this.hide, this))
          }

          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

          this.$backdrop.addClass('in')

          doAnimate ?
            this.$backdrop.one($.support.transition.end, callback) :
            callback()

        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in')

          $.support.transition && this.$element.hasClass('fade')?
            this.$backdrop.one($.support.transition.end, $.proxy(this.removeBackdrop, this)) :
            this.removeBackdrop()

        } else if (callback) {
          callback()
        }
      }
  }


 /* MODAL PLUGIN DEFINITION
  * ======================= */

  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('modal')
        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option]()
      else if (options.show) data.show()
    })
  }

  $.fn.modal.defaults = {
      backdrop: true
    , keyboard: true
    , show: true
  }

  $.fn.modal.Constructor = Modal


 /* MODAL DATA-API
  * ============== */

  $(function () {
    $('body').on('click.modal.data-api', '[data-toggle="modal"]', function ( e ) {
      var $this = $(this)
        , href = $this.attr('href')
        , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
        , option = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

      e.preventDefault()

      $target
        .modal(option)
        .one('hide', function () {
          $this.focus()
        })
    })
  })

}(window.jQuery);
},{}],35:[function(require,module,exports){
/* ===========================================================
 * bootstrap-popover.js v2.1.1
 * http://twitter.github.com/bootstrap/javascript.html#popovers
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* POPOVER PUBLIC CLASS DEFINITION
  * =============================== */

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }


  /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
     ========================================== */

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {

    constructor: Popover

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()
        , content = this.getContent()

      $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
      $tip.find('.popover-content > *')[this.options.html ? 'html' : 'text'](content)

      $tip.removeClass('fade top bottom left right in')
    }

  , hasContent: function () {
      return this.getTitle() || this.getContent()
    }

  , getContent: function () {
      var content
        , $e = this.$element
        , o = this.options

      content = $e.attr('data-content')
        || (typeof o.content == 'function' ? o.content.call($e[0]) :  o.content)

      return content
    }

  , tip: function () {
      if (!this.$tip) {
        this.$tip = $(this.options.template)
      }
      return this.$tip
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  })


 /* POPOVER PLUGIN DEFINITION
  * ======================= */

  $.fn.popover = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('popover')
        , options = typeof option == 'object' && option
      if (!data) $this.data('popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.popover.Constructor = Popover

  $.fn.popover.defaults = $.extend({} , $.fn.tooltip.defaults, {
    placement: 'right'
  , trigger: 'click'
  , content: ''
  , template: '<div class="popover"><div class="arrow"></div><div class="popover-inner"><h3 class="popover-title"></h3><div class="popover-content"><p></p></div></div></div>'
  })

}(window.jQuery);
},{}],36:[function(require,module,exports){
/* ===========================================================
 * bootstrap-tooltip.js v2.1.1
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */

  var Tooltip = function (element, options) {
    this.init('tooltip', element, options)
  }

  Tooltip.prototype = {

    constructor: Tooltip

  , init: function (type, element, options) {
      var eventIn
        , eventOut

      this.type = type
      this.$element = $(element)
      this.options = this.getOptions(options)
      this.enabled = true

      if (this.options.trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (this.options.trigger != 'manual') {
        eventIn = this.options.trigger == 'hover' ? 'mouseenter' : 'focus'
        eventOut = this.options.trigger == 'hover' ? 'mouseleave' : 'blur'
        this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    }

  , getOptions: function (options) {
      options = $.extend({}, $.fn[this.type].defaults, options, this.$element.data())

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay
        , hide: options.delay
        }
      }

      return options
    }

  , enter: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (!self.options.delay || !self.options.delay.show) return self.show()

      clearTimeout(this.timeout)
      self.hoverState = 'in'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    }

  , leave: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (this.timeout) clearTimeout(this.timeout)
      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.hoverState = 'out'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    }

  , show: function () {
      var $tip
        , inside
        , pos
        , actualWidth
        , actualHeight
        , placement
        , tp

      if (this.hasContent() && this.enabled) {
        $tip = this.tip()
        this.setContent()

        if (this.options.animation) {
          $tip.addClass('fade')
        }

        placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        inside = /in/.test(placement)

        $tip
          .remove()
          .css({ top: 0, left: 0, display: 'block' })
          .appendTo(inside ? this.$element : document.body)

        pos = this.getPosition(inside)

        actualWidth = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight

        switch (inside ? placement.split(' ')[1] : placement) {
          case 'bottom':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'top':
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'left':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
            break
          case 'right':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
            break
        }

        $tip
          .css(tp)
          .addClass(placement)
          .addClass('in')
      }
    }

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()

      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    }

  , hide: function () {
      var that = this
        , $tip = this.tip()

      $tip.removeClass('in')

      function removeWithAnimation() {
        var timeout = setTimeout(function () {
          $tip.off($.support.transition.end).remove()
        }, 500)

        $tip.one($.support.transition.end, function () {
          clearTimeout(timeout)
          $tip.remove()
        })
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        removeWithAnimation() :
        $tip.remove()

      return this
    }

  , fixTitle: function () {
      var $e = this.$element
      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').removeAttr('title')
      }
    }

  , hasContent: function () {
      return this.getTitle()
    }

  , getPosition: function (inside) {
      return $.extend({}, (inside ? {top: 0, left: 0} : this.$element.offset()), {
        width: this.$element[0].offsetWidth
      , height: this.$element[0].offsetHeight
      })
    }

  , getTitle: function () {
      var title
        , $e = this.$element
        , o = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    }

  , tip: function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

  , validate: function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options = null
      }
    }

  , enable: function () {
      this.enabled = true
    }

  , disable: function () {
      this.enabled = false
    }

  , toggleEnabled: function () {
      this.enabled = !this.enabled
    }

  , toggle: function () {
      this[this.tip().hasClass('in') ? 'hide' : 'show']()
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  }


 /* TOOLTIP PLUGIN DEFINITION
  * ========================= */

  $.fn.tooltip = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tooltip')
        , options = typeof option == 'object' && option
      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip

  $.fn.tooltip.defaults = {
    animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover'
  , title: ''
  , delay: 0
  , html: true
  }

}(window.jQuery);

},{}],37:[function(require,module,exports){
/* ===================================================
 * bootstrap-transition.js v2.1.1
 * http://twitter.github.com/bootstrap/javascript.html#transitions
 * ===================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  $(function () {

    "use strict"; // jshint ;_;


    /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
     * ======================================================= */

    $.support.transition = (function () {

      var transitionEnd = (function () {

        var el = document.createElement('bootstrap')
          , transEndEventNames = {
               'WebkitTransition' : 'webkitTransitionEnd'
            ,  'MozTransition'    : 'transitionend'
            ,  'OTransition'      : 'oTransitionEnd otransitionend'
            ,  'transition'       : 'transitionend'
            }
          , name

        for (name in transEndEventNames){
          if (el.style[name] !== undefined) {
            return transEndEventNames[name]
          }
        }

      }())

      return transitionEnd && {
        end: transitionEnd
      }

    })()

  })

}(window.jQuery);
},{}],38:[function(require,module,exports){
/* =============================================================
 * bootstrap-typeahead.js v2.1.1
 * http://twitter.github.com/bootstrap/javascript.html#typeahead
 * =============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function($){

  "use strict"; // jshint ;_;


 /* TYPEAHEAD PUBLIC CLASS DEFINITION
  * ================================= */

  var Typeahead = function (element, options) {
    this.$element = $(element)
    this.options = $.extend({}, $.fn.typeahead.defaults, options)
    this.matcher = this.options.matcher || this.matcher
    this.sorter = this.options.sorter || this.sorter
    this.highlighter = this.options.highlighter || this.highlighter
    this.updater = this.options.updater || this.updater
    this.$menu = $(this.options.menu).appendTo('body')
    this.source = this.options.source
    this.shown = false
    this.listen()
  }

  Typeahead.prototype = {

    constructor: Typeahead

  , select: function () {
      var val = this.$menu.find('.active').attr('data-value')
      this.$element
        .val(this.updater(val))
        .change()
      return this.hide()
    }

  , updater: function (item) {
      return item
    }

  , show: function () {
      var pos = $.extend({}, this.$element.offset(), {
        height: this.$element[0].offsetHeight
      })

      this.$menu.css({
        top: pos.top + pos.height
      , left: pos.left
      })

      this.$menu.show()
      this.shown = true
      return this
    }

  , hide: function () {
      this.$menu.hide()
      this.shown = false
      return this
    }

  , lookup: function (event) {
      var items

      this.query = this.$element.val()

      if (!this.query || this.query.length < this.options.minLength) {
        return this.shown ? this.hide() : this
      }

      items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source

      return items ? this.process(items) : this
    }

  , process: function (items) {
      var that = this

      items = $.grep(items, function (item) {
        return that.matcher(item)
      })

      items = this.sorter(items)

      if (!items.length) {
        return this.shown ? this.hide() : this
      }

      return this.render(items.slice(0, this.options.items)).show()
    }

  , matcher: function (item) {
      return ~item.toLowerCase().indexOf(this.query.toLowerCase())
    }

  , sorter: function (items) {
      var beginswith = []
        , caseSensitive = []
        , caseInsensitive = []
        , item

      while (item = items.shift()) {
        if (!item.toLowerCase().indexOf(this.query.toLowerCase())) beginswith.push(item)
        else if (~item.indexOf(this.query)) caseSensitive.push(item)
        else caseInsensitive.push(item)
      }

      return beginswith.concat(caseSensitive, caseInsensitive)
    }

  , highlighter: function (item) {
      var query = this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
      return item.replace(new RegExp('(' + query + ')', 'ig'), function ($1, match) {
        return '<strong>' + match + '</strong>'
      })
    }

  , render: function (items) {
      var that = this

      items = $(items).map(function (i, item) {
        i = $(that.options.item).attr('data-value', item)
        i.find('a').html(that.highlighter(item))
        return i[0]
      })

      items.first().addClass('active')
      this.$menu.html(items)
      return this
    }

  , next: function (event) {
      var active = this.$menu.find('.active').removeClass('active')
        , next = active.next()

      if (!next.length) {
        next = $(this.$menu.find('li')[0])
      }

      next.addClass('active')
    }

  , prev: function (event) {
      var active = this.$menu.find('.active').removeClass('active')
        , prev = active.prev()

      if (!prev.length) {
        prev = this.$menu.find('li').last()
      }

      prev.addClass('active')
    }

  , listen: function () {
      this.$element
        .on('blur',     $.proxy(this.blur, this))
        .on('keypress', $.proxy(this.keypress, this))
        .on('keyup',    $.proxy(this.keyup, this))

      if ($.browser.chrome || $.browser.webkit || $.browser.msie) {
        this.$element.on('keydown', $.proxy(this.keydown, this))
      }

      this.$menu
        .on('click', $.proxy(this.click, this))
        .on('mouseenter', 'li', $.proxy(this.mouseenter, this))
    }

  , move: function (e) {
      if (!this.shown) return

      switch(e.keyCode) {
        case 9: // tab
        case 13: // enter
        case 27: // escape
          e.preventDefault()
          break

        case 38: // up arrow
          e.preventDefault()
          this.prev()
          break

        case 40: // down arrow
          e.preventDefault()
          this.next()
          break
      }

      e.stopPropagation()
    }

  , keydown: function (e) {
      this.suppressKeyPressRepeat = !~$.inArray(e.keyCode, [40,38,9,13,27])
      this.move(e)
    }

  , keypress: function (e) {
      if (this.suppressKeyPressRepeat) return
      this.move(e)
    }

  , keyup: function (e) {
      switch(e.keyCode) {
        case 40: // down arrow
        case 38: // up arrow
          break

        case 9: // tab
        case 13: // enter
          if (!this.shown) return
          this.select()
          break

        case 27: // escape
          if (!this.shown) return
          this.hide()
          break

        default:
          this.lookup()
      }

      e.stopPropagation()
      e.preventDefault()
  }

  , blur: function (e) {
      var that = this
      setTimeout(function () { that.hide() }, 150)
    }

  , click: function (e) {
      e.stopPropagation()
      e.preventDefault()
      this.select()
    }

  , mouseenter: function (e) {
      this.$menu.find('.active').removeClass('active')
      $(e.currentTarget).addClass('active')
    }

  }


  /* TYPEAHEAD PLUGIN DEFINITION
   * =========================== */

  $.fn.typeahead = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('typeahead')
        , options = typeof option == 'object' && option
      if (!data) $this.data('typeahead', (data = new Typeahead(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.typeahead.defaults = {
    source: []
  , items: 8
  , menu: '<ul class="typeahead dropdown-menu"></ul>'
  , item: '<li><a href="#"></a></li>'
  , minLength: 1
  }

  $.fn.typeahead.Constructor = Typeahead


 /*   TYPEAHEAD DATA-API
  * ================== */

  $(function () {
    $('body').on('focus.typeahead.data-api', '[data-provide="typeahead"]', function (e) {
      var $this = $(this)
      if ($this.data('typeahead')) return
      e.preventDefault()
      $this.typeahead($this.data())
    })
  })

}(window.jQuery);

},{}]},{},[5])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi9ib3dlcl9jb21wb25lbnRzL3BhcGVyL2Rpc3QvcGFwZXItZnVsbC5qcyIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL2NvbGxlY3Rpb25zL2dyb3VwLmNvZmZlZSIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL2NvbGxlY3Rpb25zL3BhdHRlcm4uY29mZmVlIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9saWIvY29sbGVjdGlvbnMvc291bmQuY29mZmVlIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9saWIvbWFpbi5jb2ZmZWUiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi9tb2RlbHMvYmFzZS5jb2ZmZWUiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi9tb2RlbHMvZGlzcGxheS5jb2ZmZWUiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi9tb2RlbHMvZ3JvdXAuY29mZmVlIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9saWIvbW9kZWxzL3BhdHRlcm4uY29mZmVlIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9saWIvbW9kZWxzL3JlY2lwZS5jb2ZmZWUiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi9tb2RlbHMvc291bmQuY29mZmVlIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9saWIvbW9kZWxzL3RyYW5zcG9ydC5jb2ZmZWUiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi9yb3V0ZXMvYXBwLmNvZmZlZSIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL3RlbXBsYXRlcy9kaXNwbGF5LnRwbCIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL3RlbXBsYXRlcy9lZGl0b3IudHBsIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9saWIvdGVtcGxhdGVzL3BhZC50cGwiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi90ZW1wbGF0ZXMvc2VxdWVuY2UudHBsIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9saWIvdGVtcGxhdGVzL3RyYW5zcG9ydC50cGwiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi92ZW5kb3IvanF1ZXJ5LWJvb3RzdHJhcC5qcyIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL3ZlbmRvci90aW1icmUuZGV2LmpzIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9saWIvdmlld3MvYXBwLmNvZmZlZSIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL3ZpZXdzL2Rpc3BsYXkuY29mZmVlIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9saWIvdmlld3MvZWRpdG9yLmNvZmZlZSIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL3ZpZXdzL3BhZC5jb2ZmZWUiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi92aWV3cy9wYWRzLmNvZmZlZSIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL3ZpZXdzL3BhdHRlcm4uZ3JpZC5jb2ZmZWUiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL2xpYi92aWV3cy9wYXR0ZXJuLnVpLmNvZmZlZSIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL3ZpZXdzL3NlcXVlbmNlLmNvZmZlZSIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbGliL3ZpZXdzL3RyYW5zcG9ydC5jb2ZmZWUiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L2xpYi9fZW1wdHkuanMiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL25vZGVfbW9kdWxlcy90d2l0dGVyLWJvb3RzdHJhcC9qcy9ib290c3RyYXAtYWxlcnQuanMiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL25vZGVfbW9kdWxlcy90d2l0dGVyLWJvb3RzdHJhcC9qcy9ib290c3RyYXAtYnV0dG9uLmpzIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9ub2RlX21vZHVsZXMvdHdpdHRlci1ib290c3RyYXAvanMvYm9vdHN0cmFwLWRyb3Bkb3duLmpzIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9ub2RlX21vZHVsZXMvdHdpdHRlci1ib290c3RyYXAvanMvYm9vdHN0cmFwLW1vZGFsLmpzIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9ub2RlX21vZHVsZXMvdHdpdHRlci1ib290c3RyYXAvanMvYm9vdHN0cmFwLXBvcG92ZXIuanMiLCIvVXNlcnMvam9zaC9jb2RlL2JlZXRtYWNoaW5lL25vZGVfbW9kdWxlcy90d2l0dGVyLWJvb3RzdHJhcC9qcy9ib290c3RyYXAtdG9vbHRpcC5qcyIsIi9Vc2Vycy9qb3NoL2NvZGUvYmVldG1hY2hpbmUvbm9kZV9tb2R1bGVzL3R3aXR0ZXItYm9vdHN0cmFwL2pzL2Jvb3RzdHJhcC10cmFuc2l0aW9uLmpzIiwiL1VzZXJzL2pvc2gvY29kZS9iZWV0bWFjaGluZS9ub2RlX21vZHVsZXMvdHdpdHRlci1ib290c3RyYXAvanMvYm9vdHN0cmFwLXR5cGVhaGVhZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZtWkEsSUFBQSwrQ0FBQTtFQUFBO2lTQUFBOztBQUFBLFFBQUEsR0FBYSxPQUFBLENBQVEsVUFBUixDQUFiLENBQUE7O0FBQUEsQ0FDQSxHQUFTLE9BQUEsQ0FBUSxZQUFSLENBRFQsQ0FBQTs7QUFBQSxVQUVBLEdBQWMsT0FBQSxDQUFRLGlCQUFSLENBRmQsQ0FBQTs7QUFBQSxLQUdBLEdBQVcsT0FBQSxDQUFRLE9BQVIsQ0FIWCxDQUFBOztBQUFBO0FBT0Msb0NBQUEsQ0FBQTs7OztHQUFBOztBQUFBLDRCQUFBLEtBQUEsR0FBTyxVQUFQLENBQUE7O0FBQUEsNEJBRUEsVUFBQSxHQUFZLFVBRlosQ0FBQTs7QUFBQSw0QkFJQSxHQUFBLEdBQUssU0FKTCxDQUFBOztBQUFBLDRCQU1BLFNBQUEsR0FBVyxTQU5YLENBQUE7O0FBQUEsNEJBUUEsVUFBQSxHQUFZLFNBQUMsS0FBRCxFQUFhLE9BQWIsR0FBQTs7TUFBQyxRQUFRO0tBQ3BCOztNQUR3QixVQUFVO0tBQ2xDO1dBQUUsSUFBQyxDQUFBLGNBQUEsR0FBSCxFQUFXLFFBREE7RUFBQSxDQVJaLENBQUE7O0FBQUEsNEJBV0EsY0FBQSxHQUFnQixTQUFFLEdBQUYsRUFBUSxNQUFSLEVBQWdCLGNBQWhCLEdBQUE7QUFDZixJQURnQixJQUFDLENBQUEsTUFBQSxHQUNqQixDQUFBO0FBQUEsSUFEc0IsSUFBQyxDQUFBLFNBQUEsTUFDdkIsQ0FBQTtXQUFBLElBQUMsQ0FBQSxLQUFELENBQ0M7QUFBQSxNQUFBLEdBQUEsRUFBTSxHQUFBLEdBQUUsSUFBQyxDQUFBLFNBQUgsR0FBYyxHQUFkLEdBQWdCLENBQUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxHQUFSLENBQVksSUFBWixDQUFBLENBQWhCLEdBQW9DLElBQUMsQ0FBQSxHQUEzQztBQUFBLE1BQ0EsT0FBQSxFQUFTLENBQUEsU0FBQSxLQUFBLEdBQUE7ZUFBQSxTQUFDLFVBQUQsRUFBYSxNQUFiLEVBQXFCLE9BQXJCLEdBQUE7QUFDUixjQUFBLFVBQUE7QUFBQSxVQUFBLFVBQUEsR0FBYSxFQUFiLENBQUE7QUFBQSxVQUNBLEtBQUMsQ0FBQSxJQUFELENBQU0sU0FBQyxLQUFELEdBQUE7QUFDTCxZQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWdCLFNBQUMsUUFBRCxHQUFBO3FCQUNmLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYixDQUE0QixLQUFDLENBQUEsR0FBN0IsRUFBa0MsS0FBbEMsRUFBeUMsUUFBekMsRUFEZTtZQUFBLENBQWhCLENBQUEsQ0FBQTttQkFFQSxVQUFVLENBQUMsSUFBWCxDQUFnQixTQUFDLFNBQUQsR0FBQTtxQkFDZixLQUFLLENBQUMsUUFBUSxDQUFDLGNBQWYsQ0FBOEIsS0FBQyxDQUFBLEdBQS9CLEVBQW9DLEtBQXBDLEVBQTJDLFNBQTNDLEVBRGU7WUFBQSxDQUFoQixFQUhLO1VBQUEsQ0FBTixDQURBLENBQUE7aUJBTUEsS0FBSyxDQUFDLFFBQU4sQ0FBZSxVQUFmLEVBQTJCLGNBQTNCLEVBUFE7UUFBQSxFQUFBO01BQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQURUO0tBREQsRUFVRTtBQUFBLE1BQUEsS0FBQSxFQUFPLElBQVA7S0FWRixFQURlO0VBQUEsQ0FYaEIsQ0FBQTs7eUJBQUE7O0dBRjZCLFFBQVEsQ0FBQyxXQUx2QyxDQUFBOztBQUFBLE1BK0JNLENBQUMsT0FBUCxHQUFpQixlQS9CakIsQ0FBQTs7OztBQ0FBLElBQUEsNENBQUE7RUFBQTtpU0FBQTs7QUFBQSxRQUFBLEdBQWMsT0FBQSxDQUFRLFVBQVIsQ0FBZCxDQUFBOztBQUFBLENBQ0EsR0FBVSxPQUFBLENBQVEsWUFBUixDQURWLENBQUE7O0FBQUEsWUFFQSxHQUFnQixPQUFBLENBQVEsbUJBQVIsQ0FGaEIsQ0FBQTs7QUFBQTtBQU1DLHNDQUFBLENBQUE7Ozs7R0FBQTs7QUFBQSw4QkFBQSxVQUFBLEdBQVksU0FBQyxNQUFELEVBQWMsT0FBZCxHQUFBOztNQUFDLFNBQVM7S0FDckI7O01BRHlCLFVBQVU7S0FDbkM7V0FBRSxJQUFDLENBQUEsZ0JBQUEsS0FBSCxFQUFhLFFBREY7RUFBQSxDQUFaLENBQUE7O0FBQUEsOEJBR0EsVUFBQSxHQUFZLFVBSFosQ0FBQTs7QUFBQSw4QkFLQSxLQUFBLEdBQU8sWUFMUCxDQUFBOztBQUFBLDhCQU9BLFNBQUEsR0FBVyxRQVBYLENBQUE7O0FBQUEsOEJBU0EsR0FBQSxHQUFLLFdBVEwsQ0FBQTs7QUFBQSw4QkFXQSxjQUFBLEdBQWdCLFNBQUUsR0FBRixFQUFRLE1BQVIsRUFBZ0IsY0FBaEIsR0FBQTtBQUNmLElBRGdCLElBQUMsQ0FBQSxNQUFBLEdBQ2pCLENBQUE7QUFBQSxJQURzQixJQUFDLENBQUEsU0FBQSxNQUN2QixDQUFBO1dBQUEsSUFBQyxDQUFBLEtBQUQsQ0FDQztBQUFBLE1BQUEsR0FBQSxFQUFNLEdBQUEsR0FBRSxJQUFDLENBQUEsU0FBSCxHQUFjLEdBQWQsR0FBZ0IsQ0FBQSxJQUFDLENBQUEsTUFBTSxDQUFDLEdBQVIsQ0FBWSxJQUFaLENBQUEsQ0FBaEIsR0FBb0MsSUFBQyxDQUFBLEdBQTNDO0FBQUEsTUFDQSxPQUFBLEVBQVMsQ0FBQSxTQUFBLEtBQUEsR0FBQTtlQUFBLFNBQUMsVUFBRCxFQUFhLE1BQWIsRUFBcUIsT0FBckIsR0FBQTtpQkFDUixjQUFjLENBQUMsSUFBZixDQUFvQixLQUFwQixFQUF1QixJQUF2QixFQUE2QixNQUE3QixFQURRO1FBQUEsRUFBQTtNQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FEVDtBQUFBLE1BUUUsS0FBQSxFQUFPLElBQUMsQ0FBQSxNQVJWO0tBREQsRUFTbUIsR0FUbkIsRUFTd0IsSUFBQyxDQUFBLEdBVHpCLEVBUzhCO0FBQUEsTUFBQSxLQUFBLEVBQU8sSUFBUDtLQVQ5QixFQURlO0VBQUEsQ0FYaEIsQ0FBQTs7MkJBQUE7O0dBRitCLFFBQVEsQ0FBQyxXQUp6QyxDQUFBOztBQUFBLE1BNkJNLENBQUMsT0FBUCxHQUFpQixpQkE3QmpCLENBQUE7Ozs7QUNBQSxJQUFBLHdDQUFBO0VBQUE7aVNBQUE7O0FBQUEsUUFBQSxHQUFhLE9BQUEsQ0FBUSxVQUFSLENBQWIsQ0FBQTs7QUFBQSxDQUNBLEdBQVMsT0FBQSxDQUFRLFlBQVIsQ0FEVCxDQUFBOztBQUFBLFVBRUEsR0FBYyxPQUFBLENBQVEsaUJBQVIsQ0FGZCxDQUFBOztBQUFBO0FBTUMsb0NBQUEsQ0FBQTs7OztHQUFBOztBQUFBLDRCQUFBLFVBQUEsR0FBWSxTQUFDLE1BQUQsRUFBUyxPQUFULEdBQUE7O01BQVMsVUFBVTtLQUM5QjtXQUFFLElBQUMsQ0FBQSxnQkFBQSxLQUFILEVBQWEsUUFERjtFQUFBLENBQVosQ0FBQTs7QUFBQSw0QkFHQSxLQUFBLEdBQU8sVUFIUCxDQUFBOztBQUFBLDRCQUtBLFNBQUEsR0FBVyxTQUxYLENBQUE7O0FBQUEsNEJBT0EsR0FBQSxHQUFLLFNBUEwsQ0FBQTs7QUFBQSw0QkFTQSxjQUFBLEdBQWdCLFNBQUUsR0FBRixFQUFRLE1BQVIsRUFBZ0IsY0FBaEIsR0FBQTtBQUNmLElBRGdCLElBQUMsQ0FBQSxNQUFBLEdBQ2pCLENBQUE7QUFBQSxJQURzQixJQUFDLENBQUEsU0FBQSxNQUN2QixDQUFBO1dBQUEsSUFBQyxDQUFBLEtBQUQsQ0FDQztBQUFBLE1BQUEsR0FBQSxFQUFNLEdBQUEsR0FBRSxJQUFDLENBQUEsU0FBSCxHQUFjLEdBQWQsR0FBZ0IsQ0FBQSxJQUFDLENBQUEsTUFBTSxDQUFDLEdBQVIsQ0FBWSxJQUFaLENBQUEsQ0FBaEIsR0FBb0MsSUFBQyxDQUFBLEdBQTNDO0FBQUEsTUFDQSxPQUFBLEVBQVMsQ0FBQSxTQUFBLEtBQUEsR0FBQTtlQUFBLFNBQUMsVUFBRCxFQUFhLE1BQWIsRUFBcUIsT0FBckIsR0FBQTtpQkFDUixjQUFjLENBQUMsSUFBZixDQUFvQixLQUFwQixFQUF1QixJQUF2QixFQUE2QixNQUE3QixFQURRO1FBQUEsRUFBQTtNQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FEVDtLQURELEVBU0U7QUFBQSxNQUFBLEtBQUEsRUFBTyxJQUFDLENBQUEsTUFBUjtLQVRGLEVBU2tCLEdBVGxCLEVBU3VCLElBQUMsQ0FBQSxHQVR4QixFQVM2QjtBQUFBLE1BQUEsS0FBQSxFQUFPLElBQVA7S0FUN0IsRUFEZTtFQUFBLENBVGhCLENBQUE7O3lCQUFBOztHQUY2QixRQUFRLENBQUMsV0FKdkMsQ0FBQTs7QUFBQSxNQTJCTSxDQUFDLE9BQVAsR0FBaUIsZUEzQmpCLENBQUE7Ozs7QUNDQSxZQUFBLENBQUE7QUFBQSxNQWdCTSxDQUFDLElBQVAsR0FBYyxNQUFNLENBQUMsSUFBUCxJQUFlLE9BQUEsQ0FBUSxhQUFSLENBaEI3QixDQUFBOzs7O0FDREEsSUFBQSx5QkFBQTtFQUFBO2lTQUFBOztBQUFBLFFBQUEsR0FBd0IsT0FBQSxDQUFRLFVBQVIsQ0FBeEIsQ0FBQTs7QUFBQSxRQUNRLENBQUMsQ0FBVCxHQUF3QixDQUFBLEdBQUksT0FBQSxDQUFRLDRCQUFSLENBRDVCLENBQUE7O0FBQUEsUUFFUSxDQUFDLFdBQVQsR0FBd0IsT0FBQSxDQUFRLGlCQUFSLENBQTBCLENBQUMsV0FGbkQsQ0FBQTs7QUFBQSxDQUdBLEdBQXdCLE9BQUEsQ0FBUSxZQUFSLENBSHhCLENBQUE7O0FBQUE7QUFPRSw4QkFBQSxDQUFBOzs7O0dBQUE7O0FBQUEsc0JBQUEsV0FBQSxHQUFhLEtBQWIsQ0FBQTs7bUJBQUE7O0dBRnNCLFFBQVEsQ0FBQyxZQUxqQyxDQUFBOztBQUFBLE1BU00sQ0FBQyxPQUFQLEdBQWlCLFNBVGpCLENBQUE7Ozs7QUNBQSxJQUFBLHlCQUFBO0VBQUE7aVNBQUE7O0FBQUEsUUFBQSxHQUFjLE9BQUEsQ0FBUSxVQUFSLENBQWQsQ0FBQTs7QUFBQSxDQUNBLEdBQVUsT0FBQSxDQUFRLFlBQVIsQ0FEVixDQUFBOztBQUFBO0FBSUMsaUNBQUEsQ0FBQTs7OztHQUFBOztBQUFBLHlCQUFBLFFBQUEsR0FDQztBQUFBLElBQUEsR0FBQSxFQUFLLFNBQUw7QUFBQSxJQUNBLElBQUEsRUFBTSxDQUROO0dBREQsQ0FBQTs7QUFBQSx5QkFHQSxVQUFBLEdBQVksU0FBQyxPQUFELEdBQUEsQ0FIWixDQUFBOztzQkFBQTs7R0FEMEIsUUFBUSxDQUFDLE1BSHBDLENBQUE7O0FBQUEsTUFTTSxDQUFDLE9BQVAsR0FBaUIsWUFUakIsQ0FBQTs7OztBQ0FBLElBQUEsMkRBQUE7RUFBQTtpU0FBQTs7QUFBQSxRQUFBLEdBQWtCLE9BQUEsQ0FBUSxVQUFSLENBQWxCLENBQUE7O0FBQUEsUUFDUSxDQUFDLENBQVQsR0FBbUIsT0FBQSxDQUFRLFFBQVIsQ0FEbkIsQ0FBQTs7QUFBQSxRQUVRLENBQUMsV0FBVCxHQUF3QixPQUFBLENBQVEsaUJBQVIsQ0FBMEIsQ0FBQyxXQUZuRCxDQUFBOztBQUFBLENBR0EsR0FBYyxPQUFBLENBQVEsWUFBUixDQUhkLENBQUE7O0FBQUEsZUFJQSxHQUFxQixPQUFBLENBQVEsc0JBQVIsQ0FKckIsQ0FBQTs7QUFBQSxpQkFLQSxHQUFzQixPQUFBLENBQVEsd0JBQVIsQ0FMdEIsQ0FBQTs7QUFBQTtBQVNDLCtCQUFBLENBQUE7Ozs7R0FBQTs7QUFBQSx1QkFBQSxVQUFBLEdBQVksU0FBQyxLQUFELEVBQWEsT0FBYixHQUFBO0FBQ1gsUUFBQSxJQUFBOztNQURZLFFBQVE7S0FDcEI7O01BRHdCLFVBQVU7S0FDbEM7QUFBQSxJQUFBLE9BQWtCLE9BQU8sQ0FBQyxVQUExQixFQUFFLElBQUMsQ0FBQSxXQUFBLEdBQUgsRUFBUSxJQUFDLENBQUEsWUFBQSxJQUFULENBQUE7QUFBQSxJQUNBLElBQUMsQ0FBQSxNQUFELEdBQWMsSUFBQSxlQUFBLENBQWdCLEtBQUssQ0FBQyxNQUFOLElBQWdCO01BQUM7QUFBQSxRQUFDLEdBQUEsRUFBSyxDQUFOO09BQUQ7S0FBaEMsRUFBNEM7QUFBQSxNQUFBLEtBQUEsRUFBTyxJQUFQO0tBQTVDLENBRGQsQ0FBQTtXQUVBLElBQUMsQ0FBQSxRQUFELEdBQWdCLElBQUEsaUJBQUEsQ0FBa0IsS0FBSyxDQUFDLFFBQU4sSUFBa0I7TUFBQztBQUFBLFFBQUMsUUFBQSxFQUFVLENBQVg7T0FBRDtLQUFwQyxFQUFxRDtBQUFBLE1BQUEsS0FBQSxFQUFPLElBQVA7S0FBckQsRUFITDtFQUFBLENBQVosQ0FBQTs7QUFBQSx1QkFLQSxHQUFBLEdBQUssU0FBQSxHQUFBO0FBQ0osSUFBQSxJQUFHLElBQUMsQ0FBQSxLQUFELENBQUEsQ0FBQSxJQUFZLElBQUMsQ0FBQSxHQUFELENBQUssV0FBTCxDQUFmO0FBQ0MsYUFBUSxXQUFBLEdBQVUsQ0FBQSxJQUFDLENBQUEsR0FBRCxDQUFLLFdBQUwsQ0FBQSxDQUFWLEdBQTZCLFNBQXJDLENBREQ7S0FBQSxNQUFBO0FBR0MsTUFBQSxJQUFHLElBQUMsQ0FBQSxLQUFELENBQUEsQ0FBSDtBQUNDLGVBQU8sU0FBUCxDQUREO09BQUEsTUFBQTtBQUdDLGVBQVEsVUFBQSxHQUFTLENBQUEsSUFBQyxDQUFBLEdBQUQsQ0FBSyxJQUFMLENBQUEsQ0FBakIsQ0FIRDtPQUhEO0tBREk7RUFBQSxDQUxMLENBQUE7O29CQUFBOztHQUZ3QixRQUFRLENBQUMsWUFQbEMsQ0FBQTs7QUFBQSxNQXVCTSxDQUFDLE9BQVAsR0FBaUIsVUF2QmpCLENBQUE7Ozs7QUNBQSxJQUFBLDZDQUFBO0VBQUE7aVNBQUE7O0FBQUEsUUFBQSxHQUFrQixPQUFBLENBQVEsVUFBUixDQUFsQixDQUFBOztBQUFBLFFBQ1EsQ0FBQyxXQUFULEdBQXdCLE9BQUEsQ0FBUSxpQkFBUixDQUEwQixDQUFDLFdBRG5ELENBQUE7O0FBQUEsQ0FFQSxHQUFjLE9BQUEsQ0FBUSxZQUFSLENBRmQsQ0FBQTs7QUFBQSxDQUdBLEdBQWMsT0FBQSxDQUFRLFFBQVIsQ0FIZCxDQUFBOztBQUFBLGVBSUEsR0FBc0IsT0FBQSxDQUFRLHVCQUFSLENBSnRCLENBQUE7O0FBQUE7QUFRQyxpQ0FBQSxDQUFBOzs7O0dBQUE7O0FBQUEseUJBQUEsUUFBQSxHQUFVLFNBQUEsR0FBQTtBQUNULFFBQUEsS0FBQTtXQUFBLEtBQUEsR0FDQztBQUFBLE1BQUEsUUFBQSxFQUFVLEVBQVY7QUFBQSxNQUNBLEdBQUEsRUFBSyxDQURMO0FBQUEsTUFFQSxRQUFBLEVBQVUsQ0FGVjtBQUFBLE1BR0EsSUFBQSxFQUFNLENBSE47QUFBQSxNQUlBLElBQUEsRUFBTSxFQUpOO01BRlE7RUFBQSxDQUFWLENBQUE7O0FBQUEseUJBUUEsR0FBQSxHQUFLLFNBQUEsR0FBQTtBQUNKLElBQUEsSUFBRyxJQUFDLENBQUEsS0FBRCxDQUFBLENBQUEsSUFBWSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUwsQ0FBZjtBQUNDLGFBQVEsVUFBQSxHQUFTLENBQUEsSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFMLENBQUEsQ0FBVCxHQUEwQixXQUFsQyxDQUREO0tBQUEsTUFBQTtBQUdDLE1BQUEsSUFBRyxJQUFDLENBQUEsS0FBRCxDQUFBLENBQUg7QUFDQyxlQUFPLFdBQVAsQ0FERDtPQUFBLE1BQUE7QUFHQyxlQUFRLFlBQUEsR0FBVyxDQUFBLElBQUMsQ0FBQSxHQUFELENBQUssSUFBTCxDQUFBLENBQW5CLENBSEQ7T0FIRDtLQURJO0VBQUEsQ0FSTCxDQUFBOztBQUFBLHlCQWlCQSxVQUFBLEdBQVksU0FBQyxLQUFELEVBQWEsT0FBYixHQUFBOztNQUFDLFFBQVE7S0FDcEI7O01BRHdCLFVBQVU7S0FDbEM7V0FBQSxJQUFDLENBQUEsSUFBRCxHQUFZLElBQUEsZUFBQSxDQUFnQjtBQUFBLE1BQUEsS0FBQSxFQUFPLElBQVA7S0FBaEIsRUFERDtFQUFBLENBakJaLENBQUE7O0FBQUEseUJBb0JBLE1BQUEsR0FBUSxTQUFBLEdBQUE7QUFDUCxRQUFBLEtBQUE7QUFBQSxJQUFBLEtBQUEsR0FBUSxDQUFDLENBQUMsTUFBRixDQUFTLEVBQVQsRUFBYSxJQUFDLENBQUEsVUFBZCxDQUFSLENBQUE7QUFBQSxJQUNBLEtBQUssQ0FBQyxJQUFOLEdBQWEsUUFBQSxDQUFTLEtBQUssQ0FBQyxJQUFmLEVBQXFCLEVBQXJCLENBQUEsSUFBNEIsQ0FEekMsQ0FBQTtBQUFBLElBRUEsS0FBSyxDQUFDLElBQU4sR0FBYSxRQUFBLENBQVMsS0FBSyxDQUFDLElBQWYsRUFBcUIsRUFBckIsQ0FBQSxJQUE0QixFQUZ6QyxDQUFBO1dBR0EsTUFKTztFQUFBLENBcEJSLENBQUE7O3NCQUFBOztHQUYwQixRQUFRLENBQUMsWUFOcEMsQ0FBQTs7QUFBQSxNQWtDTSxDQUFDLE9BQVAsR0FBaUIsWUFsQ2pCLENBQUE7Ozs7QUNBQSxJQUFBLHdDQUFBO0VBQUE7aVNBQUE7O0FBQUEsUUFBQSxHQUFpQixPQUFBLENBQVEsVUFBUixDQUFqQixDQUFBOztBQUFBLGNBQ0EsR0FBb0IsT0FBQSxDQUFRLGlCQUFSLENBRHBCLENBQUE7O0FBQUEsQ0FFQSxHQUFhLE9BQUEsQ0FBUSxZQUFSLENBRmIsQ0FBQTs7QUFBQTtBQUtDLGdDQUFBLENBQUE7Ozs7R0FBQTs7QUFBQSx3QkFBQSxRQUFBLEdBQ0M7QUFBQSxJQUFBLElBQUEsRUFBTSxZQUFOO0dBREQsQ0FBQTs7QUFBQSx3QkFHQSxPQUFBLEdBQVMsVUFIVCxDQUFBOztxQkFBQTs7R0FEeUIsUUFBUSxDQUFDLFlBSm5DLENBQUE7O0FBQUEsTUFVTSxDQUFDLE9BQVAsR0FBaUIsV0FWakIsQ0FBQTs7OztBQ0FBLElBQUEsOEJBQUE7RUFBQTtpU0FBQTs7QUFBQSxDQUFBLEdBQWEsT0FBQSxDQUFRLDRCQUFSLENBQWIsQ0FBQTs7QUFBQSxDQUNBLEdBQWEsT0FBQSxDQUFRLFlBQVIsQ0FEYixDQUFBOztBQUFBLENBRUEsR0FBYSxPQUFBLENBQVEsc0JBQVIsQ0FGYixDQUFBOztBQUFBLFNBR0EsR0FBYSxPQUFBLENBQVEsUUFBUixDQUhiLENBQUE7O0FBQUE7QUFPRSwrQkFBQSxDQUFBOzs7O0dBQUE7O0FBQUEsdUJBQUEsR0FBQSxHQUFLLFNBQUEsR0FBQTtBQUNILElBQUEsSUFBRyxJQUFDLENBQUEsS0FBRCxDQUFBLENBQUEsSUFBWSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUwsQ0FBZjtBQUNFLGFBQVEsVUFBQSxHQUFTLENBQUEsSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFMLENBQUEsQ0FBVCxHQUEwQixTQUFsQyxDQURGO0tBQUEsTUFBQTtBQUdFLE1BQUEsSUFBRyxJQUFDLENBQUEsS0FBRCxDQUFBLENBQUg7ZUFBaUIsVUFBakI7T0FBQSxNQUFBO2VBQWlDLFVBQUEsR0FBUyxDQUFBLElBQUMsQ0FBQSxHQUFELENBQUssS0FBTCxDQUFBLEVBQTFDO09BSEY7S0FERztFQUFBLENBQUwsQ0FBQTs7QUFBQSx1QkFNQSxVQUFBLEdBQVksU0FBQyxLQUFELEVBQWEsT0FBYixHQUFBO0FBQ1YsUUFBQSxXQUFBOztNQURXLFFBQVE7S0FDbkI7O01BRHVCLFVBQVU7S0FDakM7QUFBQSxJQUFBLENBQUMsQ0FBQyxPQUFGLENBQVUsSUFBVixFQUFnQixTQUFoQixDQUFBLENBQUE7QUFDQSxJQUFBLElBQUcseUVBQUg7O2FBQ3VELENBQUUsa0JBQXZELENBQTBFLElBQTFFO09BREY7S0FEQTtBQUFBLElBR0EsSUFBQyxDQUFBLEVBQUQsQ0FBSSxZQUFKLEVBQWtCLElBQUMsQ0FBQSxPQUFuQixDQUhBLENBQUE7V0FJQSxJQUFDLENBQUEsRUFBRCxDQUFJLFdBQUosRUFBaUIsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUEsR0FBQTtBQUNmLFFBQUEsS0FBQyxDQUFBLHFCQUFELEdBQXlCLEtBQXpCLENBQUE7ZUFDQSxLQUFDLENBQUEsUUFBRCxHQUFZLE1BRkc7TUFBQSxFQUFBO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFqQixFQUxVO0VBQUEsQ0FOWixDQUFBOztBQUFBLHVCQWVBLElBQUEsR0FBTSxTQUFBLEdBQUE7QUFDSixRQUFBLFdBQUE7QUFBQSxJQUFBLElBQUcsQ0FBQSxJQUFLLENBQUEsUUFBUjtBQUNFLE1BQUEsS0FBQSxHQUFRLElBQUMsQ0FBQSxhQUFELENBQUEsQ0FBUixDQUFBO0FBQ0EsTUFBQSxJQUFHLENBQUEsSUFBSyxDQUFBLHFCQUFSO0FBQ0UsUUFBQSxJQUFDLENBQUEscUJBQUQsR0FBeUIsSUFBekIsQ0FBQTtBQUFBLFFBQ0EsQ0FBQSxDQUFFLEtBQUssQ0FBQyxJQUFOLENBQUEsQ0FBRixDQUFlLENBQUMsR0FBaEIsQ0FBb0IsT0FBcEIsRUFBNkIsSUFBQyxDQUFBLE9BQTlCLENBREEsQ0FERjtPQUFBLE1BQUE7QUFJRSxRQUFBLEtBQUssQ0FBQyxJQUFOLENBQUEsQ0FBQSxDQUpGO09BRkY7S0FBQSxNQUFBO0FBUUUsTUFBQSwyQ0FBYyxDQUFFLHNCQUFoQjtBQUNFLFFBQUEsSUFBQyxDQUFBLENBQUMsQ0FBQyxRQUFRLENBQUMsV0FBWixHQUEwQixDQUExQixDQURGO09BQUEsTUFBQTtBQUdFLFFBQUEsQ0FBQSxDQUFFLElBQUMsQ0FBQSxDQUFDLENBQUMsUUFBUSxDQUFDLElBQVosQ0FBQSxDQUFGLENBQXFCLENBQUMsR0FBdEIsQ0FBMEIsT0FBMUIsRUFBbUMsSUFBQyxDQUFBLE9BQXBDLENBQUEsQ0FIRjtPQVJGO0tBQUE7QUFZQSxXQUFPLElBQVAsQ0FiSTtFQUFBLENBZk4sQ0FBQTs7QUFBQSx1QkE4QkEsT0FBQSxHQUFTLFNBQUEsR0FBQTtXQUVQLElBQUMsQ0FBQSxLQUFELENBQUEsRUFGTztFQUFBLENBOUJULENBQUE7O0FBQUEsdUJBa0NBLGFBQUEsR0FBZSxTQUFDLEVBQUQsR0FBQTtBQUViLFFBQUEsS0FBQTtBQUFBLElBQUEsS0FBQSxHQUFRLElBQVIsQ0FBQTtBQUVBLElBQUEsSUFBc0IsSUFBQyxDQUFBLENBQXZCO0FBQUEsTUFBQSxNQUFBLENBQUEsSUFBUSxDQUFBLENBQUMsQ0FBQyxRQUFWLENBQUE7S0FGQTtBQUFBLElBSUEsSUFBQyxDQUFBLENBQUMsQ0FBQyxRQUFILEdBQWMsSUFBQyxDQUFBLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBUCxDQUFBLENBSmQsQ0FBQTtBQUFBLElBTUEsQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsR0FBRCxDQUFLLElBQUwsQ0FBUCxFQUFtQixDQUFBLFNBQUEsS0FBQSxHQUFBO2FBQUEsU0FBQyxNQUFELEVBQVMsRUFBVCxHQUFBO2VBQ2pCLEtBQUEsR0FBUSxDQUFBLENBQUUsRUFBRixFQUFNLE1BQU4sRUFBYyxLQUFBLElBQVMsS0FBQyxDQUFBLENBQUMsQ0FBQyxRQUExQixFQURTO01BQUEsRUFBQTtJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBbkIsQ0FOQSxDQUFBO0FBQUEsSUFTQSxJQUFDLENBQUEsUUFBRCxHQUFZLElBVFosQ0FBQTtBQVdBLFdBQU8sS0FBQSxJQUFTLElBQUMsQ0FBQSxDQUFDLENBQUMsUUFBbkIsQ0FiYTtFQUFBLENBbENmLENBQUE7O0FBQUEsdUJBaURBLE9BQUEsR0FBUyxTQUFDLEtBQUQsRUFBUSxHQUFSLEVBQWEsT0FBYixFQUFzQixFQUF0QixHQUFBO0FBQ1AsUUFBQSxLQUFBO0FBQUEsSUFBQSxLQUFBLEdBQVEsSUFBUixDQUFBO0FBQ0EsSUFBQSxJQUFHLEdBQUEsSUFBTyxJQUFDLENBQUEsR0FBRCxDQUFLLEtBQUwsQ0FBVjtBQUNFLE1BQUEsSUFBQyxDQUFBLE1BQUQsR0FBVSxLQUFWLENBQUE7YUFDQSxDQUFBLENBQUUsT0FBRixDQUFVLENBQUMsSUFBWCxDQUFpQixHQUFBLElBQU8sSUFBQyxDQUFBLEdBQUQsQ0FBSyxLQUFMLENBQXhCLEVBQXNDLFNBQUEsR0FBQTtBQUNwQyxRQUFBLEtBQUssQ0FBQyxDQUFOLEdBQVU7QUFBQSxVQUFBLEdBQUEsRUFBSyxJQUFMO1NBQVYsQ0FBQTtBQUFBLFFBQ0EsS0FBSyxDQUFDLE1BQU4sR0FBZSxJQURmLENBQUE7QUFBQSxRQUVBLEtBQUssQ0FBQyxPQUFOLENBQWMsUUFBZCxDQUZBLENBQUE7QUFHQSxRQUFBLElBQXVCLEVBQXZCO2lCQUFBLEVBQUUsQ0FBQyxJQUFILENBQVEsS0FBUixFQUFlLElBQWYsRUFBQTtTQUpvQztNQUFBLENBQXRDLEVBRkY7S0FGTztFQUFBLENBakRULENBQUE7O29CQUFBOztHQUZ1QixVQUx6QixDQUFBOztBQUFBLE1BaUZNLENBQUMsT0FBUCxHQUFpQixVQWpGakIsQ0FBQTs7OztBQ0FBLElBQUEsMkJBQUE7RUFBQTtpU0FBQTs7QUFBQSxRQUFBLEdBQWMsT0FBQSxDQUFRLFVBQVIsQ0FBZCxDQUFBOztBQUFBLENBQ0EsR0FBVSxPQUFBLENBQVEsWUFBUixDQURWLENBQUE7O0FBQUE7QUFLQyxtQ0FBQSxDQUFBOzs7O0dBQUE7O0FBQUEsMkJBQUEsVUFBQSxHQUFZLFNBQUMsS0FBRCxHQUFBOztNQUFDLFFBQVE7S0FDcEI7QUFBQSxJQUFBLElBQUcsbUJBQUEsSUFBZSxLQUFLLENBQUMsSUFBeEI7QUFDQyxNQUFBLElBQUMsQ0FBQSxXQUFELENBQWEsS0FBSyxDQUFDLEdBQW5CLEVBQXdCLEtBQUssQ0FBQyxJQUE5QixDQUFBLENBREQ7S0FBQTtBQUFBLElBRUEsSUFBQyxDQUFBLEVBQUQsQ0FBSSxpQkFBSixFQUF1QixJQUFDLENBQUEsV0FBeEIsQ0FGQSxDQUFBO0FBQUEsSUFHQSxJQUFDLENBQUEsRUFBRCxDQUFJLFlBQUosRUFBa0IsSUFBQyxDQUFBLFdBQW5CLENBSEEsQ0FBQTtXQUlBLElBQUMsQ0FBQSxFQUFELENBQUksYUFBSixFQUFtQixJQUFDLENBQUEsV0FBcEIsRUFMVztFQUFBLENBQVosQ0FBQTs7QUFBQSwyQkFTQSxXQUFBLEdBQWEsU0FBQyxHQUFELEVBQU0sSUFBTixHQUFBO0FBQ1osUUFBQSxRQUFBO0FBQUEsSUFBQSxRQUFBLEdBQVksQ0FBQyxFQUFBLEdBQUssSUFBTixDQUFBLEdBQWMsUUFBQSxDQUFTLEdBQUEsSUFBTyxJQUFDLENBQUEsR0FBRCxDQUFLLEtBQUwsQ0FBaEIsRUFBNkIsRUFBN0IsQ0FBZCxHQUFpRCxRQUFBLENBQVMsSUFBQSxJQUFRLElBQUMsQ0FBQSxHQUFELENBQUssTUFBTCxDQUFqQixFQUErQixFQUEvQixDQUE3RCxDQUFBO1dBQ0EsSUFBQyxDQUFBLEdBQUQsQ0FBSyxVQUFMLEVBQWlCLFFBQWpCLEVBRlk7RUFBQSxDQVRiLENBQUE7O3dCQUFBOztHQUY0QixRQUFRLENBQUMsTUFIdEMsQ0FBQTs7QUFBQSxNQWtCTSxDQUFDLE9BQVAsR0FBaUIsY0FsQmpCLENBQUE7Ozs7QUNBQSxJQUFBLHNCQUFBO0VBQUE7aVNBQUE7O0FBQUEsUUFBQSxHQUFjLE9BQUEsQ0FBUSxVQUFSLENBQWQsQ0FBQTs7QUFBQSxDQUNBLEdBQVUsT0FBQSxDQUFRLFlBQVIsQ0FEVixDQUFBOztBQUFBO0FBSUMsOEJBQUEsQ0FBQTs7OztHQUFBOztBQUFBLHNCQUFBLE1BQUEsR0FBUTtBQUFBLElBQ1AsRUFBQSxFQUFVLE1BREg7QUFBQSxJQUVQLFVBQUEsRUFBYyxhQUZQO0FBQUEsSUFHUCxVQUFBLEVBQWMsTUFIUDtHQUFSLENBQUE7O0FBQUEsc0JBTUEsVUFBQSxHQUFZLFNBQUMsT0FBRCxHQUFBO1dBQ1QsSUFBQyxDQUFBLGNBQUEsR0FBSCxFQUFXLFFBREE7RUFBQSxDQU5aLENBQUE7O0FBQUEsc0JBU0EsSUFBQSxHQUFNLFNBQUEsR0FBQSxDQVROLENBQUE7O0FBQUEsc0JBV0EsV0FBQSxHQUFhLFNBQUMsU0FBRCxHQUFBLENBWGIsQ0FBQTs7QUFBQSxzQkFhQSxJQUFBLEdBQU0sU0FBQyxFQUFELEdBQUE7V0FDTCxPQUFPLENBQUMsR0FBUixDQUFZLE9BQUEsR0FBUSxFQUFwQixFQURLO0VBQUEsQ0FiTixDQUFBOzttQkFBQTs7R0FEdUIsUUFBUSxDQUFDLE9BSGpDLENBQUE7O0FBQUEsTUFvQk0sQ0FBQyxPQUFQLEdBQWlCLFNBcEJqQixDQUFBOzs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlzWEEsSUFBQSx1TEFBQTtFQUFBO2lTQUFBOztBQUFBLFFBQUEsR0FBa0IsT0FBQSxDQUFRLFVBQVIsQ0FBbEIsQ0FBQTs7QUFBQSxRQUNRLENBQUMsQ0FBVCxHQUFtQixDQUFBLEdBQUksT0FBQSxDQUFRLFFBQVIsQ0FEdkIsQ0FBQTs7QUFBQSxRQUVRLENBQUMsV0FBVCxHQUF1QixPQUFBLENBQVEsaUJBQVIsQ0FBMEIsQ0FBQyxXQUZsRCxDQUFBOztBQUFBLENBR0EsR0FBYyxPQUFBLENBQVEsWUFBUixDQUhkLENBQUE7O0FBQUEsS0FJQSxHQUFnQixPQUFBLENBQVEsT0FBUixDQUpoQixDQUFBOztBQUFBLE1BS0EsR0FBaUIsT0FBQSxDQUFRLGVBQVIsQ0FMakIsQ0FBQTs7QUFBQSxJQU1BLEdBQWdCLE9BQUEsQ0FBUSxRQUFSLENBTmhCLENBQUE7O0FBQUEsT0FPQSxHQUFpQixPQUFBLENBQVEsV0FBUixDQVBqQixDQUFBOztBQUFBLFNBUUEsR0FBa0IsT0FBQSxDQUFRLGFBQVIsQ0FSbEIsQ0FBQTs7QUFBQSxRQVNBLEdBQWtCLE9BQUEsQ0FBUSxZQUFSLENBVGxCLENBQUE7O0FBQUEsYUFVQSxHQUFvQixPQUFBLENBQVEsY0FBUixDQVZwQixDQUFBOztBQUFBLFdBV0EsR0FBbUIsT0FBQSxDQUFRLGtCQUFSLENBWG5CLENBQUE7O0FBQUEsZUFZQSxHQUFxQixPQUFBLENBQVEsc0JBQVIsQ0FackIsQ0FBQTs7QUFBQSxnQkFjQSxHQUFtQixDQUNsQixFQURrQixFQUNkLEVBRGMsRUFDVixFQURVLEVBQ0wsRUFESyxFQUVsQixFQUZrQixFQUVkLEVBRmMsRUFFVixFQUZVLEVBRUwsRUFGSyxFQUdsQixFQUhrQixFQUdkLEVBSGMsRUFHVixFQUhVLEVBR0wsRUFISyxFQUlsQixFQUprQixFQUlkLEVBSmMsRUFJVixHQUpVLEVBSUwsR0FKSyxDQWRuQixDQUFBOztBQUFBLFdBb0JBLEdBQWdCLEVBcEJoQixDQUFBOztBQUFBLGNBcUJBLEdBQWtCLEVBckJsQixDQUFBOztBQUFBLGVBc0JBLEdBQWtCLE1BdEJsQixDQUFBOztBQUFBO0FBMEJDLDRCQUFBLENBQUE7Ozs7R0FBQTs7QUFBQSxvQkFBQSxFQUFBLEdBQUksZUFBSixDQUFBOztBQUFBLG9CQUVBLFVBQUEsR0FBWSxTQUFBLEdBQUE7QUFDWCxRQUFBLG9CQUFBO0FBQUEsSUFBQSxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQWpCLENBQXVCO0FBQUEsTUFBQSxTQUFBLEVBQVcsSUFBWDtLQUF2QixDQUFBLENBQUE7QUFBQSxJQUlBLElBQUMsQ0FBQSxPQUFELEdBQWdCLEVBSmhCLENBQUE7QUFBQSxJQUtBLElBQUMsQ0FBQSxNQUFELEdBQWUsRUFMZixDQUFBO0FBQUEsSUFNQSxJQUFDLENBQUEsTUFBRCxHQUFtQixJQUFBLFdBQUEsQ0FBQSxDQU5uQixDQUFBO0FBQUEsSUFPQSxJQUFDLENBQUEsTUFBRCxHQUFtQixJQUFBLE1BQUEsQ0FBTztBQUFBLE1BQUEsR0FBQSxFQUFLLElBQUw7S0FBUCxDQVBuQixDQUFBO0FBQUEsSUFRQSxDQUFDLElBQUMsQ0FBQSxPQUFELEdBQW1CLElBQUEsT0FBQSxDQUFRO0FBQUEsTUFBQSxHQUFBLEVBQUssSUFBTDtLQUFSLENBQXBCLENBQW1DLENBQUMsR0FBcEMsQ0FBd0MsZ0JBQXhDLENBUkEsQ0FBQTtBQUFBLElBU0EsSUFBQyxDQUFBLFNBQUQsR0FBcUIsSUFBQSxTQUFBLENBQVU7QUFBQSxNQUFBLEdBQUEsRUFBSyxJQUFMO0tBQVYsQ0FUckIsQ0FBQTtBQUFBLElBVUEsSUFBQyxDQUFBLE9BQUQsR0FBb0IsSUFBQSxhQUFBLENBQWM7QUFBQSxNQUFBLEdBQUEsRUFBSyxJQUFMO0tBQWQsQ0FWcEIsQ0FBQTtBQUFBLElBV0EsSUFBQyxDQUFBLE1BQUQsR0FBbUIsSUFBQSxlQUFBLENBQWdCO0FBQUEsTUFBQyxRQUFBLEVBQVUsQ0FBWDtLQUFoQixFQUErQjtBQUFBLE1BQUEsR0FBQSxFQUFLLElBQUw7S0FBL0IsQ0FYbkIsQ0FBQTtBQUFBLElBWUEsSUFBQyxDQUFBLElBQUQsR0FBa0IsSUFBQSxJQUFBLENBQUs7QUFBQSxNQUFBLEdBQUEsRUFBSyxJQUFMO0tBQUwsQ0FabEIsQ0FBQTtBQUFBLElBYUEsSUFBQyxDQUFBLFFBQUQsR0FBb0IsSUFBQSxRQUFBLENBQVM7QUFBQSxNQUFBLEdBQUEsRUFBSyxJQUFMO0tBQVQsQ0FicEIsQ0FBQTtBQUFBLElBY0EsSUFBQyxDQUFBLE9BQUQsR0FBZSxHQUFBLENBQUEsQ0FBSyxRQUFRLENBQUMsV0FBVyxDQUFDLE1BQXJCLENBQUEsQ0FBRCxDQWRuQixDQUFBO0FBQUEsSUFnQkEsS0FBSyxDQUFDLE1BQU4sQ0FBYTtNQUNaLENBQUEsU0FBQSxLQUFBLEdBQUE7ZUFBQSxTQUFDLFFBQUQsR0FBQTtBQUNDLFVBQUEsSUFBRyxLQUFDLENBQUEsTUFBTSxDQUFDLEdBQVIsQ0FBWSxJQUFaLENBQUg7bUJBQ0MsS0FBQyxDQUFBLElBQUQsQ0FBTSxLQUFDLENBQUEsTUFBUCxFQUFlLFNBQUEsR0FBQTtxQkFDZCxRQUFBLENBQVMsSUFBVCxFQUFlLElBQWYsRUFEYztZQUFBLENBQWYsRUFERDtXQUFBLE1BQUE7bUJBSUMsUUFBQSxDQUFTLElBQVQsRUFBZSxLQUFmLEVBSkQ7V0FERDtRQUFBLEVBQUE7TUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBRFk7S0FBYixFQU9HLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFDLEdBQUQsRUFBTSxNQUFOLEdBQUE7QUFDRixRQUFBLEtBQUMsQ0FBQSxjQUFELENBQWdCLENBQWhCLENBQUEsQ0FBQTtlQUNBLEtBQUMsQ0FBQSxPQUFPLENBQUMsZ0JBQVQsQ0FBMEIsQ0FBMUIsRUFGRTtNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBUEgsQ0FoQkEsQ0FBQTtBQTJCQSxTQUFBLCtEQUFBO29DQUFBO0FBQUEsTUFBQSxJQUFDLENBQUEsTUFBTyxDQUFBLE9BQUEsQ0FBUixHQUFtQixDQUFuQixDQUFBO0FBQUEsS0EzQkE7V0E2QkEsSUFBQyxDQUFBLE9BQU8sQ0FBQyxHQUFULENBQWEsT0FBYixFQTlCVztFQUFBLENBRlosQ0FBQTs7QUFBQSxvQkFrQ0EsTUFBQSxHQUNDO0FBQUEsSUFBQSx1QkFBQSxFQUE0QixrQkFBNUI7QUFBQSxJQUNBLFVBQUEsRUFBcUIsa0JBRHJCO0FBQUEsSUFFQSxTQUFBLEVBQXFCLGlCQUZyQjtBQUFBLElBR0EsT0FBQSxFQUFvQixlQUhwQjtHQW5DRCxDQUFBOztBQUFBLG9CQXdDQSxnQkFBQSxHQUFrQixTQUFDLENBQUQsR0FBQTtBQUNqQixRQUFBLGNBQUE7QUFBQSxJQUFBLFFBQUEsR0FBVyxDQUFBLENBQUUsQ0FBQyxDQUFDLGFBQUosQ0FBa0IsQ0FBQyxJQUFuQixDQUF3QixVQUF4QixDQUFYLENBQUE7QUFBQSxJQUNBLElBQUEsR0FBTyxDQUFBLENBQUUsQ0FBQyxDQUFDLGFBQUosQ0FBa0IsQ0FBQyxJQUFuQixDQUF3QixNQUF4QixDQURQLENBQUE7QUFFQSxJQUFBLElBQUcsa0JBQUEsSUFBYyxDQUFDLENBQUMsVUFBRixDQUFhLElBQUUsQ0FBQSxRQUFBLENBQWYsQ0FBakI7YUFDQyxJQUFFLENBQUEsUUFBQSxDQUFTLENBQUMsSUFBWixDQUFpQixJQUFqQixFQUFvQixDQUFwQixFQUF1QixJQUF2QixFQUREO0tBSGlCO0VBQUEsQ0F4Q2xCLENBQUE7O0FBQUEsb0JBOENBLFdBQUEsR0FBYSxTQUFDLENBQUQsRUFBSSxNQUFKLEdBQUE7V0FDWixJQUFDLENBQUEsWUFBRCxDQUFjLE1BQWQsRUFEWTtFQUFBLENBOUNiLENBQUE7O0FBQUEsb0JBaURBLGNBQUEsR0FBZ0IsU0FBQyxHQUFELEdBQUE7V0FDZixJQUFDLENBQUEsWUFBRCxDQUFjLElBQUMsQ0FBQSxNQUFNLENBQUMsRUFBUixDQUFXLENBQVgsQ0FBYSxDQUFDLEdBQWQsQ0FBa0IsVUFBbEIsQ0FBZCxFQURlO0VBQUEsQ0FqRGhCLENBQUE7O0FBQUEsb0JBb0RBLFlBQUEsR0FBYyxTQUFDLFdBQUQsR0FBQTtBQUNiLElBQUEsSUFBQyxDQUFBLE9BQU8sQ0FBQyxLQUFULEdBQWlCLElBQUMsQ0FBQSxNQUFNLENBQUMsU0FBUixDQUFrQjtBQUFBLE1BQUEsUUFBQSxFQUFVLFdBQVY7S0FBbEIsQ0FBakIsQ0FBQTtXQUNBLElBQUMsQ0FBQSxJQUFJLENBQUMsTUFBTixDQUFhLFdBQWIsRUFGYTtFQUFBLENBcERkLENBQUE7O0FBQUEsb0JBd0RBLElBQUEsR0FBTSxTQUFDLE1BQUQsRUFBUyxRQUFULEdBQUE7QUFDTCxRQUFBLEtBQUE7QUFBQSxJQUFBLEtBQUEsR0FBUSxJQUFSLENBQUE7QUFBQSxJQUNBLElBQUMsQ0FBQSxPQUFPLENBQUMsR0FBVCxDQUFjLFVBQUEsR0FBUyxDQUFBLElBQUMsQ0FBQSxNQUFNLENBQUMsR0FBUixDQUFZLE1BQVosQ0FBQSxDQUFULEdBQThCLEtBQTVDLENBREEsQ0FBQTtXQUVBLElBQUMsQ0FBQSxNQUFNLENBQUMsY0FBUixDQUF1QixJQUF2QixFQUEwQixJQUFDLENBQUEsTUFBM0IsRUFBbUMsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsR0FBRCxFQUFNLE9BQU4sR0FBQTtBQUVsQyxRQUFBLFFBQVEsQ0FBQyxJQUFULENBQWMsS0FBZCxDQUFBLENBQUE7ZUFDQSxLQUFDLENBQUEsT0FBTyxDQUFDLEdBQVQsQ0FBYyxXQUFBLEdBQVUsQ0FBQSxLQUFDLENBQUEsTUFBTSxDQUFDLEdBQVIsQ0FBWSxNQUFaLENBQUEsQ0FBVixHQUErQixXQUE3QyxFQUhrQztNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQW5DLEVBSEs7RUFBQSxDQXhETixDQUFBOztBQUFBLG9CQWdFQSxJQUFBLEdBQU0sU0FBQyxDQUFELEdBQUE7QUFDTCxRQUFBLEtBQUE7QUFBQSxJQUFBLEtBQUEsR0FBUSxJQUFSLENBQUE7V0FDQSxLQUFLLENBQUMsU0FBTixDQUFnQjtNQUNmLENBQUEsU0FBQSxLQUFBLEdBQUE7ZUFBQSxTQUFDLG1CQUFELEdBQUE7aUJBQ0MsS0FBQyxDQUFBLE1BQU0sQ0FBQyxJQUFSLENBQWEsRUFBYixFQUFpQjtBQUFBLFlBQ2hCLE9BQUEsRUFBUyxTQUFDLFdBQUQsR0FBQTtxQkFDUixLQUFLLENBQUMsSUFBTixDQUFXLEtBQUMsQ0FBQSxNQUFNLENBQUMsTUFBbkIsRUFBMkIsU0FBQyxLQUFELEVBQVEsc0JBQVIsR0FBQTt1QkFDMUIsS0FBSyxDQUFDLElBQU4sQ0FBVztBQUFBLGtCQUFDLFNBQUEsRUFBVyxXQUFXLENBQUMsRUFBeEI7aUJBQVgsRUFBd0M7QUFBQSxrQkFDdkMsT0FBQSxFQUFTLENBQUEsU0FBQSxLQUFBLEdBQUE7MkJBQUEsU0FBQyxVQUFELEdBQUE7NkJBQ1IsS0FBSyxDQUFDLFFBQU4sQ0FBZTt3QkFDZCxTQUFDLE9BQUQsR0FBQTtpQ0FDQyxLQUFLLENBQUMsSUFBTixDQUFXLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBeEIsRUFBZ0MsU0FBQyxLQUFELEVBQVEsc0JBQVIsR0FBQTttQ0FDL0IsS0FBSyxDQUFDLElBQU4sQ0FBVztBQUFBLDhCQUFDLE9BQUEsRUFBUyxLQUFLLENBQUMsRUFBaEI7NkJBQVgsRUFBZ0M7QUFBQSw4QkFDL0IsT0FBQSxFQUFTLFNBQUMsVUFBRCxHQUFBO3VDQUNSLHNCQUFBLENBQXVCLElBQXZCLEVBQTZCLFVBQTdCLEVBRFE7OEJBQUEsQ0FEc0I7QUFBQSw4QkFHL0IsS0FBQSxFQUFPLFNBQUMsR0FBRCxHQUFBO3VDQUNOLHNCQUFBLENBQXVCLEdBQXZCLEVBRE07OEJBQUEsQ0FId0I7NkJBQWhDLEVBRCtCOzBCQUFBLENBQWhDLEVBT0UsU0FBQyxHQUFELEdBQUE7QUFDRCw0QkFBQSxJQUFnQixHQUFoQjtBQUFBLDhCQUFBLE9BQUEsQ0FBUSxHQUFSLENBQUEsQ0FBQTs2QkFBQTttQ0FDQSxPQUFBLENBQVEsSUFBUixFQUZDOzBCQUFBLENBUEYsRUFERDt3QkFBQSxDQURjLEVBWVosU0FBQyxTQUFELEdBQUE7aUNBQ0QsS0FBSyxDQUFDLElBQU4sQ0FBVyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQTFCLEVBQWtDLFNBQUMsT0FBRCxFQUFVLHdCQUFWLEdBQUE7bUNBQ2pDLE9BQU8sQ0FBQyxJQUFSLENBQWE7QUFBQSw4QkFBQyxPQUFBLEVBQVMsS0FBSyxDQUFDLEVBQWhCOzZCQUFiLEVBQWtDO0FBQUEsOEJBQ2pDLE9BQUEsRUFBUyxTQUFDLFlBQUQsR0FBQTt1Q0FDUix3QkFBQSxDQUF5QixJQUF6QixFQUErQixZQUEvQixFQURROzhCQUFBLENBRHdCO0FBQUEsOEJBR2pDLEtBQUEsRUFBTyxTQUFDLEdBQUQsR0FBQTt1Q0FDTix3QkFBQSxDQUF5QixHQUF6QixFQURNOzhCQUFBLENBSDBCOzZCQUFsQyxFQURpQzswQkFBQSxDQUFsQyxFQU9FLFNBQUMsR0FBRCxHQUFBO0FBQ0QsNEJBQUEsSUFBa0IsR0FBbEI7QUFBQSw4QkFBQSxTQUFBLENBQVUsR0FBVixDQUFBLENBQUE7NkJBQUE7bUNBQ0EsU0FBQSxDQUFVLElBQVYsRUFGQzswQkFBQSxDQVBGLEVBREM7d0JBQUEsQ0FaWTt1QkFBZixFQXVCRyxTQUFDLEdBQUQsR0FBQTtBQUNGLHdCQUFBLElBQStCLEdBQS9CO0FBQUEsMEJBQUEsc0JBQUEsQ0FBdUIsR0FBdkIsQ0FBQSxDQUFBO3lCQUFBOytCQUNBLHNCQUFBLENBQXVCLElBQXZCLEVBRkU7c0JBQUEsQ0F2QkgsRUFEUTtvQkFBQSxFQUFBO2tCQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FEOEI7aUJBQXhDLEVBRDBCO2NBQUEsQ0FBM0IsRUE4QkUsU0FBQyxHQUFELEdBQUE7dUJBQ0QsbUJBQUEsQ0FBb0IsSUFBcEIsRUFEQztjQUFBLENBOUJGLEVBRFE7WUFBQSxDQURPO0FBQUEsWUFrQ2hCLEtBQUEsRUFBTyxTQUFDLEdBQUQsR0FBQTtxQkFDTixtQkFBQSxDQUFvQixHQUFwQixFQURNO1lBQUEsQ0FsQ1M7V0FBakIsRUFERDtRQUFBLEVBQUE7TUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBRGU7S0FBaEIsRUF1Q0csQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsR0FBRCxFQUFNLE9BQU4sR0FBQTtBQUNGLFFBQUEsSUFBd0IsR0FBeEI7QUFBQSxnQkFBVSxJQUFBLEtBQUEsQ0FBTSxHQUFOLENBQVYsQ0FBQTtTQUFBO0FBQUEsUUFDQSxLQUFDLENBQUEsTUFBTSxDQUFDLFFBQVIsQ0FBa0IsU0FBQSxHQUFRLENBQUEsS0FBQyxDQUFBLE1BQU0sQ0FBQyxHQUFSLENBQVksSUFBWixDQUFBLENBQTFCLEVBQWdEO0FBQUEsVUFBQyxNQUFBLEVBQVEsSUFBVDtTQUFoRCxDQURBLENBQUE7ZUFFQSxLQUFDLENBQUEsT0FBTyxDQUFDLEdBQVQsQ0FBYyxXQUFBLEdBQVUsQ0FBQSxLQUFDLENBQUEsTUFBTSxDQUFDLEdBQVIsQ0FBWSxNQUFaLENBQUEsQ0FBVixHQUErQixVQUE3QyxFQUhFO01BQUEsRUFBQTtJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0F2Q0gsRUFGSztFQUFBLENBaEVOLENBQUE7O0FBQUEsb0JBOEdBLE1BQUEsR0FBUSxTQUFDLENBQUQsR0FBQTtBQUNQLFFBQUEsTUFBQTtBQUFBLElBQUEsTUFBQSxHQUFTLElBQUMsQ0FBQSxNQUFNLENBQUMsTUFBUixDQUFBLENBQVQsQ0FBQTtBQUFBLElBQ0EsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsRUFEaEIsQ0FBQTtBQUFBLElBRUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxJQUFSLENBQWEsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsS0FBRCxHQUFBO0FBQ1osWUFBQSxlQUFBO0FBQUEsUUFBQSxlQUFBLEdBQWtCLEtBQUssQ0FBQyxNQUFOLENBQUEsQ0FBbEIsQ0FBQTtBQUFBLFFBQ0EsZUFBZSxDQUFDLE1BQWhCLEdBQXlCLEVBRHpCLENBQUE7QUFBQSxRQUVBLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBYixDQUFrQixTQUFDLEtBQUQsR0FBQTtpQkFDakIsZUFBZSxDQUFDLE1BQU0sQ0FBQyxJQUF2QixDQUE0QixLQUFLLENBQUMsTUFBTixDQUFBLENBQTVCLEVBRGlCO1FBQUEsQ0FBbEIsQ0FGQSxDQUFBO0FBQUEsUUFJQSxlQUFlLENBQUMsUUFBaEIsR0FBMkIsRUFKM0IsQ0FBQTtBQUFBLFFBS0EsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFmLENBQW9CLFNBQUMsT0FBRCxHQUFBO2lCQUNuQixlQUFlLENBQUMsUUFBUSxDQUFDLElBQXpCLENBQThCLE9BQU8sQ0FBQyxNQUFSLENBQUEsQ0FBOUIsRUFEbUI7UUFBQSxDQUFwQixDQUxBLENBQUE7ZUFPQSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQWQsQ0FBbUIsZUFBbkIsRUFSWTtNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQWIsQ0FGQSxDQUFBO1dBV0EsT0FBTyxDQUFDLEdBQVIsQ0FBWSxNQUFaLEVBWk87RUFBQSxDQTlHUixDQUFBOztBQUFBLG9CQTRIQSxlQUFBLEdBQWlCLFNBQUMsQ0FBRCxHQUFBO0FBQ2hCLFFBQUEsYUFBQTtBQUFBLElBQUEsSUFBQSxHQUFPLE1BQU0sQ0FBQyxZQUFQLENBQW9CLENBQUMsQ0FBQyxPQUF0QixDQUFQLENBQUE7QUFFQSxJQUFBLElBQUcsSUFBQSxLQUFRLFdBQVIsSUFBd0IsQ0FBQyxDQUFDLE9BQTdCO0FBQ0MsTUFBQSxJQUFDLENBQUEsU0FBUyxDQUFDLE1BQVgsQ0FBQSxDQUFBLENBQUE7QUFBQSxNQUNBLE9BQUEsR0FBVSxJQURWLENBREQ7S0FBQSxNQUdLLElBQUcsSUFBQSxLQUFRLGNBQVg7QUFDSixNQUFBLElBQUMsQ0FBQSxTQUFTLENBQUMsSUFBWCxDQUFBLENBQUEsQ0FBQTtBQUFBLE1BQ0EsT0FBQSxHQUFVLElBRFYsQ0FESTtLQUFBLE1BR0EsSUFBRyxDQUFDLENBQUMsT0FBRixDQUFVLENBQUMsQ0FBRCxFQUFJLEdBQUosRUFBUyxHQUFULEVBQWMsR0FBZCxFQUFtQixHQUFuQixFQUF3QixHQUF4QixFQUE2QixHQUE3QixFQUFrQyxHQUFsQyxFQUF1QyxHQUF2QyxDQUFWLEVBQXVELElBQXZELENBQUEsR0FBK0QsQ0FBL0QsSUFBcUUsQ0FBQyxDQUFDLE9BQTFFO0FBQ0osTUFBQSxPQUFBLEdBQVUsSUFBVixDQUFBO0FBQUEsTUFDQSxJQUFDLENBQUEsSUFBSSxDQUFDLE1BQU4sQ0FBYSxJQUFiLENBREEsQ0FESTtLQVJMO0FBWUEsSUFBQSxJQUFzQixPQUF0QjthQUFBLENBQUMsQ0FBQyxjQUFGLENBQUEsRUFBQTtLQWJnQjtFQUFBLENBNUhqQixDQUFBOztBQUFBLG9CQTJJQSxnQkFBQSxHQUFrQixTQUFDLENBQUQsR0FBQTtBQUNqQixRQUFBLFNBQUE7QUFBQSxJQUFBLElBQUcsNEJBQUg7QUFDQyxNQUFBLElBQUMsQ0FBQSxRQUFELEdBQVksQ0FBQyxDQUFDLEtBQWQsQ0FBQTthQUVBLEdBQUEsa0VBQXFDLENBQUUsT0FBakMsQ0FBeUMsT0FBekMsV0FIUDtLQURpQjtFQUFBLENBM0lsQixDQUFBOztBQUFBLG9CQWlKQSxhQUFBLEdBQWUsU0FBQyxDQUFELEdBQUE7QUFDZCxRQUFBLFNBQUE7QUFBQSxJQUFBLElBQTZELENBQUMsQ0FBQyxLQUFGLEtBQVcsSUFBQyxDQUFBLFFBQXpFO2FBQUEsR0FBQSxrRUFBcUMsQ0FBRSxPQUFqQyxDQUF5QyxTQUF6QyxXQUFOO0tBRGM7RUFBQSxDQWpKZixDQUFBOztpQkFBQTs7R0FGcUIsUUFBUSxDQUFDLEtBeEIvQixDQUFBOztBQUFBLE1BOEtNLENBQUMsT0FBUCxHQUFxQixJQUFBLE9BQUEsQ0FBQSxDQTlLckIsQ0FBQTs7OztBQ0FBLElBQUEsaUVBQUE7RUFBQTtpU0FBQTs7QUFBQSxRQUFBLEdBQWdCLE9BQUEsQ0FBUSxVQUFSLENBQWhCLENBQUE7O0FBQUEsUUFDUSxDQUFDLENBQVQsR0FBaUIsT0FBQSxDQUFRLFFBQVIsQ0FEakIsQ0FBQTs7QUFBQSxRQUVBLEdBQWdCLE9BQUEsQ0FBUSxvQkFBUixDQUZoQixDQUFBOztBQUFBLENBR0EsR0FBWSxPQUFBLENBQVEsWUFBUixDQUhaLENBQUE7O0FBQUEsWUFJQSxHQUFrQixPQUFBLENBQVEsbUJBQVIsQ0FKbEIsQ0FBQTs7QUFBQSxlQUtBLEdBQW1CLE9BQUEsQ0FBUSwwQkFBUixDQUxuQixDQUFBOztBQUFBO0FBU0MsZ0NBQUEsQ0FBQTs7OztHQUFBOztBQUFBLHdCQUFBLEVBQUEsR0FBSSxVQUFKLENBQUE7O0FBQUEsd0JBRUEsUUFBQSxHQUFVLGVBRlYsQ0FBQTs7QUFBQSx3QkFJQSxVQUFBLEdBQVksU0FBQyxPQUFELEdBQUE7QUFDWCxJQUFFLElBQUMsQ0FBQSxNQUFRLFFBQVIsR0FBSCxDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsS0FBRCxHQUFhLElBQUEsWUFBQSxDQUFBLENBRGIsQ0FBQTtBQUFBLElBRUEsSUFBQyxDQUFBLE1BQUQsQ0FBQSxDQUZBLENBQUE7QUFBQSxJQUdBLElBQUMsQ0FBQSxPQUFELEdBQVcsSUFBSSxDQUFDLENBQUwsQ0FBTyxXQUFQLENBSFgsQ0FBQTtXQUlJLElBQUEsUUFBQSxDQUFTO0FBQUEsTUFBQSxLQUFBLEVBQU8sSUFBQyxDQUFBLEtBQVI7QUFBQSxNQUFlLElBQUEsRUFBTSxJQUFyQjtLQUFULEVBTE87RUFBQSxDQUpaLENBQUE7O0FBQUEsd0JBV0EsR0FBQSxHQUFLLFNBQUMsT0FBRCxHQUFBO0FBQ0osUUFBQSxPQUFBO0FBQUEsSUFBQSxJQUFHLE1BQUEsQ0FBQSxPQUFBLEtBQWtCLFFBQXJCO0FBQ0MsTUFBQSxPQUFBLEdBQVUsT0FBVixDQUREO0tBQUEsTUFBQTtBQUdDLE1BQUEsT0FBQSxHQUFVLE9BQU8sQ0FBQyxPQUFsQixDQUhEO0tBQUE7QUFBQSxJQUlBLElBQUMsQ0FBQSxLQUFLLENBQUMsR0FBUCxDQUFXLEtBQVgsRUFBa0IsT0FBbEIsQ0FKQSxDQUFBO1dBS0EsSUFBQyxDQUFBLE1BQUQsQ0FBQSxFQU5JO0VBQUEsQ0FYTCxDQUFBOztBQUFBLHdCQW1CQSxNQUFBLEdBQVEsU0FBQSxHQUFBO1dBQ1AsSUFBQyxDQUFBLEVBQUUsQ0FBQyxTQUFKLEdBQWdCLElBQUMsQ0FBQSxRQUFELENBQVUsSUFBQyxDQUFBLEtBQUssQ0FBQyxNQUFQLENBQUEsQ0FBVixFQURUO0VBQUEsQ0FuQlIsQ0FBQTs7cUJBQUE7O0dBRnlCLFFBQVEsQ0FBQyxLQVBuQyxDQUFBOztBQUFBLE1BK0JNLENBQUMsT0FBUCxHQUFpQixXQS9CakIsQ0FBQTs7OztBQ0FBLElBQUEsa0VBQUE7RUFBQTtpU0FBQTs7QUFBQSxRQUFBLEdBQWtCLE9BQUEsQ0FBUSxVQUFSLENBQWxCLENBQUE7O0FBQUEsUUFDUSxDQUFDLENBQVQsR0FBa0IsT0FBQSxDQUFRLCtCQUFSLENBRGxCLENBQUE7O0FBQUEsUUFFQSxHQUFrQixPQUFBLENBQVEsb0JBQVIsQ0FGbEIsQ0FBQTs7QUFBQSxDQUlBLEdBQWtCLE9BQUEsQ0FBUSxZQUFSLENBSmxCLENBQUE7O0FBQUEsT0FLQSxHQUFrQixPQUFBLENBQVEsV0FBUixDQUxsQixDQUFBOztBQUFBLGNBTUEsR0FBa0IsT0FBQSxDQUFRLHlCQUFSLENBTmxCLENBQUE7O0FBQUEsTUFTQSxHQUFTLFNBVFQsQ0FBQTs7QUFBQTtBQWFFLCtCQUFBLENBQUE7Ozs7R0FBQTs7QUFBQSx1QkFBQSxRQUFBLEdBQVUsY0FBVixDQUFBOztBQUFBLHVCQUVBLFVBQUEsR0FDRTtBQUFBLElBQUEsT0FBQSxFQUFrQixZQUFsQjtHQUhGLENBQUE7O0FBQUEsdUJBS0EsVUFBQSxHQUFZLFNBQUMsT0FBRCxHQUFBO0FBQ1YsSUFBQSxJQUFDLENBQUEsUUFBRCxHQUFZLEVBQVosQ0FBQTtBQUFBLElBQ0UsSUFBQyxDQUFBLGdCQUFBLEtBQUgsRUFBVSxJQUFDLENBQUEsY0FBQSxHQURYLENBQUE7QUFBQSxJQUdBLENBQUMsQ0FBQyxPQUFGLENBQVUsSUFBVixFQUFhLFlBQWIsQ0FIQSxDQUFBO0FBQUEsSUFLQSxJQUFDLENBQUEsTUFBRCxDQUFBLENBTEEsQ0FBQTtBQUFBLElBT0EsSUFBQyxDQUFBLFFBQUQsR0FBZ0IsSUFBQSxRQUFBLENBQVM7QUFBQSxNQUFBLEtBQUEsRUFBTyxJQUFDLENBQUEsS0FBUjtBQUFBLE1BQWUsSUFBQSxFQUFNLElBQXJCO0tBQVQsQ0FQaEIsQ0FBQTtXQVFBLElBQUMsQ0FBQSxRQUFELENBQVUsSUFBQyxDQUFBLEtBQVgsRUFBa0IsUUFBbEIsRUFBNEIsSUFBQyxDQUFBLFVBQTdCLEVBVFU7RUFBQSxDQUxaLENBQUE7O0FBQUEsdUJBZ0JBLE1BQUEsR0FDRTtBQUFBLElBQUEsdUJBQUEsRUFBZ0Msa0JBQWhDO0FBQUEsSUFDQSxjQUFBLEVBQWdDLE1BRGhDO0FBQUEsSUFFQSxpQkFBQSxFQUFnQyxJQUZoQztHQWpCRixDQUFBOztBQUFBLHVCQXFCQSxnQkFBQSxHQUFrQixTQUFDLENBQUQsR0FBQTtBQUNoQixRQUFBLFFBQUE7QUFBQSxJQUFBLFFBQUEsR0FBVyxDQUFBLENBQUUsQ0FBQyxDQUFDLGFBQUosQ0FBa0IsQ0FBQyxJQUFuQixDQUF3QixVQUF4QixDQUFYLENBQUE7QUFDQSxJQUFBLElBQUcsa0JBQUEsSUFBYyxDQUFDLENBQUMsVUFBRixDQUFhLElBQUssQ0FBQSxRQUFBLENBQWxCLENBQWpCO2FBQ0UsSUFBSyxDQUFBLFFBQUEsQ0FBUyxDQUFDLElBQWYsQ0FBb0IsSUFBcEIsRUFBMEIsQ0FBMUIsRUFERjtLQUZnQjtFQUFBLENBckJsQixDQUFBOztBQUFBLHVCQTBCQSxJQUFBLEdBQU0sU0FBQyxDQUFELEdBQUE7V0FDSixJQUFDLENBQUEsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFYLENBQUEsRUFESTtFQUFBLENBMUJOLENBQUE7O0FBQUEsdUJBNkJBLEVBQUEsR0FBSSxTQUFDLENBQUQsR0FBQTtBQUNGLFFBQUEsV0FBQTtBQUFBLElBQUEsS0FBQSxHQUFRLENBQUMsQ0FBQyxhQUFhLENBQUMsWUFBaEIsQ0FBNkIsWUFBN0IsQ0FBUixDQUFBO0FBQUEsSUFDQSxJQUFBLEdBQU8sSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsZUFBQSxHQUFnQixLQUEzQixDQURQLENBQUE7QUFBQSxJQUVBLElBQUssQ0FBQSxDQUFBLENBQUwsR0FBVSxRQUFBLENBQVMsQ0FBQSxDQUFFLENBQUMsQ0FBQyxhQUFKLENBQWtCLENBQUMsR0FBbkIsQ0FBQSxDQUFULEVBQW1DLEVBQW5DLENBRlYsQ0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsZUFBQSxHQUFnQixLQUEzQixFQUFrQyxJQUFsQyxDQUhBLENBQUE7V0FJQSxPQUFPLENBQUMsR0FBUixDQUFZLElBQVosRUFMRTtFQUFBLENBN0JKLENBQUE7O0FBQUEsdUJBb0NBLEdBQUEsR0FBSyxTQUFDLENBQUQsR0FBQTtBQUNILFFBQUEsUUFBQTtBQUFBLElBQUEsUUFBQSxHQUFXLENBQUEsQ0FBRSxDQUFDLENBQUMsYUFBSixDQUFrQixDQUFDLElBQW5CLENBQXdCLEtBQXhCLENBQVgsQ0FBQTtBQUFBLElBQ0EsQ0FBQSxDQUFFLENBQUMsQ0FBQyxhQUFKLENBQWtCLENBQUMsUUFBbkIsQ0FBNEIsUUFBNUIsQ0FBcUMsQ0FBQyxRQUF0QyxDQUFBLENBQWdELENBQUMsV0FBakQsQ0FBNkQsUUFBN0QsQ0FEQSxDQUFBO0FBQUEsSUFFQSxJQUFJLENBQUMsQ0FBTCxDQUFPLFdBQVAsQ0FBbUIsQ0FBQyxJQUFwQixDQUFBLENBRkEsQ0FBQTtXQUdBLElBQUksQ0FBQyxDQUFMLENBQU8sV0FBQSxHQUFZLFFBQW5CLENBQTRCLENBQUMsSUFBN0IsQ0FBQSxFQUpHO0VBQUEsQ0FwQ0wsQ0FBQTs7QUFBQSx1QkEwQ0EsWUFBQSxHQUFjLFNBQUMsQ0FBRCxHQUFBO0FBQ1osUUFBQSxNQUFBO0FBQUEsSUFBQSxNQUFBLEdBQVMsQ0FBQSxDQUFFLENBQUMsQ0FBQyxhQUFKLENBQWtCLENBQUMsSUFBbkIsQ0FBd0IsUUFBeEIsQ0FBVCxDQUFBO0FBQ0EsSUFBQSxJQUFHLENBQUEsSUFBSyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVksS0FBQSxHQUFJLE1BQWhCLENBQVA7QUFDRSxNQUFBLElBQUMsQ0FBQSxRQUFRLENBQUMsSUFBVixHQUFpQixNQUFqQixDQUFBO2FBQ0EsSUFBQyxDQUFBLFNBQUQsQ0FBVyxNQUFYLEVBRkY7S0FBQSxNQUFBO0FBSUUsTUFBQSxNQUFBLENBQUEsSUFBUSxDQUFBLFFBQVEsQ0FBQyxJQUFqQixDQUFBO2FBQ0EsSUFBQyxDQUFBLFlBQUQsQ0FBYyxNQUFkLEVBTEY7S0FGWTtFQUFBLENBMUNkLENBQUE7O0FBQUEsdUJBbURBLFNBQUEsR0FBVyxTQUFDLE1BQUQsR0FBQTtBQUNULFFBQUEsRUFBQTtBQUFBLFlBQU8sTUFBUDtBQUFBLFdBQ08sUUFEUDtBQUVJLFFBQUEsRUFBQSxHQUNFO0FBQUEsVUFBQSxJQUFBLEVBQVksQ0FBWjtBQUFBLFVBQ0EsSUFBQSxFQUFZLENBRFo7QUFBQSxVQUVBLEdBQUEsRUFBWSxHQUZaO1NBREYsQ0FGSjtBQUNPO0FBRFAsV0FNTyxPQU5QO0FBT0ksUUFBQSxFQUFBLEdBQ0U7QUFBQSxVQUFBLElBQUEsRUFBWSxHQUFaO0FBQUEsVUFDQSxFQUFBLEVBQVksR0FEWjtBQUFBLFVBRUEsR0FBQSxFQUFZLElBRlo7U0FERixDQVBKO0FBTU87QUFOUCxXQVdPLFFBWFA7QUFZSSxRQUFBLEVBQUEsR0FDRTtBQUFBLFVBQUEsSUFBQSxFQUFZLEtBQVo7QUFBQSxVQUNBLEtBQUEsRUFBWSxFQURaO0FBQUEsVUFFQSxJQUFBLEVBQVksQ0FGWjtBQUFBLFVBR0EsS0FBQSxFQUFZLEVBSFo7QUFBQSxVQUlBLEVBQUEsRUFBWSxHQUpaO0FBQUEsVUFLQSxHQUFBLEVBQVksSUFMWjtTQURGLENBWko7QUFBQSxLQUFBO0FBQUEsSUFvQkEsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVksS0FBQSxHQUFJLE1BQWhCLEVBQTJCLEVBQTNCLENBcEJBLENBQUE7V0FzQkEsSUFBQyxDQUFBLFVBQUQsQ0FBQSxFQXZCUztFQUFBLENBbkRYLENBQUE7O0FBQUEsdUJBNEVBLFlBQUEsR0FBYyxTQUFDLE1BQUQsR0FBQTtBQUNaLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxLQUFQLENBQWMsS0FBQSxHQUFJLE1BQWxCLENBQUEsQ0FBQTtXQUNBLElBQUMsQ0FBQSxVQUFELENBQUEsRUFGWTtFQUFBLENBNUVkLENBQUE7O0FBQUEsdUJBZ0ZBLElBQUEsR0FBTSxTQUFDLENBQUQsR0FBQTtBQUNKLElBQUEsQ0FBQyxDQUFDLGNBQUYsQ0FBQSxDQUFBLENBQUE7V0FDQSxJQUFDLENBQUEsR0FBRyxDQUFDLE9BQUwsQ0FBYSxPQUFiLEVBRkk7RUFBQSxDQWhGTixDQUFBOztBQUFBLHVCQW9GQSxJQUFBLEdBQU0sU0FBQSxHQUFBO0FBQ0osSUFBQSxJQUFDLENBQUEsVUFBRCxDQUFBLENBQUEsQ0FBQTtXQUNBLElBQUMsQ0FBQSxHQUFHLENBQUMsS0FBTCxDQUFXLE1BQVgsRUFGSTtFQUFBLENBcEZOLENBQUE7O0FBQUEsdUJBd0ZBLElBQUEsR0FBTSxTQUFBLEdBQUE7V0FDSixJQUFDLENBQUEsR0FBRyxDQUFDLEtBQUwsQ0FBVyxNQUFYLEVBREk7RUFBQSxDQXhGTixDQUFBOztBQUFBLHVCQTJGQSxNQUFBLEdBQVEsU0FBQSxHQUFBO0FBQ04sSUFBQSxJQUFDLENBQUEsRUFBRSxDQUFDLFNBQUosR0FBZ0IsSUFBQyxDQUFBLFFBQUQsQ0FDZDtBQUFBLE1BQUEsSUFBQSxFQUFNLElBQUMsQ0FBQSxLQUFLLENBQUMsTUFBUCxDQUFBLENBQU47QUFBQSxNQUNBLElBQUEsRUFBTSxJQUFDLENBQUEsUUFEUDtLQURjLENBQWhCLENBQUE7V0FJQSxJQUFDLENBQUEsVUFBRCxDQUFBLEVBTE07RUFBQSxDQTNGUixDQUFBOztBQUFBLHVCQWtHQSxVQUFBLEdBQVksU0FBQSxHQUFBO0FBQ1YsUUFBQSx3Q0FBQTtBQUFBLElBQUEsSUFBQSxDQUFBLElBQXVDLENBQUEsT0FBdkM7QUFBQSxNQUFBLElBQUMsQ0FBQSxPQUFELEdBQVcsSUFBSSxDQUFDLENBQUwsQ0FBTyxXQUFQLENBQVgsQ0FBQTtLQUFBO0FBQUEsSUFDQSxhQUFBLEdBQWdCO0FBQUEsTUFDZCxLQUFBLEVBQU8sR0FETztBQUFBLE1BRWQsTUFBQSxFQUFRLEdBRk07QUFBQSxNQUdkLE1BQUEsRUFBUSxJQUFDLENBQUEsT0FBTyxDQUFDLEdBQVQsQ0FBYSxDQUFiLENBSE07QUFBQSxNQUlkLFNBQUEsRUFBVyxHQUpHO0FBQUEsTUFLZCxVQUFBLEVBQVksTUFMRTtBQUFBLE1BTWQsVUFBQSxFQUFZLE1BTkU7S0FEaEIsQ0FBQTtBQVNBLElBQUEsSUFBRyx1R0FBSDthQUNFLElBQUMsQ0FBQSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBdEIsQ0FBMkIsYUFBM0IsRUFERjtLQUFBLE1BRUssSUFBRyxvR0FBSDthQUNILElBQUMsQ0FBQSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBakIsQ0FBc0IsYUFBdEIsRUFERztLQVpLO0VBQUEsQ0FsR1osQ0FBQTs7b0JBQUE7O0dBRnVCLFFBQVEsQ0FBQyxLQVhsQyxDQUFBOztBQUFBLE1BOEhNLENBQUMsT0FBUCxHQUFpQixVQTlIakIsQ0FBQTs7OztBQ0FBLElBQUEsb0VBQUE7RUFBQTtpU0FBQTs7QUFBQSxRQUFBLEdBQWUsT0FBQSxDQUFRLFVBQVIsQ0FBZixDQUFBOztBQUFBLFFBQ1EsQ0FBQyxDQUFULEdBQWUsT0FBQSxDQUFRLFFBQVIsQ0FEZixDQUFBOztBQUFBLFFBRUEsR0FBZSxPQUFBLENBQVEsb0JBQVIsQ0FGZixDQUFBOztBQUFBLENBR0EsR0FBZSxPQUFBLENBQVEsWUFBUixDQUhmLENBQUE7O0FBQUEsVUFJQSxHQUFlLE9BQUEsQ0FBUSxpQkFBUixDQUpmLENBQUE7O0FBQUEsV0FLQSxHQUFlLE9BQUEsQ0FBUSxVQUFSLENBTGYsQ0FBQTs7QUFBQSxXQU1BLEdBQWUsT0FBQSxDQUFRLHNCQUFSLENBTmYsQ0FBQTs7QUFBQTtBQVVFLDRCQUFBLENBQUE7Ozs7R0FBQTs7QUFBQSxFQUFBLE9BQUMsQ0FBQSxXQUFELEdBQWdCLCtCQUFoQixDQUFBOztBQUFBLEVBQ0EsT0FBQyxDQUFBLHNCQUFELEdBQTJCLEVBRDNCLENBQUE7O0FBQUEsb0JBR0EsVUFBQSxHQUNFO0FBQUEsSUFBQSxPQUFBLEVBQU8sT0FBQyxDQUFBLFdBQVI7R0FKRixDQUFBOztBQUFBLG9CQU1BLFFBQUEsR0FBVSxXQU5WLENBQUE7O0FBQUEsb0JBUUEsVUFBQSxHQUFZLFNBQUMsT0FBRCxHQUFBO0FBQ1YsSUFBRSxJQUFDLENBQUEsaUJBQUEsTUFBSCxFQUFXLElBQUMsQ0FBQSxlQUFBLElBQVosRUFBa0IsSUFBQyxDQUFBLGlCQUFBLE1BQW5CLENBQUE7QUFBQSxJQUVBLENBQUMsQ0FBQyxPQUFGLENBQVUsSUFBVixFQUFhLHFCQUFiLEVBQW9DLE9BQXBDLENBRkEsQ0FBQTtBQUFBLElBSUEsSUFBQyxDQUFBLEVBQUQsQ0FBSSxPQUFKLEVBQWEsSUFBQyxDQUFBLEtBQWQsQ0FKQSxDQUFBO1dBTUEsSUFBQyxDQUFBLE1BQUQsQ0FBQSxFQVBVO0VBQUEsQ0FSWixDQUFBOztBQUFBLG9CQWlCQSxNQUFBLEdBQ0U7QUFBQSxJQUFBLGtCQUFBLEVBQXdCLE1BQXhCO0FBQUEsSUFDQSxnQkFBQSxFQUF3QixPQUR4QjtBQUFBLElBRUEsY0FBQSxFQUF3QixTQUZ4QjtBQUFBLElBR0EsVUFBQSxFQUF3QixTQUh4QjtBQUFBLElBSUEsV0FBQSxFQUF3QixTQUp4QjtBQUFBLElBS0EsTUFBQSxFQUF3QixhQUx4QjtHQWxCRixDQUFBOztBQUFBLG9CQXlCQSxtQkFBQSxHQUFxQixTQUFBLEdBQUE7QUFDbkIsSUFBQSxJQUFDLENBQUEsYUFBRCxDQUFlLElBQUMsQ0FBQSxLQUFoQixFQUF1QixPQUF2QixDQUFBLENBQUE7QUFBQSxJQUNBLElBQUMsQ0FBQSxRQUFELENBQVUsSUFBQyxDQUFBLEtBQVgsRUFBa0IsT0FBbEIsRUFBMkIsSUFBQyxDQUFBLEtBQTVCLENBREEsQ0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLGFBQUQsQ0FBZSxJQUFDLENBQUEsS0FBaEIsRUFBdUIsUUFBdkIsQ0FIQSxDQUFBO1dBSUEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFDLENBQUEsS0FBWCxFQUFrQixRQUFsQixFQUE0QixDQUFBLFNBQUEsS0FBQSxHQUFBO2FBQUEsU0FBQSxHQUFBO0FBQzFCLFFBQUEsS0FBQyxDQUFBLENBQUQsQ0FBRyxNQUFILENBQVUsQ0FBQyxRQUFYLENBQW9CLFFBQXBCLENBQUEsQ0FBQTtlQUNBLEtBQUMsQ0FBQSxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFwQixDQUF3QixDQUFDLEtBQUMsQ0FBQSxLQUFLLENBQUMsR0FBUCxDQUFXLE1BQVgsQ0FBQSxJQUFzQixLQUFDLENBQUEsSUFBeEIsQ0FBQSxHQUFnQyxTQUF4RCxFQUYwQjtNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQTVCLEVBTG1CO0VBQUEsQ0F6QnJCLENBQUE7O0FBQUEsb0JBbUNBLGtCQUFBLEdBQW9CLFNBQUMsVUFBRCxHQUFBO0FBQ2xCLFFBQUEsT0FBQTtBQUFBLElBQUEsSUFBRyxDQUFBLFVBQUEsSUFBbUIsQ0FBQSxVQUFBLFlBQTBCLFVBQWhEO0FBQ0UsWUFBVSxJQUFBLEtBQUEsQ0FBTSx3REFBTixDQUFWLENBREY7S0FBQTtBQUFBLElBR0EsQ0FBQyxJQUFDLENBQUEsS0FBRCxHQUFTLFVBQVYsQ0FBcUIsQ0FBQyxHQUF0QixHQUE0QixJQUg1QixDQUFBO0FBQUEsSUFLQSxJQUFDLENBQUEsbUJBQUQsQ0FBQSxDQUxBLENBQUE7QUFPQSxJQUFBLElBQUcsQ0FBQyxPQUFBLEdBQVUsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsU0FBWCxDQUFYLENBQUg7QUFDRSxNQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsR0FBUCxDQUFXLEtBQVgsRUFBa0IsT0FBbEIsQ0FBQSxDQURGO0tBUEE7V0FVQSxJQUFDLENBQUEsUUFBRCxHQUFnQixJQUFBLFFBQUEsQ0FBUztBQUFBLE1BQUEsS0FBQSxFQUFPLElBQUMsQ0FBQSxLQUFSO0FBQUEsTUFBZSxJQUFBLEVBQU0sSUFBckI7S0FBVCxFQVhFO0VBQUEsQ0FuQ3BCLENBQUE7O0FBQUEsb0JBZ0RBLE9BQUEsR0FBUyxTQUFDLENBQUQsR0FBQTtBQUNQLElBQUEsQ0FBQyxDQUFDLGNBQUYsQ0FBQSxDQUFBLENBQUE7V0FDQSxDQUFDLENBQUMsZUFBRixDQUFBLEVBRk87RUFBQSxDQWhEVCxDQUFBOztBQUFBLG9CQW9EQSxLQUFBLEdBQU8sU0FBQyxDQUFELEdBQUE7QUFDTCxRQUFBLElBQUE7O01BRE0sSUFBSTtLQUNWO0FBQUEsSUFBQSxJQUFlLFdBQUEsSUFBTyxDQUFDLENBQUMsTUFBRixLQUFZLENBQWxDO0FBQUEsYUFBTyxJQUFQLENBQUE7S0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLENBQUQsQ0FBRyxNQUFILENBQVUsQ0FBQyxRQUFYLENBQW9CLFFBQXBCLENBREEsQ0FBQTtBQUFBLElBSUEsVUFBQSxDQUFXLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFBLEdBQUE7ZUFDVCxLQUFDLENBQUEsQ0FBRCxDQUFHLE1BQUgsQ0FBVSxDQUFDLFdBQVgsQ0FBdUIsUUFBdkIsRUFEUztNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQVgsRUFFRSxJQUFDLENBQUEsc0JBRkgsQ0FKQSxDQUFBO0FBUUEsSUFBQSxzQ0FBUyxDQUFFLGVBQVg7QUFDRSxNQUFBLElBQStCLENBQUEsQ0FBSyxDQUFDLE1BQXJDO0FBQUEsUUFBQSxJQUFDLENBQUEsTUFBTSxDQUFDLE9BQVIsQ0FBZ0IsT0FBaEIsRUFBeUIsSUFBekIsQ0FBQSxDQUFBO09BQUE7YUFDQSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQVAsQ0FBQSxFQUZGO0tBVEs7RUFBQSxDQXBEUCxDQUFBOztBQUFBLG9CQWlFQSxPQUFBLEdBQVMsU0FBQyxDQUFELEdBQUEsQ0FqRVQsQ0FBQTs7QUFvRUE7QUFBQTs7O0tBcEVBOztBQUFBLG9CQXdFQSxpQkFBQSxHQUFtQixTQUFDLEtBQUQsR0FBQTs7TUFBQyxRQUFRO0tBQzFCO0FBQUEsSUFBQSxJQUFBLENBQUEsQ0FBUSxJQUFDLENBQUEsS0FBRCxHQUFTLElBQUMsQ0FBQSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFuQixDQUE2QjtBQUFBLE1BQUEsUUFBQSxFQUFVLElBQUMsQ0FBQSxXQUFYO0tBQTdCLENBQW9ELENBQUMsTUFBTSxDQUFDLFNBQTVELENBQXNFO0FBQUEsTUFBQSxHQUFBLEVBQUssSUFBQyxDQUFBLE1BQU47S0FBdEUsQ0FBVixDQUFQO0FBQ0UsTUFBQSxJQUFDLENBQUEsS0FBRCxHQUFhLElBQUEsVUFBQSxDQUFXLENBQUMsQ0FBQyxNQUFGLENBQVM7QUFBQSxRQUFBLEdBQUEsRUFBSyxJQUFDLENBQUEsR0FBRyxDQUFDLEtBQUwsQ0FBQSxDQUFBLEdBQWUsQ0FBcEI7T0FBVCxFQUFnQyxLQUFoQyxDQUFYLENBQWIsQ0FBQTtBQUFBLE1BQ0EsSUFBQyxDQUFBLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBakMsQ0FBcUMsSUFBQyxDQUFBLEtBQXRDLENBREEsQ0FBQTtBQUFBLE1BRUEsSUFBQyxDQUFBLGtCQUFELENBQW9CLElBQUMsQ0FBQSxLQUFyQixDQUZBLENBREY7S0FBQTtXQUlBLElBQUMsQ0FBQSxNQUxnQjtFQUFBLENBeEVuQixDQUFBOztBQUFBLG9CQStFQSxXQUFBLEdBQWEsU0FBQyxDQUFELEdBQUE7QUFDWCxRQUFBLDZCQUFBO0FBQUEsSUFBQSxDQUFBLEdBQUksQ0FBQyxDQUFDLGFBQU4sQ0FBQTtBQUFBLElBQ0EsQ0FBQyxDQUFDLGNBQUYsQ0FBQSxDQURBLENBQUE7QUFBQSxJQUVBLENBQUMsQ0FBQyxlQUFGLENBQUEsQ0FGQSxDQUFBO0FBSUEsSUFBQSxJQUFBLENBQUEsSUFBNkIsQ0FBQSxLQUE3QjtBQUFBLE1BQUEsSUFBQyxDQUFBLGlCQUFELENBQUEsQ0FBQSxDQUFBO0tBSkE7QUFBQSxJQU1BLFNBQUEsa0ZBQXNCLENBQUUsd0ZBQXdDLENBQUEsQ0FBQSxzQ0FOaEUsQ0FBQTtBQUFBLElBUUEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxDQUFDLENBQUMsWUFBWSxDQUFDLEtBQU0sQ0FBQSxDQUFBLENBQS9CLEVBQW1DLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFDLEtBQUQsRUFBUSxLQUFSLEdBQUE7QUFDakMsaUJBQUE7QUFDQSxRQUFBLElBQUEsQ0FBQSxTQUFBO2lCQUNFLEtBQUssQ0FBQyxHQUFOLENBQVUsS0FBVixFQUFpQixLQUFLLENBQUMsR0FBTixDQUFBLENBQWpCLEVBREY7U0FGaUM7TUFBQSxFQUFBO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFuQyxDQVJBLENBQUE7QUFhQSxJQUFBLElBQUcsU0FBSDtBQUNFLE1BQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsS0FBWCxFQUFrQixTQUFsQixDQUFBLENBQUE7YUFDQSxJQUFDLENBQUEsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBcEIsQ0FBeUIsUUFBQSxHQUFPLENBQUMsQ0FBQyxZQUFZLENBQUMsS0FBTSxDQUFBLENBQUEsQ0FBRSxDQUFDLElBQS9CLEdBQXFDLGNBQXJDLEdBQWtELElBQUMsQ0FBQSxJQUE1RSxFQUZGO0tBQUEsTUFBQTthQUlFLElBQUMsQ0FBQSxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFwQixDQUF5QixhQUFBLEdBQVksQ0FBQyxDQUFDLFlBQVksQ0FBQyxLQUFNLENBQUEsQ0FBQSxDQUFFLENBQUMsSUFBN0QsRUFKRjtLQWRXO0VBQUEsQ0EvRWIsQ0FBQTs7QUFBQSxvQkFtR0EsUUFBQSxHQUFVLFNBQUMsSUFBRCxFQUFPLEVBQVAsR0FBQTtBQUNSLElBQUEsSUFBQyxDQUFBLFFBQUQsR0FBZ0IsSUFBQSxRQUFBLENBQUEsQ0FBaEIsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLEdBQUQsR0FBVyxJQUFBLGNBQUEsQ0FBQSxDQURYLENBQUE7QUFBQSxJQUVBLElBQUMsQ0FBQSxHQUFHLENBQUMsSUFBTCxDQUFVLE1BQVYsRUFBa0IsU0FBbEIsRUFBNkIsSUFBN0IsQ0FGQSxDQUFBO0FBQUEsSUFHQSxJQUFDLENBQUEsUUFBUSxDQUFDLE1BQVYsQ0FBaUIsT0FBakIsRUFBMEIsSUFBMUIsQ0FIQSxDQUFBO0FBQUEsSUFJQSxJQUFDLENBQUEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFaLEdBQXlCLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFDLENBQUQsR0FBQTtBQUN2QixZQUFBLFNBQUE7QUFBQSxRQUFBLElBQUcsQ0FBQyxDQUFDLGdCQUFMO0FBQ0UsVUFBQSxTQUFBLEdBQVksQ0FBQyxDQUFDLENBQUMsTUFBRixHQUFXLENBQUMsQ0FBQyxLQUFkLENBQUEsR0FBdUIsR0FBbkMsQ0FBQTtpQkFDQSxLQUFDLENBQUEsQ0FBRCxDQUFHLGVBQUgsQ0FBbUIsQ0FBQyxHQUFwQixDQUF3QjtBQUFBLFlBQUEsS0FBQSxFQUFPLEVBQUEsR0FBRSxDQUFBLFNBQVMsQ0FBQyxPQUFWLENBQWtCLENBQWxCLENBQUEsQ0FBRixHQUF3QixHQUEvQjtXQUF4QixFQUZGO1NBRHVCO01BQUEsRUFBQTtJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FKekIsQ0FBQTtBQUFBLElBUUEsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFMLEdBQWUsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsQ0FBRCxHQUFBO2VBQ2IsS0FBQyxDQUFBLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQXBCLENBQXdCLGVBQXhCLEVBRGE7TUFBQSxFQUFBO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQVJmLENBQUE7QUFBQSxJQVVBLElBQUMsQ0FBQSxHQUFHLENBQUMsTUFBTCxHQUFjLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFDLENBQUQsR0FBQTtBQUNaLFlBQUEsSUFBQTtBQUFBLFFBQUEsSUFBQSxHQUFPLElBQUksQ0FBQyxLQUFMLENBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxZQUFwQixDQUFQLENBQUE7QUFDQSxpQkFEQTtBQUFBLFFBRUEsS0FBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsSUFBWCxDQUZBLENBQUE7QUFBQSxRQUdBLEtBQUMsQ0FBQSxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFwQixDQUF5QixvQkFBQSxHQUFtQixJQUFJLENBQUMsUUFBakQsQ0FIQSxDQUFBO0FBQUEsUUFJQSxFQUFBLElBQU8sRUFBQSxDQUFHLEtBQUMsQ0FBQSxLQUFKLEVBQVcsSUFBWCxDQUpQLENBQUE7QUFLQTtBQUFBO1NBQUEsY0FBQTtBQUdFLFVBREksVUFDSixDQUFBO0FBQUEsVUFBQSxLQUFDLENBQUEsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBcEIsQ0FBd0IsZUFBeEIsQ0FBQSxDQUFBO2lCQUNBLEtBQUEsQ0FBTyxvQkFBQSxHQUFtQixDQUFDLENBQUMsT0FBckIsR0FBOEIsaUJBQTlCLEdBQThDLENBQUMsQ0FBQyxZQUF2RCxFQUpGO1NBTlk7TUFBQSxFQUFBO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQVZkLENBQUE7QUFBQSxJQXFCQSxJQUFDLENBQUEsR0FBRyxDQUFDLElBQUwsQ0FBVSxJQUFDLENBQUEsUUFBWCxDQXJCQSxDQUFBO0FBQUEsSUFzQkEsTUFBQSxDQUFBLElBQVEsQ0FBQSxHQXRCUixDQUFBO1dBdUJBLE1BQUEsQ0FBQSxJQUFRLENBQUEsU0F4QkE7RUFBQSxDQW5HVixDQUFBOztBQUFBLG9CQTZIQSxJQUFBLEdBQU0sU0FBQyxDQUFELEdBQUE7QUFDSixJQUFBLENBQUMsQ0FBQyxjQUFGLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxJQUFHLENBQUEsSUFBSyxDQUFBLE1BQVI7QUFDRSxNQUFBLElBQUMsQ0FBQSxNQUFELEdBQWMsSUFBQSxXQUFBLENBQ1o7QUFBQSxRQUFBLEtBQUEsRUFBTyxJQUFDLENBQUEsS0FBRCxJQUFVLElBQUMsQ0FBQSxpQkFBRCxDQUFBLENBQWpCO0FBQUEsUUFDQSxHQUFBLEVBQUssSUFETDtPQURZLENBQWQsQ0FERjtLQURBO1dBTUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxJQUFSLENBQUEsRUFQSTtFQUFBLENBN0hOLENBQUE7O0FBQUEsb0JBc0lBLE1BQUEsR0FBUSxTQUFBLEdBQUE7V0FDTixJQUFDLENBQUEsRUFBRSxDQUFDLFNBQUosR0FBZ0IsSUFBQyxDQUFBLFFBQUQsQ0FBVTtBQUFBLE1BQUEsSUFBQSxFQUFNLElBQUMsQ0FBQSxJQUFQO0tBQVYsRUFEVjtFQUFBLENBdElSLENBQUE7O2lCQUFBOztHQUZvQixRQUFRLENBQUMsS0FSL0IsQ0FBQTs7QUFBQSxNQW1KTSxDQUFDLE9BQVAsR0FBaUIsT0FuSmpCLENBQUE7Ozs7QUNBQSxJQUFBLDZEQUFBO0VBQUE7aVNBQUE7O0FBQUEsUUFBQSxHQUFnQixPQUFBLENBQVEsVUFBUixDQUFoQixDQUFBOztBQUFBLFFBQ1EsQ0FBQyxDQUFULEdBQWdCLE9BQUEsQ0FBUSxRQUFSLENBRGhCLENBQUE7O0FBQUEsQ0FFQSxHQUFnQixPQUFBLENBQVEsWUFBUixDQUZoQixDQUFBOztBQUFBLE9BR0EsR0FBZ0IsT0FBQSxDQUFRLE9BQVIsQ0FIaEIsQ0FBQTs7QUFBQSxZQUlBLEdBQWdCLE9BQUEsQ0FBUSxzQkFBUixDQUpoQixDQUFBOztBQUFBLGVBTUEsR0FBc0IsR0FOdEIsQ0FBQTs7QUFBQTtBQVVFLDZCQUFBLENBQUE7Ozs7R0FBQTs7QUFBQSxxQkFBQSxFQUFBLEdBQUksT0FBSixDQUFBOztBQUFBLHFCQUVBLFFBQUEsR0FBVSxZQUZWLENBQUE7O0FBQUEscUJBSUEsUUFBQSxHQUNFO0FBQUEsSUFBQSxHQUFBLEVBQUssU0FBTDtBQUFBLElBQ0EsR0FBQSxFQUFLLFNBREw7QUFBQSxJQUVBLEdBQUEsRUFBSyxTQUZMO0FBQUEsSUFHQSxHQUFBLEVBQUssU0FITDtBQUFBLElBSUEsR0FBQSxFQUFLLFNBSkw7R0FMRixDQUFBOztBQUFBLHFCQVdBLFVBQUEsR0FBWSxTQUFDLE9BQUQsR0FBQTtBQUNWLElBQUUsSUFBQyxDQUFBLE1BQVEsUUFBUixHQUFILENBQUE7QUFBQSxJQUNBLElBQUMsQ0FBQSxVQUFELENBQUEsQ0FEQSxDQUFBO0FBQUEsSUFHQSxJQUFDLENBQUEsTUFBRCxDQUFBLENBSEEsQ0FBQTtBQUFBLElBS0EsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFDLENBQUEsR0FBRyxDQUFDLE1BQWYsRUFBdUIsT0FBdkIsRUFBZ0MsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsVUFBRCxHQUFBO0FBQzlCLFFBQUEsVUFBVSxDQUFDLElBQVgsQ0FBZ0IsU0FBQyxLQUFELEdBQUE7aUJBQ2QsS0FBQyxDQUFBLGtCQUFELENBQW9CLEtBQXBCLEVBRGM7UUFBQSxDQUFoQixDQUFBLENBQUE7ZUFFQSxLQUFDLENBQUEsTUFBRCxDQUFBLEVBSDhCO01BQUEsRUFBQTtJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBaEMsQ0FMQSxDQUFBO1dBVUEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFDLENBQUEsR0FBRyxDQUFDLE1BQWYsRUFBdUIsS0FBdkIsRUFBOEIsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsS0FBRCxHQUFBO2VBQzVCLEtBQUMsQ0FBQSxrQkFBRCxDQUFvQixLQUFwQixFQUQ0QjtNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQTlCLEVBWFU7RUFBQSxDQVhaLENBQUE7O0FBQUEscUJBeUJBLFVBQUEsR0FBWSxTQUFBLEdBQUE7QUFDVixRQUFBLG9DQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsSUFBRCxHQUFRLEVBQVIsQ0FBQTtBQUFBLElBQ0EsQ0FBQSxHQUFJLENBREosQ0FBQTtBQUVBO1NBQVMsK0JBQVQsR0FBQTtBQUNFLE1BQUEsT0FBQSxHQUNFO0FBQUEsUUFBQSxJQUFBLEVBQU0sRUFBQSxHQUFFLENBQUEsZUFBQSxHQUFrQixDQUFDLENBQUEsR0FBSSxDQUFBLEdBQUksRUFBVCxDQUFsQixDQUFSO0FBQUEsUUFDQSxNQUFBLEVBQVEsSUFEUjtBQUFBLFFBRUEsTUFBQSxFQUFTLENBQUEsR0FBSSxDQUFBLEdBQUksRUFGakI7T0FERixDQUFBO0FBQUEsTUFJQSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxDQUFDLE9BQUEsR0FBYyxJQUFBLE9BQUEsQ0FBUSxPQUFSLENBQWYsQ0FBWCxDQUpBLENBQUE7QUFBQSxNQUtBLE9BQU8sQ0FBQyxXQUFSLEdBQXNCLENBQUEsR0FBSSxDQUwxQixDQUFBO0FBTUEsTUFBQSxJQUFPLENBQUEsR0FBSSxFQUFKLEtBQVUsQ0FBakI7c0JBQUEsQ0FBQSxJQUFBO09BQUEsTUFBQTs4QkFBQTtPQVBGO0FBQUE7b0JBSFU7RUFBQSxDQXpCWixDQUFBOztBQUFBLHFCQXFDQSxrQkFBQSxHQUFvQixTQUFDLEtBQUQsR0FBQTtBQUNsQixRQUFBLHFDQUFBO0FBQUEsSUFBQSxHQUFBLEdBQVMsS0FBSyxDQUFDLEdBQU4sQ0FBVSxVQUFWLENBQUEsR0FBd0IsQ0FBeEIsR0FBNEIsQ0FBQSxDQUEvQixHQUF1QyxLQUFLLENBQUMsR0FBTixDQUFVLFVBQVYsQ0FBQSxHQUF3QixDQUEvRCxHQUFzRSxDQUE1RSxDQUFBO0FBQUEsSUFDQSxJQUFBLEdBQU8sSUFBQyxDQUFBLElBQUksQ0FBQyxLQUFOLENBQVksR0FBQSxHQUFNLEVBQWxCLEVBQXNCLEdBQUEsR0FBTSxFQUFOLEdBQVcsRUFBakMsQ0FEUCxDQUFBO0FBR0EsSUFBQSxJQUFnRSwwQkFBaEU7QUFBQTtXQUFBLG1EQUFBO3NCQUFBO0FBQUEsc0JBQUEsR0FBRyxDQUFDLGtCQUFKLENBQXVCLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBYixDQUFnQixDQUFoQixDQUF2QixFQUFBLENBQUE7QUFBQTtzQkFBQTtLQUprQjtFQUFBLENBckNwQixDQUFBOztBQUFBLHFCQTJDQSx3QkFBQSxHQUEwQixTQUFDLEtBQUQsR0FBQTtXQUN4QixJQUFDLENBQUEsR0FBRyxDQUFDLENBQUwsQ0FBTywrQkFBUCxDQUNFLENBQUMsV0FESCxDQUNlLFFBRGYsQ0FFRSxDQUFDLE1BRkgsQ0FFVyxlQUFBLEdBQWMsS0FBZCxHQUFxQixLQUZoQyxDQUdFLENBQUMsUUFISCxDQUdZLFFBSFosRUFEd0I7RUFBQSxDQTNDMUIsQ0FBQTs7QUFBQSxxQkFpREEsTUFBQSxHQUFRLFNBQUMsV0FBRCxHQUFBO0FBSU4sUUFBQSxpQkFBQTs7TUFKTyxjQUFjO0tBSXJCO0FBQUEsSUFBQSxJQUFDLENBQUEsQ0FBRCxDQUFHLGdCQUFILENBQW9CLENBQUMsTUFBckIsQ0FBQSxDQUFBLENBQUE7QUFBQSxJQUVBLFdBQUEsR0FBYyxXQUFBLEdBQWMsQ0FGNUIsQ0FBQTtBQUFBLElBS0EsSUFBQyxDQUFBLHdCQUFELENBQTBCLFdBQTFCLENBTEEsQ0FBQTtBQUFBLElBUUEsV0FBQSxHQUFjLFdBQUEsR0FBYyxDQVI1QixDQUFBO0FBQUEsSUFXQSxJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFiLEdBQXFCLElBQUMsQ0FBQSxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVosQ0FBc0I7QUFBQSxNQUFBLFFBQUEsRUFBVSxXQUFWO0tBQXRCLENBWHJCLENBQUE7QUFjQSxJQUFBLElBQUcsQ0FBQSxJQUFLLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFwQjtBQUNFLE1BQUEsSUFBQyxDQUFBLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBWixDQUFnQjtBQUFBLFFBQUEsUUFBQSxFQUFVLFdBQVY7T0FBaEIsQ0FBQSxDQUFBO0FBQUEsTUFDQSxJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFiLEdBQXFCLElBQUMsQ0FBQSxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVosQ0FBc0I7QUFBQSxRQUFBLFFBQUEsRUFBVSxXQUFWO09BQXRCLENBRHJCLENBREY7S0FkQTtBQUFBLElBa0JBLElBQUMsQ0FBQSxHQUFHLENBQUMsQ0FBTCxDQUFPLGlCQUFQLENBQXlCLENBQUMsSUFBMUIsQ0FBQSxDQWxCQSxDQUFBO0FBQUEsSUFxQkEsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsY0FBYixrRUFBZ0UsQ0FBRSxHQUF0QyxDQUEwQyxVQUExQyxXQUFBLElBQXlELENBQXJGLENBckJBLENBQUE7QUFBQSxJQXdCQSxJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFiLEdBQW9CLElBQUMsQ0FBQSxJQUFJLENBQUMsS0FBTixDQUFZLFdBQUEsR0FBYyxFQUExQixFQUE4QixXQUFBLEdBQWMsRUFBZCxHQUFtQixFQUFqRCxDQXhCcEIsQ0FBQTtBQUFBLElBMkJBLElBQUMsQ0FBQSxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFuQixDQUF1QixPQUF2QixFQUFpQyxRQUFBLEdBQU8sV0FBeEMsQ0EzQkEsQ0FBQTtXQThCQSxJQUFDLENBQUEsR0FBRyxDQUFDLE1BQUwsQ0FBWSxDQUFDLENBQUMsS0FBRixDQUFRLElBQUMsQ0FBQSxHQUFHLENBQUMsT0FBTyxDQUFDLElBQXJCLEVBQTJCLElBQTNCLENBQVosRUFsQ007RUFBQSxDQWpEUixDQUFBOztrQkFBQTs7R0FGcUIsUUFBUSxDQUFDLEtBUmhDLENBQUE7O0FBQUEsTUErRk0sQ0FBQyxPQUFQLEdBQWlCLFFBL0ZqQixDQUFBOzs7O0FDQUEsSUFBQSw0RkFBQTtFQUFBOzt1SkFBQTs7QUFBQSxRQUFBLEdBQXNCLE9BQUEsQ0FBUSxVQUFSLENBQXRCLENBQUE7O0FBQUEsUUFDUSxDQUFDLENBQVQsR0FBc0IsQ0FBQSxHQUFJLE9BQUEsQ0FBUSxRQUFSLENBRDFCLENBQUE7O0FBQUEsQ0FFQSxHQUFzQixPQUFBLENBQVEsWUFBUixDQUZ0QixDQUFBOztBQUFBLGlCQUdBLEdBQXNCLE9BQUEsQ0FBUSx3QkFBUixDQUh0QixDQUFBOztBQUFBLEtBSUEsR0FBc0IsT0FBQSxDQUFRLDJDQUFSLENBSnRCLENBQUE7O0FBQUEsaUJBTUEsR0FBb0IsYUFOcEIsQ0FBQTs7QUFBQSxjQU9BLEdBQW9CLEdBUHBCLENBQUE7O0FBQUE7QUFXRSxvQ0FBQSxDQUFBOzs7O0dBQUE7O0FBQUEsNEJBQUEsVUFBQSxHQUNFO0FBQUEsSUFBQSxPQUFBLEVBQWMsTUFBZDtBQUFBLElBQ0EsS0FBQSxFQUFjLGVBRGQ7R0FERixDQUFBOztBQUFBLDRCQUlBLFVBQUEsR0FBWSxTQUFDLE9BQUQsR0FBQTs7TUFBQyxVQUFVO0tBQ3JCO0FBQUEsSUFBRSxJQUFDLENBQUEsUUFBVSxRQUFWLEtBQUgsQ0FBQTtBQUFBLElBRUEsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxJQUFWLEVBQWEsVUFBYixFQUF5QixZQUF6QixFQUF1QyxlQUF2QyxFQUF3RCxRQUF4RCxDQUZBLENBQUE7QUFBQSxJQU9BLElBQUMsQ0FBQSxHQUFELEdBQU8sSUFBQyxDQUFBLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBUC9CLENBQUE7QUFBQSxJQVFBLElBQUMsQ0FBQSxFQUFELEdBQU0sSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQVJYLENBQUE7QUFBQSxJQVdBLElBQUMsQ0FBQSxFQUFFLENBQUMsQ0FBSixDQUFNLFdBQU4sQ0FBa0IsQ0FBQyxNQUFuQixDQUEwQixJQUFDLENBQUEsR0FBM0IsQ0FYQSxDQUFBO0FBYUEsSUFBQSxJQUFBLENBQUEsSUFBMEMsQ0FBQSxLQUFLLENBQUMsR0FBUCxDQUFXLEtBQVgsQ0FBekM7QUFBQSxNQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsR0FBUCxDQUFXLEtBQVgsRUFBa0IsY0FBbEIsQ0FBQSxDQUFBO0tBYkE7QUFBQSxJQWVBLElBQUMsQ0FBQSxNQUFELENBQUEsQ0FmQSxDQUFBO0FBQUEsSUFrQkEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFDLENBQUEsS0FBWCxFQUFrQixZQUFsQixFQUFnQyxJQUFDLENBQUEsUUFBakMsQ0FsQkEsQ0FBQTtBQUFBLElBbUJBLElBQUMsQ0FBQSxRQUFELENBQVUsSUFBQyxDQUFBLEtBQVgsRUFBa0IsYUFBbEIsRUFBaUMsSUFBQyxDQUFBLFFBQWxDLENBbkJBLENBQUE7QUFBQSxJQW9CQSxJQUFDLENBQUEsUUFBRCxDQUFVLElBQUMsQ0FBQSxLQUFYLEVBQWtCLGFBQWxCLEVBQWlDLElBQUMsQ0FBQSxRQUFsQyxDQXBCQSxDQUFBO0FBQUEsSUFxQkEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFDLENBQUEsS0FBWCxFQUFrQixRQUFsQixFQUE0QixJQUFDLENBQUEsTUFBN0IsQ0FyQkEsQ0FBQTtXQXVCQSxJQUFDLENBQUEsUUFBRCxDQUFVLElBQUMsQ0FBQSxFQUFYLEVBQWUsTUFBZixFQUF1QixJQUFDLENBQUEsTUFBeEIsRUF4QlU7RUFBQSxDQUpaLENBQUE7O0FBQUEsNEJBOEJBLE1BQUEsR0FDRTtBQUFBLElBQUEsc0JBQUEsRUFBd0Msb0JBQXhDO0FBQUEsSUFDQSxVQUFBLEVBQXdDLGlCQUR4QztHQS9CRixDQUFBOztBQWtDQTtBQUFBOzs7S0FsQ0E7O0FBQUEsNEJBc0NBLGVBQUEsR0FBaUIsU0FBQyxDQUFELEdBQUE7QUFDZixJQUFBLENBQUMsQ0FBQyxjQUFGLENBQUEsQ0FBQSxDQUFBO1dBQ0EsSUFBQyxDQUFBLFVBQUQsQ0FBWSxJQUFDLENBQUEsaUJBQUQsQ0FBbUIsQ0FBQyxDQUFDLE9BQXJCLENBQVosRUFBMkMsSUFBQyxDQUFBLFlBQUQsQ0FBYyxDQUFDLENBQUMsT0FBaEIsQ0FBM0MsRUFGZTtFQUFBLENBdENqQixDQUFBOztBQTBDQTtBQUFBOzs7S0ExQ0E7O0FBQUEsNEJBOENBLGtCQUFBLEdBQW9CLFNBQUMsQ0FBRCxHQUFBO0FBQ2xCLFFBQUEsSUFBQTtBQUFBLElBQUEsQ0FBQyxDQUFDLGNBQUYsQ0FBQSxDQUFBLENBQUE7QUFBQSxJQUNBLElBQUEsR0FBTyxDQUFBLENBQUUsQ0FBQyxDQUFDLE1BQUosQ0FBVyxDQUFDLElBQVosQ0FBQSxDQURQLENBQUE7QUFBQSxJQUVBLElBQUMsQ0FBQSxhQUFELENBQWUsSUFBSSxDQUFDLFNBQXBCLEVBQStCLElBQUksQ0FBQyxJQUFwQyxDQUZBLENBQUE7V0FHQSxDQUFBLENBQUUsQ0FBQyxDQUFDLE1BQUosQ0FBVyxDQUFDLE1BQVosQ0FBQSxFQUprQjtFQUFBLENBOUNwQixDQUFBOztBQUFBLDRCQW9EQSxNQUFBLEdBQVEsU0FBQyxJQUFELEdBQUE7QUFDTixRQUFBLHdCQUFBO0FBQUEsSUFBQSxjQUFBLEdBQWlCLElBQUMsQ0FBQSxpQkFBRCxDQUFtQixJQUFuQixDQUFqQixDQUFBO0FBQ0EsSUFBQSxJQUFHLElBQUMsQ0FBQSxHQUFHLENBQUMsU0FBUyxDQUFDLFFBQWYsSUFBMkIsQ0FBQyxRQUFBLEdBQVcsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVksV0FBQSxHQUFVLGNBQXRCLENBQVosQ0FBOUI7YUFDRSxDQUFDLENBQUMsSUFBRixDQUFPLFFBQVAsRUFBaUIsQ0FBQSxTQUFBLEtBQUEsR0FBQTtlQUFBLFNBQUMsU0FBRCxHQUFBO0FBQ2YsY0FBQSxJQUFBO0FBQUEsVUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLEtBQUMsQ0FBQSxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FBL0IsQ0FBeUM7QUFBQSxZQUFBLEdBQUEsRUFBSyxTQUFMO1dBQXpDLENBQVosQ0FBQSxDQUFBOzs7NEJBQ3dELENBQUUsT0FBMUQsQ0FBa0UsT0FBbEUsRUFBMkU7QUFBQSxZQUFBLE1BQUEsRUFBUSxJQUFSO1dBQTNFLFdBRmU7UUFBQSxFQUFBO01BQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFqQixFQURGO0tBRk07RUFBQSxDQXBEUixDQUFBOztBQUFBLDRCQTJEQSxZQUFBLEdBQWMsU0FBQSxHQUFBO0FBQ1osUUFBQSx5Q0FBQTtBQUFBO0FBQUE7U0FBQSxZQUFBOzs0QkFBQTtBQUNFOztBQUFBO2FBQUEsK0NBQUE7bUNBQUE7QUFDRSx5QkFBQSxJQUFDLENBQUEsV0FBRCxDQUFhLFNBQWIsRUFBd0IsSUFBeEIsRUFBQSxDQURGO0FBQUE7O29CQUFBLENBREY7QUFBQTtvQkFEWTtFQUFBLENBM0RkLENBQUE7O0FBQUEsNEJBZ0VBLFdBQUEsR0FBYSxTQUFDLFNBQUQsRUFBWSxJQUFaLEdBQUE7QUFDWCxRQUFBLDBCQUFBO0FBQUEsSUFBQSxVQUFBLEdBQWEsSUFBQyxDQUFBLGFBQUQsQ0FBQSxDQUFiLENBQUE7QUFBQSxJQUNBLElBQUEsR0FBTyxDQUFDLEdBQUEsR0FBTSxJQUFDLENBQUEsYUFBRCxDQUFBLENBQVAsQ0FBQSxHQUEyQixJQUFDLENBQUEsaUJBQUQsQ0FBbUIsSUFBbkIsQ0FEbEMsQ0FBQTtBQUFBLElBRUEsUUFBQSxHQUFXLENBQUEsQ0FBRSx1QkFBRixDQUNHLENBQUMsR0FESixDQUVLO0FBQUEsTUFBQSxHQUFBLEVBQUssQ0FBQyxTQUFBLEdBQVksQ0FBYixDQUFBLEdBQWtCLElBQUMsQ0FBQSxFQUFFLENBQUMsQ0FBSixDQUFNLE9BQU4sQ0FBYyxDQUFDLEVBQWYsQ0FBa0IsQ0FBbEIsQ0FBb0IsQ0FBQyxXQUFyQixDQUFBLENBQWxCLEdBQXVELElBQTVEO0FBQUEsTUFDQSxNQUFBLEVBQVEsRUFBQSxHQUFFLENBQUEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxDQUFKLENBQU0sT0FBTixDQUFjLENBQUMsRUFBZixDQUFrQixDQUFsQixDQUFvQixDQUFDLFdBQXJCLENBQUEsQ0FBQSxDQUFGLEdBQXNDLElBRDlDO0FBQUEsTUFFQSxLQUFBLEVBQU8sRUFBQSxHQUFFLENBQUEsQ0FBQyxJQUFDLENBQUEsQ0FBRCxHQUFLLFVBQU4sQ0FBQSxHQUFvQixJQUFDLENBQUEsQ0FBckIsR0FBeUIsR0FBekIsQ0FBRixHQUFnQyxHQUZ2QztBQUFBLE1BR0EsSUFBQSxFQUFNLEVBQUEsR0FBRSxJQUFGLEdBQVEsR0FIZDtLQUZMLENBTUcsQ0FBQyxJQU5KLENBTVMsTUFOVCxFQU1pQixJQU5qQixDQU9HLENBQUMsSUFQSixDQU9TLFdBUFQsRUFPc0IsU0FQdEIsQ0FGWCxDQUFBO1dBVUEsSUFBQyxDQUFBLEdBQUcsQ0FBQyxNQUFMLENBQVksUUFBWixFQVhXO0VBQUEsQ0FoRWIsQ0FBQTs7QUFBQSw0QkE2RUEsYUFBQSxHQUFlLFNBQUMsU0FBRCxFQUFZLGNBQVosR0FBQTtBQUNiLFFBQUEsaUJBQUE7QUFBQSxJQUFBLElBQUcsQ0FBQyxRQUFBLEdBQVcsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVksV0FBQSxHQUFVLGNBQXRCLENBQVosQ0FBSDtBQUNFLE1BQUEsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUExQixDQUFzQyxjQUF0QyxFQUFzRCxTQUF0RCxDQUFBLENBQUE7QUFBQSxNQUNBLE9BQUEsR0FBVSxRQUFRLENBQUMsTUFBVCxDQUFnQixDQUFDLENBQUMsT0FBRixDQUFVLFFBQVYsRUFBb0IsU0FBcEIsQ0FBaEIsRUFBZ0QsQ0FBaEQsQ0FEVixDQUFBO0FBQUEsTUFFQSxJQUFDLENBQUEsS0FBSyxDQUFDLEdBQVAsQ0FBWSxXQUFBLEdBQVUsY0FBdEIsRUFBeUMsUUFBekMsQ0FGQSxDQUFBO2FBR0EsUUFKRjtLQUFBLE1BQUE7YUFNRSxNQU5GO0tBRGE7RUFBQSxDQTdFZixDQUFBOztBQUFBLDRCQXNGQSxVQUFBLEdBQVksU0FBQyxTQUFELEVBQVksY0FBWixHQUFBO0FBQ1YsUUFBQSxRQUFBO0FBQUEsSUFBQSxRQUFBLEdBQVcsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVksV0FBQSxHQUFVLGNBQXRCLENBQUEsSUFBNEMsRUFBdkQsQ0FBQTtBQUNBLElBQUEsSUFBQSxDQUFBLENBQU8sUUFBUSxDQUFDLE9BQVQsQ0FBaUIsU0FBakIsQ0FBQSxHQUE4QixDQUFBLENBQXJDLENBQUE7QUFDRSxNQUFBLFFBQVEsQ0FBQyxJQUFULENBQWMsU0FBZCxDQUFBLENBQUE7QUFBQSxNQUNBLElBQUMsQ0FBQSxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBMUIsQ0FBc0MsU0FBdEMsRUFBaUQsY0FBakQsQ0FEQSxDQUFBO0FBQUEsTUFFQSxJQUFDLENBQUEsS0FBSyxDQUFDLEdBQVAsQ0FBWSxXQUFBLEdBQVUsY0FBdEIsRUFBeUMsUUFBekMsQ0FGQSxDQURGO0tBREE7V0FLQSxVQU5VO0VBQUEsQ0F0RlosQ0FBQTs7QUFBQSw0QkE4RkEsYUFBQSxHQUFlLFNBQUEsR0FBQTtBQUNiLFFBQUEsVUFBQTtXQUFBLFVBQUEsR0FBYyxJQUFDLENBQUEsS0FBSyxDQUFDLEdBQVAsQ0FBVyxLQUFYLENBQUEsR0FBb0IsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsTUFBWCxFQURyQjtFQUFBLENBOUZmLENBQUE7O0FBQUEsNEJBaUdBLGlCQUFBLEdBQW1CLFNBQUMsSUFBRCxFQUFPLFlBQVAsR0FBQTtBQUNqQixRQUFBLGtCQUFBOztNQUR3QixlQUFlO0tBQ3ZDO0FBQUEsSUFBQSxTQUFBLE9BQVMsSUFBQyxDQUFBLEdBQUcsQ0FBQyxTQUFTLENBQUMsT0FBZixDQUFBLEVBQVQsQ0FBQTtBQUFBLElBQ0EsVUFBQSxHQUFhLElBQUMsQ0FBQSxhQUFELENBQUEsQ0FEYixDQUFBO0FBRUEsSUFBQSxJQUFHLElBQUEsSUFBUSxVQUFYO0FBQ0UsTUFBQSxNQUFBLEdBQVMsSUFBVCxDQURGO0tBQUEsTUFBQTtBQUdFLE1BQUEsTUFBQSxHQUFTLElBQUEsR0FBTyxJQUFDLENBQUEsYUFBRCxDQUFBLENBQWhCLENBSEY7S0FGQTtBQU1BLElBQUEsSUFBRyxZQUFIO0FBQ0UsYUFBTyxDQUFDLEdBQUEsR0FBTSxVQUFQLENBQUEsR0FBcUIsTUFBNUIsQ0FERjtLQUFBLE1BQUE7QUFHRSxhQUFPLE1BQVAsQ0FIRjtLQVBpQjtFQUFBLENBakduQixDQUFBOztBQUFBLDRCQTZHQSxpQkFBQSxHQUFtQixTQUFDLE1BQUQsRUFBUyxZQUFULEdBQUE7QUFDakIsUUFBQSxTQUFBOztNQUQwQixlQUFlO0tBQ3pDO0FBQUEsSUFBQSxJQUFBLENBQUEsWUFBQTtBQUNFLE1BQUEsTUFBQSxHQUFTLE1BQUEsR0FBUyxJQUFDLENBQUEsR0FBRyxDQUFDLFdBQUwsQ0FBQSxDQUFsQixDQURGO0tBQUE7V0FFQSxTQUFBLEdBQVksSUFBSSxDQUFDLElBQUwsQ0FBVSxNQUFBLEdBQVMsRUFBbkIsRUFISztFQUFBLENBN0duQixDQUFBOztBQUFBLDRCQWtIQSxZQUFBLEdBQWMsU0FBQyxNQUFELEVBQVMsWUFBVCxHQUFBO0FBQ1osUUFBQSxJQUFBOztNQURxQixlQUFlO0tBQ3BDO0FBQUEsSUFBQSxJQUFBLENBQUEsWUFBQTtBQUNFLE1BQUEsTUFBQSxHQUFTLE1BQUEsR0FBUyxJQUFDLENBQUEsQ0FBbkIsQ0FERjtLQUFBO1dBRUEsSUFBQSxHQUFPLElBQUksQ0FBQyxLQUFMLENBQVcsSUFBQyxDQUFBLGFBQUQsQ0FBQSxDQUFBLEdBQW1CLE1BQTlCLEVBSEs7RUFBQSxDQWxIZCxDQUFBOztBQUFBLDRCQXVIQSxZQUFBLEdBQWMsU0FBQSxHQUFBLENBdkhkLENBQUE7O0FBQUEsNEJBMEhBLFFBQUEsR0FBVSxTQUFBLEdBQUE7QUFDUixRQUFBLDZIQUFBO0FBQUEsSUFBQSxJQUFBLEdBQU8sSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsTUFBWCxDQUFBLElBQXNCLENBQTdCLENBQUE7QUFBQSxJQUNBLGNBQUEsR0FBaUIsSUFBQyxDQUFBLEVBQUUsQ0FBQyxDQUFKLENBQU0sV0FBTixDQURqQixDQUFBO0FBQUEsSUFFQSxDQUFBLEdBQUksSUFBQyxDQUFBLENBQUQsR0FBSyxjQUFjLENBQUMsS0FBZixDQUFBLENBQUEsR0FBeUIsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsTUFBWCxDQUF6QixHQUE4QyxHQUZ2RCxDQUFBO0FBQUEsSUFHQSxDQUFBLEdBQUksR0FISixDQUFBO0FBQUEsSUFJQSxJQUFDLENBQUEsR0FBRyxDQUFDLEtBQUwsQ0FBVyxDQUFYLENBSkEsQ0FBQTtBQUFBLElBS0EsSUFBQyxDQUFBLEdBQUcsQ0FBQyxNQUFMLENBQVksQ0FBWixDQUxBLENBQUE7QUFBQSxJQU1BLEdBQUEsR0FBTSxRQUFBLENBQVMsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsS0FBWCxDQUFULEVBQTRCLEVBQTVCLENBTk4sQ0FBQTtBQUFBLElBT0EsSUFBQSxHQUFPLFFBQUEsQ0FBUyxJQUFDLENBQUEsS0FBSyxDQUFDLEdBQVAsQ0FBVyxNQUFYLENBQVQsRUFBNkIsRUFBN0IsQ0FQUCxDQUFBO0FBQUEsSUFRQSxVQUFBLEdBQWEsSUFBQSxHQUFPLEdBUnBCLENBQUE7QUFBQSxJQVNBLFNBQUEsR0FBWSxDQUFBLEdBQUksVUFUaEIsQ0FBQTtBQUFBLElBVUEsV0FBQSxHQUFjLENBVmQsQ0FBQTtBQUFBLElBV0EsR0FBQSxHQUFNLElBQUksQ0FBQyxJQUFMLENBQVUsVUFBQSxHQUFhLEdBQXZCLENBWE4sQ0FBQTtBQVlBLFNBQWtELDRGQUFsRCxHQUFBO0FBQUEsTUFBQSxDQUFDLElBQUEsSUFBUSxDQUFBLElBQUEsR0FBTyxFQUFQLENBQVQsQ0FBbUIsQ0FBQyxJQUFwQixDQUEwQixDQUFBLEdBQUksR0FBSixJQUFXLENBQXJDLENBQUEsQ0FBQTtBQUFBLEtBWkE7QUFBQSxJQWFBLElBQUMsQ0FBQSxLQUFELEdBQVMsS0FBSyxDQUFDLEtBQU4sQ0FBWSxJQUFDLENBQUEsT0FBTyxDQUFDLEdBQVQsQ0FBYSxDQUFiLENBQVosQ0FiVCxDQUFBO0FBQUEsSUFjQSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFaLEdBQTJCLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxJQUFQLENBQVksQ0FBWixFQUFlLENBQWYsQ0FkM0IsQ0FBQTtBQUFBLElBZUEsSUFBQSxHQUFXLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxJQUFQLENBQUEsQ0FmWCxDQUFBO0FBZ0JBLFdBQU0sV0FBQSxJQUFlLFVBQXJCLEdBQUE7QUFDRSxNQUFBLENBQUEsR0FBSSxXQUFBLEdBQWMsU0FBbEIsQ0FBQTtBQUFBLE1BQ0EsSUFBQSxHQUFXLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxJQUFQLENBQUEsQ0FEWCxDQUFBO0FBQUEsTUFFQSxJQUFJLENBQUMsV0FBTCxHQUFtQixDQUZuQixDQUFBO0FBQUEsTUFHQSxJQUFJLENBQUMsV0FBTCxHQUFzQixlQUFlLElBQWYsRUFBQSxXQUFBLE1BQUgsR0FBNEIsTUFBNUIsR0FBd0MsTUFIM0QsQ0FBQTtBQUFBLE1BSUEsSUFBSSxDQUFDLE1BQUwsQ0FBZ0IsSUFBQSxJQUFDLENBQUEsS0FBSyxDQUFDLEtBQVAsQ0FBYSxDQUFBLEdBQUksR0FBakIsRUFBc0IsQ0FBdEIsQ0FBaEIsQ0FKQSxDQUFBO0FBQUEsTUFLQSxJQUFJLENBQUMsTUFBTCxDQUFnQixJQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsS0FBUCxDQUFhLENBQUEsR0FBSSxHQUFqQixFQUFzQixDQUF0QixDQUFoQixDQUxBLENBQUE7QUFBQSxNQU1BLFdBQUEsRUFOQSxDQURGO0lBQUEsQ0FoQkE7QUFBQSxJQXdCQSxVQUFBLEdBQWEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxDQUFKLENBQU0sT0FBTixDQUFjLENBQUMsRUFBZixDQUFrQixDQUFsQixDQUFvQixDQUFDLFdBQXJCLENBQUEsQ0F4QmIsQ0FBQTtBQXlCQSxTQUFTLDhCQUFULEdBQUE7QUFDRSxNQUFBLENBQUEsR0FBSSxDQUFKLENBQUE7QUFBQSxNQUNBLENBQUEsR0FBSSxDQUFBLEdBQUksVUFEUixDQUFBO0FBQUEsTUFFQSxJQUFBLEdBQVcsSUFBQSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQVAsQ0FBQSxDQUZYLENBQUE7QUFBQSxNQUdBLElBQUksQ0FBQyxXQUFMLEdBQW1CLEdBSG5CLENBQUE7QUFBQSxNQUlBLElBQUksQ0FBQyxXQUFMLEdBQW1CLE1BSm5CLENBQUE7QUFBQSxNQUtBLElBQUksQ0FBQyxNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsQ0FMQSxDQUFBO0FBQUEsTUFNQSxJQUFJLENBQUMsTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLENBTkEsQ0FERjtBQUFBLEtBekJBO0FBQUEsSUFpQ0EsSUFBQyxDQUFBLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBWixDQUFBLENBakNBLENBQUE7QUFBQSxJQWtDQSxJQUFDLENBQUEsR0FBRyxDQUFDLElBQUwsQ0FBVSxVQUFWLENBQXFCLENBQUMsTUFBdEIsQ0FBQSxDQWxDQSxDQUFBO1dBbUNBLElBQUMsQ0FBQSxZQUFELENBQUEsRUFwQ1E7RUFBQSxDQTFIVixDQUFBOztBQUFBLDRCQWdLQSxNQUFBLEdBQVEsU0FBQSxHQUFBO0FBQ04sSUFBQSxJQUFDLENBQUEsR0FBRyxDQUFDLEtBQUwsQ0FBQSxDQUFBLENBQUE7QUFBQSxJQUVBLElBQUMsQ0FBQSxPQUFELEdBQVcsQ0FBQSxDQUFFLFVBQUYsQ0FBYSxDQUFDLFFBQWQsQ0FBdUIsSUFBQyxDQUFBLEdBQXhCLENBRlgsQ0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLFNBQUQsR0FBYSxDQUFBLENBQUUsd0JBQUYsQ0FBMkIsQ0FBQyxRQUE1QixDQUFxQyxJQUFDLENBQUEsR0FBdEMsQ0FIYixDQUFBO1dBSUEsSUFBQyxDQUFBLFFBQUQsQ0FBQSxFQUxNO0VBQUEsQ0FoS1IsQ0FBQTs7eUJBQUE7O0dBRjRCLFFBQVEsQ0FBQyxLQVR2QyxDQUFBOztBQUFBLE1Ba0xNLENBQUMsT0FBUCxHQUFpQixlQWxMakIsQ0FBQTs7OztBQ0FBLElBQUEsb0ZBQUE7RUFBQTtpU0FBQTs7QUFBQSxRQUFBLEdBQXdCLE9BQUEsQ0FBUSxVQUFSLENBQXhCLENBQUE7O0FBQUEsUUFDUSxDQUFDLENBQVQsR0FBd0IsQ0FBQSxHQUFJLE9BQUEsQ0FBUSxRQUFSLENBRDVCLENBQUE7O0FBQUEsUUFFUSxDQUFDLFdBQVQsR0FBd0IsT0FBQSxDQUFRLGlCQUFSLENBQTBCLENBQUMsV0FGbkQsQ0FBQTs7QUFBQSxRQUdBLEdBQXdCLE9BQUEsQ0FBUSxvQkFBUixDQUh4QixDQUFBOztBQUFBLENBSUEsR0FBd0IsT0FBQSxDQUFRLFlBQVIsQ0FKeEIsQ0FBQTs7QUFBQSxpQkFLQSxHQUF3QixPQUFBLENBQVEsd0JBQVIsQ0FMeEIsQ0FBQTs7QUFBQSxTQU1BLEdBQXdCLE9BQUEsQ0FBUSxhQUFSLENBTnhCLENBQUE7O0FBQUEsYUFPQSxHQUF3QixTQVB4QixDQUFBOztBQUFBO0FBV0Msa0NBQUEsQ0FBQTs7OztHQUFBOztBQUFBLDBCQUFBLEVBQUEsR0FBSSxVQUFKLENBQUE7O0FBQUEsMEJBRUEsVUFBQSxHQUFZLFNBQUMsT0FBRCxHQUFBOztNQUFDLFVBQVU7S0FDdEI7QUFBQSxJQUFFLElBQUMsQ0FBQSxNQUFRLFFBQVIsR0FBSCxDQUFBO0FBQUEsSUFFQSxDQUFDLENBQUMsT0FBRixDQUFVLElBQVYsRUFBZ0IsZ0JBQWhCLEVBQWtDLGVBQWxDLENBRkEsQ0FBQTtBQUFBLElBSUEsSUFBQyxDQUFBLE9BQUQsR0FBVyxHQUFBLENBQUEsQ0FBSyxRQUFRLENBQUMsV0FBVyxDQUFDLE1BQXJCLENBQTRCLEVBQTVCLENBQUQsQ0FKZixDQUFBO0FBQUEsSUFNQSxJQUFDLENBQUEsUUFBRCxHQUFnQixJQUFBLFFBQUEsQ0FDZjtBQUFBLE1BQUEsS0FBQSxFQUFPLElBQUMsQ0FBQSxPQUFSO0FBQUEsTUFDQSxJQUFBLEVBQU0sSUFETjtBQUFBLE1BRUEsUUFBQSxFQUNDO0FBQUEsUUFBQSxjQUFBLEVBQWdCO0FBQUEsVUFBQyxJQUFBLEVBQU0sQ0FBQyxVQUFELEVBQWEsRUFBYixDQUFQO1NBQWhCO0FBQUEsUUFDQSxhQUFBLEVBQWU7QUFBQSxVQUFDLElBQUEsRUFBTSxDQUFDLFFBQUQsRUFBVyxFQUFYLENBQVA7U0FEZjtBQUFBLFFBRUEsY0FBQSxFQUFnQjtBQUFBLFVBQUMsSUFBQSxFQUFNLENBQUMsUUFBRCxFQUFXLEVBQVgsQ0FBUDtTQUZoQjtPQUhEO0tBRGUsQ0FOaEIsQ0FBQTtBQUFBLElBY0EsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFDLENBQUEsT0FBWCxFQUFvQixnQkFBcEIsRUFBc0MsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsS0FBRCxFQUFRLE9BQVIsR0FBQTtlQUNyQyxLQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBckIsQ0FBeUIsT0FBekIsRUFEcUM7TUFBQSxFQUFBO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUF0QyxDQWRBLENBQUE7QUFBQSxJQWlCQSxJQUFDLENBQUEsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFmLENBQWtCLE1BQWxCLEVBQTBCLElBQUMsQ0FBQSxjQUEzQixDQWpCQSxDQUFBO1dBbUJBLElBQUMsQ0FBQSxXQUFELEdBQWUsV0FBQSxDQUFZLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFBLEdBQUE7QUFDMUIsUUFBQSxZQUFBLENBQWEsS0FBQyxDQUFBLFdBQWQsQ0FBQSxDQUFBO0FBQ0EsUUFBQSxJQUFHLEtBQUMsQ0FBQSxHQUFHLENBQUMsSUFBUjtpQkFDQyxLQUFDLENBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFWLENBQWEsT0FBYixFQUFzQixLQUFDLENBQUEsYUFBdkIsRUFERDtTQUYwQjtNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQVosRUFJYixHQUphLEVBcEJKO0VBQUEsQ0FGWixDQUFBOztBQUFBLDBCQTRCQSxNQUFBLEdBR0M7QUFBQSxJQUFBLHVCQUFBLEVBQWtDLGtCQUFsQztHQS9CRCxDQUFBOztBQUFBLDBCQWlDQSxnQkFBQSxHQUFrQixTQUFDLENBQUQsR0FBQTtBQUNqQixRQUFBLHdCQUFBO0FBQUEsSUFBQSxRQUFBLEdBQVcsQ0FBQSxDQUFFLENBQUMsQ0FBQyxNQUFKLENBQVcsQ0FBQyxJQUFaLENBQWlCLFVBQWpCLENBQVgsQ0FBQTtBQUNBLElBQUEsSUFBRyxRQUFBLElBQVksQ0FBQyxRQUFBLEdBQVcsSUFBRSxDQUFBLFFBQUEsQ0FBZCxDQUFmO0FBQ0MsTUFBQSxJQUFBLEdBQU8sQ0FBQSxDQUFFLENBQUMsQ0FBQyxNQUFKLENBQVcsQ0FBQyxJQUFaLENBQWlCLE1BQWpCLENBQVAsQ0FBQTthQUNBLFFBQVEsQ0FBQyxJQUFULENBQWMsSUFBZCxFQUFpQixDQUFqQixFQUFvQixJQUFwQixFQUZEO0tBRmlCO0VBQUEsQ0FqQ2xCLENBQUE7O0FBdUNBO0FBQUE7OztLQXZDQTs7QUFBQSwwQkEyQ0EsY0FBQSxHQUFnQixTQUFDLElBQUQsR0FBQTtBQUNmLFFBQUEsZ0JBQUE7QUFBQSxJQUFBLFNBQUEsT0FBUyxJQUFDLENBQUEsR0FBRyxDQUFDLFNBQVMsQ0FBQyxPQUFmLENBQUEsRUFBVCxDQUFBO0FBQUEsSUFFQSxnQkFBQSxHQUFtQixJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGlCQUExQixDQUE0QyxJQUE1QyxFQUFrRCxJQUFsRCxDQUZuQixDQUFBO0FBQUEsSUFHQSxJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFwQyxDQUF3QztBQUFBLE1BQUEsSUFBQSxFQUFNLEVBQUEsR0FBRSxnQkFBRixHQUFvQixHQUExQjtLQUF4QyxDQUhBLENBQUE7QUFBQSxJQUtBLElBQUMsQ0FBQSxPQUFELENBQVMsTUFBVCxFQUFpQixJQUFqQixDQUxBLENBQUE7V0FNQSxpQkFQZTtFQUFBLENBM0NoQixDQUFBOztBQXFEQTtBQUFBOzs7S0FyREE7O0FBQUEsMEJBeURBLG1CQUFBLEdBQXFCLFNBQUMsQ0FBRCxHQUFBO1dBQ3BCLEtBRG9CO0VBQUEsQ0F6RHJCLENBQUE7O0FBNERBO0FBQUE7OztLQTVEQTs7QUFBQSwwQkFnRUEsc0JBQUEsR0FBd0IsU0FBQyxDQUFELEdBQUE7V0FDdkIsS0FEdUI7RUFBQSxDQWhFeEIsQ0FBQTs7QUFvRUE7QUFBQTs7O0tBcEVBOztBQUFBLDBCQXdFQSxhQUFBLEdBQWUsU0FBQyxHQUFELEdBQUE7QUFDZCxRQUFBLGNBQUE7QUFBQSxJQUFBLElBQUcsSUFBQyxDQUFBLEdBQUcsQ0FBQyxTQUFTLENBQUMsVUFBbEI7QUFDQyxNQUFBLGNBQUEsR0FBaUIsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxpQkFBMUIsQ0FBQSxDQUFqQixDQUFBO2FBQ0EsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUExQixDQUFxQyxHQUFHLENBQUMsTUFBekMsRUFBaUQsY0FBakQsRUFGRDtLQURjO0VBQUEsQ0F4RWYsQ0FBQTs7QUFBQSwwQkE2RUEsMEJBQUEsR0FBNEIsU0FBQyxhQUFELEdBQUE7V0FDM0IsSUFBQyxDQUFBLENBQUQsQ0FBRyxpQ0FBSCxDQUNDLENBQUMsV0FERixDQUNjLFFBRGQsQ0FFQyxDQUFDLE1BRkYsQ0FFVSxlQUFBLEdBQWMsYUFBZCxHQUE2QixLQUZ2QyxDQUdDLENBQUMsUUFIRixDQUdXLFFBSFgsRUFEMkI7RUFBQSxDQTdFNUIsQ0FBQTs7QUFBQSwwQkFtRkEsYUFBQSxHQUFlLFNBQUMsQ0FBRCxFQUFJLE1BQUosR0FBQTtXQUNkLElBQUMsQ0FBQSxjQUFELENBQWdCLE1BQWhCLEVBRGM7RUFBQSxDQW5GZixDQUFBOztBQUFBLDBCQXNGQSxnQkFBQSxHQUFrQixTQUFDLEdBQUQsR0FBQTtXQUNqQixJQUFDLENBQUEsY0FBRCxDQUFnQixJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQTVCLENBQStCLENBQS9CLENBQWlDLENBQUMsR0FBbEMsQ0FBc0MsVUFBdEMsQ0FBaEIsRUFEaUI7RUFBQSxDQXRGbEIsQ0FBQTs7QUFBQSwwQkF5RkEsY0FBQSxHQUFnQixTQUFDLGFBQUQsR0FBQTtBQUNmLFFBQUEsSUFBQTtBQUFBLElBQUEsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxTQUE1QixDQUFzQztBQUFBLE1BQUEsUUFBQSxFQUFVLGFBQVY7S0FBdEMsQ0FBQSxJQUFrRSxJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEdBQTVCLENBQWdDO0FBQUEsTUFBQSxRQUFBLEVBQVUsYUFBVjtLQUFoQyxDQUFsRSxDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFiLEdBQXVCLElBQUMsQ0FBQSxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsU0FBNUIsQ0FBc0M7QUFBQSxNQUFBLFFBQUEsRUFBVSxhQUFWO0tBQXRDLENBRHZCLENBQUE7QUFBQSxJQUVBLElBQUMsQ0FBQSxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxpQkFBbkIsR0FBdUMsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FGcEQsQ0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLDBCQUFELENBQTRCLGFBQTVCLENBSEEsQ0FBQTtBQUFBLElBSUEsSUFBQyxDQUFBLENBQUQsQ0FBRyxPQUFILENBQVcsQ0FBQyxJQUFaLENBQUEsQ0FKQSxDQUFBO0FBQUEsSUFLQSxJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUE5QixDQUFBLENBTEEsQ0FBQTtBQUFBLElBTUEsSUFBQyxDQUFBLE9BQU8sQ0FBQyxHQUFULENBQWEsY0FBYixFQUE2QixJQUFDLENBQUEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBckIsQ0FBeUIsTUFBekIsQ0FBN0IsQ0FOQSxDQUFBO0FBQUEsSUFRQSxJQUFBLEdBQU8sSUFBQyxDQUFBLGNBQUQsQ0FBQSxDQVJQLENBQUE7QUFBQSxJQVVBLElBQUMsQ0FBQSxDQUFELENBQUcsV0FBSCxDQUFlLENBQUMsSUFBaEIsQ0FBcUIsWUFBckIsRUFBbUMsQ0FBQyxJQUFBLEdBQU8sRUFBUixDQUFBLEdBQWMsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBOUIsQ0FBQSxDQUFqRCxDQVZBLENBQUE7V0FXQSxJQUFDLENBQUEsT0FBRCxDQUFTLGVBQVQsRUFBMEIsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBdkMsRUFaZTtFQUFBLENBekZoQixDQUFBOzt1QkFBQTs7R0FGMkIsUUFBUSxDQUFDLEtBVHJDLENBQUE7O0FBQUEsTUFrSE0sQ0FBQyxPQUFQLEdBQWlCLGFBbEhqQixDQUFBOzs7O0FDQUEsSUFBQSxrR0FBQTtFQUFBO2lTQUFBOztBQUFBLFFBQUEsR0FBZ0IsT0FBQSxDQUFRLFVBQVIsQ0FBaEIsQ0FBQTs7QUFBQSxRQUNRLENBQUMsQ0FBVCxHQUFpQixDQUFBLEdBQUksT0FBQSxDQUFRLFFBQVIsQ0FEckIsQ0FBQTs7QUFBQSxDQUVBLEdBQVksT0FBQSxDQUFRLFlBQVIsQ0FGWixDQUFBOztBQUFBLGdCQUdBLEdBQW9CLE9BQUEsQ0FBUSwyQkFBUixDQUhwQixDQUFBOztBQUFBLGtCQUtBLEdBQXlCLGlCQUx6QixDQUFBOztBQUFBLGdCQU1BLEdBQXVCLFdBTnZCLENBQUE7O0FBQUEsWUFPQSxHQUFxQixNQVByQixDQUFBOztBQUFBO0FBV0MsaUNBQUEsQ0FBQTs7OztHQUFBOztBQUFBLHlCQUFBLFFBQUEsR0FBVSxnQkFBVixDQUFBOztBQUFBLHlCQUVBLEVBQUEsR0FBSSxXQUZKLENBQUE7O0FBQUEseUJBSUEsVUFBQSxHQUFZLFNBQUMsT0FBRCxHQUFBO0FBQ1gsSUFBRSxJQUFDLENBQUEsTUFBUSxRQUFSLEdBQUgsQ0FBQTtXQUNBLElBQUMsQ0FBQSxhQUFELENBQUEsRUFGVztFQUFBLENBSlosQ0FBQTs7QUFBQSx5QkFRQSxhQUFBLEdBQWUsU0FBQSxHQUFBO0FBQ2QsUUFBQSw2QkFBQTtBQUFBLElBQUEsTUFBQSxHQUFTLENBQVQsQ0FBQTtBQUFBLElBQ0EsSUFBQSxHQUFPLEVBRFAsQ0FBQTtBQUVBLFdBQU0sTUFBQSxHQUFTLEVBQWYsR0FBQTtBQUNDLE1BQUEsR0FBQSxHQUFNLENBQU4sQ0FBQTtBQUFBLE1BQ0EsSUFBSyxDQUFBLE1BQUEsQ0FBTCxHQUFlLENBQUEsQ0FBRyxlQUFBLEdBQWMsZ0JBQWQsR0FBZ0MsS0FBbkMsQ0FEZixDQUFBO0FBQUEsTUFFQSxJQUFBLEdBQU8sRUFGUCxDQUFBO0FBR0EsYUFBTSxHQUFBLEdBQU0sQ0FBWixHQUFBO0FBQ0MsUUFBQSxJQUFHLE1BQUEsS0FBVSxDQUFiO0FBQ0MsVUFBQSxJQUFBLEdBQVEsZUFBQSxHQUFjLFlBQWQsR0FBNEIsV0FBNUIsR0FBc0MsQ0FBQSxHQUFBLEdBQU0sQ0FBTixDQUF0QyxHQUErQyxRQUF2RCxDQUREO1NBQUEsTUFBQTtBQUdDLFVBQUEsSUFBQSxHQUFRLGVBQUEsR0FBYyxZQUFkLEdBQTRCLGlCQUFwQyxDQUhEO1NBQUE7QUFBQSxRQUlBLElBQUksQ0FBQyxJQUFMLENBQVUsQ0FBQSxDQUFFLElBQUYsQ0FBVixDQUpBLENBQUE7QUFBQSxRQUtBLEdBQUEsRUFMQSxDQUREO01BQUEsQ0FIQTtBQUFBLE1BVUEsSUFBSyxDQUFBLE1BQUEsQ0FBTyxDQUFDLE1BQWIsQ0FBb0IsSUFBcEIsQ0FWQSxDQUFBO0FBQUEsTUFXQSxNQUFBLEVBWEEsQ0FERDtJQUFBLENBRkE7V0FlQSxJQUFDLENBQUEsR0FBRyxDQUFDLE1BQUwsQ0FBWSxJQUFaLEVBaEJjO0VBQUEsQ0FSZixDQUFBOztzQkFBQTs7R0FGMEIsUUFBUSxDQUFDLEtBVHBDLENBQUE7O0FBQUEsTUFxQ00sQ0FBQyxPQUFQLEdBQWlCLFlBckNqQixDQUFBOzs7O0FDQUEsSUFBQSxnRUFBQTtFQUFBO2lTQUFBOztBQUFBLFFBQUEsR0FBc0IsT0FBQSxDQUFRLFVBQVIsQ0FBdEIsQ0FBQTs7QUFBQSxRQUNRLENBQUMsQ0FBVCxHQUFzQixDQUFBLEdBQUksT0FBQSxDQUFRLFFBQVIsQ0FEMUIsQ0FBQTs7QUFBQSxDQUVBLEdBQXNCLE9BQUEsQ0FBUSxZQUFSLENBRnRCLENBQUE7O0FBQUEsY0FHQSxHQUFzQixPQUFBLENBQVEscUJBQVIsQ0FIdEIsQ0FBQTs7QUFBQSxpQkFJQSxHQUFzQixPQUFBLENBQVEsNEJBQVIsQ0FKdEIsQ0FBQTs7QUFBQTtBQVFFLGtDQUFBLENBQUE7Ozs7R0FBQTs7QUFBQSwwQkFBQSxFQUFBLEdBQUksWUFBSixDQUFBOztBQUFBLDBCQUVBLFFBQUEsR0FBVSxpQkFGVixDQUFBOztBQUFBLDBCQUlBLFVBQUEsR0FBWSxTQUFDLE9BQUQsR0FBQTs7TUFBQyxVQUFVO0tBQ3JCO0FBQUEsSUFBRSxJQUFDLENBQUEsTUFBUSxRQUFSLEdBQUgsQ0FBQTtBQUFBLElBRUEsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxJQUFWLEVBQWEsUUFBYixFQUF1QixPQUF2QixFQUFnQyxPQUFoQyxFQUF5QyxhQUF6QyxDQUZBLENBQUE7QUFBQSxJQUdBLElBQUMsQ0FBQSxLQUFELEdBQWEsSUFBQSxjQUFBLENBQWU7QUFBQSxNQUFBLEdBQUEsRUFBSyxFQUFMO0FBQUEsTUFBUyxJQUFBLEVBQU0sRUFBZjtLQUFmLENBSGIsQ0FBQTtBQUFBLElBSUEsSUFBQyxDQUFBLFlBQUQsR0FBa0IsSUFBQyxDQUFBLFlBQUQsR0FBa0IsQ0FKcEMsQ0FBQTtBQUFBLElBS0EsSUFBQyxDQUFBLFFBQUQsR0FBa0IsSUFBQyxDQUFBLFVBQUQsR0FBa0IsS0FMcEMsQ0FBQTtXQU1BLElBQUMsQ0FBQSxNQUFELENBQUEsRUFQVTtFQUFBLENBSlosQ0FBQTs7QUFBQSwwQkFhQSxNQUFBLEdBQ0U7QUFBQSxJQUFBLHVCQUFBLEVBQThCLGdCQUE5QjtHQWRGLENBQUE7O0FBQUEsMEJBZ0JBLE1BQUEsR0FBUSxTQUFBLEdBQUE7V0FDTixJQUFDLENBQUEsRUFBRSxDQUFDLFNBQUosR0FBZ0IsSUFBQyxDQUFBLFFBQUQsQ0FBQSxFQURWO0VBQUEsQ0FoQlIsQ0FBQTs7QUFBQSwwQkFtQkEsY0FBQSxHQUFnQixTQUFDLENBQUQsR0FBQTtBQUNkLFFBQUEsUUFBQTtBQUFBLElBQUEsUUFBQSxHQUFXLENBQUEsQ0FBRSxDQUFDLENBQUMsYUFBSixDQUFrQixDQUFDLElBQW5CLENBQXdCLFVBQXhCLENBQVgsQ0FBQTtBQUNBLElBQUEsSUFBRyxJQUFLLENBQUEsUUFBQSxDQUFSO0FBQ0UsTUFBQSxDQUFDLENBQUMsY0FBRixDQUFBLENBQUEsQ0FBQTthQUNBLElBQUssQ0FBQSxRQUFBLENBQVMsQ0FBQyxJQUFmLENBQW9CLElBQXBCLEVBQTBCLENBQTFCLEVBRkY7S0FGYztFQUFBLENBbkJoQixDQUFBOztBQUFBLDBCQXlCQSxJQUFBLEdBQU0sU0FBQyxDQUFELEdBQUE7QUFDSixJQUFBLElBQUMsQ0FBQSxLQUFELENBQUEsQ0FBQSxDQUFBO1dBQ0EsSUFBQyxDQUFBLENBQUQsQ0FBRyxrREFBSCxDQUFzRCxDQUFDLFdBQXZELENBQW1FLFFBQW5FLEVBRkk7RUFBQSxDQXpCTixDQUFBOztBQTZCQTtBQUFBOztLQTdCQTs7QUFBQSwwQkFnQ0EsSUFBQSxHQUFNLFNBQUMsQ0FBRCxHQUFBO0FBQ0osSUFBQSxJQUFHLElBQUMsQ0FBQSxRQUFKO2FBQWtCLElBQUMsQ0FBQSxLQUFELENBQUEsRUFBbEI7S0FBQSxNQUFBO2FBQWdDLElBQUMsQ0FBQSxNQUFELENBQUEsRUFBaEM7S0FESTtFQUFBLENBaENOLENBQUE7O0FBbUNBO0FBQUE7OztLQW5DQTs7QUFBQSwwQkF1Q0EsTUFBQSxHQUFRLFNBQUMsQ0FBRCxHQUFBO0FBQ04sSUFBQSxJQUFHLENBQUEsSUFBSyxDQUFBLFFBQVI7QUFBc0IsTUFBQSxJQUFDLENBQUEsTUFBRCxDQUFBLENBQUEsQ0FBdEI7S0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLFVBQUQsR0FBYyxDQUFBLElBQUUsQ0FBQSxVQURoQixDQUFBO1dBRUEsSUFBQyxDQUFBLENBQUQsQ0FBRywwQkFBSCxDQUE4QixDQUFDLFdBQS9CLENBQTJDLFFBQTNDLEVBSE07RUFBQSxDQXZDUixDQUFBOztBQTRDQTtBQUFBOztLQTVDQTs7QUFBQSwwQkErQ0EsT0FBQSxHQUFTLFNBQUMsQ0FBRCxHQUFBO1dBQ1AsSUFBQyxDQUFBLE9BQUQsQ0FBUyxDQUFULEVBRE87RUFBQSxDQS9DVCxDQUFBOztBQUFBLDBCQW1EQSxHQUFBLEdBQUssU0FBQyxDQUFELEdBQUE7QUFDSCxhQURHO0VBQUEsQ0FuREwsQ0FBQTs7QUFzREE7QUFBQTs7S0F0REE7O0FBQUEsMEJBeURBLE1BQUEsR0FBUSxTQUFBLEdBQUE7QUFDTixJQUFBLElBQUMsQ0FBQSxRQUFELEdBQVksSUFBWixDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsS0FBRCxHQUFTLFdBQUEsQ0FBWSxJQUFDLENBQUEsS0FBYixFQUFvQixRQUFBLENBQVMsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsVUFBWCxDQUFULEVBQWlDLEVBQWpDLENBQXBCLENBRFQsQ0FBQTtXQUVBLElBQUMsQ0FBQSxDQUFELENBQUcsd0JBQUgsQ0FBNEIsQ0FBQyxRQUE3QixDQUFzQyxRQUF0QyxFQUhNO0VBQUEsQ0F6RFIsQ0FBQTs7QUE4REE7QUFBQTs7S0E5REE7O0FBQUEsMEJBaUVBLEtBQUEsR0FBTyxTQUFBLEdBQUE7QUFDTCxJQUFBLGFBQUEsQ0FBYyxJQUFDLENBQUEsS0FBZixDQUFBLENBQUE7QUFBQSxJQUNBLElBQUMsQ0FBQSxVQUFELEdBQWMsS0FEZCxDQUFBO0FBQUEsSUFFQSxJQUFDLENBQUEsUUFBRCxHQUFZLEtBRlosQ0FBQTtXQUdBLElBQUMsQ0FBQSxDQUFELENBQUcsa0RBQUgsQ0FBc0QsQ0FBQyxXQUF2RCxDQUFtRSxRQUFuRSxFQUpLO0VBQUEsQ0FqRVAsQ0FBQTs7QUFBQSwwQkF3RkEsS0FBQSxHQUFPLFNBQUEsR0FBQTtXQUNMLElBQUMsQ0FBQSxPQUFELENBQVMsSUFBQyxDQUFBLFlBQUQsR0FBZ0IsQ0FBekIsRUFESztFQUFBLENBeEZQLENBQUE7O0FBQUEsMEJBMkZBLE9BQUEsR0FBUyxTQUFBLEdBQUE7V0FDUCxJQUFDLENBQUEsYUFETTtFQUFBLENBM0ZULENBQUE7O0FBQUEsMEJBOEZBLE9BQUEsR0FBUyxTQUFDLGFBQUQsR0FBQTtBQUNQLFFBQUEsZUFBQTs7TUFEUSxnQkFBZ0I7S0FDeEI7QUFBQSxJQUFBLElBQUcsQ0FBQSxhQUFIO2FBQ0UsSUFBQyxDQUFBLGFBREg7S0FBQSxNQUFBO0FBR0UsTUFBQSxJQUFBLEdBQU8sQ0FBQyxFQUFBLEdBQUcsQ0FBQyxJQUFDLENBQUEsWUFBRCxHQUFnQixJQUFoQixHQUF1QixHQUF4QixDQUFKLENBQWlDLENBQUMsS0FBbEMsQ0FBd0MsR0FBeEMsQ0FBNkMsQ0FBQSxDQUFBLENBQXBELENBQUE7QUFBQSxNQUNBLFNBQUEsR0FBWSxFQURaLENBQUE7QUFFQSxhQUFNLElBQUksQ0FBQyxNQUFMLEdBQWMsQ0FBcEIsR0FBQTtBQUNFLFFBQUEsSUFBQSxHQUFPLEdBQUEsR0FBSSxJQUFYLENBREY7TUFBQSxDQUZBO0FBQUEsTUFJQSxJQUFBLEdBQU8sSUFBSSxDQUFDLEtBQUwsQ0FBVyxFQUFYLENBSlAsQ0FBQTtBQUtBLGFBQU0sSUFBTixHQUFBO0FBQ0UsUUFBQSxTQUFBLElBQWEsSUFBSSxDQUFDLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZixDQUFpQixDQUFDLElBQWxCLENBQXVCLEVBQXZCLENBQWIsQ0FBQTtBQUNBLFFBQUEsSUFBRyxJQUFJLENBQUMsTUFBTCxJQUFlLENBQWxCO0FBQ0UsVUFBQSxTQUFBLElBQWEsR0FBYixDQURGO1NBREE7QUFHQSxRQUFBLElBQVMsQ0FBQSxJQUFRLENBQUMsTUFBbEI7QUFBQSxnQkFBQTtTQUpGO01BQUEsQ0FMQTtBQVVBLGFBQU8sU0FBUCxDQWJGO0tBRE87RUFBQSxDQTlGVCxDQUFBOztBQThHQTtBQUFBOzs7S0E5R0E7O0FBQUEsMEJBa0hBLE9BQUEsR0FBUyxTQUFDLEtBQUQsR0FBQTtBQUNQLElBQUEsSUFBQyxDQUFBLE9BQUQsQ0FBUyxNQUFULEVBQWlCLEtBQWpCLENBQUEsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLFlBQUQsR0FBZ0IsS0FEaEIsQ0FBQTtBQUFBLElBRUEsSUFBQyxDQUFBLFlBQUQsR0FBZ0IsS0FBQSxHQUFRLFFBQUEsQ0FBUyxJQUFDLENBQUEsS0FBSyxDQUFDLEdBQVAsQ0FBVyxVQUFYLENBQVQsRUFBaUMsRUFBakMsQ0FGeEIsQ0FBQTtXQUdBLElBQUMsQ0FBQSxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFuQixDQUF1QixNQUF2QixFQUErQixJQUFDLENBQUEsT0FBRCxDQUFTLElBQVQsQ0FBL0IsRUFKTztFQUFBLENBbEhULENBQUE7O0FBd0hBO0FBQUE7OztLQXhIQTs7QUFBQSwwQkE0SEEsT0FBQSxHQUFTLFNBQUMsS0FBRCxHQUFBO0FBQ1AsSUFBQSxJQUFDLENBQUEsWUFBRCxHQUFnQixLQUFoQixDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsWUFBRCxHQUFnQixLQUFBLEdBQVEsSUFBQyxDQUFBLEtBQUssQ0FBQyxHQUFQLENBQVcsVUFBWCxDQUR4QixDQUFBO1dBRUEsSUFBQyxDQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQW5CLENBQXVCLE1BQXZCLEVBQStCLElBQUMsQ0FBQSxPQUFELENBQVMsSUFBVCxDQUEvQixFQUhPO0VBQUEsQ0E1SFQsQ0FBQTs7QUFpSUE7QUFBQTs7S0FqSUE7O0FBQUEsMEJBb0lBLFdBQUEsR0FBYSxTQUFDLEtBQUQsRUFBUSxPQUFSLEdBQUE7QUFDWCxJQUFBLElBQUcsT0FBTyxDQUFDLEdBQVg7QUFDRSxNQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsR0FBUCxDQUFXLFVBQVgsRUFBdUIsSUFBQyxDQUFBLGlCQUFELENBQW1CLE9BQU8sQ0FBQyxHQUEzQixDQUF2QixDQUFBLENBREY7S0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLEtBQUQsQ0FBQSxDQUhBLENBQUE7V0FJQSxJQUFDLENBQUEsTUFBRCxDQUFBLEVBTFc7RUFBQSxDQXBJYixDQUFBOzt1QkFBQTs7R0FGMEIsUUFBUSxDQUFDLEtBTnJDLENBQUE7O0FBQUEsTUFtSk0sQ0FBQyxPQUFQLEdBQWlCLGFBbkpqQixDQUFBOzs7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyohXG4gKiBQYXBlci5qcyB2MC45LjE4IC0gVGhlIFN3aXNzIEFybXkgS25pZmUgb2YgVmVjdG9yIEdyYXBoaWNzIFNjcmlwdGluZy5cbiAqIGh0dHA6Ly9wYXBlcmpzLm9yZy9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgLSAyMDE0LCBKdWVyZyBMZWhuaSAmIEpvbmF0aGFuIFB1Y2tleVxuICogaHR0cDovL3NjcmF0Y2hkaXNrLmNvbS8gJiBodHRwOi8vam9uYXRoYW5wdWNrZXkuY29tL1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbiAqXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIERhdGU6IE1vbiBBcHIgNyAxMToyNDozOCAyMDE0ICswMjAwXG4gKlxuICoqKlxuICpcbiAqIFN0cmFwcy5qcyAtIENsYXNzIGluaGVyaXRhbmNlIGxpYnJhcnkgd2l0aCBzdXBwb3J0IGZvciBiZWFuLXN0eWxlIGFjY2Vzc29yc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAwNiAtIDIwMTMgSnVlcmcgTGVobmlcbiAqIGh0dHA6Ly9zY3JhdGNoZGlzay5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqKipcbiAqXG4gKiBBY29ybi5qc1xuICogaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9hY29ybi9cbiAqXG4gKiBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LFxuICogY3JlYXRlZCBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbiAqXG4gKi9cblxudmFyIHBhcGVyID0gbmV3IGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG52YXIgQmFzZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGhpZGRlbiA9IC9eKHN0YXRpY3N8ZW51bWVyYWJsZXxiZWFuc3xwcmVzZXJ2ZSkkLyxcblxuXHRcdGZvckVhY2ggPSBbXS5mb3JFYWNoIHx8IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0Zm9ySW4gPSBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIHRoaXMpXG5cdFx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbihwcm90bykge1xuXHRcdFx0cmV0dXJuIHsgX19wcm90b19fOiBwcm90byB9O1xuXHRcdH0sXG5cblx0XHRkZXNjcmliZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgfHwgZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG5cdFx0XHR2YXIgZ2V0ID0gb2JqLl9fbG9va3VwR2V0dGVyX18gJiYgb2JqLl9fbG9va3VwR2V0dGVyX18obmFtZSk7XG5cdFx0XHRyZXR1cm4gZ2V0XG5cdFx0XHRcdFx0PyB7IGdldDogZ2V0LCBzZXQ6IG9iai5fX2xvb2t1cFNldHRlcl9fKG5hbWUpLFxuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH1cblx0XHRcdFx0XHQ6IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuXHRcdFx0XHRcdFx0PyB7IHZhbHVlOiBvYmpbbmFtZV0sIGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdH0sXG5cblx0XHRfZGVmaW5lID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uKG9iaiwgbmFtZSwgZGVzYykge1xuXHRcdFx0aWYgKChkZXNjLmdldCB8fCBkZXNjLnNldCkgJiYgb2JqLl9fZGVmaW5lR2V0dGVyX18pIHtcblx0XHRcdFx0aWYgKGRlc2MuZ2V0KVxuXHRcdFx0XHRcdG9iai5fX2RlZmluZUdldHRlcl9fKG5hbWUsIGRlc2MuZ2V0KTtcblx0XHRcdFx0aWYgKGRlc2Muc2V0KVxuXHRcdFx0XHRcdG9iai5fX2RlZmluZVNldHRlcl9fKG5hbWUsIGRlc2Muc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9ialtuYW1lXSA9IGRlc2MudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHRkZWZpbmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIGRlc2MpIHtcblx0XHRcdGRlbGV0ZSBvYmpbbmFtZV07XG5cdFx0XHRyZXR1cm4gX2RlZmluZShvYmosIG5hbWUsIGRlc2MpO1xuXHRcdH07XG5cblx0ZnVuY3Rpb24gaW5qZWN0KGRlc3QsIHNyYywgZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKSB7XG5cdFx0dmFyIGJlYW5zTmFtZXMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGZpZWxkKG5hbWUsIHZhbCkge1xuXHRcdFx0dmFsID0gdmFsIHx8ICh2YWwgPSBkZXNjcmliZShzcmMsIG5hbWUpKVxuXHRcdFx0XHRcdCYmICh2YWwuZ2V0ID8gdmFsIDogdmFsLnZhbHVlKTtcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWxbMF0gPT09ICcjJylcblx0XHRcdFx0dmFsID0gZGVzdFt2YWwuc3Vic3RyaW5nKDEpXSB8fCB2YWw7XG5cdFx0XHR2YXIgaXNGdW5jID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcblx0XHRcdFx0cmVzID0gdmFsLFxuXHRcdFx0XHRwcmV2ID0gcHJlc2VydmUgfHwgaXNGdW5jXG5cdFx0XHRcdFx0XHQ/ICh2YWwgJiYgdmFsLmdldCA/IG5hbWUgaW4gZGVzdCA6IGRlc3RbbmFtZV0pXG5cdFx0XHRcdFx0XHQ6IG51bGwsXG5cdFx0XHRcdGJlYW47XG5cdFx0XHRpZiAoIXByZXNlcnZlIHx8ICFwcmV2KSB7XG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgcHJldilcblx0XHRcdFx0XHR2YWwuYmFzZSA9IHByZXY7XG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgYmVhbnMgIT09IGZhbHNlXG5cdFx0XHRcdFx0XHQmJiAoYmVhbiA9IG5hbWUubWF0Y2goL14oW2dzXWV0fGlzKSgoW0EtWl0pKC4qKSkkLykpKVxuXHRcdFx0XHRcdGJlYW5zTmFtZXNbYmVhblszXS50b0xvd2VyQ2FzZSgpICsgYmVhbls0XV0gPSBiZWFuWzJdO1xuXHRcdFx0XHRpZiAoIXJlcyB8fCBpc0Z1bmMgfHwgIXJlcy5nZXQgfHwgdHlwZW9mIHJlcy5nZXQgIT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHRcdHx8ICFCYXNlLmlzUGxhaW5PYmplY3QocmVzKSlcblx0XHRcdFx0XHRyZXMgPSB7IHZhbHVlOiByZXMsIHdyaXRhYmxlOiB0cnVlIH07XG5cdFx0XHRcdGlmICgoZGVzY3JpYmUoZGVzdCwgbmFtZSlcblx0XHRcdFx0XHRcdHx8IHsgY29uZmlndXJhYmxlOiB0cnVlIH0pLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRcdHJlcy5jb25maWd1cmFibGUgPSB0cnVlO1xuXHRcdFx0XHRcdHJlcy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZpbmUoZGVzdCwgbmFtZSwgcmVzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBzcmMpIHtcblx0XHRcdFx0aWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhaGlkZGVuLnRlc3QobmFtZSkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIGJlYW5zTmFtZXMpIHtcblx0XHRcdFx0dmFyIHBhcnQgPSBiZWFuc05hbWVzW25hbWVdLFxuXHRcdFx0XHRcdHNldCA9IGRlc3RbJ3NldCcgKyBwYXJ0XSxcblx0XHRcdFx0XHRnZXQgPSBkZXN0WydnZXQnICsgcGFydF0gfHwgc2V0ICYmIGRlc3RbJ2lzJyArIHBhcnRdO1xuXHRcdFx0XHRpZiAoZ2V0ICYmIChiZWFucyA9PT0gdHJ1ZSB8fCBnZXQubGVuZ3RoID09PSAwKSlcblx0XHRcdFx0XHRmaWVsZChuYW1lLCB7IGdldDogZ2V0LCBzZXQ6IHNldCB9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGRlc3Q7XG5cdH1cblxuXHRmdW5jdGlvbiBlYWNoKG9iaiwgaXRlciwgYmluZCkge1xuXHRcdGlmIChvYmopXG5cdFx0XHQoJ2xlbmd0aCcgaW4gb2JqICYmICFvYmouZ2V0TGVuZ3RoXG5cdFx0XHRcdFx0JiYgdHlwZW9mIG9iai5sZW5ndGggPT09ICdudW1iZXInXG5cdFx0XHRcdD8gZm9yRWFjaFxuXHRcdFx0XHQ6IGZvckluKS5jYWxsKG9iaiwgaXRlciwgYmluZCA9IGJpbmQgfHwgb2JqKTtcblx0XHRyZXR1cm4gYmluZDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldChvYmosIHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiBwcm9wcylcblx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShpKSlcblx0XHRcdFx0b2JqW2ldID0gcHJvcHNbaV07XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cdHJldHVybiBpbmplY3QoZnVuY3Rpb24gQmFzZSgpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZXQodGhpcywgYXJndW1lbnRzW2ldKTtcblx0fSwge1xuXHRcdGluamVjdDogZnVuY3Rpb24oc3JjKSB7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdHZhciBzdGF0aWNzID0gc3JjLnN0YXRpY3MgPT09IHRydWUgPyBzcmMgOiBzcmMuc3RhdGljcyxcblx0XHRcdFx0XHRiZWFucyA9IHNyYy5iZWFucyxcblx0XHRcdFx0XHRwcmVzZXJ2ZSA9IHNyYy5wcmVzZXJ2ZTtcblx0XHRcdFx0aWYgKHN0YXRpY3MgIT09IHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcy5wcm90b3R5cGUsIHNyYywgc3JjLmVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHRcdGluamVjdCh0aGlzLCBzdGF0aWNzLCB0cnVlLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLmluamVjdChhcmd1bWVudHNbaV0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYmFzZSA9IHRoaXMsXG5cdFx0XHRcdGN0b3I7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGlmIChjdG9yID0gYXJndW1lbnRzW2ldLmluaXRpYWxpemUpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjdG9yID0gY3RvciB8fCBmdW5jdGlvbigpIHtcblx0XHRcdFx0YmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHRcdGN0b3IucHJvdG90eXBlID0gY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcblx0XHRcdGN0b3IuYmFzZSA9IGJhc2U7XG5cdFx0XHRkZWZpbmUoY3Rvci5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsXG5cdFx0XHRcdFx0eyB2YWx1ZTogY3Rvciwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0XHRcdGluamVjdChjdG9yLCB0aGlzLCB0cnVlKTtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5pbmplY3QuYXBwbHkoY3RvciwgYXJndW1lbnRzKSA6IGN0b3I7XG5cdFx0fVxuXHR9LCB0cnVlKS5pbmplY3Qoe1xuXHRcdGluamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0aWYgKHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcywgc3JjLCBzcmMuZW51bWVyYWJsZSwgc3JjLmJlYW5zLCBzcmMucHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVzID0gY3JlYXRlKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHJlcy5pbmplY3QuYXBwbHkocmVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRlYWNoOiBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRyZXR1cm4gZWFjaCh0aGlzLCBpdGVyLCBiaW5kKTtcblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRlYWNoOiBlYWNoLFxuXHRcdFx0Y3JlYXRlOiBjcmVhdGUsXG5cdFx0XHRkZWZpbmU6IGRlZmluZSxcblx0XHRcdGRlc2NyaWJlOiBkZXNjcmliZSxcblx0XHRcdHNldDogc2V0LFxuXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHJldHVybiBzZXQobmV3IG9iai5jb25zdHJ1Y3RvcigpLCBvYmopO1xuXHRcdFx0fSxcblxuXHRcdFx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHZhciBjdG9yID0gb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gY3RvciAmJiAoY3RvciA9PT0gT2JqZWN0IHx8IGN0b3IgPT09IEJhc2Vcblx0XHRcdFx0XHRcdHx8IGN0b3IubmFtZSA9PT0gJ09iamVjdCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0cGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRpZiAoYXJndW1lbnRzW2ldICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRyZXR1cm4gYXJndW1lbnRzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuaWYgKCFBcnJheS5pc0FycmF5KSB7XG5cdEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG59XG5cbmlmICghZG9jdW1lbnQuaGVhZCkge1xuXHRkb2N1bWVudC5oZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbn1cblxuQmFzZS5pbmplY3Qoe1xuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkICE9IG51bGxcblx0XHRcdD8gICh0aGlzLl9jbGFzcyB8fCAnT2JqZWN0JykgKyAodGhpcy5fbmFtZVxuXHRcdFx0XHQ/IFwiICdcIiArIHRoaXMuX25hbWUgKyBcIidcIlxuXHRcdFx0XHQ6ICcgQCcgKyB0aGlzLl9pZClcblx0XHRcdDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICghL15fLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArICh0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0XHQ/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZycgPyBcIidcIiArIHZhbHVlICsgXCInXCIgOiB2YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSkuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLmV4cG9ydEpTT04odGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcyk7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24ocHJvcHMsIGV4Y2x1ZGUpIHtcblx0XHRpZiAocHJvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSkge1xuXHRcdFx0dmFyIG9yaWcgPSBwcm9wcy5fZmlsdGVyaW5nIHx8IHByb3BzO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG9yaWcpIHtcblx0XHRcdFx0aWYgKGtleSBpbiB0aGlzICYmIG9yaWcuaGFzT3duUHJvcGVydHkoa2V5KVxuXHRcdFx0XHRcdFx0JiYgKCFleGNsdWRlIHx8ICFleGNsdWRlW2tleV0pKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcHJvcHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXG5cdFx0ZXhwb3J0czoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSBcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdFx0XHR2YXIgcmVzID0gZXh0ZW5kLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcblx0XHRcdFx0bmFtZSA9IHJlcy5wcm90b3R5cGUuX2NsYXNzO1xuXHRcdFx0aWYgKG5hbWUgJiYgIUJhc2UuZXhwb3J0c1tuYW1lXSlcblx0XHRcdFx0QmFzZS5leHBvcnRzW25hbWVdID0gcmVzO1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbihvYmoxLCBvYmoyKSB7XG5cdFx0XHRmdW5jdGlvbiBjaGVja0tleXMobzEsIG8yKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgaW4gbzEpXG5cdFx0XHRcdFx0aWYgKG8xLmhhc093blByb3BlcnR5KGkpICYmICFvMi5oYXNPd25Qcm9wZXJ0eShpKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAob2JqMSA9PT0gb2JqMilcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRpZiAob2JqMSAmJiBvYmoxLmVxdWFscylcblx0XHRcdFx0cmV0dXJuIG9iajEuZXF1YWxzKG9iajIpO1xuXHRcdFx0aWYgKG9iajIgJiYgb2JqMi5lcXVhbHMpXG5cdFx0XHRcdHJldHVybiBvYmoyLmVxdWFscyhvYmoxKTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9iajEpICYmIEFycmF5LmlzQXJyYXkob2JqMikpIHtcblx0XHRcdFx0aWYgKG9iajEubGVuZ3RoICE9PSBvYmoyLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gb2JqMS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoIUJhc2UuZXF1YWxzKG9iajFbaV0sIG9iajJbaV0pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9iajEgJiYgdHlwZW9mIG9iajEgPT09ICdvYmplY3QnXG5cdFx0XHRcdFx0JiYgb2JqMiAmJiB0eXBlb2Ygb2JqMiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKCFjaGVja0tleXMob2JqMSwgb2JqMikgfHwgIWNoZWNrS2V5cyhvYmoyLCBvYmoxKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGZvciAodmFyIGkgaW4gb2JqMSkge1xuXHRcdFx0XHRcdGlmIChvYmoxLmhhc093blByb3BlcnR5KGkpXG5cdFx0XHRcdFx0XHRcdCYmICFCYXNlLmVxdWFscyhvYmoxW2ldLCBvYmoyW2ldKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0cmVhZDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCkge1xuXHRcdFx0aWYgKHRoaXMgPT09IEJhc2UpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5wZWVrKGxpc3QsIHN0YXJ0KTtcblx0XHRcdFx0bGlzdC5fX2luZGV4Kys7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlLFxuXHRcdFx0XHRyZWFkSW5kZXggPSBwcm90by5fcmVhZEluZGV4LFxuXHRcdFx0XHRpbmRleCA9IHN0YXJ0IHx8IHJlYWRJbmRleCAmJiBsaXN0Ll9faW5kZXggfHwgMDtcblx0XHRcdGlmICghbGVuZ3RoKVxuXHRcdFx0XHRsZW5ndGggPSBsaXN0Lmxlbmd0aCAtIGluZGV4O1xuXHRcdFx0dmFyIG9iaiA9IGxpc3RbaW5kZXhdO1xuXHRcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIHRoaXNcblx0XHRcdFx0fHwgb3B0aW9ucyAmJiBvcHRpb25zLnJlYWROdWxsICYmIG9iaiA9PSBudWxsICYmIGxlbmd0aCA8PSAxKSB7XG5cdFx0XHRcdGlmIChyZWFkSW5kZXgpXG5cdFx0XHRcdFx0bGlzdC5fX2luZGV4ID0gaW5kZXggKyAxO1xuXHRcdFx0XHRyZXR1cm4gb2JqICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5jbG9uZSA/IG9iai5jbG9uZSgpIDogb2JqO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gQmFzZS5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0b2JqLl9fcmVhZCA9IHRydWU7XG5cdFx0XHRvYmogPSBvYmouaW5pdGlhbGl6ZS5hcHBseShvYmosIGluZGV4ID4gMCB8fCBsZW5ndGggPCBsaXN0Lmxlbmd0aFxuXHRcdFx0XHQ/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGluZGV4LCBpbmRleCArIGxlbmd0aClcblx0XHRcdFx0OiBsaXN0KSB8fCBvYmo7XG5cdFx0XHRpZiAocmVhZEluZGV4KSB7XG5cdFx0XHRcdGxpc3QuX19pbmRleCA9IGluZGV4ICsgb2JqLl9fcmVhZDtcblx0XHRcdFx0b2JqLl9fcmVhZCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdHBlZWs6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0KSB7XG5cdFx0XHRyZXR1cm4gbGlzdFtsaXN0Ll9faW5kZXggPSBzdGFydCB8fCBsaXN0Ll9faW5kZXggfHwgMF07XG5cdFx0fSxcblxuXHRcdHJlbWFpbjogZnVuY3Rpb24obGlzdCkge1xuXHRcdFx0cmV0dXJuIGxpc3QubGVuZ3RoIC0gKGxpc3QuX19pbmRleCB8fCAwKTtcblx0XHR9LFxuXG5cdFx0cmVhZEFsbDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciByZXMgPSBbXSxcblx0XHRcdFx0ZW50cnk7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQgfHwgMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHJlcy5wdXNoKEFycmF5LmlzQXJyYXkoZW50cnkgPSBsaXN0W2ldKVxuXHRcdFx0XHRcdFx0PyB0aGlzLnJlYWQoZW50cnksIDAsIG9wdGlvbnMpXG5cdFx0XHRcdFx0XHQ6IHRoaXMucmVhZChsaXN0LCBpLCBvcHRpb25zLCAxKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRyZWFkTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUsIHN0YXJ0LCBvcHRpb25zLCBsZW5ndGgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSksXG5cdFx0XHRcdGhhc09iamVjdCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG5cdFx0XHRpZiAoaGFzT2JqZWN0KSB7XG5cdFx0XHRcdHZhciBmaWx0ZXJlZCA9IGxpc3QuX2ZpbHRlcmVkO1xuXHRcdFx0XHRpZiAoIWZpbHRlcmVkKSB7XG5cdFx0XHRcdFx0ZmlsdGVyZWQgPSBsaXN0Ll9maWx0ZXJlZCA9IEJhc2UuY3JlYXRlKGxpc3RbMF0pO1xuXHRcdFx0XHRcdGZpbHRlcmVkLl9maWx0ZXJpbmcgPSBsaXN0WzBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpbHRlcmVkW25hbWVdID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmVhZChoYXNPYmplY3QgPyBbdmFsdWVdIDogbGlzdCwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCk7XG5cdFx0fSxcblxuXHRcdGdldE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lKSB7XG5cdFx0XHR2YXIgYXJnID0gbGlzdFswXTtcblx0XHRcdGlmIChsaXN0Ll9oYXNPYmplY3QgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0bGlzdC5faGFzT2JqZWN0ID0gbGlzdC5sZW5ndGggPT09IDEgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZyk7XG5cdFx0XHRpZiAobGlzdC5faGFzT2JqZWN0KVxuXHRcdFx0XHRyZXR1cm4gbmFtZSA/IGFyZ1tuYW1lXSA6IGxpc3QuX2ZpbHRlcmVkIHx8IGFyZztcblx0XHR9LFxuXG5cdFx0aGFzTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRcdHJldHVybiAhIXRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdGlzUGxhaW5WYWx1ZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopO1xuXHRcdH0sXG5cblx0XHRzZXJpYWxpemU6IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucywgY29tcGFjdCwgZGljdGlvbmFyeSkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRcdHZhciByb290ID0gIWRpY3Rpb25hcnksXG5cdFx0XHRcdHJlcztcblx0XHRcdGlmIChyb290KSB7XG5cdFx0XHRcdG9wdGlvbnMuZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0XHRcdGRpY3Rpb25hcnkgPSB7XG5cdFx0XHRcdFx0bGVuZ3RoOiAwLFxuXHRcdFx0XHRcdGRlZmluaXRpb25zOiB7fSxcblx0XHRcdFx0XHRyZWZlcmVuY2VzOiB7fSxcblx0XHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKGl0ZW0sIGNyZWF0ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGlkID0gJyMnICsgaXRlbS5faWQsXG5cdFx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF07XG5cdFx0XHRcdFx0XHRpZiAoIXJlZikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdFx0XHRcdFx0XHR2YXIgcmVzID0gY3JlYXRlLmNhbGwoaXRlbSksXG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGl0ZW0uX2NsYXNzO1xuXHRcdFx0XHRcdFx0XHRpZiAobmFtZSAmJiByZXNbMF0gIT09IG5hbWUpXG5cdFx0XHRcdFx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVmaW5pdGlvbnNbaWRdID0gcmVzO1xuXHRcdFx0XHRcdFx0XHRyZWYgPSB0aGlzLnJlZmVyZW5jZXNbaWRdID0gW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9iaiAmJiBvYmouX3NlcmlhbGl6ZSkge1xuXHRcdFx0XHRyZXMgPSBvYmouX3NlcmlhbGl6ZShvcHRpb25zLCBkaWN0aW9uYXJ5KTtcblx0XHRcdFx0dmFyIG5hbWUgPSBvYmouX2NsYXNzO1xuXHRcdFx0XHRpZiAobmFtZSAmJiAhY29tcGFjdCAmJiAhcmVzLl9jb21wYWN0ICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVzW2ldID0gQmFzZS5zZXJpYWxpemUob2JqW2ldLCBvcHRpb25zLCBjb21wYWN0LFxuXHRcdFx0XHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0XHRcdFx0aWYgKGNvbXBhY3QpXG5cdFx0XHRcdFx0cmVzLl9jb21wYWN0ID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KG9iaikpIHtcblx0XHRcdFx0cmVzID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkgaW4gb2JqKVxuXHRcdFx0XHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpXG5cdFx0XHRcdFx0XHRyZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsXG5cdFx0XHRcdFx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJlcyA9IG9wdGlvbnMuZm9ybWF0dGVyLm51bWJlcihvYmosIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlcyA9IG9iajtcblx0XHRcdH1cblx0XHRcdHJldHVybiByb290ICYmIGRpY3Rpb25hcnkubGVuZ3RoID4gMFxuXHRcdFx0XHRcdD8gW1snZGljdGlvbmFyeScsIGRpY3Rpb25hcnkuZGVmaW5pdGlvbnNdLCByZXNdXG5cdFx0XHRcdFx0OiByZXM7XG5cdFx0fSxcblxuXHRcdGRlc2VyaWFsaXplOiBmdW5jdGlvbihqc29uLCBjcmVhdGUsIF9kYXRhKSB7XG5cdFx0XHR2YXIgcmVzID0ganNvbixcblx0XHRcdFx0aXNSb290ID0gIV9kYXRhO1xuXHRcdFx0X2RhdGEgPSBfZGF0YSB8fCB7fTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG5cdFx0XHRcdHZhciB0eXBlID0ganNvblswXSxcblx0XHRcdFx0XHRpc0RpY3Rpb25hcnkgPSB0eXBlID09PSAnZGljdGlvbmFyeSc7XG5cdFx0XHRcdGlmICghaXNEaWN0aW9uYXJ5KSB7XG5cdFx0XHRcdFx0aWYgKF9kYXRhLmRpY3Rpb25hcnkgJiYganNvbi5sZW5ndGggPT0gMSAmJiAvXiMvLnRlc3QodHlwZSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gX2RhdGEuZGljdGlvbmFyeVt0eXBlXTtcblx0XHRcdFx0XHR0eXBlID0gQmFzZS5leHBvcnRzW3R5cGVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gdHlwZSA/IDEgOiAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVzLnB1c2goQmFzZS5kZXNlcmlhbGl6ZShqc29uW2ldLCBjcmVhdGUsIF9kYXRhKSk7XG5cdFx0XHRcdGlmIChpc0RpY3Rpb25hcnkpIHtcblx0XHRcdFx0XHRfZGF0YS5kaWN0aW9uYXJ5ID0gcmVzWzBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUpIHtcblx0XHRcdFx0XHR2YXIgYXJncyA9IHJlcztcblx0XHRcdFx0XHRpZiAoY3JlYXRlKSB7XG5cdFx0XHRcdFx0XHRyZXMgPSBjcmVhdGUodHlwZSwgYXJncywgaXNSb290KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzID0gQmFzZS5jcmVhdGUodHlwZS5wcm90b3R5cGUpO1xuXHRcdFx0XHRcdFx0dHlwZS5hcHBseShyZXMsIGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoanNvbikpIHtcblx0XHRcdFx0cmVzID0ge307XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBqc29uKVxuXHRcdFx0XHRcdHJlc1trZXldID0gQmFzZS5kZXNlcmlhbGl6ZShqc29uW2tleV0sIGNyZWF0ZSwgX2RhdGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXG5cdFx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIganNvbiA9IEJhc2Uuc2VyaWFsaXplKG9iaiwgb3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmFzU3RyaW5nID09PSBmYWxzZVxuXHRcdFx0XHRcdD8ganNvblxuXHRcdFx0XHRcdDogSlNPTi5zdHJpbmdpZnkoanNvbik7XG5cdFx0fSxcblxuXHRcdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24sIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIEJhc2UuZGVzZXJpYWxpemUoXG5cdFx0XHRcdFx0dHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb24sXG5cdFx0XHRcdFx0ZnVuY3Rpb24odHlwZSwgYXJncywgaXNSb290KSB7XG5cdFx0XHRcdFx0XHR2YXIgb2JqID0gdGFyZ2V0ICYmIHRhcmdldC5jb25zdHJ1Y3RvciA9PT0gdHlwZVxuXHRcdFx0XHRcdFx0XHRcdD8gdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0OiBCYXNlLmNyZWF0ZSh0eXBlLnByb3RvdHlwZSksXG5cdFx0XHRcdFx0XHRcdGlzVGFyZ2V0ID0gb2JqID09PSB0YXJnZXQ7XG5cdFx0XHRcdFx0XHRpZiAoIWlzUm9vdCAmJiBhcmdzLmxlbmd0aCA9PT0gMSAmJiBvYmogaW5zdGFuY2VvZiBJdGVtXG5cdFx0XHRcdFx0XHRcdFx0JiYgKCEob2JqIGluc3RhbmNlb2YgTGF5ZXIpIHx8IGlzVGFyZ2V0KSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXJnID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKVxuXHRcdFx0XHRcdFx0XHRcdGFyZy5pbnNlcnQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR5cGUuYXBwbHkob2JqLCBhcmdzKTtcblx0XHRcdFx0XHRcdGlmIChpc1RhcmdldClcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHNwbGljZTogZnVuY3Rpb24obGlzdCwgaXRlbXMsIGluZGV4LCByZW1vdmUpIHtcblx0XHRcdHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG5cdFx0XHRcdGFwcGVuZCA9IGluZGV4ID09PSB1bmRlZmluZWQ7XG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IGxpc3QubGVuZ3RoIDogaW5kZXg7XG5cdFx0XHRpZiAoaW5kZXggPiBsaXN0Lmxlbmd0aClcblx0XHRcdFx0aW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG5cdFx0XHRcdGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdFx0bGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBbaW5kZXgsIHJlbW92ZV07XG5cdFx0XHRcdGlmIChpdGVtcylcblx0XHRcdFx0XHRhcmdzLnB1c2guYXBwbHkoYXJncywgaXRlbXMpO1xuXHRcdFx0XHR2YXIgcmVtb3ZlZCA9IGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHJlbW92ZWRbaV0uX2luZGV4ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRsaXN0W2ldLl9pbmRleCA9IGk7XG5cdFx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvXFxiW2Etel0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Y2FtZWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKGFsbCwgY2hyKSB7XG5cdFx0XHRcdHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRoeXBoZW5hdGU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBDYWxsYmFjayA9IHtcblx0YXR0YWNoOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0QmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0dGhpcy5hdHRhY2goa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGVudHJ5ID0gdGhpcy5fZXZlbnRUeXBlc1t0eXBlXTtcblx0XHRpZiAoZW50cnkpIHtcblx0XHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMgfHwge307XG5cdFx0XHRoYW5kbGVycyA9IGhhbmRsZXJzW3R5cGVdID0gaGFuZGxlcnNbdHlwZV0gfHwgW107XG5cdFx0XHRpZiAoaGFuZGxlcnMuaW5kZXhPZihmdW5jKSA9PSAtMSkgeyBcblx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jKTtcblx0XHRcdFx0aWYgKGVudHJ5Lmluc3RhbGwgJiYgaGFuZGxlcnMubGVuZ3RoID09IDEpXG5cdFx0XHRcdFx0ZW50cnkuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRkZXRhY2g6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLmRldGFjaChrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZW50cnkgPSB0aGlzLl9ldmVudFR5cGVzW3R5cGVdLFxuXHRcdFx0aGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVycyAmJiB0aGlzLl9oYW5kbGVyc1t0eXBlXSxcblx0XHRcdGluZGV4O1xuXHRcdGlmIChlbnRyeSAmJiBoYW5kbGVycykge1xuXHRcdFx0aWYgKCFmdW5jIHx8IChpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYykpICE9IC0xXG5cdFx0XHRcdFx0JiYgaGFuZGxlcnMubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0aWYgKGVudHJ5LnVuaW5zdGFsbClcblx0XHRcdFx0XHRlbnRyeS51bmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2hhbmRsZXJzW3R5cGVdO1xuXHRcdFx0fSBlbHNlIGlmIChpbmRleCAhPSAtMSkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRvbmNlOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0dGhpcy5hdHRhY2godHlwZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLmRldGFjaCh0eXBlLCBmdW5jKTtcblx0XHR9KTtcblx0fSxcblxuXHRmaXJlOiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzICYmIHRoaXMuX2hhbmRsZXJzW3R5cGVdO1xuXHRcdGlmICghaGFuZGxlcnMpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG5cdFx0XHR0aGF0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGhhbmRsZXJzW2ldLmFwcGx5KHRoYXQsIGFyZ3MpID09PSBmYWxzZVxuXHRcdFx0XHRcdCYmIGV2ZW50ICYmIGV2ZW50LnN0b3ApIHtcblx0XHRcdFx0ZXZlbnQuc3RvcCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0cmVzcG9uZHM6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRyZXR1cm4gISEodGhpcy5faGFuZGxlcnMgJiYgdGhpcy5faGFuZGxlcnNbdHlwZV0pO1xuXHR9LFxuXG5cdG9uOiAnI2F0dGFjaCcsXG5cdG9mZjogJyNkZXRhY2gnLFxuXHR0cmlnZ2VyOiAnI2ZpcmUnLFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbihpbnN0YWxsKSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMsXG5cdFx0XHRrZXkgPSBpbnN0YWxsID8gJ2luc3RhbGwnIDogJ3VuaW5zdGFsbCc7XG5cdFx0Zm9yICh2YXIgdHlwZSBpbiBoYW5kbGVycykge1xuXHRcdFx0aWYgKGhhbmRsZXJzW3R5cGVdLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5fZXZlbnRUeXBlc1t0eXBlXSxcblx0XHRcdFx0XHRmdW5jID0gZW50cnlba2V5XTtcblx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbiBpbmplY3QoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHNyYyA9IGFyZ3VtZW50c1tpXSxcblx0XHRcdFx0XHRldmVudHMgPSBzcmMuX2V2ZW50cztcblx0XHRcdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0XHRcdHZhciB0eXBlcyA9IHt9O1xuXHRcdFx0XHRcdEJhc2UuZWFjaChldmVudHMsIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0XHRcdFx0XHRcdHZhciBpc1N0cmluZyA9IHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycsXG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBpc1N0cmluZyA/IGVudHJ5IDoga2V5LFxuXHRcdFx0XHRcdFx0XHRwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0XHRcdFx0XHR0eXBlID0gbmFtZS5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHR5cGVzW3R5cGVdID0gaXNTdHJpbmcgPyB7fSA6IGVudHJ5O1xuXHRcdFx0XHRcdFx0bmFtZSA9ICdfJyArIG5hbWU7XG5cdFx0XHRcdFx0XHRzcmNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRzcmNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKGZ1bmMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHByZXYgPSB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdFx0XHRpZiAocHJldilcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRldGFjaCh0eXBlLCBwcmV2KTtcblx0XHRcdFx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRhY2godHlwZSwgZnVuYyk7XG5cdFx0XHRcdFx0XHRcdHRoaXNbbmFtZV0gPSBmdW5jO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzcmMuX2V2ZW50VHlwZXMgPSB0eXBlcztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmplY3QuYmFzZS5jYWxsKHRoaXMsIHNyYyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH1cbn07XG5cbnZhciBQYXBlclNjb3BlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXBlclNjb3BlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXBlclNjb3BlKHNjcmlwdCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnNldHRpbmdzID0ge1xuXHRcdFx0YXBwbHlNYXRyaXg6IHRydWUsXG5cdFx0XHRoYW5kbGVTaXplOiA0LFxuXHRcdFx0aGl0VG9sZXJhbmNlOiAwXG5cdFx0fTtcblx0XHR0aGlzLnByb2plY3QgPSBudWxsO1xuXHRcdHRoaXMucHJvamVjdHMgPSBbXTtcblx0XHR0aGlzLnRvb2xzID0gW107XG5cdFx0dGhpcy5wYWxldHRlcyA9IFtdO1xuXHRcdHRoaXMuX2lkID0gc2NyaXB0ICYmIChzY3JpcHQuZ2V0QXR0cmlidXRlKCdpZCcpIHx8IHNjcmlwdC5zcmMpXG5cdFx0XHRcdHx8ICgncGFwZXJzY29wZS0nICsgKFBhcGVyU2NvcGUuX2lkKyspKTtcblx0XHRpZiAoc2NyaXB0KVxuXHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLl9pZCk7XG5cdFx0UGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0aWYgKCF0aGlzLnN1cHBvcnQpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRcdFx0UGFwZXJTY29wZS5wcm90b3R5cGUuc3VwcG9ydCA9IHtcblx0XHRcdFx0bmF0aXZlRGFzaDogJ3NldExpbmVEYXNoJyBpbiBjdHggfHwgJ21vekRhc2gnIGluIGN0eCxcblx0XHRcdFx0bmF0aXZlQmxlbmRNb2RlczogQmxlbmRNb2RlLm5hdGl2ZU1vZGVzXG5cdFx0XHR9O1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdH1cblx0fSxcblxuXHR2ZXJzaW9uOiAnMC45LjE4JyxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0ICYmIHRoaXMucHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0Z2V0UGFwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGV4ZWN1dGU6IGZ1bmN0aW9uKGNvZGUpIHtcblx0XHRwYXBlci5QYXBlclNjcmlwdC5leGVjdXRlKGNvZGUsIHRoaXMpO1xuXHRcdFZpZXcudXBkYXRlRm9jdXMoKTtcblx0fSxcblxuXHRpbnN0YWxsOiBmdW5jdGlvbihzY29wZSkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRCYXNlLmVhY2goWydwcm9qZWN0JywgJ3ZpZXcnLCAndG9vbCddLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdEJhc2UuZGVmaW5lKHNjb3BlLCBrZXksIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGF0W2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzKVxuXHRcdFx0aWYgKCEvXl8vLnRlc3Qoa2V5KSAmJiB0aGlzW2tleV0pXG5cdFx0XHRcdHNjb3BlW2tleV0gPSB0aGlzW2tleV07XG5cdH0sXG5cblx0c2V0dXA6IGZ1bmN0aW9uKGNhbnZhcykge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnByb2plY3QgPSBuZXcgUHJvamVjdChjYW52YXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnByb2plY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5wcm9qZWN0c1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy50b29scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMudG9vbHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMucGFsZXR0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnBhbGV0dGVzW2ldLnJlbW92ZSgpO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jbGVhcigpO1xuXHRcdGRlbGV0ZSBQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdO1xuXHR9LFxuXG5cdHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGUobmFtZSkge1xuXHRcdFx0bmFtZSArPSAnQXR0cmlidXRlJztcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbCwgYXR0cikge1xuXHRcdFx0XHRyZXR1cm4gZWxbbmFtZV0oYXR0cikgfHwgZWxbbmFtZV0oJ2RhdGEtcGFwZXItJyArIGF0dHIpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0X3Njb3Blczoge30sXG5cdFx0XHRfaWQ6IDAsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0aWYgKGlkICYmIGlkLmdldEF0dHJpYnV0ZSlcblx0XHRcdFx0XHRpZCA9IGlkLmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Njb3Blc1tpZF0gfHwgbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdGdldEF0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdnZXQnKSxcblx0XHRcdGhhc0F0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdoYXMnKVxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgUGFwZXJTY29wZUl0ZW0gPSBCYXNlLmV4dGVuZChDYWxsYmFjaywge1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGFjdGl2YXRlKSB7XG5cdFx0dGhpcy5fc2NvcGUgPSBwYXBlcjtcblx0XHR0aGlzLl9pbmRleCA9IHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLnB1c2godGhpcykgLSAxO1xuXHRcdGlmIChhY3RpdmF0ZSB8fCAhdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSlcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9zY29wZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgcHJldiA9IHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV07XG5cdFx0aWYgKHByZXYgJiYgcHJldiAhPT0gdGhpcylcblx0XHRcdHByZXYuZmlyZSgnZGVhY3RpdmF0ZScpO1xuXHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSB0aGlzO1xuXHRcdHRoaXMuZmlyZSgnYWN0aXZhdGUnLCBwcmV2KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0FjdGl2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT09IHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5faW5kZXggPT0gbnVsbClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRCYXNlLnNwbGljZSh0aGlzLl9zY29wZVt0aGlzLl9saXN0XSwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdGlmICh0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09IHRoaXMpXG5cdFx0XHR0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gbnVsbDtcblx0XHR0aGlzLl9zY29wZSA9IG51bGw7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG52YXIgRm9ybWF0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblx0XHR0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCA1O1xuXHRcdHRoaXMubXVsdGlwbGllciA9IE1hdGgucG93KDEwLCB0aGlzLnByZWNpc2lvbik7XG5cdH0sXG5cblx0bnVtYmVyOiBmdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCh2YWwgKiB0aGlzLm11bHRpcGxpZXIpIC8gdGhpcy5tdWx0aXBsaWVyO1xuXHR9LFxuXG5cdHBvaW50OiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwueCkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwueSk7XG5cdH0sXG5cblx0c2l6ZTogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsLndpZHRoKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMubnVtYmVyKHZhbC5oZWlnaHQpO1xuXHR9LFxuXG5cdHJlY3RhbmdsZTogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5wb2ludCh2YWwsIHNlcGFyYXRvcikgKyAoc2VwYXJhdG9yIHx8ICcsJylcblx0XHRcdFx0KyB0aGlzLnNpemUodmFsLCBzZXBhcmF0b3IpO1xuXHR9XG59KTtcblxuRm9ybWF0dGVyLmluc3RhbmNlID0gbmV3IEZvcm1hdHRlcigpO1xuXG52YXIgTnVtZXJpY2FsID0gbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBhYnNjaXNzYXMgPSBbXG5cdFx0WyAgMC41NzczNTAyNjkxODk2MjU3NjQ1MDkxNDg4XSxcblx0XHRbMCwwLjc3NDU5NjY2OTI0MTQ4MzM3NzAzNTg1MzFdLFxuXHRcdFsgIDAuMzM5OTgxMDQzNTg0ODU2MjY0ODAyNjY1OCwwLjg2MTEzNjMxMTU5NDA1MjU3NTIyMzk0NjVdLFxuXHRcdFswLDAuNTM4NDY5MzEwMTA1NjgzMDkxMDM2MzE0NCwwLjkwNjE3OTg0NTkzODY2Mzk5Mjc5NzYyNjldLFxuXHRcdFsgIDAuMjM4NjE5MTg2MDgzMTk2OTA4NjMwNTAxNywwLjY2MTIwOTM4NjQ2NjI2NDUxMzY2MTM5OTYsMC45MzI0Njk1MTQyMDMxNTIwMjc4MTIzMDE2XSxcblx0XHRbMCwwLjQwNTg0NTE1MTM3NzM5NzE2NjkwNjYwNjQsMC43NDE1MzExODU1OTkzOTQ0Mzk4NjM4NjQ4LDAuOTQ5MTA3OTEyMzQyNzU4NTI0NTI2MTg5N10sXG5cdFx0WyAgMC4xODM0MzQ2NDI0OTU2NDk4MDQ5Mzk0NzYxLDAuNTI1NTMyNDA5OTE2MzI4OTg1ODE3NzM5MCwwLjc5NjY2NjQ3NzQxMzYyNjczOTU5MTU1MzksMC45NjAyODk4NTY0OTc1MzYyMzE2ODM1NjA5XSxcblx0XHRbMCwwLjMyNDI1MzQyMzQwMzgwODkyOTAzODUzODAsMC42MTMzNzE0MzI3MDA1OTAzOTczMDg3MDIwLDAuODM2MDMxMTA3MzI2NjM1Nzk0Mjk5NDI5OCwwLjk2ODE2MDIzOTUwNzYyNjA4OTgzNTU3NjJdLFxuXHRcdFsgIDAuMTQ4ODc0MzM4OTgxNjMxMjEwODg0ODI2MCwwLjQzMzM5NTM5NDEyOTI0NzE5MDc5OTI2NTksMC42Nzk0MDk1NjgyOTkwMjQ0MDYyMzQzMjc0LDAuODY1MDYzMzY2Njg4OTg0NTEwNzMyMDk2NywwLjk3MzkwNjUyODUxNzE3MTcyMDA3Nzk2NDBdLFxuXHRcdFswLDAuMjY5NTQzMTU1OTUyMzQ0OTcyMzMxNTMyMCwwLjUxOTA5NjEyOTIwNjgxMTgxNTkyNTcyNTcsMC43MzAxNTIwMDU1NzQwNDkzMjQwOTM0MTYzLDAuODg3MDYyNTk5NzY4MDk1Mjk5MDc1MTU3OCwwLjk3ODIyODY1ODE0NjA1Njk5MjgwMzkzODBdLFxuXHRcdFsgIDAuMTI1MjMzNDA4NTExNDY4OTE1NDcyNDQxNCwwLjM2NzgzMTQ5ODk5ODE4MDE5Mzc1MjY5MTUsMC41ODczMTc5NTQyODY2MTc0NDcyOTY3MDI0LDAuNzY5OTAyNjc0MTk0MzA0Njg3MDM2ODkzOCwwLjkwNDExNzI1NjM3MDQ3NDg1NjY3ODQ2NTksMC45ODE1NjA2MzQyNDY3MTkyNTA2OTA1NDkxXSxcblx0XHRbMCwwLjIzMDQ1ODMxNTk1NTEzNDc5NDA2NTUyODEsMC40NDg0OTI3NTEwMzY0NDY4NTI4Nzc5MTI5LDAuNjQyMzQ5MzM5NDQwMzQwMjIwNjQzOTg0NiwwLjgwMTU3ODA5MDczMzMwOTkxMjc5NDIwNjUsMC45MTc1OTgzOTkyMjI5Nzc5NjUyMDY1NDc4LDAuOTg0MTgzMDU0NzE4NTg4MTQ5NDcyODI5NF0sXG5cdFx0WyAgMC4xMDgwNTQ5NDg3MDczNDM2NjIwNjYyNDQ3LDAuMzE5MTEyMzY4OTI3ODg5NzYwNDM1NjcxOCwwLjUxNTI0ODYzNjM1ODE1NDA5MTk2NTI5MDcsMC42ODcyOTI5MDQ4MTE2ODU0NzAxNDgwMTk4LDAuODI3MjAxMzE1MDY5NzY0OTkzMTg5Nzk0NywwLjkyODQzNDg4MzY2MzU3MzUxNzMzNjM5MTEsMC45ODYyODM4MDg2OTY4MTIzMzg4NDE1OTczXSxcblx0XHRbMCwwLjIwMTE5NDA5Mzk5NzQzNDUyMjMwMDYyODMsMC4zOTQxNTEzNDcwNzc1NjMzNjk4OTcyMDc0LDAuNTcwOTcyMTcyNjA4NTM4ODQ3NTM3MjI2NywwLjcyNDQxNzczMTM2MDE3MDA0NzQxNjE4NjEsMC44NDgyMDY1ODM0MTA0MjcyMTYyMDA2NDgzLDAuOTM3MjczMzkyNDAwNzA1OTA0MzA3NzU4OSwwLjk4Nzk5MjUxODAyMDQ4NTQyODQ4OTU2NTddLFxuXHRcdFsgIDAuMDk1MDEyNTA5ODM3NjM3NDQwMTg1MzE5MywwLjI4MTYwMzU1MDc3OTI1ODkxMzIzMDQ2MDUsMC40NTgwMTY3Nzc2NTcyMjczODYzNDI0MTk0LDAuNjE3ODc2MjQ0NDAyNjQzNzQ4NDQ2NjcxOCwwLjc1NTQwNDQwODM1NTAwMzAzMzg5NTEwMTIsMC44NjU2MzEyMDIzODc4MzE3NDM4ODA0Njc5LDAuOTQ0NTc1MDIzMDczMjMyNTc2MDc3OTg4NCwwLjk4OTQwMDkzNDk5MTY0OTkzMjU5NjE1NDJdXG5cdF07XG5cblx0dmFyIHdlaWdodHMgPSBbXG5cdFx0WzFdLFxuXHRcdFswLjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC41NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU2XSxcblx0XHRbMC42NTIxNDUxNTQ4NjI1NDYxNDI2MjY5MzYxLDAuMzQ3ODU0ODQ1MTM3NDUzODU3MzczMDYzOV0sXG5cdFx0WzAuNTY4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjQ3ODYyODY3MDQ5OTM2NjQ2ODA0MTI5MTUsMC4yMzY5MjY4ODUwNTYxODkwODc1MTQyNjQwXSxcblx0XHRbMC40Njc5MTM5MzQ1NzI2OTEwNDczODk4NzAzLDAuMzYwNzYxNTczMDQ4MTM4NjA3NTY5ODMzNSwwLjE3MTMyNDQ5MjM3OTE3MDM0NTA0MDI5NjFdLFxuXHRcdFswLjQxNzk1OTE4MzY3MzQ2OTM4Nzc1NTEwMjAsMC4zODE4MzAwNTA1MDUxMTg5NDQ5NTAzNjk4LDAuMjc5NzA1MzkxNDg5Mjc2NjY3OTAxNDY3OCwwLjEyOTQ4NDk2NjE2ODg2OTY5MzI3MDYxMTRdLFxuXHRcdFswLjM2MjY4Mzc4MzM3ODM2MTk4Mjk2NTE1MDQsMC4zMTM3MDY2NDU4Nzc4ODcyODczMzc5NjIyLDAuMjIyMzgxMDM0NDUzMzc0NDcwNTQ0MzU2MCwwLjEwMTIyODUzNjI5MDM3NjI1OTE1MjUzMTRdLFxuXHRcdFswLjMzMDIzOTM1NTAwMTI1OTc2MzE2NDUyNTEsMC4zMTIzNDcwNzcwNDAwMDI4NDAwNjg2MzA0LDAuMjYwNjEwNjk2NDAyOTM1NDYyMzE4NzQyOSwwLjE4MDY0ODE2MDY5NDg1NzQwNDA1ODQ3MjAsMC4wODEyNzQzODgzNjE1NzQ0MTE5NzE4OTIyXSxcblx0XHRbMC4yOTU1MjQyMjQ3MTQ3NTI4NzAxNzM4OTMwLDAuMjY5MjY2NzE5MzA5OTk2MzU1MDkxMjI2OSwwLjIxOTA4NjM2MjUxNTk4MjA0Mzk5NTUzNDksMC4xNDk0NTEzNDkxNTA1ODA1OTMxNDU3NzYzLDAuMDY2NjcxMzQ0MzA4Njg4MTM3NTkzNTY4OF0sXG5cdFx0WzAuMjcyOTI1MDg2Nzc3OTAwNjMwNzE0NDgzNSwwLjI2MjgwNDU0NDUxMDI0NjY2MjE4MDY4ODksMC4yMzMxOTM3NjQ1OTE5OTA0Nzk5MTg1MjM3LDAuMTg2MjkwMjEwOTI3NzM0MjUxNDI2MDk3NiwwLjEyNTU4MDM2OTQ2NDkwNDYyNDYzNDY5NDMsMC4wNTU2Njg1NjcxMTYxNzM2NjY0ODI3NTM3XSxcblx0XHRbMC4yNDkxNDcwNDU4MTM0MDI3ODUwMDA1NjI0LDAuMjMzNDkyNTM2NTM4MzU0ODA4NzYwODQ5OSwwLjIwMzE2NzQyNjcyMzA2NTkyMTc0OTA2NDUsMC4xNjAwNzgzMjg1NDMzNDYyMjYzMzQ2NTI1LDAuMTA2OTM5MzI1OTk1MzE4NDMwOTYwMjU0NywwLjA0NzE3NTMzNjM4NjUxMTgyNzE5NDYxNjBdLFxuXHRcdFswLjIzMjU1MTU1MzIzMDg3MzkxMDE5NDU4OTUsMC4yMjYyODMxODAyNjI4OTcyMzg0MTIwOTAyLDAuMjA3ODE2MDQ3NTM2ODg4NTAyMzEyNTIzMiwwLjE3ODE0NTk4MDc2MTk0NTczODI4MDA0NjcsMC4xMzg4NzM1MTAyMTk3ODcyMzg0NjM2MDE4LDAuMDkyMTIxNDk5ODM3NzI4NDQ3OTE0NDIxOCwwLjA0MDQ4NDAwNDc2NTMxNTg3OTUyMDAyMTZdLFxuXHRcdFswLjIxNTI2Mzg1MzQ2MzE1Nzc5MDE5NTg3NjQsMC4yMDUxOTg0NjM3MjEyOTU2MDM5NjU5MjQxLDAuMTg1NTM4Mzk3NDc3OTM3ODEzNzQxNzE2NiwwLjE1NzIwMzE2NzE1ODE5MzUzNDU2OTYwMTksMC4xMjE1MTg1NzA2ODc5MDMxODQ2ODk0MTQ4LDAuMDgwMTU4MDg3MTU5NzYwMjA5ODA1NjMzMywwLjAzNTExOTQ2MDMzMTc1MTg2MzAzMTgzMjldLFxuXHRcdFswLjIwMjU3ODI0MTkyNTU2MTI3Mjg4MDYyMDIsMC4xOTg0MzE0ODUzMjcxMTE1NzY0NTYxMTgzLDAuMTg2MTYxMDAwMDE1NTYyMjExMDI2ODAwNiwwLjE2NjI2OTIwNTgxNjk5MzkzMzU1MzIwMDksMC4xMzk1NzA2Nzc5MjYxNTQzMTQ0NDc4MDQ4LDAuMTA3MTU5MjIwNDY3MTcxOTM1MDExODY5NSwwLjA3MDM2NjA0NzQ4ODEwODEyNDcwOTI2NzQsMC4wMzA3NTMyNDE5OTYxMTcyNjgzNTQ2Mjg0XSxcblx0XHRbMC4xODk0NTA2MTA0NTUwNjg0OTYyODUzOTY3LDAuMTgyNjAzNDE1MDQ0OTIzNTg4ODY2NzYzNywwLjE2OTE1NjUxOTM5NTAwMjUzODE4OTMxMjEsMC4xNDk1OTU5ODg4MTY1NzY3MzIwODE1MDE3LDAuMTI0NjI4OTcxMjU1NTMzODcyMDUyNDc2MywwLjA5NTE1ODUxMTY4MjQ5Mjc4NDgwOTkyNTEsMC4wNjIyNTM1MjM5Mzg2NDc4OTI4NjI4NDM4LDAuMDI3MTUyNDU5NDExNzU0MDk0ODUxNzgwNl1cblx0XTtcblxuXHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0c3FydCA9IE1hdGguc3FydCxcblx0XHRwb3cgPSBNYXRoLnBvdyxcblx0XHRjb3MgPSBNYXRoLmNvcyxcblx0XHRQSSA9IE1hdGguUEksXG5cdFx0VE9MRVJBTkNFID0gMTBlLTYsXG5cdFx0RVBTSUxPTiA9IDEwZS0xMjtcblxuXHRmdW5jdGlvbiBzZXR1cFJvb3RzKHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdHZhciB1bmJvdW5kID0gbWluID09PSB1bmRlZmluZWQsXG5cdFx0XHRtaW5FID0gbWluIC0gRVBTSUxPTixcblx0XHRcdG1heEUgPSBtYXggKyBFUFNJTE9OLFxuXHRcdFx0Y291bnQgPSAwO1xuXHRcdHJldHVybiBmdW5jdGlvbihyb290KSB7XG5cdFx0XHRpZiAodW5ib3VuZCB8fCByb290ID4gbWluRSAmJiByb290IDwgbWF4RSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSByb290IDwgbWluID8gbWluIDogcm9vdCA+IG1heCA/IG1heCA6IHJvb3Q7XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0VE9MRVJBTkNFOiBUT0xFUkFOQ0UsXG5cdFx0RVBTSUxPTjogRVBTSUxPTixcblx0XHRLQVBQQTogNCAqIChzcXJ0KDIpIC0gMSkgLyAzLFxuXG5cdFx0aXNaZXJvOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHJldHVybiBhYnModmFsKSA8PSBFUFNJTE9OO1xuXHRcdH0sXG5cblx0XHRpbnRlZ3JhdGU6IGZ1bmN0aW9uKGYsIGEsIGIsIG4pIHtcblx0XHRcdHZhciB4ID0gYWJzY2lzc2FzW24gLSAyXSxcblx0XHRcdFx0dyA9IHdlaWdodHNbbiAtIDJdLFxuXHRcdFx0XHRBID0gMC41ICogKGIgLSBhKSxcblx0XHRcdFx0QiA9IEEgKyBhLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bSA9IChuICsgMSkgPj4gMSxcblx0XHRcdFx0c3VtID0gbiAmIDEgPyB3W2krK10gKiBmKEIpIDogMDsgXG5cdFx0XHR3aGlsZSAoaSA8IG0pIHtcblx0XHRcdFx0dmFyIEF4ID0gQSAqIHhbaV07XG5cdFx0XHRcdHN1bSArPSB3W2krK10gKiAoZihCICsgQXgpICsgZihCIC0gQXgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBBICogc3VtO1xuXHRcdH0sXG5cblx0XHRmaW5kUm9vdDogZnVuY3Rpb24oZiwgZGYsIHgsIGEsIGIsIG4sIHRvbGVyYW5jZSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGZ4ID0gZih4KSxcblx0XHRcdFx0XHRkeCA9IGZ4IC8gZGYoeCksXG5cdFx0XHRcdFx0bnggPSB4IC0gZHg7XG5cdFx0XHRcdGlmIChhYnMoZHgpIDwgdG9sZXJhbmNlKVxuXHRcdFx0XHRcdHJldHVybiBueDtcblx0XHRcdFx0aWYgKGZ4ID4gMCkge1xuXHRcdFx0XHRcdGIgPSB4O1xuXHRcdFx0XHRcdHggPSBueCA8PSBhID8gMC41ICogKGEgKyBiKSA6IG54O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGEgPSB4O1xuXHRcdFx0XHRcdHggPSBueCA+PSBiID8gMC41ICogKGEgKyBiKSA6IG54O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geDtcblx0XHR9LFxuXG5cdFx0c29sdmVRdWFkcmF0aWM6IGZ1bmN0aW9uKGEsIGIsIGMsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIGFkZCA9IHNldHVwUm9vdHMocm9vdHMsIG1pbiwgbWF4KTtcblxuXHRcdFx0aWYgKGFicyhhKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0aWYgKGFicyhiKSA+PSBFUFNJTE9OKVxuXHRcdFx0XHRcdHJldHVybiBhZGQoLWMgLyBiKTtcblx0XHRcdFx0cmV0dXJuIGFicyhjKSA8IEVQU0lMT04gPyAtMSA6IDA7IFxuXHRcdFx0fVxuXHRcdFx0dmFyIHAgPSBiIC8gKDIgKiBhKTtcblx0XHRcdHZhciBxID0gYyAvIGE7XG5cdFx0XHR2YXIgcDIgPSBwICogcDtcblx0XHRcdGlmIChwMiA8IHEgLSBFUFNJTE9OKVxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdHZhciBzID0gcDIgPiBxID8gc3FydChwMiAtIHEpIDogMCxcblx0XHRcdFx0Y291bnQgPSBhZGQocyAtIHApO1xuXHRcdFx0aWYgKHMgPiAwKVxuXHRcdFx0XHRjb3VudCA9IGFkZCgtcyAtIHApO1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRzb2x2ZUN1YmljOiBmdW5jdGlvbihhLCBiLCBjLCBkLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdGlmIChhYnMoYSkgPCBFUFNJTE9OKVxuXHRcdFx0XHRyZXR1cm4gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGIsIGMsIGQsIHJvb3RzLCBtaW4sIG1heCk7XG5cblx0XHRcdGIgLz0gYTtcblx0XHRcdGMgLz0gYTtcblx0XHRcdGQgLz0gYTtcblx0XHRcdHZhciBhZGQgPSBzZXR1cFJvb3RzKHJvb3RzLCBtaW4sIG1heCksXG5cdFx0XHRcdGJiID0gYiAqIGIsXG5cdFx0XHRcdHAgPSAoYmIgLSAzICogYykgLyA5LFxuXHRcdFx0XHRxID0gKDIgKiBiYiAqIGIgLSA5ICogYiAqIGMgKyAyNyAqIGQpIC8gNTQsXG5cdFx0XHRcdHBwcCA9IHAgKiBwICogcCxcblx0XHRcdFx0RCA9IHEgKiBxIC0gcHBwO1xuXHRcdFx0YiAvPSAzO1xuXHRcdFx0aWYgKGFicyhEKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0aWYgKGFicyhxKSA8IEVQU0lMT04pIFxuXHRcdFx0XHRcdHJldHVybiBhZGQoLWIpO1xuXHRcdFx0XHR2YXIgc3FwID0gc3FydChwKSxcblx0XHRcdFx0XHRzbnEgPSBxID4gMCA/IDEgOiAtMTtcblx0XHRcdFx0YWRkKC1zbnEgKiAyICogc3FwIC0gYik7XG5cdFx0XHRcdHJldHVybiBhZGQoc25xICogc3FwIC0gYik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoRCA8IDApIHsgXG5cdFx0XHRcdHZhciBzcXAgPSBzcXJ0KHApLFxuXHRcdFx0XHRcdHBoaSA9IE1hdGguYWNvcyhxIC8gKHNxcCAqIHNxcCAqIHNxcCkpIC8gMyxcblx0XHRcdFx0XHR0ID0gLTIgKiBzcXAsXG5cdFx0XHRcdFx0byA9IDIgKiBQSSAvIDM7XG5cdFx0XHRcdGFkZCh0ICogY29zKHBoaSkgLSBiKTtcblx0XHRcdFx0YWRkKHQgKiBjb3MocGhpICsgbykgLSBiKTtcblx0XHRcdFx0cmV0dXJuIGFkZCh0ICogY29zKHBoaSAtIG8pIC0gYik7XG5cdFx0XHR9XG5cdFx0XHR2YXIgQSA9IChxID4gMCA/IC0xIDogMSkgKiBwb3coYWJzKHEpICsgc3FydChEKSwgMSAvIDMpO1xuXHRcdFx0cmV0dXJuIGFkZChBICsgcCAvIEEgLSBiKTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgUG9pbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BvaW50Jyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludChhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBoYXNZID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuXHRcdFx0dGhpcy54ID0gYXJnMDtcblx0XHRcdHRoaXMueSA9IGhhc1kgPyBhcmcxIDogYXJnMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBoYXNZID8gMiA6IDE7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLnggPSB0aGlzLnkgPSAwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMFswXTtcblx0XHRcdFx0dGhpcy55ID0gYXJnMC5sZW5ndGggPiAxID8gYXJnMFsxXSA6IGFyZzBbMF07XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAueCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAueDtcblx0XHRcdFx0dGhpcy55ID0gYXJnMC55O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLndpZHRoICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC53aWR0aDtcblx0XHRcdFx0dGhpcy55ID0gYXJnMC5oZWlnaHQ7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAuYW5nbGUgIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLmxlbmd0aDtcblx0XHRcdFx0dGhpcy55ID0gMDtcblx0XHRcdFx0dGhpcy5zZXRBbmdsZShhcmcwLmFuZ2xlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMueCA9IHRoaXMueSA9IDA7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHR0aGlzLl9fcmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gMTtcblx0XHR9XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gdGhpcyA9PT0gcG9pbnQgfHwgcG9pbnRcblx0XHRcdFx0JiYgKHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50Lnlcblx0XHRcdFx0XHR8fCBBcnJheS5pc0FycmF5KHBvaW50KVxuXHRcdFx0XHRcdFx0JiYgdGhpcy54ID09PSBwb2ludFswXSAmJiB0aGlzLnkgPT09IHBvaW50WzFdKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KSArICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpICsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMueCksIGYubnVtYmVyKHRoaXMueSldO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKHRoaXMuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBhbmdsZSA9IHRoaXMuX2FuZ2xlIHx8IDA7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0TWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLFxuXHRcdFx0XHRNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGhcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBzY2FsZSA9IGxlbmd0aCAvIHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhzY2FsZSkpXG5cdFx0XHRcdHRoaXMuZ2V0QW5nbGUoKTtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHR0aGlzLnggKiBzY2FsZSxcblx0XHRcdFx0dGhpcy55ICogc2NhbGVcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXHRnZXRBbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QW5nbGVJblJhZGlhbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIDE4MCAvIE1hdGguUEk7XG5cdH0sXG5cblx0c2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cdFx0dGhpcy5zZXRBbmdsZUluUmFkaWFucy5jYWxsKHRoaXMsIGFuZ2xlICogTWF0aC5QSSAvIDE4MCk7XG5cdH0sXG5cblx0Z2V0QW5nbGVJbkRlZ3JlZXM6ICcjZ2V0QW5nbGUnLFxuXHRzZXRBbmdsZUluRGVncmVlczogJyNzZXRBbmdsZScsXG5cblx0Z2V0QW5nbGVJblJhZGlhbnM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2FuZ2xlIHx8IDBcblx0XHRcdFx0XHQ6IHRoaXMuX2FuZ2xlID0gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0ZGl2ID0gdGhpcy5nZXRMZW5ndGgoKSAqIHBvaW50LmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oZGl2KSkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguYWNvcyh0aGlzLmRvdChwb2ludCkgLyBkaXYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuXHRcdGlmICghdGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0TWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLFxuXHRcdFx0XHRNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGhcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFF1YWRyYW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ID49IDAgPyB0aGlzLnkgPj0gMCA/IDEgOiA0IDogdGhpcy55ID49IDAgPyAyIDogMztcblx0fVxufSwge1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0RGlyZWN0ZWRBbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBNYXRoLmF0YW4yKHRoaXMuY3Jvc3MocG9pbnQpLCB0aGlzLmRvdChwb2ludCkpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LnggLSB0aGlzLngsXG5cdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMueSxcblx0XHRcdGQgPSB4ICogeCArIHkgKiB5LFxuXHRcdFx0c3F1YXJlZCA9IEJhc2UucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBzcXVhcmVkID8gZCA6IE1hdGguc3FydChkKTtcblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmIChsZW5ndGggPT09IHVuZGVmaW5lZClcblx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldExlbmd0aCgpLFxuXHRcdFx0c2NhbGUgPSBjdXJyZW50ICE9PSAwID8gbGVuZ3RoIC8gY3VycmVudCA6IDAsXG5cdFx0XHRwb2ludCA9IG5ldyBQb2ludCh0aGlzLnggKiBzY2FsZSwgdGhpcy55ICogc2NhbGUpO1xuXHRcdGlmIChzY2FsZSA+PSAwKVxuXHRcdFx0cG9pbnQuX2FuZ2xlID0gdGhpcy5fYW5nbGU7XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIGNlbnRlcikge1xuXHRcdGlmIChhbmdsZSA9PT0gMClcblx0XHRcdHJldHVybiB0aGlzLmNsb25lKCk7XG5cdFx0YW5nbGUgPSBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIHBvaW50ID0gY2VudGVyID8gdGhpcy5zdWJ0cmFjdChjZW50ZXIpIDogdGhpcyxcblx0XHRcdHMgPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRjID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHBvaW50ID0gbmV3IFBvaW50KFxuXHRcdFx0cG9pbnQueCAqIGMgLSBwb2ludC55ICogcyxcblx0XHRcdHBvaW50LnggKiBzICsgcG9pbnQueSAqIGNcblx0XHQpO1xuXHRcdHJldHVybiBjZW50ZXIgPyBwb2ludC5hZGQoY2VudGVyKSA6IHBvaW50O1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodGhpcykgOiB0aGlzO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgcG9pbnQueCwgdGhpcy55ICsgcG9pbnQueSk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHBvaW50LngsIHRoaXMueSAtIHBvaW50LnkpO1xuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICUgcG9pbnQueCwgdGhpcy55ICUgcG9pbnQueSk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KC10aGlzLngsIC10aGlzLnkpO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIHJlY3QuY29udGFpbnModGhpcyk7XG5cdH0sXG5cblx0aXNDbG9zZTogZnVuY3Rpb24ocG9pbnQsIHRvbGVyYW5jZSkge1xuXHRcdHJldHVybiB0aGlzLmdldERpc3RhbmNlKHBvaW50KSA8IHRvbGVyYW5jZTtcblx0fSxcblxuXHRpc0NvbGluZWFyOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiBNYXRoLmFicyh0aGlzLmNyb3NzKHBvaW50KSkgPCAwLjAwMDAxO1xuXHR9LFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy5kb3QocG9pbnQpKSA8IDAuMDAwMDE7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLmlzWmVybyh0aGlzLngpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy55KTtcblx0fSxcblxuXHRpc05hTjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGlzTmFOKHRoaXMueCkgfHwgaXNOYU4odGhpcy55KTtcblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy54ICogcG9pbnQueCArIHRoaXMueSAqIHBvaW50Lnk7XG5cdH0sXG5cblx0Y3Jvc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy54ICogcG9pbnQueSAtIHRoaXMueSAqIHBvaW50Lng7XG5cdH0sXG5cblx0cHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmIChwb2ludC5pc1plcm8oKSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludCgwLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNjYWxlID0gdGhpcy5kb3QocG9pbnQpIC8gcG9pbnQuZG90KHBvaW50KTtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdHBvaW50LnggKiBzY2FsZSxcblx0XHRcdFx0cG9pbnQueSAqIHNjYWxlXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0bWluOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb2ludDEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBvaW50MiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdE1hdGgubWluKHBvaW50MS54LCBwb2ludDIueCksXG5cdFx0XHRcdE1hdGgubWluKHBvaW50MS55LCBwb2ludDIueSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1heChwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1heChwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3JvdW5kJywgJ2NlaWwnLCAnZmxvb3InLCAnYWJzJ10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dmFyIG9wID0gTWF0aFtuYW1lXTtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQob3AodGhpcy54KSwgb3AodGhpcy55KSk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGlua2VkUG9pbnQgPSBQb2ludC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludCh4LCB5LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIFNpemUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1NpemUnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUoYXJnMCwgYXJnMSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR2YXIgaGFzSGVpZ2h0ID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuXHRcdFx0dGhpcy53aWR0aCA9IGFyZzA7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhhc0hlaWdodCA/IGFyZzEgOiBhcmcwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGhhc0hlaWdodCA/IDIgOiAxO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwWzBdO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAubGVuZ3RoID4gMSA/IGFyZzBbMV0gOiBhcmcwWzBdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLndpZHRoICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzAud2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMC5oZWlnaHQ7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAueCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwLng7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMC55O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdHRoaXMuX19yZWFkID0gMDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSAxO1xuXHRcdH1cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0cmV0dXJuIHNpemUgPT09IHRoaXMgfHwgc2l6ZSAmJiAodGhpcy53aWR0aCA9PT0gc2l6ZS53aWR0aFxuXHRcdFx0XHQmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZS5oZWlnaHRcblx0XHRcdFx0fHwgQXJyYXkuaXNBcnJheShzaXplKSAmJiB0aGlzLndpZHRoID09PSBzaXplWzBdXG5cdFx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemVbMV0pIHx8IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgd2lkdGg6ICcgKyBmLm51bWJlcih0aGlzLndpZHRoKVxuXHRcdFx0XHQrICcsIGhlaWdodDogJyArIGYubnVtYmVyKHRoaXMuaGVpZ2h0KSArICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLndpZHRoKSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy5oZWlnaHQpXTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCArIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAtIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICogc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKiBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC8gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bW9kdWxvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICUgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgJSBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUoLXRoaXMud2lkdGgsIC10aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLmlzWmVybyh0aGlzLndpZHRoKSAmJiBOdW1lcmljYWwuaXNaZXJvKHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRpc05hTjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGlzTmFOKHRoaXMud2lkdGgpIHx8IGlzTmFOKHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0bWluOiBmdW5jdGlvbihzaXplMSwgc2l6ZTIpIHtcblx0XHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdFx0TWF0aC5taW4oc2l6ZTEud2lkdGgsIHNpemUyLndpZHRoKSxcblx0XHRcdFx0TWF0aC5taW4oc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbihzaXplMSwgc2l6ZTIpIHtcblx0XHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdFx0TWF0aC5tYXgoc2l6ZTEud2lkdGgsIHNpemUyLndpZHRoKSxcblx0XHRcdFx0TWF0aC5tYXgoc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcblx0XHR9LFxuXG5cdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgU2l6ZShNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3JvdW5kJywgJ2NlaWwnLCAnZmxvb3InLCAnYWJzJ10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dmFyIG9wID0gTWF0aFtuYW1lXTtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZShvcCh0aGlzLndpZHRoKSwgb3AodGhpcy5oZWlnaHQpKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5rZWRTaXplID0gU2l6ZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl93aWR0aDtcblx0fSxcblxuXHRzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGVpZ2h0O1xuXHR9LFxuXG5cdHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgUmVjdGFuZ2xlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSZWN0YW5nbGUnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSZWN0YW5nbGUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzAsXG5cdFx0XHRyZWFkID0gMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHRoaXMueCA9IGFyZzA7XG5cdFx0XHR0aGlzLnkgPSBhcmcxO1xuXHRcdFx0dGhpcy53aWR0aCA9IGFyZzI7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGFyZzM7XG5cdFx0XHRyZWFkID0gNDtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMueCA9IHRoaXMueSA9IHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRyZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMFswXTtcblx0XHRcdFx0dGhpcy55ID0gYXJnMFsxXTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzBbMl07XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMFszXTtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAueCAhPT0gdW5kZWZpbmVkIHx8IGFyZzAud2lkdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLnggfHwgMDtcblx0XHRcdFx0dGhpcy55ID0gYXJnMC55IHx8IDA7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwLndpZHRoIHx8IDA7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMC5oZWlnaHQgfHwgMDtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAuZnJvbSA9PT0gdW5kZWZpbmVkICYmIGFyZzAudG8gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnggPSB0aGlzLnkgPSB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0XHR0aGlzLl9zZXQoYXJnMCk7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXJlYWQpIHtcblx0XHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG5cdFx0XHRcdG5leHQgPSBCYXNlLnBlZWsoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHRcdFx0aWYgKG5leHQgJiYgbmV4dC54ICE9PSB1bmRlZmluZWQgfHwgQmFzZS5oYXNOYW1lZChhcmd1bWVudHMsICd0bycpKSB7XG5cdFx0XHRcdHZhciB0byA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdG8ueCAtIHBvaW50Lng7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gdG8ueSAtIHBvaW50Lnk7XG5cdFx0XHRcdGlmICh0aGlzLndpZHRoIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMueCA9IHRvLng7XG5cdFx0XHRcdFx0dGhpcy53aWR0aCA9IC10aGlzLndpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmhlaWdodCA8IDApIHtcblx0XHRcdFx0XHR0aGlzLnkgPSB0by55O1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gLXRoaXMuaGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdH1cblx0XHRcdHJlYWQgPSBhcmd1bWVudHMuX19pbmRleDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHJ0ID0gQmFzZS5pc1BsYWluVmFsdWUocmVjdClcblx0XHRcdFx0PyBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpXG5cdFx0XHRcdDogcmVjdDtcblx0XHRyZXR1cm4gcnQgPT09IHRoaXNcblx0XHRcdFx0fHwgcnQgJiYgdGhpcy54ID09PSBydC54ICYmIHRoaXMueSA9PT0gcnQueVxuXHRcdFx0XHRcdCYmIHRoaXMud2lkdGggPT09IHJ0LndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBydC5oZWlnaHRcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KVxuXHRcdFx0XHQrICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpXG5cdFx0XHRcdCsgJywgd2lkdGg6ICcgKyBmLm51bWJlcih0aGlzLndpZHRoKVxuXHRcdFx0XHQrICcsIGhlaWdodDogJyArIGYubnVtYmVyKHRoaXMuaGVpZ2h0KVxuXHRcdFx0XHQrICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLngpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLnkpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLndpZHRoKSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy5oZWlnaHQpXTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcywgJ3NldFBvaW50Jyk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnggPSBwb2ludC54O1xuXHRcdHRoaXMueSA9IHBvaW50Lnk7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBTaXplIDogTGlua2VkU2l6ZTtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAodGhpcy5fZml4WClcblx0XHRcdHRoaXMueCArPSAodGhpcy53aWR0aCAtIHNpemUud2lkdGgpICogdGhpcy5fZml4WDtcblx0XHRpZiAodGhpcy5fZml4WSlcblx0XHRcdHRoaXMueSArPSAodGhpcy5oZWlnaHQgLSBzaXplLmhlaWdodCkgKiB0aGlzLl9maXhZO1xuXHRcdHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0dGhpcy5fZml4VyA9IDE7XG5cdFx0dGhpcy5fZml4SCA9IDE7XG5cdH0sXG5cblx0Z2V0TGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueDtcblx0fSxcblxuXHRzZXRMZWZ0OiBmdW5jdGlvbihsZWZ0KSB7XG5cdFx0aWYgKCF0aGlzLl9maXhXKVxuXHRcdFx0dGhpcy53aWR0aCAtPSBsZWZ0IC0gdGhpcy54O1xuXHRcdHRoaXMueCA9IGxlZnQ7XG5cdFx0dGhpcy5fZml4WCA9IDA7XG5cdH0sXG5cblx0Z2V0VG9wOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55O1xuXHR9LFxuXG5cdHNldFRvcDogZnVuY3Rpb24odG9wKSB7XG5cdFx0aWYgKCF0aGlzLl9maXhIKVxuXHRcdFx0dGhpcy5oZWlnaHQgLT0gdG9wIC0gdGhpcy55O1xuXHRcdHRoaXMueSA9IHRvcDtcblx0XHR0aGlzLl9maXhZID0gMDtcblx0fSxcblxuXHRnZXRSaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG5cdH0sXG5cblx0c2V0UmlnaHQ6IGZ1bmN0aW9uKHJpZ2h0KSB7XG5cdFx0aWYgKHRoaXMuX2ZpeFggIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9maXhYICE9PSAxKVxuXHRcdFx0dGhpcy5fZml4VyA9IDA7XG5cdFx0aWYgKHRoaXMuX2ZpeFcpXG5cdFx0XHR0aGlzLnggPSByaWdodCAtIHRoaXMud2lkdGg7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy53aWR0aCA9IHJpZ2h0IC0gdGhpcy54O1xuXHRcdHRoaXMuX2ZpeFggPSAxO1xuXHR9LFxuXG5cdGdldEJvdHRvbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdHNldEJvdHRvbTogZnVuY3Rpb24oYm90dG9tKSB7XG5cdFx0aWYgKHRoaXMuX2ZpeFkgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9maXhZICE9PSAxKVxuXHRcdFx0dGhpcy5fZml4SCA9IDA7XG5cdFx0aWYgKHRoaXMuX2ZpeEgpXG5cdFx0XHR0aGlzLnkgPSBib3R0b20gLSB0aGlzLmhlaWdodDtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLmhlaWdodCA9IGJvdHRvbSAtIHRoaXMueTtcblx0XHR0aGlzLl9maXhZID0gMTtcblx0fSxcblxuXHRnZXRDZW50ZXJYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aCAqIDAuNTtcblx0fSxcblxuXHRzZXRDZW50ZXJYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy54ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG5cdFx0dGhpcy5fZml4WCA9IDAuNTtcblx0fSxcblxuXHRnZXRDZW50ZXJZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgKiAwLjU7XG5cdH0sXG5cblx0c2V0Q2VudGVyWTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMueSA9IHkgLSB0aGlzLmhlaWdodCAqIDAuNTtcblx0XHR0aGlzLl9maXhZID0gMC41O1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLmdldENlbnRlclgoKSwgdGhpcy5nZXRDZW50ZXJZKCksIHRoaXMsICdzZXRDZW50ZXInKTtcblx0fSxcblxuXHRzZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnNldENlbnRlclgocG9pbnQueCk7XG5cdFx0dGhpcy5zZXRDZW50ZXJZKHBvaW50LnkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDA7XG5cdH0sXG5cblx0Y29udGFpbnM6IGZ1bmN0aW9uKGFyZykge1xuXHRcdHJldHVybiBhcmcgJiYgYXJnLndpZHRoICE9PSB1bmRlZmluZWRcblx0XHRcdFx0fHwgKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cykubGVuZ3RoID09IDRcblx0XHRcdFx0PyB0aGlzLl9jb250YWluc1JlY3RhbmdsZShSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpKVxuXHRcdFx0XHQ6IHRoaXMuX2NvbnRhaW5zUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgeCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHRyZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnlcblx0XHRcdFx0JiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0X2NvbnRhaW5zUmVjdGFuZ2xlOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHggPSByZWN0LngsXG5cdFx0XHR5ID0gcmVjdC55O1xuXHRcdHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueVxuXHRcdFx0XHQmJiB4ICsgcmVjdC53aWR0aCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHkgKyByZWN0LmhlaWdodCA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHJlY3QueCArIHJlY3Qud2lkdGggPiB0aGlzLnhcblx0XHRcdFx0JiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPiB0aGlzLnlcblx0XHRcdFx0JiYgcmVjdC54IDwgdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiByZWN0LnkgPCB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHR0b3VjaGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHJlY3QueCArIHJlY3Qud2lkdGggPj0gdGhpcy54XG5cdFx0XHRcdCYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID49IHRoaXMueVxuXHRcdFx0XHQmJiByZWN0LnggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiByZWN0LnkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aW50ZXJzZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdC54KSxcblx0XHRcdHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0LnkpLFxuXHRcdFx0eDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKSxcblx0XHRcdHkyID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdHVuaXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4MSA9IE1hdGgubWluKHRoaXMueCwgcmVjdC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCByZWN0LnkpLFxuXHRcdFx0eDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKSxcblx0XHRcdHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGluY2x1ZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgeDEgPSBNYXRoLm1pbih0aGlzLngsIHBvaW50LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1pbih0aGlzLnksIHBvaW50LnkpLFxuXHRcdFx0eDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCBwb2ludC54KSxcblx0XHRcdHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHBvaW50LnkpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0ZXhwYW5kOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW1vdW50ID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRob3IgPSBhbW91bnQud2lkdGgsXG5cdFx0XHR2ZXIgPSBhbW91bnQuaGVpZ2h0O1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIGhvciAvIDIsIHRoaXMueSAtIHZlciAvIDIsXG5cdFx0XHRcdHRoaXMud2lkdGggKyBob3IsIHRoaXMuaGVpZ2h0ICsgdmVyKTtcblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24oaG9yLCB2ZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5leHBhbmQodGhpcy53aWR0aCAqIGhvciAtIHRoaXMud2lkdGgsXG5cdFx0XHRcdHRoaXMuaGVpZ2h0ICogKHZlciA9PT0gdW5kZWZpbmVkID8gaG9yIDogdmVyKSAtIHRoaXMuaGVpZ2h0KTtcblx0fVxufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gQmFzZS5lYWNoKFtcblx0XHRcdFsnVG9wJywgJ0xlZnQnXSwgWydUb3AnLCAnUmlnaHQnXSxcblx0XHRcdFsnQm90dG9tJywgJ0xlZnQnXSwgWydCb3R0b20nLCAnUmlnaHQnXSxcblx0XHRcdFsnTGVmdCcsICdDZW50ZXInXSwgWydUb3AnLCAnQ2VudGVyJ10sXG5cdFx0XHRbJ1JpZ2h0JywgJ0NlbnRlciddLCBbJ0JvdHRvbScsICdDZW50ZXInXVxuXHRcdF0sXG5cdFx0ZnVuY3Rpb24ocGFydHMsIGluZGV4KSB7XG5cdFx0XHR2YXIgcGFydCA9IHBhcnRzLmpvaW4oJycpO1xuXHRcdFx0dmFyIHhGaXJzdCA9IC9eW1JMXS8udGVzdChwYXJ0KTtcblx0XHRcdGlmIChpbmRleCA+PSA0KVxuXHRcdFx0XHRwYXJ0c1sxXSArPSB4Rmlyc3QgPyAnWScgOiAnWCc7XG5cdFx0XHR2YXIgeCA9IHBhcnRzW3hGaXJzdCA/IDAgOiAxXSxcblx0XHRcdFx0eSA9IHBhcnRzW3hGaXJzdCA/IDEgOiAwXSxcblx0XHRcdFx0Z2V0WCA9ICdnZXQnICsgeCxcblx0XHRcdFx0Z2V0WSA9ICdnZXQnICsgeSxcblx0XHRcdFx0c2V0WCA9ICdzZXQnICsgeCxcblx0XHRcdFx0c2V0WSA9ICdzZXQnICsgeSxcblx0XHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0LFxuXHRcdFx0XHRzZXQgPSAnc2V0JyArIHBhcnQ7XG5cdFx0XHR0aGlzW2dldF0gPSBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0XHRyZXR1cm4gbmV3IGN0b3IodGhpc1tnZXRYXSgpLCB0aGlzW2dldFldKCksIHRoaXMsIHNldCk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpc1tzZXRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpc1tzZXRYXShwb2ludC54KTtcblx0XHRcdFx0dGhpc1tzZXRZXShwb2ludC55KTtcblx0XHRcdH07XG5cdFx0fSwge1xuXHRcdFx0YmVhbnM6IHRydWVcblx0XHR9KTtcbn0pO1xuXG52YXIgTGlua2VkUmVjdGFuZ2xlID0gUmVjdGFuZ2xlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBwcm90byA9IFJlY3RhbmdsZS5wcm90b3R5cGU7XG5cblx0cmV0dXJuIEJhc2UuZWFjaChbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KTtcblx0XHR2YXIgaW50ZXJuYWwgPSAnXycgKyBrZXk7XG5cdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tpbnRlcm5hbF07XG5cdFx0fTtcblxuXHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzW2ludGVybmFsXSA9IHZhbHVlO1xuXHRcdFx0aWYgKCF0aGlzLl9kb250Tm90aWZ5KVxuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdH07XG5cdH0sIEJhc2UuZWFjaChbJ1BvaW50JywgJ1NpemUnLCAnQ2VudGVyJyxcblx0XHRcdCdMZWZ0JywgJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnQ2VudGVyWCcsICdDZW50ZXJZJyxcblx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0J0xlZnRDZW50ZXInLCAnVG9wQ2VudGVyJywgJ1JpZ2h0Q2VudGVyJywgJ0JvdHRvbUNlbnRlciddLFxuXHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dmFyIG5hbWUgPSAnc2V0JyArIGtleTtcblx0XHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IHRydWU7XG5cdFx0XHRcdHByb3RvW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMuX2RvbnROb3RpZnkgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRcdH07XG5cdFx0fSwge1xuXHRcdFx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9vd25lci5fYm91bmRzU2VsZWN0ZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0XHRcdGlmIChvd25lci5zZXRTZWxlY3RlZCkge1xuXHRcdFx0XHRcdG93bmVyLl9ib3VuZHNTZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdFx0XHRcdG93bmVyLnNldFNlbGVjdGVkKHNlbGVjdGVkIHx8IG93bmVyLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA+IDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0KTtcbn0pO1xuXG52YXIgTWF0cml4ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdNYXRyaXgnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIE1hdHJpeChhcmcpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0b2sgPSB0cnVlO1xuXHRcdGlmIChjb3VudCA9PT0gNikge1xuXHRcdFx0dGhpcy5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoYXJnIGluc3RhbmNlb2YgTWF0cml4KSB7XG5cdFx0XHRcdHRoaXMuc2V0KGFyZy5fYSwgYXJnLl9jLCBhcmcuX2IsIGFyZy5fZCwgYXJnLl90eCwgYXJnLl90eSk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHR0aGlzLnNldC5hcHBseSh0aGlzLCBhcmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9rID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghb2spXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG1hdHJpeCBwYXJhbWV0ZXJzJyk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihhLCBjLCBiLCBkLCB0eCwgdHksIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fYSA9IGE7XG5cdFx0dGhpcy5fYyA9IGM7XG5cdFx0dGhpcy5fYiA9IGI7XG5cdFx0dGhpcy5fZCA9IGQ7XG5cdFx0dGhpcy5fdHggPSB0eDtcblx0XHR0aGlzLl90eSA9IHR5O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmdldFZhbHVlcygpLCBvcHRpb25zKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0aWYgKG93bmVyKSB7XG5cdFx0XHRpZiAob3duZXIuX2FwcGx5TWF0cml4KSB7XG5cdFx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG93bmVyLl9jaGFuZ2VkKDkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCxcblx0XHRcdFx0dGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKG14KSB7XG5cdFx0cmV0dXJuIG14ID09PSB0aGlzIHx8IG14ICYmIHRoaXMuX2EgPT09IG14Ll9hICYmIHRoaXMuX2IgPT09IG14Ll9iXG5cdFx0XHRcdCYmIHRoaXMuX2MgPT09IG14Ll9jICYmIHRoaXMuX2QgPT09IG14Ll9kXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSBteC5fdHggJiYgdGhpcy5fdHkgPT09IG14Ll90eVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICdbWycgKyBbZi5udW1iZXIodGhpcy5fYSksIGYubnVtYmVyKHRoaXMuX2IpLFxuXHRcdFx0XHRcdGYubnVtYmVyKHRoaXMuX3R4KV0uam9pbignLCAnKSArICddLCBbJ1xuXHRcdFx0XHQrIFtmLm51bWJlcih0aGlzLl9jKSwgZi5udW1iZXIodGhpcy5fZCksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHkpXS5qb2luKCcsICcpICsgJ11dJztcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gdGhpcy5fZCA9IDE7XG5cdFx0dGhpcy5fYyA9IHRoaXMuX2IgPSB0aGlzLl90eCA9IHRoaXMuX3R5ID0gMDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFwcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHR0aGlzLl90eCArPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iO1xuXHRcdHRoaXMuX3R5ICs9IHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2NhbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR0aGlzLl9hICo9IHNjYWxlLng7XG5cdFx0dGhpcy5fYyAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2IgKj0gc2NhbGUueTtcblx0XHR0aGlzLl9kICo9IHNjYWxlLnk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUgKSB7XG5cdFx0YW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpLFxuXHRcdFx0eCA9IGNlbnRlci54LFxuXHRcdFx0eSA9IGNlbnRlci55LFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0dHggPSB4IC0geCAqIGNvcyArIHkgKiBzaW4sXG5cdFx0XHR0eSA9IHkgLSB4ICogc2luIC0geSAqIGNvcyxcblx0XHRcdGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kO1xuXHRcdHRoaXMuX2EgPSBjb3MgKiBhICsgc2luICogYjtcblx0XHR0aGlzLl9iID0gLXNpbiAqIGEgKyBjb3MgKiBiO1xuXHRcdHRoaXMuX2MgPSBjb3MgKiBjICsgc2luICogZDtcblx0XHR0aGlzLl9kID0gLXNpbiAqIGMgKyBjb3MgKiBkO1xuXHRcdHRoaXMuX3R4ICs9IHR4ICogYSArIHR5ICogYjtcblx0XHR0aGlzLl90eSArPSB0eCAqIGMgKyB0eSAqIGQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNoZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2hlYXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRjID0gdGhpcy5fYztcblx0XHR0aGlzLl9hICs9IHNoZWFyLnkgKiB0aGlzLl9iO1xuXHRcdHRoaXMuX2MgKz0gc2hlYXIueSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fYiArPSBzaGVhci54ICogYTtcblx0XHR0aGlzLl9kICs9IHNoZWFyLnggKiBjO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRza2V3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2tldyA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0dG9SYWRpYW5zID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdHNoZWFyID0gbmV3IFBvaW50KE1hdGgudGFuKHNrZXcueCAqIHRvUmFkaWFucyksXG5cdFx0XHRcdE1hdGgudGFuKHNrZXcueSAqIHRvUmFkaWFucykpO1xuXHRcdHJldHVybiB0aGlzLnNoZWFyKHNoZWFyLCBjZW50ZXIpO1xuXHR9LFxuXG5cdGNvbmNhdGVuYXRlOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZDtcblx0XHR0aGlzLl9hID0gbXguX2EgKiBhICsgbXguX2MgKiBiO1xuXHRcdHRoaXMuX2IgPSBteC5fYiAqIGEgKyBteC5fZCAqIGI7XG5cdFx0dGhpcy5fYyA9IG14Ll9hICogYyArIG14Ll9jICogZDtcblx0XHR0aGlzLl9kID0gbXguX2IgKiBjICsgbXguX2QgKiBkO1xuXHRcdHRoaXMuX3R4ICs9IG14Ll90eCAqIGEgKyBteC5fdHkgKiBiO1xuXHRcdHRoaXMuX3R5ICs9IG14Ll90eCAqIGMgKyBteC5fdHkgKiBkO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVDb25jYXRlbmF0ZTogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYixcblx0XHRcdGMgPSB0aGlzLl9jLFxuXHRcdFx0ZCA9IHRoaXMuX2QsXG5cdFx0XHR0eCA9IHRoaXMuX3R4LFxuXHRcdFx0dHkgPSB0aGlzLl90eTtcblx0XHR0aGlzLl9hID0gbXguX2EgKiBhICsgbXguX2IgKiBjO1xuXHRcdHRoaXMuX2IgPSBteC5fYSAqIGIgKyBteC5fYiAqIGQ7XG5cdFx0dGhpcy5fYyA9IG14Ll9jICogYSArIG14Ll9kICogYztcblx0XHR0aGlzLl9kID0gbXguX2MgKiBiICsgbXguX2QgKiBkO1xuXHRcdHRoaXMuX3R4ID0gbXguX2EgKiB0eCArIG14Ll9iICogdHkgKyBteC5fdHg7XG5cdFx0dGhpcy5fdHkgPSBteC5fYyAqIHR4ICsgbXguX2QgKiB0eSArIG14Ll90eTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0aXNJZGVudGl0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2EgPT09IDEgJiYgdGhpcy5fYyA9PT0gMCAmJiB0aGlzLl9iID09PSAwICYmIHRoaXMuX2QgPT09IDFcblx0XHRcdFx0JiYgdGhpcy5fdHggPT09IDAgJiYgdGhpcy5fdHkgPT09IDA7XG5cdH0sXG5cblx0b3JOdWxsSWZJZGVudGl0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNJZGVudGl0eSgpID8gbnVsbCA6IHRoaXM7XG5cdH0sXG5cblx0aXNJbnZlcnRpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHR9LFxuXG5cdGlzU2luZ3VsYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKCBzcmMsIHNyY09mZnNldCwgZHN0LCBkc3RPZmZzZXQsIGNvdW50KSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCA1XG5cdFx0XHQ/IHRoaXMuX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoc3JjLCBzcmNPZmZzZXQsIGRzdCwgZHN0T2Zmc2V0LCBjb3VudCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgeCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KFxuXHRcdFx0eCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYiArIHRoaXMuX3R4LFxuXHRcdFx0eCAqIHRoaXMuX2MgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5LFxuXHRcdFx0X2RvbnROb3RpZnlcblx0XHQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24oc3JjLCBzcmNPZmZzZXQsIGRzdCwgZHN0T2Zmc2V0LCBjb3VudCkge1xuXHRcdHZhciBpID0gc3JjT2Zmc2V0LFxuXHRcdFx0aiA9IGRzdE9mZnNldCxcblx0XHRcdG1heCA9IGkgKyAyICogY291bnQ7XG5cdFx0d2hpbGUgKGkgPCBtYXgpIHtcblx0XHRcdHZhciB4ID0gc3JjW2krK10sXG5cdFx0XHRcdHkgPSBzcmNbaSsrXTtcblx0XHRcdGRzdFtqKytdID0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYiArIHRoaXMuX3R4O1xuXHRcdFx0ZHN0W2orK10gPSB4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHk7XG5cdFx0fVxuXHRcdHJldHVybiBkc3Q7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvcm5lcnM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeDEgPSByZWN0LngsXG5cdFx0XHR5MSA9IHJlY3QueSxcblx0XHRcdHgyID0geDEgKyByZWN0LndpZHRoLFxuXHRcdFx0eTIgPSB5MSArIHJlY3QuaGVpZ2h0LFxuXHRcdFx0Y29vcmRzID0gWyB4MSwgeTEsIHgyLCB5MSwgeDIsIHkyLCB4MSwgeTIgXTtcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCAwLCBjb29yZHMsIDAsIDQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Cb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5fdHJhbnNmb3JtQ29ybmVycyhib3VuZHMpLFxuXHRcdFx0bWluID0gY29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gY29vcmRzLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDI7IGkgPCA4OyBpKyspIHtcblx0XHRcdHZhciB2YWwgPSBjb29yZHNbaV0sXG5cdFx0XHRcdGogPSBpICYgMTtcblx0XHRcdGlmICh2YWwgPCBtaW5bal0pXG5cdFx0XHRcdG1pbltqXSA9IHZhbDtcblx0XHRcdGVsc2UgaWYgKHZhbCA+IG1heFtqXSlcblx0XHRcdFx0bWF4W2pdID0gdmFsO1xuXHRcdH1cblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHJldHVybiBkZXN0LnNldChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0sXG5cdFx0XHRcdF9kb250Tm90aWZ5KTtcblx0fSxcblxuXHRpbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9nZXREZXRlcm1pbmFudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2EgKiB0aGlzLl9kIC0gdGhpcy5fYiAqIHRoaXMuX2M7XG5cdFx0cmV0dXJuIGlzRmluaXRlKGRldCkgJiYgIU51bWVyaWNhbC5pc1plcm8oZGV0KVxuXHRcdFx0XHQmJiBpc0Zpbml0ZSh0aGlzLl90eCkgJiYgaXNGaW5pdGUodGhpcy5fdHkpXG5cdFx0XHRcdD8gZGV0IDogbnVsbDtcblx0fSxcblxuXHRfaW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2dldERldGVybWluYW50KCk7XG5cdFx0aWYgKCFkZXQpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLl90eCxcblx0XHRcdHkgPSBwb2ludC55IC0gdGhpcy5fdHk7XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBQb2ludCgpO1xuXHRcdHJldHVybiBkZXN0LnNldChcblx0XHRcdCh4ICogdGhpcy5fZCAtIHkgKiB0aGlzLl9iKSAvIGRldCxcblx0XHRcdCh5ICogdGhpcy5fYSAtIHggKiB0aGlzLl9jKSAvIGRldCxcblx0XHRcdF9kb250Tm90aWZ5XG5cdFx0KTtcblx0fSxcblxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhID0gdGhpcy5fYSwgYiA9IHRoaXMuX2IsIGMgPSB0aGlzLl9jLCBkID0gdGhpcy5fZDtcblx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhhICogZCAtIGIgKiBjKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblx0XHRhIC89IHNjYWxlWDtcblx0XHRiIC89IHNjYWxlWDtcblxuXHRcdHZhciBzaGVhciA9IGEgKiBjICsgYiAqIGQ7XG5cdFx0YyAtPSBhICogc2hlYXI7XG5cdFx0ZCAtPSBiICogc2hlYXI7XG5cblx0XHR2YXIgc2NhbGVZID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuXHRcdGMgLz0gc2NhbGVZO1xuXHRcdGQgLz0gc2NhbGVZO1xuXHRcdHNoZWFyIC89IHNjYWxlWTtcblxuXHRcdGlmIChhICogZCA8IGIgKiBjKSB7XG5cdFx0XHRhID0gLWE7XG5cdFx0XHRiID0gLWI7XG5cdFx0XHRzaGVhciA9IC1zaGVhcjtcblx0XHRcdHNjYWxlWCA9IC1zY2FsZVg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHNjYWxpbmc6IG5ldyBQb2ludChzY2FsZVgsIHNjYWxlWSksXG5cdFx0XHRyb3RhdGlvbjogLU1hdGguYXRhbjIoYiwgYSkgKiAxODAgLyBNYXRoLlBJLFxuXHRcdFx0c2hlYXJpbmc6IHNoZWFyXG5cdFx0fTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbIHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSBdO1xuXHR9LFxuXG5cdGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRlY29tcG9zZSgpIHx8IHt9KS5zY2FsaW5nO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGVjb21wb3NlKCkgfHwge30pLnJvdGF0aW9uO1xuXHR9LFxuXG5cdGludmVydGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0XHRyZXR1cm4gZGV0ICYmIG5ldyBNYXRyaXgoXG5cdFx0XHRcdHRoaXMuX2QgLyBkZXQsXG5cdFx0XHRcdC10aGlzLl9jIC8gZGV0LFxuXHRcdFx0XHQtdGhpcy5fYiAvIGRldCxcblx0XHRcdFx0dGhpcy5fYSAvIGRldCxcblx0XHRcdFx0KHRoaXMuX2IgKiB0aGlzLl90eSAtIHRoaXMuX2QgKiB0aGlzLl90eCkgLyBkZXQsXG5cdFx0XHRcdCh0aGlzLl9jICogdGhpcy5fdHggLSB0aGlzLl9hICogdGhpcy5fdHkpIC8gZGV0KTtcblx0fSxcblxuXHRzaGlmdGxlc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIDAsIDApO1xuXHR9LFxuXG5cdGFwcGx5VG9Db250ZXh0OiBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHgudHJhbnNmb3JtKHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2EnLCAnYycsICdiJywgJ2QnLCAndHgnLCAndHknXSwgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRwcm9wID0gJ18nICsgbmFtZTtcblx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXNbcHJvcF07XG5cdH07XG5cdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpc1twcm9wXSA9IHZhbHVlO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5lID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdMaW5lJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBMaW5lKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcblx0XHR2YXIgYXNWZWN0b3IgPSBmYWxzZTtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG5cdFx0XHR0aGlzLl9weCA9IGFyZzA7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzE7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzI7XG5cdFx0XHR0aGlzLl92eSA9IGFyZzM7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMC54O1xuXHRcdFx0dGhpcy5fcHkgPSBhcmcwLnk7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzEueDtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMS55O1xuXHRcdFx0YXNWZWN0b3IgPSBhcmcyO1xuXHRcdH1cblx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHR0aGlzLl92eCAtPSB0aGlzLl9weDtcblx0XHRcdHRoaXMuX3Z5IC09IHRoaXMuX3B5O1xuXHRcdH1cblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl9weCwgdGhpcy5fcHkpO1xuXHR9LFxuXG5cdGdldFZlY3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl92eCwgdGhpcy5fdnkpO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmVjdG9yKCkuZ2V0TGVuZ3RoKCk7XG5cdH0sXG5cblx0aW50ZXJzZWN0OiBmdW5jdGlvbihsaW5lLCBpc0luZmluaXRlKSB7XG5cdFx0cmV0dXJuIExpbmUuaW50ZXJzZWN0KFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0bGluZS5fcHgsIGxpbmUuX3B5LCBsaW5lLl92eCwgbGluZS5fdnksXG5cdFx0XHRcdHRydWUsIGlzSW5maW5pdGUpO1xuXHR9LFxuXG5cdGdldFNpZGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIExpbmUuZ2V0U2lkZShcblx0XHRcdFx0dGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdHBvaW50LngsIHBvaW50LnksIHRydWUpO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiBNYXRoLmFicyhMaW5lLmdldFNpZ25lZERpc3RhbmNlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSkpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKGFweCwgYXB5LCBhdngsIGF2eSwgYnB4LCBicHksIGJ2eCwgYnZ5LCBhc1ZlY3Rvcixcblx0XHRcdFx0aXNJbmZpbml0ZSkge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHRhdnggLT0gYXB4O1xuXHRcdFx0XHRhdnkgLT0gYXB5O1xuXHRcdFx0XHRidnggLT0gYnB4O1xuXHRcdFx0XHRidnkgLT0gYnB5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNyb3NzID0gYnZ5ICogYXZ4IC0gYnZ4ICogYXZ5O1xuXHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKGNyb3NzKSkge1xuXHRcdFx0XHR2YXIgZHggPSBhcHggLSBicHgsXG5cdFx0XHRcdFx0ZHkgPSBhcHkgLSBicHksXG5cdFx0XHRcdFx0dGEgPSAoYnZ4ICogZHkgLSBidnkgKiBkeCkgLyBjcm9zcyxcblx0XHRcdFx0XHR0YiA9IChhdnggKiBkeSAtIGF2eSAqIGR4KSAvIGNyb3NzO1xuXHRcdFx0XHRpZiAoKGlzSW5maW5pdGUgfHwgMCA8PSB0YSAmJiB0YSA8PSAxKVxuXHRcdFx0XHRcdFx0JiYgKGlzSW5maW5pdGUgfHwgMCA8PSB0YiAmJiB0YiA8PSAxKSlcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0XHRcdGFweCArIHRhICogYXZ4LFxuXHRcdFx0XHRcdFx0XHRcdGFweSArIHRhICogYXZ5KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0U2lkZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdHZ4IC09IHB4O1xuXHRcdFx0XHR2eSAtPSBweTtcblx0XHRcdH1cblx0XHRcdHZhciB2MnggPSB4IC0gcHgsXG5cdFx0XHRcdHYyeSA9IHkgLSBweSxcblx0XHRcdFx0Y2N3ID0gdjJ4ICogdnkgLSB2MnkgKiB2eDsgXG5cdFx0XHRpZiAoY2N3ID09PSAwKSB7XG5cdFx0XHRcdGNjdyA9IHYyeCAqIHZ4ICsgdjJ5ICogdnk7IFxuXHRcdFx0XHRpZiAoY2N3ID4gMCkge1xuXHRcdFx0XHRcdHYyeCAtPSB2eDtcblx0XHRcdFx0XHR2MnkgLT0gdnk7XG5cdFx0XHRcdFx0Y2N3ID0gdjJ4ICogdnggKyB2MnkgKiB2eTtcblx0XHRcdFx0XHRpZiAoY2N3IDwgMClcblx0XHRcdFx0XHRcdGNjdyA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjY3cgPCAwID8gLTEgOiBjY3cgPiAwID8gMSA6IDA7XG5cdFx0fSxcblxuXHRcdGdldFNpZ25lZERpc3RhbmNlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0dnggLT0gcHg7XG5cdFx0XHRcdHZ5IC09IHB5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIG0gPSB2eSAvIHZ4LCBcblx0XHRcdFx0YiA9IHB5IC0gbSAqIHB4OyBcblx0XHRcdHJldHVybiAoeSAtIChtICogeCkgLSBiKSAvIE1hdGguc3FydChtICogbSArIDEpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBQcm9qZWN0ID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUHJvamVjdCcsXG5cdF9saXN0OiAncHJvamVjdHMnLFxuXHRfcmVmZXJlbmNlOiAncHJvamVjdCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUHJvamVjdChlbGVtZW50KSB7XG5cdFx0UGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzLCB0cnVlKTtcblx0XHR0aGlzLmxheWVycyA9IFtdO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcblx0XHR0aGlzLmFjdGl2ZUxheWVyID0gbmV3IExheWVyKCk7XG5cdFx0dGhpcy5fdmlldyA9IFZpZXcuY3JlYXRlKHRoaXMsXG5cdFx0XHRcdGVsZW1lbnQgfHwgQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKDEsIDEpKTtcblx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1zID0ge307XG5cdFx0dGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQgPSAwO1xuXHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24gPSAwO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5sYXllcnMsIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLmxheWVyc1tpXS5yZW1vdmUoKTtcblx0XHR0aGlzLnN5bWJvbHMgPSBbXTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5sYXllcnMubGVuZ3RoIDw9IDFcblx0XHRcdCYmICghdGhpcy5hY3RpdmVMYXllciB8fCB0aGlzLmFjdGl2ZUxheWVyLmlzRW1wdHkoKSk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0aWYgKCFyZW1vdmUuYmFzZS5jYWxsKHRoaXMpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0aGlzLl92aWV3KVxuXHRcdFx0dGhpcy5fdmlldy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmlldztcblx0fSxcblxuXHRnZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50U3R5bGU7XG5cdH0sXG5cblx0c2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZS5pbml0aWFsaXplKHN0eWxlKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGFkZENoaWxkOiBmdW5jdGlvbihjaGlsZCkge1xuXHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIExheWVyKSB7XG5cdFx0XHRCYXNlLnNwbGljZSh0aGlzLmxheWVycywgW2NoaWxkXSk7XG5cdFx0XHRpZiAoIXRoaXMuYWN0aXZlTGF5ZXIpXG5cdFx0XHRcdHRoaXMuYWN0aXZlTGF5ZXIgPSBjaGlsZDtcblx0XHR9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgSXRlbSkge1xuXHRcdFx0KHRoaXMuYWN0aXZlTGF5ZXJcblx0XHRcdFx0fHwgdGhpcy5hZGRDaGlsZChuZXcgTGF5ZXIoSXRlbS5OT19JTlNFUlQpKSkuYWRkQ2hpbGQoY2hpbGQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBjaGlsZDtcblx0fSxcblxuXHRnZXRTZWxlY3RlZEl0ZW1zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9zZWxlY3RlZEl0ZW1zKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX3NlbGVjdGVkSXRlbXNbaWRdO1xuXHRcdFx0aWYgKGl0ZW0uaXNJbnNlcnRlZCgpKVxuXHRcdFx0XHRpdGVtcy5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0Z2V0T3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlLnNldHRpbmdzO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgaWQgPSBpdGVtLl9pZCxcblx0XHRcdHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9zZWxlY3RlZEl0ZW1zO1xuXHRcdGlmIChpdGVtLl9zZWxlY3RlZCkge1xuXHRcdFx0aWYgKHNlbGVjdGVkSXRlbXNbaWRdICE9PSBpdGVtKSB7XG5cdFx0XHRcdHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50Kys7XG5cdFx0XHRcdHNlbGVjdGVkSXRlbXNbaWRdID0gaXRlbTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHNlbGVjdGVkSXRlbXNbaWRdID09PSBpdGVtKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudC0tO1xuXHRcdFx0ZGVsZXRlIHNlbGVjdGVkSXRlbXNbaWRdO1xuXHRcdH1cblx0fSxcblxuXHRzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXllcnMgPSB0aGlzLmxheWVycztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRsYXllcnNbaV0uc2V0RnVsbHlTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRkZXNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9zZWxlY3RlZEl0ZW1zO1xuXHRcdGZvciAodmFyIGkgaW4gc2VsZWN0ZWRJdGVtcylcblx0XHRcdHNlbGVjdGVkSXRlbXNbaV0uc2V0RnVsbHlTZWxlY3RlZChmYWxzZSk7XG5cdH0sXG5cblx0aGl0VGVzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0b3B0aW9ucyA9IEhpdFJlc3VsdC5nZXRPcHRpb25zKEJhc2UucmVhZChhcmd1bWVudHMpKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciByZXMgPSB0aGlzLmxheWVyc1tpXS5oaXRUZXN0KHBvaW50LCBvcHRpb25zKTtcblx0XHRcdGlmIChyZXMpIHJldHVybiByZXM7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLmxheWVycywgbWF0Y2gsIHRydWUpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMubGF5ZXJzLCBtYXRjaCwgZmFsc2UpO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5hY3RpdmVMYXllcjtcblx0XHRyZXR1cm4gQmFzZS5pbXBvcnRKU09OKGpzb24sIGxheWVyICYmIGxheWVyLmlzRW1wdHkoKSAmJiBsYXllcik7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHBpeGVsUmF0aW8pIHtcblx0XHR0aGlzLl91cGRhdGVWZXJzaW9uKys7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR2YXIgcGFyYW0gPSBuZXcgQmFzZSh7XG5cdFx0XHRvZmZzZXQ6IG5ldyBQb2ludCgwLCAwKSxcblx0XHRcdHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG5cdFx0XHR0cmFja1RyYW5zZm9ybXM6IHRydWUsXG5cdFx0XHR0cmFuc2Zvcm1zOiBbbWF0cml4XVxuXHRcdH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5sYXllcnNbaV0uZHJhdyhjdHgsIHBhcmFtKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXG5cdFx0aWYgKHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50ID4gMCkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zdHJva2VXaWR0aCA9IDE7XG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9zZWxlY3RlZEl0ZW1zKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gdGhpcy5fc2VsZWN0ZWRJdGVtc1tpZF0sXG5cdFx0XHRcdFx0Z2xvYmFsTWF0cml4ID0gaXRlbS5fZ2xvYmFsTWF0cml4LFxuXHRcdFx0XHRcdHNpemUgPSB0aGlzLl9zY29wZS5zZXR0aW5ncy5oYW5kbGVTaXplLFxuXHRcdFx0XHRcdGhhbGYgPSBzaXplIC8gMjtcblx0XHRcdFx0aWYgKGl0ZW0uX3VwZGF0ZVZlcnNpb24gPT09IHRoaXMuX3VwZGF0ZVZlcnNpb25cblx0XHRcdFx0XHRcdCYmIChpdGVtLl9kcmF3U2VsZWN0ZWQgfHwgaXRlbS5fYm91bmRzU2VsZWN0ZWQpXG5cdFx0XHRcdFx0XHQmJiBnbG9iYWxNYXRyaXgpIHtcblx0XHRcdFx0XHR2YXIgY29sb3IgPSBpdGVtLmdldFNlbGVjdGVkQ29sb3IoKVxuXHRcdFx0XHRcdFx0XHR8fCBpdGVtLmdldExheWVyKCkuZ2V0U2VsZWN0ZWRDb2xvcigpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvclxuXHRcdFx0XHRcdFx0XHQ/IGNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KSA6ICcjMDA5ZGVjJztcblx0XHRcdFx0XHRpZiAoaXRlbS5fZHJhd1NlbGVjdGVkKVxuXHRcdFx0XHRcdFx0aXRlbS5fZHJhd1NlbGVjdGVkKGN0eCwgZ2xvYmFsTWF0cml4KTtcblx0XHRcdFx0XHRpZiAoaXRlbS5fYm91bmRzU2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdHZhciBjb29yZHMgPSBnbG9iYWxNYXRyaXguX3RyYW5zZm9ybUNvcm5lcnMoXG5cdFx0XHRcdFx0XHRcdFx0aXRlbS5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuXHRcdFx0XHRcdFx0XHRjdHhbaSA9PT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29vcmRzW2ldLCBjb29yZHNbKytpXSk7XG5cdFx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKylcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGNvb3Jkc1tpXSAtIGhhbGYsIGNvb3Jkc1srK2ldIC0gaGFsZixcblx0XHRcdFx0XHRcdFx0XHRcdHNpemUsIHNpemUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU3ltYm9sID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTeW1ib2wnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbChpdGVtLCBkb250Q2VudGVyKSB7XG5cdFx0dGhpcy5faWQgPSBTeW1ib2wuX2lkID0gKFN5bWJvbC5faWQgfHwgMCkgKyAxO1xuXHRcdHRoaXMucHJvamVjdCA9IHBhcGVyLnByb2plY3Q7XG5cdFx0dGhpcy5wcm9qZWN0LnN5bWJvbHMucHVzaCh0aGlzKTtcblx0XHRpZiAoaXRlbSlcblx0XHRcdHRoaXMuc2V0RGVmaW5pdGlvbihpdGVtLCBkb250Q2VudGVyKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jbGFzcywgdGhpcy5fZGVmaW5pdGlvbl0sXG5cdFx0XHRcdFx0b3B0aW9ucywgZmFsc2UsIGRpY3Rpb25hcnkpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdHRoaXMucHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRnZXREZWZpbml0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcblx0fSxcblxuXHRzZXREZWZpbml0aW9uOiBmdW5jdGlvbihpdGVtLCBfZG9udENlbnRlcikge1xuXHRcdGlmIChpdGVtLl9wYXJlbnRTeW1ib2wpXG5cdFx0XHRpdGVtID0gaXRlbS5jbG9uZSgpO1xuXHRcdGlmICh0aGlzLl9kZWZpbml0aW9uKVxuXHRcdFx0dGhpcy5fZGVmaW5pdGlvbi5fcGFyZW50U3ltYm9sID0gbnVsbDtcblx0XHR0aGlzLl9kZWZpbml0aW9uID0gaXRlbTtcblx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdGl0ZW0uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuXHRcdGlmICghX2RvbnRDZW50ZXIpXG5cdFx0XHRpdGVtLnNldFBvc2l0aW9uKG5ldyBQb2ludCgpKTtcblx0XHRpdGVtLl9wYXJlbnRTeW1ib2wgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0cGxhY2U6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuIG5ldyBQbGFjZWRTeW1ib2wodGhpcywgcG9zaXRpb24pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFN5bWJvbCh0aGlzLl9kZWZpbml0aW9uLmNsb25lKGZhbHNlKSk7XG5cdH1cbn0pO1xuXG52YXIgSXRlbSA9IEJhc2UuZXh0ZW5kKENhbGxiYWNrLCB7XG5cdHN0YXRpY3M6IHtcblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcblx0XHRcdGlmIChzcmMuX3NlcmlhbGl6ZUZpZWxkcylcblx0XHRcdFx0c3JjLl9zZXJpYWxpemVGaWVsZHMgPSBuZXcgQmFzZShcblx0XHRcdFx0XHRcdHRoaXMucHJvdG90eXBlLl9zZXJpYWxpemVGaWVsZHMsIHNyYy5fc2VyaWFsaXplRmllbGRzKTtcblx0XHRcdHJldHVybiBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHROT19JTlNFUlQ6IHsgaW5zZXJ0OiBmYWxzZSB9XG5cdH0sXG5cblx0X2NsYXNzOiAnSXRlbScsXG5cdF9hcHBseU1hdHJpeDogdHJ1ZSxcblx0X2NhbkFwcGx5TWF0cml4OiB0cnVlLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IGZhbHNlLFxuXHRfc2VsZWN0Q2hpbGRyZW46IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0bmFtZTogbnVsbCxcblx0XHRtYXRyaXg6IG5ldyBNYXRyaXgoKSxcblx0XHRwaXZvdDogbnVsbCxcblx0XHRsb2NrZWQ6IGZhbHNlLFxuXHRcdHZpc2libGU6IHRydWUsXG5cdFx0YmxlbmRNb2RlOiAnbm9ybWFsJyxcblx0XHRvcGFjaXR5OiAxLFxuXHRcdGd1aWRlOiBmYWxzZSxcblx0XHRzZWxlY3RlZDogZmFsc2UsXG5cdFx0Y2xpcE1hc2s6IGZhbHNlLFxuXHRcdGFwcGx5TWF0cml4OiBudWxsLFxuXHRcdGRhdGE6IHt9XG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSXRlbSgpIHtcblx0fSxcblxuXHRfaW5pdGlhbGl6ZTogZnVuY3Rpb24ocHJvcHMsIHBvaW50KSB7XG5cdFx0dmFyIGludGVybmFsID0gcHJvcHMgJiYgcHJvcHMuaW50ZXJuYWwgPT09IHRydWUsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRwcm9qZWN0ID0gcGFwZXIucHJvamVjdDtcblx0XHRpZiAoIWludGVybmFsKVxuXHRcdFx0dGhpcy5faWQgPSBJdGVtLl9pZCA9IChJdGVtLl9pZCB8fCAwKSArIDE7XG5cdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiBwYXBlci5zZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRpZiAocG9pbnQpXG5cdFx0XHRtYXRyaXgudHJhbnNsYXRlKHBvaW50KTtcblx0XHRtYXRyaXguX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9zdHlsZSA9IG5ldyBTdHlsZShwcm9qZWN0Ll9jdXJyZW50U3R5bGUsIHRoaXMsIHByb2plY3QpO1xuXHRcdGlmICghdGhpcy5fcHJvamVjdCkge1xuXHRcdFx0aWYgKGludGVybmFsIHx8IHByb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdChwcm9qZWN0LmFjdGl2ZUxheWVyIHx8IG5ldyBMYXllcigpKS5hZGRDaGlsZCh0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHByb3BzICYmIHByb3BzICE9PSBJdGVtLk5PX0lOU0VSVFxuXHRcdFx0XHQ/IHRoaXMuX3NldChwcm9wcywgeyBpbnNlcnQ6IHRydWUgfSkgXG5cdFx0XHRcdDogdHJ1ZTtcblx0fSxcblxuXHRfZXZlbnRzOiBuZXcgZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbW91c2VGbGFncyA9IHtcblx0XHRcdG1vdXNlZG93bjoge1xuXHRcdFx0XHRtb3VzZWRvd246IDEsXG5cdFx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdFx0Y2xpY2s6IDEsXG5cdFx0XHRcdGRvdWJsZWNsaWNrOiAxXG5cdFx0XHR9LFxuXHRcdFx0bW91c2V1cDoge1xuXHRcdFx0XHRtb3VzZXVwOiAxLFxuXHRcdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0XHRkb3VibGVjbGljazogMVxuXHRcdFx0fSxcblx0XHRcdG1vdXNlbW92ZToge1xuXHRcdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRcdG1vdXNlbW92ZTogMSxcblx0XHRcdFx0bW91c2VlbnRlcjogMSxcblx0XHRcdFx0bW91c2VsZWF2ZTogMVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgbW91c2VFdmVudCA9IHtcblx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0dmFyIGNvdW50ZXJzID0gdGhpcy5nZXRWaWV3KCkuX2V2ZW50Q291bnRlcnM7XG5cdFx0XHRcdGlmIChjb3VudGVycykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBtb3VzZUZsYWdzKSB7XG5cdFx0XHRcdFx0XHRjb3VudGVyc1trZXldID0gKGNvdW50ZXJzW2tleV0gfHwgMClcblx0XHRcdFx0XHRcdFx0XHQrIChtb3VzZUZsYWdzW2tleV1bdHlwZV0gfHwgMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHZhciBjb3VudGVycyA9IHRoaXMuZ2V0VmlldygpLl9ldmVudENvdW50ZXJzO1xuXHRcdFx0XHRpZiAoY291bnRlcnMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbW91c2VGbGFncylcblx0XHRcdFx0XHRcdGNvdW50ZXJzW2tleV0gLT0gbW91c2VGbGFnc1trZXldW3R5cGVdIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIEJhc2UuZWFjaChbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbkNsaWNrJyxcblx0XHRcdCdvbkRvdWJsZUNsaWNrJywgJ29uTW91c2VNb3ZlJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnXSxcblx0XHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0dGhpc1tuYW1lXSA9IG1vdXNlRXZlbnQ7XG5cdFx0XHR9LCB7XG5cdFx0XHRcdG9uRnJhbWU6IHtcblx0XHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FuaW1hdGVJdGVtKHRydWUpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FuaW1hdGVJdGVtKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0b25Mb2FkOiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH0sXG5cblx0X2FuaW1hdGVJdGVtOiBmdW5jdGlvbihhbmltYXRlKSB7XG5cdFx0dGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIGFuaW1hdGUpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHR2YXIgcHJvcHMgPSB7fSxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZpZWxkcykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGF0W2tleV07XG5cdFx0XHRcdGlmICghQmFzZS5lcXVhbHModmFsdWUsIGtleSA9PT0gJ2xlYWRpbmcnXG5cdFx0XHRcdFx0XHQ/IGZpZWxkcy5mb250U2l6ZSAqIDEuMiA6IGZpZWxkc1trZXldKSkge1xuXHRcdFx0XHRcdHByb3BzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucyxcblx0XHRcdFx0XHRcdFx0a2V5ICE9PSAnZGF0YScsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VyaWFsaXplKHRoaXMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdHNlcmlhbGl6ZSh0aGlzLl9zdHlsZS5fZGVmYXVsdHMpO1xuXHRcdHJldHVybiBbIHRoaXMuX2NsYXNzLCBwcm9wcyBdO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdHZhciBzeW1ib2wgPSB0aGlzLl9wYXJlbnRTeW1ib2wsXG5cdFx0XHRjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCBzeW1ib2wsXG5cdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZWQgPVxuXHRcdFx0XHRcdHRoaXMuX2dsb2JhbE1hdHJpeCA9IHRoaXMuX2N1cnJlbnRQYXRoID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoY2FjaGVQYXJlbnQgJiYgKGZsYWdzXG5cdFx0XHRcdCYgKDggfCAzMikpKSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKGNhY2hlUGFyZW50KTtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMikge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKHByb2plY3QpIHtcblx0XHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHByb2plY3QuX2NoYW5nZXMpIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gcHJvamVjdC5fY2hhbmdlc0J5SWRbdGhpcy5faWRdO1xuXHRcdFx0XHRpZiAoZW50cnkpIHtcblx0XHRcdFx0XHRlbnRyeS5mbGFncyB8PSBmbGFncztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbnRyeSA9IHsgaXRlbTogdGhpcywgZmxhZ3M6IGZsYWdzIH07XG5cdFx0XHRcdFx0cHJvamVjdC5fY2hhbmdlc0J5SWRbdGhpcy5faWRdID0gZW50cnk7XG5cdFx0XHRcdFx0cHJvamVjdC5fY2hhbmdlcy5wdXNoKGVudHJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3ltYm9sKVxuXHRcdFx0c3ltYm9sLl9jaGFuZ2VkKGZsYWdzKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0aWYgKHByb3BzKVxuXHRcdFx0dGhpcy5fc2V0KHByb3BzLCB7IGluc2VydDogdHJ1ZSB9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkO1xuXHR9LFxuXG5cdGdldENsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsYXNzO1xuXHR9LFxuXG5cdGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9uYW1lO1xuXHR9LFxuXG5cdHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUsIHVuaXF1ZSkge1xuXG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdGlmIChuYW1lID09PSAoK25hbWUpICsgJycpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J05hbWVzIGNvbnNpc3Rpbmcgb25seSBvZiBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdGlmIChuYW1lICYmIHRoaXMuX3BhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IHRoaXMuX3BhcmVudC5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0b3JpZyA9IG5hbWUsXG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0d2hpbGUgKHVuaXF1ZSAmJiBjaGlsZHJlbltuYW1lXSlcblx0XHRcdFx0bmFtZSA9IG9yaWcgKyAnICcgKyAoaSsrKTtcblx0XHRcdChuYW1lZENoaWxkcmVuW25hbWVdID0gbmFtZWRDaGlsZHJlbltuYW1lXSB8fCBbXSkucHVzaCh0aGlzKTtcblx0XHRcdGNoaWxkcmVuW25hbWVdID0gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NoYW5nZWQoMTI4KTtcblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0eWxlO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuZ2V0U3R5bGUoKS5zZXQoc3R5bGUpO1xuXHR9LFxuXG5cdGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzRmlsbCgpO1xuXHR9LFxuXG5cdGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTdHJva2UoKTtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU2hhZG93KCk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2xvY2tlZCcsICd2aXNpYmxlJywgJ2JsZW5kTW9kZScsICdvcGFjaXR5JywgJ2d1aWRlJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdFx0fTtcblx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlICE9IHRoaXNbbmFtZV0pIHtcblx0XHRcdFx0dGhpc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKG5hbWUgPT09ICdfbG9ja2VkJ1xuXHRcdFx0XHRcdFx0PyAxMjggOiAxMjkpO1xuXHRcdFx0fVxuXHRcdH07XG59LCB7fSksIHtcblx0YmVhbnM6IHRydWUsXG5cblx0X2xvY2tlZDogZmFsc2UsXG5cblx0X3Zpc2libGU6IHRydWUsXG5cblx0X2JsZW5kTW9kZTogJ25vcm1hbCcsXG5cblx0X29wYWNpdHk6IDEsXG5cblx0X2d1aWRlOiBmYWxzZSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAodGhpcy5fY2hpbGRyZW5baV0uaXNTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkLCBub0NoaWxkcmVuKSB7XG5cdFx0aWYgKCFub0NoaWxkcmVuICYmIHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fY2hpbGRyZW5baV0uc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdH1cblx0XHRpZiAoKHNlbGVjdGVkID0gISFzZWxlY3RlZCkgXiB0aGlzLl9zZWxlY3RlZCkge1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcblx0XHRcdHRoaXMuX3Byb2plY3QuX3VwZGF0ZVNlbGVjdGlvbih0aGlzKTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTI5KTtcblx0XHR9XG5cdH0sXG5cblx0X3NlbGVjdGVkOiBmYWxzZSxcblxuXHRpc0Z1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9zZWxlY3RlZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGlmICghdGhpcy5fY2hpbGRyZW5baV0uaXNGdWxseVNlbGVjdGVkKCkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZDtcblx0fSxcblxuXHRzZXRGdWxseVNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLnNldEZ1bGx5U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdH1cblx0XHR0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkLCB0cnVlKTtcblx0fSxcblxuXHRpc0NsaXBNYXNrOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xpcE1hc2s7XG5cdH0sXG5cblx0c2V0Q2xpcE1hc2s6IGZ1bmN0aW9uKGNsaXBNYXNrKSB7XG5cdFx0aWYgKHRoaXMuX2NsaXBNYXNrICE9IChjbGlwTWFzayA9ICEhY2xpcE1hc2spKSB7XG5cdFx0XHR0aGlzLl9jbGlwTWFzayA9IGNsaXBNYXNrO1xuXHRcdFx0aWYgKGNsaXBNYXNrKSB7XG5cdFx0XHRcdHRoaXMuc2V0RmlsbENvbG9yKG51bGwpO1xuXHRcdFx0XHR0aGlzLnNldFN0cm9rZUNvbG9yKG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMjkpO1xuXHRcdFx0aWYgKHRoaXMuX3BhcmVudClcblx0XHRcdFx0dGhpcy5fcGFyZW50Ll9jaGFuZ2VkKDEwMjQpO1xuXHRcdH1cblx0fSxcblxuXHRfY2xpcE1hc2s6IGZhbHNlLFxuXG5cdGdldERhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fZGF0YSlcblx0XHRcdHRoaXMuX2RhdGEgPSB7fTtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YTtcblx0fSxcblxuXHRzZXREYXRhOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdH0sXG5cblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uLFxuXHRcdFx0Y3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0aWYgKCFwb3NpdGlvbikge1xuXHRcdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uID0gcGl2b3Rcblx0XHRcdFx0XHQ/IHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQocGl2b3QpXG5cdFx0XHRcdFx0OiB0aGlzLmdldEJvdW5kcygpLmdldENlbnRlcih0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHRoaXMsICdzZXRQb3NpdGlvbicpO1xuXHR9LFxuXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykuc3VidHJhY3QodGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9LFxuXG5cdGdldFBpdm90OiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRpZiAocGl2b3QpIHtcblx0XHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRcdHBpdm90ID0gbmV3IGN0b3IocGl2b3QueCwgcGl2b3QueSwgdGhpcywgJ3NldEFuY2hvcicpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGl2b3Q7XG5cdH0sXG5cblx0c2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Bpdm90ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9waXZvdDogbnVsbCxcblxuXHRnZXRSZWdpc3RyYXRpb246ICcjZ2V0UGl2b3QnLFxuXHRzZXRSZWdpc3RyYXRpb246ICcjc2V0UGl2b3QnXG59LCBCYXNlLmVhY2goWydib3VuZHMnLCAnc3Ryb2tlQm91bmRzJywgJ2hhbmRsZUJvdW5kcycsICdyb3VnaEJvdW5kcycsXG5cdFx0J2ludGVybmFsQm91bmRzJywgJ2ludGVybmFsUm91Z2hCb3VuZHMnXSxcblx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIGdldHRlciA9ICdnZXQnICsgQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRtYXRjaCA9IGtleS5tYXRjaCgvXmludGVybmFsKC4qKSQvKSxcblx0XHRcdGludGVybmFsR2V0dGVyID0gbWF0Y2ggPyAnZ2V0JyArIG1hdGNoWzFdIDogbnVsbDtcblx0XHR0aGlzW2dldHRlcl0gPSBmdW5jdGlvbihfbWF0cml4KSB7XG5cdFx0XHR2YXIgYm91bmRzR2V0dGVyID0gdGhpcy5fYm91bmRzR2V0dGVyLFxuXHRcdFx0XHRuYW1lID0gIWludGVybmFsR2V0dGVyICYmICh0eXBlb2YgYm91bmRzR2V0dGVyID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBib3VuZHNHZXR0ZXIgOiBib3VuZHNHZXR0ZXIgJiYgYm91bmRzR2V0dGVyW2dldHRlcl0pXG5cdFx0XHRcdFx0XHR8fCBnZXR0ZXIsXG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuX2dldENhY2hlZEJvdW5kcyhuYW1lLCBfbWF0cml4LCBudWxsLFxuXHRcdFx0XHRcdFx0aW50ZXJuYWxHZXR0ZXIpO1xuXHRcdFx0cmV0dXJuIGtleSA9PT0gJ2JvdW5kcydcblx0XHRcdFx0XHQ/IG5ldyBMaW5rZWRSZWN0YW5nbGUoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQsIHRoaXMsICdzZXRCb3VuZHMnKVxuXHRcdFx0XHRcdDogYm91bmRzO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHR2YXIgeDEgPSBJbmZpbml0eSxcblx0XHRcdHgyID0gLXgxLFxuXHRcdFx0eTEgPSB4MSxcblx0XHRcdHkyID0geDI7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkLl92aXNpYmxlICYmICFjaGlsZC5pc0VtcHR5KCkpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBjaGlsZC5fZ2V0Q2FjaGVkQm91bmRzKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pO1xuXHRcdFx0XHR4MSA9IE1hdGgubWluKHJlY3QueCwgeDEpO1xuXHRcdFx0XHR5MSA9IE1hdGgubWluKHJlY3QueSwgeTEpO1xuXHRcdFx0XHR4MiA9IE1hdGgubWF4KHJlY3QueCArIHJlY3Qud2lkdGgsIHgyKTtcblx0XHRcdFx0eTIgPSBNYXRoLm1heChyZWN0LnkgKyByZWN0LmhlaWdodCwgeTIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaXNGaW5pdGUoeDEpXG5cdFx0XHRcdD8gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpXG5cdFx0XHRcdDogbmV3IFJlY3RhbmdsZSgpO1xuXHR9LFxuXG5cdHNldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKCk7XG5cdFx0bWF0cml4LnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdGlmIChyZWN0LndpZHRoICE9IGJvdW5kcy53aWR0aCB8fCByZWN0LmhlaWdodCAhPSBib3VuZHMuaGVpZ2h0KSB7XG5cdFx0XHRtYXRyaXguc2NhbGUoXG5cdFx0XHRcdFx0Ym91bmRzLndpZHRoICE9IDAgPyByZWN0LndpZHRoIC8gYm91bmRzLndpZHRoIDogMSxcblx0XHRcdFx0XHRib3VuZHMuaGVpZ2h0ICE9IDAgPyByZWN0LmhlaWdodCAvIGJvdW5kcy5oZWlnaHQgOiAxKTtcblx0XHR9XG5cdFx0Y2VudGVyID0gYm91bmRzLmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoLWNlbnRlci54LCAtY2VudGVyLnkpO1xuXHRcdHRoaXMudHJhbnNmb3JtKG1hdHJpeCk7XG5cdH0sXG5cblx0X2dldENhY2hlZEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSwgaW50ZXJuYWxHZXR0ZXIpIHtcblx0XHRtYXRyaXggPSBtYXRyaXggJiYgbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKTtcblx0XHR2YXIgX21hdHJpeCA9IGludGVybmFsR2V0dGVyID8gbnVsbCA6IHRoaXMuX21hdHJpeC5vck51bGxJZklkZW50aXR5KCksXG5cdFx0XHRjYWNoZSA9ICghbWF0cml4IHx8IG1hdHJpeC5lcXVhbHMoX21hdHJpeCkpICYmIGdldHRlcjtcblx0XHR2YXIgY2FjaGVQYXJlbnQgPSB0aGlzLl9wYXJlbnQgfHwgdGhpcy5fcGFyZW50U3ltYm9sO1xuXHRcdGlmIChjYWNoZUl0ZW0gJiYgY2FjaGVQYXJlbnQpIHtcblx0XHRcdHZhciBpZCA9IGNhY2hlSXRlbS5faWQsXG5cdFx0XHRcdHJlZiA9IGNhY2hlUGFyZW50Ll9ib3VuZHNDYWNoZSA9IGNhY2hlUGFyZW50Ll9ib3VuZHNDYWNoZSB8fCB7XG5cdFx0XHRcdFx0aWRzOiB7fSxcblx0XHRcdFx0XHRsaXN0OiBbXVxuXHRcdFx0XHR9O1xuXHRcdFx0aWYgKCFyZWYuaWRzW2lkXSkge1xuXHRcdFx0XHRyZWYubGlzdC5wdXNoKGNhY2hlSXRlbSk7XG5cdFx0XHRcdHJlZi5pZHNbaWRdID0gY2FjaGVJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2FjaGUgJiYgdGhpcy5fYm91bmRzICYmIHRoaXMuX2JvdW5kc1tjYWNoZV0pXG5cdFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzW2NhY2hlXS5jbG9uZSgpO1xuXHRcdG1hdHJpeCA9ICFtYXRyaXhcblx0XHRcdFx0PyBfbWF0cml4XG5cdFx0XHRcdDogX21hdHJpeFxuXHRcdFx0XHRcdD8gbWF0cml4LmNsb25lKCkuY29uY2F0ZW5hdGUoX21hdHJpeClcblx0XHRcdFx0XHQ6IG1hdHJpeDtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0Qm91bmRzKGludGVybmFsR2V0dGVyIHx8IGdldHRlciwgbWF0cml4LFxuXHRcdFx0XHRjYWNoZSA/IHRoaXMgOiBjYWNoZUl0ZW0pO1xuXHRcdGlmIChjYWNoZSkge1xuXHRcdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHRcdHRoaXMuX2JvdW5kcyA9IHt9O1xuXHRcdFx0dmFyIGNhY2hlZCA9IHRoaXMuX2JvdW5kc1tjYWNoZV0gPSBib3VuZHMuY2xvbmUoKTtcblx0XHRcdGNhY2hlZC5faW50ZXJuYWwgPSAhIWludGVybmFsR2V0dGVyO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRfY2xlYXJCb3VuZHNDYWNoZTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGl0ZW0uX2JvdW5kc0NhY2hlKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsaXN0ID0gaXRlbS5fYm91bmRzQ2FjaGUubGlzdCwgbCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IGxpc3RbaV07XG5cdFx0XHRcdFx0Y2hpbGQuX2JvdW5kcyA9IGNoaWxkLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRpZiAoY2hpbGQgIT09IGl0ZW0gJiYgY2hpbGQuX2JvdW5kc0NhY2hlKVxuXHRcdFx0XHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZShjaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aXRlbS5fYm91bmRzQ2FjaGUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn0pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9kZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQgfHwgdGhpcy5fZGVjb21wb3NlKCk7XG5cdFx0cmV0dXJuIGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5yb3RhdGlvbjtcblx0fSxcblxuXHRzZXRSb3RhdGlvbjogZnVuY3Rpb24ocm90YXRpb24pIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblx0XHRpZiAoY3VycmVudCAhPSBudWxsICYmIHJvdGF0aW9uICE9IG51bGwpIHtcblx0XHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZDtcblx0XHRcdHRoaXMucm90YXRlKHJvdGF0aW9uIC0gY3VycmVudCk7XG5cdFx0XHRkZWNvbXBvc2VkLnJvdGF0aW9uID0gcm90YXRpb247XG5cdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkIHx8IHRoaXMuX2RlY29tcG9zZSgpO1xuXHRcdHJldHVybiBkZWNvbXBvc2VkICYmIGRlY29tcG9zZWQuc2NhbGluZztcblx0fSxcblxuXHRzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpO1xuXHRcdGlmIChjdXJyZW50ICE9IG51bGwpIHtcblx0XHRcdHZhciBzY2FsaW5nID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgY2xvbmU6IHRydWUgfSksXG5cdFx0XHRcdGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuXHRcdFx0dGhpcy5zY2FsZShzY2FsaW5nLnggLyBjdXJyZW50LngsIHNjYWxpbmcueSAvIGN1cnJlbnQueSk7XG5cdFx0XHRkZWNvbXBvc2VkLnNjYWxpbmcgPSBzY2FsaW5nO1xuXHRcdFx0dGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeDtcblx0fSxcblxuXHRzZXRNYXRyaXg6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHRoaXMuX21hdHJpeC5pbml0aWFsaXplKG1hdHJpeCk7XG5cdFx0aWYgKHRoaXMuX2FwcGx5TWF0cml4KSB7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0R2xvYmFsTWF0cml4OiBmdW5jdGlvbihfaW50ZXJuYWwpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4LFxuXHRcdFx0dXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb24sXG5cdFx0XHR2aWV3TWF0cml4ID0gdGhpcy5nZXRWaWV3KCkuX21hdHJpeDtcblx0XHRpZiAobWF0cml4ICYmIG1hdHJpeC5fdXBkYXRlVmVyc2lvbiAhPT0gdXBkYXRlVmVyc2lvbilcblx0XHRcdG1hdHJpeCA9IG51bGw7XG5cdFx0aWYgKCFtYXRyaXgpIHtcblx0XHRcdG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeCA9IHRoaXMuX21hdHJpeC5jbG9uZSgpO1xuXHRcdFx0bWF0cml4LnByZUNvbmNhdGVuYXRlKHRoaXMuX3BhcmVudFxuXHRcdFx0XHRcdD8gdGhpcy5fcGFyZW50LmdldEdsb2JhbE1hdHJpeCh0cnVlKVxuXHRcdFx0XHRcdDogdmlld01hdHJpeCk7XG5cdFx0XHRtYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gX2ludGVybmFsID8gbWF0cml4IDogdmlld01hdHJpeC5pbnZlcnRlZCgpLmNvbmNhdGVuYXRlKG1hdHJpeCk7XG5cdH0sXG5cblx0Z2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBseU1hdHJpeDtcblx0fSxcblxuXHRzZXRBcHBseU1hdHJpeDogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG5cdFx0aWYgKHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgISF0cmFuc2Zvcm0pXG5cdFx0XHR0aGlzLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0fSxcblxuXHRnZXRUcmFuc2Zvcm1Db250ZW50OiAnI2dldEFwcGx5TWF0cml4Jyxcblx0c2V0VHJhbnNmb3JtQ29udGVudDogJyNzZXRBcHBseU1hdHJpeCcsXG59LCB7XG5cdGdldFByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0O1xuXHR9LFxuXG5cdF9zZXRQcm9qZWN0OiBmdW5jdGlvbihwcm9qZWN0LCBpbnN0YWxsRXZlbnRzKSB7XG5cdFx0aWYgKHRoaXMuX3Byb2plY3QgIT09IHByb2plY3QpIHtcblx0XHRcdGlmICh0aGlzLl9wcm9qZWN0KVxuXHRcdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uX3NldFByb2plY3QocHJvamVjdCk7XG5cdFx0XHRpbnN0YWxsRXZlbnRzID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKGluc3RhbGxFdmVudHMpXG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKHRydWUpO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0LmdldFZpZXcoKTtcblx0fSxcblxuXHRfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24gX2luc3RhbGxFdmVudHMoaW5zdGFsbCkge1xuXHRcdF9pbnN0YWxsRXZlbnRzLmJhc2UuY2FsbCh0aGlzLCBpbnN0YWxsKTtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLl9pbnN0YWxsRXZlbnRzKGluc3RhbGwpO1xuXHR9LFxuXG5cdGdldExheWVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcztcblx0XHR3aGlsZSAocGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBMYXllcilcblx0XHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50O1xuXHR9LFxuXG5cdHNldFBhcmVudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLmFkZENoaWxkKHRoaXMpO1xuXHR9LFxuXG5cdGdldENoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XG5cdH0sXG5cblx0c2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0dGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuXHRcdHRoaXMuYWRkQ2hpbGRyZW4oaXRlbXMpO1xuXHR9LFxuXG5cdGdldEZpcnN0Q2hpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldExhc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuW3RoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDFdXG5cdFx0XHRcdHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TmV4dFNpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50Ll9jaGlsZHJlblt0aGlzLl9pbmRleCArIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5fY2hpbGRyZW5bdGhpcy5faW5kZXggLSAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pc0luc2VydGVkKCkgOiBmYWxzZTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA9PT0gdGhpcyB8fCBpdGVtICYmIHRoaXMuX2NsYXNzID09PSBpdGVtLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdHlsZS5lcXVhbHMoaXRlbS5fc3R5bGUpXG5cdFx0XHRcdCYmIHRoaXMuX21hdHJpeC5lcXVhbHMoaXRlbS5fbWF0cml4KVxuXHRcdFx0XHQmJiB0aGlzLl9sb2NrZWQgPT09IGl0ZW0uX2xvY2tlZFxuXHRcdFx0XHQmJiB0aGlzLl92aXNpYmxlID09PSBpdGVtLl92aXNpYmxlXG5cdFx0XHRcdCYmIHRoaXMuX2JsZW5kTW9kZSA9PT0gaXRlbS5fYmxlbmRNb2RlXG5cdFx0XHRcdCYmIHRoaXMuX29wYWNpdHkgPT09IGl0ZW0uX29wYWNpdHlcblx0XHRcdFx0JiYgdGhpcy5fY2xpcE1hc2sgPT09IGl0ZW0uX2NsaXBNYXNrXG5cdFx0XHRcdCYmIHRoaXMuX2d1aWRlID09PSBpdGVtLl9ndWlkZVxuXHRcdFx0XHQmJiB0aGlzLl9lcXVhbHMoaXRlbSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBCYXNlLmVxdWFscyh0aGlzLl9jaGlsZHJlbiwgaXRlbS5fY2hpbGRyZW4pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUobmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLCBpbnNlcnQpO1xuXHR9LFxuXG5cdF9jbG9uZTogZnVuY3Rpb24oY29weSwgaW5zZXJ0KSB7XG5cdFx0Y29weS5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y29weS5hZGRDaGlsZCh0aGlzLl9jaGlsZHJlbltpXS5jbG9uZShmYWxzZSksIHRydWUpO1xuXHRcdH1cblx0XHRpZiAoaW5zZXJ0IHx8IGluc2VydCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0Y29weS5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHR2YXIga2V5cyA9IFsnX2xvY2tlZCcsICdfdmlzaWJsZScsICdfYmxlbmRNb2RlJywgJ19vcGFjaXR5Jyxcblx0XHRcdFx0J19jbGlwTWFzaycsICdfZ3VpZGUnLCAnX2FwcGx5TWF0cml4J107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuXHRcdFx0XHRjb3B5W2tleV0gPSB0aGlzW2tleV07XG5cdFx0fVxuXHRcdGNvcHkuX21hdHJpeC5pbml0aWFsaXplKHRoaXMuX21hdHJpeCk7XG5cdFx0Y29weS5fZGF0YSA9IHRoaXMuX2RhdGEgPyBCYXNlLmNsb25lKHRoaXMuX2RhdGEpIDogbnVsbDtcblx0XHRjb3B5LnNldFNlbGVjdGVkKHRoaXMuX3NlbGVjdGVkKTtcblx0XHRpZiAodGhpcy5fbmFtZSlcblx0XHRcdGNvcHkuc2V0TmFtZSh0aGlzLl9uYW1lLCB0cnVlKTtcblx0XHRyZXR1cm4gY29weTtcblx0fSxcblxuXHRjb3B5VG86IGZ1bmN0aW9uKGl0ZW1PclByb2plY3QpIHtcblx0XHRyZXR1cm4gaXRlbU9yUHJvamVjdC5hZGRDaGlsZCh0aGlzLmNsb25lKGZhbHNlKSk7XG5cdH0sXG5cblx0cmFzdGVyaXplOiBmdW5jdGlvbihyZXNvbHV0aW9uKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKCksXG5cdFx0XHRzY2FsZSA9IChyZXNvbHV0aW9uIHx8IHRoaXMuZ2V0VmlldygpLmdldFJlc29sdXRpb24oKSkgLyA3Mixcblx0XHRcdHRvcExlZnQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCksXG5cdFx0XHRib3R0b21SaWdodCA9IGJvdW5kcy5nZXRCb3R0b21SaWdodCgpLmNlaWwoKSxcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShib3R0b21SaWdodC5zdWJ0cmFjdCh0b3BMZWZ0KSksXG5cdFx0XHRjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZS5tdWx0aXBseShzY2FsZSkpLFxuXHRcdFx0Y3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkuc2NhbGUoc2NhbGUpLnRyYW5zbGF0ZSh0b3BMZWZ0Lm5lZ2F0ZSgpKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHRoaXMuZHJhdyhjdHgsIG5ldyBCYXNlKHsgdHJhbnNmb3JtczogW21hdHJpeF0gfSkpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJhc3Rlci5zZXRDYW52YXMoY2FudmFzKTtcblx0XHRyYXN0ZXIudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUodG9wTGVmdC5hZGQoc2l6ZS5kaXZpZGUoMikpKVxuXHRcdFx0XHQuc2NhbGUoMSAvIHNjYWxlKSk7XG5cdFx0cmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiByYXN0ZXI7XG5cdH0sXG5cblx0Y29udGFpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2NvbnRhaW5zKFxuXHRcdFx0XHR0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jaGlsZHJlbltpXS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludC5pc0luc2lkZSh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuXHR9LFxuXG5cdGhpdFRlc3Q6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0b3B0aW9ucyA9IEhpdFJlc3VsdC5nZXRPcHRpb25zKEJhc2UucmVhZChhcmd1bWVudHMpKTtcblx0XHRpZiAodGhpcy5fbG9ja2VkIHx8ICF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX2d1aWRlICYmICFvcHRpb25zLmd1aWRlc1xuXHRcdFx0XHR8fCB0aGlzLmlzRW1wdHkoKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdHBhcmVudFRvdGFsTWF0cml4ID0gb3B0aW9ucy5fdG90YWxNYXRyaXgsXG5cdFx0XHR2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG5cdFx0XHR0b3RhbE1hdHJpeCA9IG9wdGlvbnMuX3RvdGFsTWF0cml4ID0gcGFyZW50VG90YWxNYXRyaXhcblx0XHRcdFx0XHQ/IHBhcmVudFRvdGFsTWF0cml4LmNsb25lKCkuY29uY2F0ZW5hdGUobWF0cml4KVxuXHRcdFx0XHRcdDogdGhpcy5nZXRHbG9iYWxNYXRyaXgoKS5jbG9uZSgpLnByZUNvbmNhdGVuYXRlKFxuXHRcdFx0XHRcdFx0XHR2aWV3Ll9tYXRyaXgpLFxuXHRcdFx0dG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcgPSBuZXcgU2l6ZShcblx0XHRcdFx0XHRcdFBhdGguX2dldFBlblBhZGRpbmcoMSwgdG90YWxNYXRyaXguaW52ZXJ0ZWQoKSlcblx0XHRcdFx0XHQpLm11bHRpcGx5KFxuXHRcdFx0XHRcdFx0TWF0aC5tYXgob3B0aW9ucy50b2xlcmFuY2UsIDAuMDAwMDEpXG5cdFx0XHRcdFx0KTtcblx0XHRwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShwb2ludCk7XG5cblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuICYmICF0aGlzLmdldEludGVybmFsUm91Z2hCb3VuZHMoKVxuXHRcdFx0XHQuZXhwYW5kKHRvbGVyYW5jZVBhZGRpbmcubXVsdGlwbHkoMikpLl9jb250YWluc1BvaW50KHBvaW50KSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciB0eXBlLFxuXHRcdFx0Y2hlY2tTZWxmID0gIShvcHRpb25zLmd1aWRlcyAmJiAhdGhpcy5fZ3VpZGVcblx0XHRcdFx0fHwgb3B0aW9ucy5zZWxlY3RlZCAmJiAhdGhpcy5fc2VsZWN0ZWRcblx0XHRcdFx0fHwgKHR5cGUgPSBvcHRpb25zLnR5cGUpICYmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZydcblx0XHRcdFx0XHRcdD8gdHlwZSAhPT0gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpXG5cdFx0XHRcdFx0XHQ6ICEodGhpcyBpbnN0YW5jZW9mIHR5cGUpKSksXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdHJlcztcblxuXHRcdGZ1bmN0aW9uIGNoZWNrQm91bmRzKHR5cGUsIHBhcnQpIHtcblx0XHRcdHZhciBwdCA9IGJvdW5kc1snZ2V0JyArIHBhcnRdKCk7XG5cdFx0XHRpZiAocG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZSh0b2xlcmFuY2VQYWRkaW5nKS5sZW5ndGggPD0gMSlcblx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQodHlwZSwgdGhhdCxcblx0XHRcdFx0XHRcdHsgbmFtZTogQmFzZS5oeXBoZW5hdGUocGFydCksIHBvaW50OiBwdCB9KTtcblx0XHR9XG5cblx0XHRpZiAoY2hlY2tTZWxmICYmIChvcHRpb25zLmNlbnRlciB8fCBvcHRpb25zLmJvdW5kcykgJiYgdGhpcy5fcGFyZW50KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpO1xuXHRcdFx0aWYgKG9wdGlvbnMuY2VudGVyKVxuXHRcdFx0XHRyZXMgPSBjaGVja0JvdW5kcygnY2VudGVyJywgJ0NlbnRlcicpO1xuXHRcdFx0aWYgKCFyZXMgJiYgb3B0aW9ucy5ib3VuZHMpIHtcblx0XHRcdFx0dmFyIHBvaW50cyA9IFtcblx0XHRcdFx0XHQnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0Jyxcblx0XHRcdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ1xuXHRcdFx0XHRdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDggJiYgIXJlczsgaSsrKVxuXHRcdFx0XHRcdHJlcyA9IGNoZWNrQm91bmRzKCdib3VuZHMnLCBwb2ludHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGlsZHJlbiA9ICFyZXMgJiYgdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHR2YXIgb3B0cyA9IHRoaXMuX2dldENoaWxkSGl0VGVzdE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwICYmICFyZXM7IGktLSlcblx0XHRcdFx0cmVzID0gY2hpbGRyZW5baV0uaGl0VGVzdChwb2ludCwgb3B0cyk7XG5cdFx0fVxuXHRcdGlmICghcmVzICYmIGNoZWNrU2VsZilcblx0XHRcdHJlcyA9IHRoaXMuX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdGlmIChyZXMgJiYgcmVzLnBvaW50KVxuXHRcdFx0cmVzLnBvaW50ID0gbWF0cml4LnRyYW5zZm9ybShyZXMucG9pbnQpO1xuXHRcdG9wdGlvbnMuX3RvdGFsTWF0cml4ID0gcGFyZW50VG90YWxNYXRyaXg7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfZ2V0Q2hpbGRIaXRUZXN0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9LFxuXG5cdF9oaXRUZXN0OiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zLmZpbGwgJiYgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKTtcblx0fVxufSwgeyBcblx0bWF0Y2hlczogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRmdW5jdGlvbiBtYXRjaE9iamVjdChvYmoxLCBvYmoyKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG9iajEpIHtcblx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsMSA9IG9iajFbaV0sXG5cdFx0XHRcdFx0XHR2YWwyID0gb2JqMltpXTtcblx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KHZhbDEpICYmIEJhc2UuaXNQbGFpbk9iamVjdCh2YWwyKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaE9iamVjdCh2YWwxLCB2YWwyKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbDEsIHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yICh2YXIga2V5IGluIG1hdGNoKSB7XG5cdFx0XHRpZiAobWF0Y2guaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzW2tleV0sXG5cdFx0XHRcdFx0Y29tcGFyZSA9IG1hdGNoW2tleV07XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGtleSA9PT0gJ3R5cGUnKVxuXHRcdFx0XHRcdHZhbHVlID0gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpO1xuXHRcdFx0XHRpZiAoL14oY29uc3RydWN0b3J8Y2xhc3MpJC8udGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIGNvbXBhcmUpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNvbXBhcmUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdFx0XHRpZiAoIWNvbXBhcmUudGVzdCh2YWx1ZSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRpZiAoIWNvbXBhcmUodmFsdWUpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChjb21wYXJlKSkge1xuXHRcdFx0XHRcdGlmICghbWF0Y2hPYmplY3QoY29tcGFyZSwgdmFsdWUpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwgY29tcGFyZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMuX2NoaWxkcmVuLCBtYXRjaCwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5fY2hpbGRyZW4sIG1hdGNoLCBmYWxzZSk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF9nZXRJdGVtczogZnVuY3Rpb24gX2dldEl0ZW1zKGNoaWxkcmVuLCBtYXRjaCwgbGlzdCkge1xuXHRcdFx0dmFyIGl0ZW1zID0gbGlzdCAmJiBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubWF0Y2hlcyhtYXRjaCkpIHtcblx0XHRcdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRcdFx0aXRlbXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBjaGlsZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHJlcyA9IF9nZXRJdGVtcyhjaGlsZC5fY2hpbGRyZW4sIG1hdGNoLCBsaXN0KTtcblx0XHRcdFx0aWYgKGxpc3QpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoLmFwcGx5KGl0ZW1zLCByZXMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlcykge1xuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBsaXN0ID8gaXRlbXMgOiBudWxsO1xuXHRcdH1cblx0fVxufSwge1xuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR2YXIgcmVzID0gQmFzZS5pbXBvcnRKU09OKGpzb24sIHRoaXMpO1xuXHRcdHJldHVybiByZXMgIT09IHRoaXNcblx0XHRcdFx0PyB0aGlzLmFkZENoaWxkKHJlcylcblx0XHRcdFx0OiByZXM7XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZDogZnVuY3Rpb24oaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHZhciByZXMgPSB0aGlzLmluc2VydENoaWxkcmVuKGluZGV4LCBbaXRlbV0sIF9wcmVzZXJ2ZSk7XG5cdFx0cmV0dXJuIHJlcyAmJiByZXNbMF07XG5cdH0sXG5cblx0YWRkQ2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZHJlbih0aGlzLl9jaGlsZHJlbi5sZW5ndGgsIGl0ZW1zLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbihpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSwgX3Byb3RvKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdGl0ZW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGl0ZW1zKTtcblx0XHRcdGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRpZiAoX3Byb3RvICYmICEoaXRlbSBpbnN0YW5jZW9mIF9wcm90bykpIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QmFzZS5zcGxpY2UoY2hpbGRyZW4sIGl0ZW1zLCBpbmRleCwgMCk7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdG5vdGlmeVNlbGYgPSBwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRpdGVtLl9wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRpdGVtLl9zZXRQcm9qZWN0KHRoaXMuX3Byb2plY3QsIHRydWUpO1xuXHRcdFx0XHRpZiAoaXRlbS5fbmFtZSlcblx0XHRcdFx0XHRpdGVtLnNldE5hbWUoaXRlbS5fbmFtZSk7XG5cdFx0XHRcdGlmIChub3RpZnlTZWxmKVxuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlbXMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0X2luc2VydDogZnVuY3Rpb24oYWJvdmUsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdGlmICghaXRlbS5fcGFyZW50KVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGluZGV4ID0gaXRlbS5faW5kZXggKyAoYWJvdmUgPyAxIDogMCk7XG5cdFx0aWYgKGl0ZW0uX3BhcmVudCA9PT0gdGhpcy5fcGFyZW50ICYmIGluZGV4ID4gdGhpcy5faW5kZXgpXG5cdFx0XHQgaW5kZXgtLTtcblx0XHRyZXR1cm4gaXRlbS5fcGFyZW50Lmluc2VydENoaWxkKGluZGV4LCB0aGlzLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydEFib3ZlOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0KHRydWUsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0QmVsb3c6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHQgXHRyZXR1cm4gdGhpcy5faW5zZXJ0KGZhbHNlLCBpdGVtLCBfcHJlc2VydmUpO1xuXHQgfSxcblxuXHRzZW5kVG9CYWNrOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydENoaWxkKDAsIHRoaXMpO1xuXHR9LFxuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudC5hZGRDaGlsZCh0aGlzKTtcblx0fSxcblxuXHRhcHBlbmRUb3A6ICcjYWRkQ2hpbGQnLFxuXG5cdGFwcGVuZEJvdHRvbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKDAsIGl0ZW0pO1xuXHR9LFxuXG5cdG1vdmVBYm92ZTogJyNpbnNlcnRBYm92ZScsXG5cblx0bW92ZUJlbG93OiAnI2luc2VydEJlbG93JyxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuWzBdLnJlZHVjZSgpO1xuXHRcdFx0Y2hpbGQuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRjaGlsZC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcmVtb3ZlTmFtZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX3BhcmVudC5fY2hpbGRyZW4sXG5cdFx0XHRuYW1lZENoaWxkcmVuID0gdGhpcy5fcGFyZW50Ll9uYW1lZENoaWxkcmVuLFxuXHRcdFx0bmFtZSA9IHRoaXMuX25hbWUsXG5cdFx0XHRuYW1lZEFycmF5ID0gbmFtZWRDaGlsZHJlbltuYW1lXSxcblx0XHRcdGluZGV4ID0gbmFtZWRBcnJheSA/IG5hbWVkQXJyYXkuaW5kZXhPZih0aGlzKSA6IC0xO1xuXHRcdGlmIChpbmRleCA9PSAtMSlcblx0XHRcdHJldHVybjtcblx0XHRpZiAoY2hpbGRyZW5bbmFtZV0gPT0gdGhpcylcblx0XHRcdGRlbGV0ZSBjaGlsZHJlbltuYW1lXTtcblx0XHRuYW1lZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cdFx0aWYgKG5hbWVkQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRjaGlsZHJlbltuYW1lXSA9IG5hbWVkQXJyYXlbbmFtZWRBcnJheS5sZW5ndGggLSAxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIG5hbWVkQ2hpbGRyZW5bbmFtZV07XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uKG5vdGlmeVNlbGYsIG5vdGlmeVBhcmVudCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0XHRpZiAodGhpcy5faW5kZXggIT0gbnVsbClcblx0XHRcdFx0QmFzZS5zcGxpY2UocGFyZW50Ll9jaGlsZHJlbiwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHRpZiAobm90aWZ5U2VsZikge1xuXHRcdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRcdGlmIChwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXMpXG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdGlmIChub3RpZnlQYXJlbnQpXG5cdFx0XHRcdHBhcmVudC5fY2hhbmdlZCgxMSk7XG5cdFx0XHR0aGlzLl9wYXJlbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdH0sXG5cblx0cmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0aWYgKCF0aGlzLl9jaGlsZHJlbilcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGZyb20gPSBmcm9tIHx8IDA7XG5cdFx0dG8gPSBCYXNlLnBpY2sodG8sIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG5cdFx0dmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgZnJvbSwgdG8gLSBmcm9tKTtcblx0XHRmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0cmVtb3ZlZFtpXS5fcmVtb3ZlKHRydWUsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKHJlbW92ZWQubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZUNoaWxkcmVuJyxcblxuXHRyZXZlcnNlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLl9pbmRleCA9IGk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT0gMDtcblx0fSxcblxuXHRpc0VkaXRhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXM7XG5cdFx0d2hpbGUgKGl0ZW0pIHtcblx0XHRcdGlmICghaXRlbS5fdmlzaWJsZSB8fCBpdGVtLl9sb2NrZWQpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdGl0ZW0gPSBpdGVtLl9wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9nZXRPcmRlcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGZ1bmN0aW9uIGdldExpc3QoaXRlbSkge1xuXHRcdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGlzdC51bnNoaWZ0KGl0ZW0pO1xuXHRcdFx0fSB3aGlsZSAoaXRlbSA9IGl0ZW0uX3BhcmVudCk7XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9XG5cdFx0dmFyIGxpc3QxID0gZ2V0TGlzdCh0aGlzKSxcblx0XHRcdGxpc3QyID0gZ2V0TGlzdChpdGVtKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGxpc3QxLmxlbmd0aCwgbGlzdDIubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3QxW2ldICE9IGxpc3QyW2ldKSB7XG5cdFx0XHRcdHJldHVybiBsaXN0MVtpXS5faW5kZXggPCBsaXN0MltpXS5faW5kZXggPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMDtcblx0fSxcblxuXHRpc0Fib3ZlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAtMTtcblx0fSxcblxuXHRpc0JlbG93OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAxO1xuXHR9LFxuXG5cdGlzUGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbTtcblx0fSxcblxuXHRpc0NoaWxkOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gJiYgaXRlbS5fcGFyZW50ID09PSB0aGlzO1xuXHR9LFxuXG5cdGlzRGVzY2VuZGFudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCA9PSBpdGVtKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzQW5jZXN0b3I6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA/IGl0ZW0uaXNEZXNjZW5kYW50KHRoaXMpIDogZmFsc2U7XG5cdH0sXG5cblx0aXNHcm91cGVkV2l0aDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0d2hpbGUgKHBhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudC5fcGFyZW50XG5cdFx0XHRcdCYmIC9eKEdyb3VwfExheWVyfENvbXBvdW5kUGF0aCkkLy50ZXN0KHBhcmVudC5fY2xhc3MpXG5cdFx0XHRcdCYmIGl0ZW0uaXNEZXNjZW5kYW50KHBhcmVudCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG14ID0gbmV3IE1hdHJpeCgpO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShteC50cmFuc2xhdGUuYXBwbHkobXgsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5yb3RhdGUoYW5nbGUsXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzLCAxLCB7IHJlYWROdWxsOiB0cnVlIH0pXG5cdFx0XHRcdFx0fHwgdGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9XG59LCBCYXNlLmVhY2goWydzY2FsZScsICdzaGVhcicsICdza2V3J10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KClbbmFtZV0ocG9pbnQsXG5cdFx0XHRcdGNlbnRlciB8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH07XG59LCB7XG5cbn0pLCB7XG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4LCBfYXBwbHlNYXRyaXgpIHtcblx0XHRpZiAobWF0cml4ICYmIG1hdHJpeC5pc0lkZW50aXR5KCkpXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdHZhciBfbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0YXBwbHlNYXRyaXggPSAoX2FwcGx5TWF0cml4IHx8IHRoaXMuX2FwcGx5TWF0cml4KVxuXHRcdFx0XHQmJiAoIV9tYXRyaXguaXNJZGVudGl0eSgpIHx8IG1hdHJpeCk7XG5cdFx0aWYgKCFtYXRyaXggJiYgIWFwcGx5TWF0cml4KVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdF9tYXRyaXgucHJlQ29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHRpZiAoYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeCAmJiB0aGlzLl90cmFuc2Zvcm1Db250ZW50KF9tYXRyaXgpKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdCxcblx0XHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdFx0ZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKHRydWUpLFxuXHRcdFx0XHRzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKHRydWUpO1xuXHRcdFx0aWYgKHBpdm90KVxuXHRcdFx0XHRwaXZvdC50cmFuc2Zvcm0oX21hdHJpeCk7XG5cdFx0XHRpZiAoZmlsbENvbG9yKVxuXHRcdFx0XHRmaWxsQ29sb3IudHJhbnNmb3JtKF9tYXRyaXgpO1xuXHRcdFx0aWYgKHN0cm9rZUNvbG9yKVxuXHRcdFx0XHRzdHJva2VDb2xvci50cmFuc2Zvcm0oX21hdHJpeCk7XG5cdFx0XHRfbWF0cml4LnJlc2V0KHRydWUpO1xuXHRcdH1cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzLFxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdHZhciBkZWNvbXAgPSBib3VuZHMgJiYgbWF0cml4ICYmIG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRpZiAoZGVjb21wICYmICFkZWNvbXAuc2hlYXJpbmcgJiYgZGVjb21wLnJvdGF0aW9uICUgOTAgPT09IDApIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBib3VuZHMpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBib3VuZHNba2V5XTtcblx0XHRcdFx0aWYgKGFwcGx5TWF0cml4IHx8ICFyZWN0Ll9pbnRlcm5hbClcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0LCByZWN0KTtcblx0XHRcdH1cblx0XHRcdHZhciBnZXR0ZXIgPSB0aGlzLl9ib3VuZHNHZXR0ZXIsXG5cdFx0XHRcdHJlY3QgPSBib3VuZHNbZ2V0dGVyICYmIGdldHRlci5nZXRCb3VuZHMgfHwgZ2V0dGVyIHx8ICdnZXRCb3VuZHMnXTtcblx0XHRcdGlmIChyZWN0KVxuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0dGhpcy5fYm91bmRzID0gYm91bmRzO1xuXHRcdH0gZWxzZSBpZiAobWF0cml4ICYmIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9zaXRpb24sIHBvc2l0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnRyYW5zZm9ybShtYXRyaXgsIHRydWUpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLmdldEdsb2JhbE1hdHJpeCgpO1xuXHRcdHJldHVybiBtYXRyaXggJiYgbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0bG9jYWxUb0dsb2JhbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCk7XG5cdFx0cmV0dXJuIG1hdHJpeCAmJiBtYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Zml0Qm91bmRzOiBmdW5jdGlvbihyZWN0YW5nbGUsIGZpbGwpIHtcblx0XHRyZWN0YW5nbGUgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0aXRlbVJhdGlvID0gYm91bmRzLmhlaWdodCAvIGJvdW5kcy53aWR0aCxcblx0XHRcdHJlY3RSYXRpbyA9IHJlY3RhbmdsZS5oZWlnaHQgLyByZWN0YW5nbGUud2lkdGgsXG5cdFx0XHRzY2FsZSA9IChmaWxsID8gaXRlbVJhdGlvID4gcmVjdFJhdGlvIDogaXRlbVJhdGlvIDwgcmVjdFJhdGlvKVxuXHRcdFx0XHRcdD8gcmVjdGFuZ2xlLndpZHRoIC8gYm91bmRzLndpZHRoXG5cdFx0XHRcdFx0OiByZWN0YW5nbGUuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCxcblx0XHRcdG5ld0JvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksXG5cdFx0XHRcdFx0bmV3IFNpemUoYm91bmRzLndpZHRoICogc2NhbGUsIGJvdW5kcy5oZWlnaHQgKiBzY2FsZSkpO1xuXHRcdG5ld0JvdW5kcy5zZXRDZW50ZXIocmVjdGFuZ2xlLmdldENlbnRlcigpKTtcblx0XHR0aGlzLnNldEJvdW5kcyhuZXdCb3VuZHMpO1xuXHR9LFxuXG5cdF9zZXRTdHlsZXM6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0ZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKCksXG5cdFx0XHRzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKCksXG5cdFx0XHRzaGFkb3dDb2xvciA9IHN0eWxlLmdldFNoYWRvd0NvbG9yKCk7XG5cdFx0aWYgKGZpbGxDb2xvcilcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdGlmIChzdHJva2VDb2xvcikge1xuXHRcdFx0dmFyIHN0cm9rZVdpZHRoID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKTtcblx0XHRcdGlmIChzdHJva2VXaWR0aCA+IDApIHtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdHZhciBzdHJva2VKb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuXHRcdFx0XHRcdHN0cm9rZUNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0XHRcdG1pdGVyTGltaXQgPSBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRcdGlmIChzdHJva2VKb2luKVxuXHRcdFx0XHRcdGN0eC5saW5lSm9pbiA9IHN0cm9rZUpvaW47XG5cdFx0XHRcdGlmIChzdHJva2VDYXApXG5cdFx0XHRcdFx0Y3R4LmxpbmVDYXAgPSBzdHJva2VDYXA7XG5cdFx0XHRcdGlmIChtaXRlckxpbWl0KVxuXHRcdFx0XHRcdGN0eC5taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcblx0XHRcdFx0aWYgKHBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCkge1xuXHRcdFx0XHRcdHZhciBkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcblx0XHRcdFx0XHRcdGRhc2hPZmZzZXQgPSBzdHlsZS5nZXREYXNoT2Zmc2V0KCk7XG5cdFx0XHRcdFx0aWYgKGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoJ3NldExpbmVEYXNoJyBpbiBjdHgpIHtcblx0XHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjdHgubW96RGFzaCA9IGRhc2hBcnJheTtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc2hhZG93Q29sb3IpIHtcblx0XHRcdHZhciBzaGFkb3dCbHVyID0gc3R5bGUuZ2V0U2hhZG93Qmx1cigpO1xuXHRcdFx0aWYgKHNoYWRvd0JsdXIgPiAwKSB7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRcdFx0Y3R4LnNoYWRvd0JsdXIgPSBzaGFkb3dCbHVyO1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5nZXRTaGFkb3dPZmZzZXQoKTtcblx0XHRcdFx0Y3R4LnNoYWRvd09mZnNldFggPSBvZmZzZXQueDtcblx0XHRcdFx0Y3R4LnNoYWRvd09mZnNldFkgPSBvZmZzZXQueTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdGlmICghdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9vcGFjaXR5ID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciB1cGRhdGVWZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0dmFyIHRyYWNrVHJhbnNmb3JtcyA9IHBhcmFtLnRyYWNrVHJhbnNmb3Jtcyxcblx0XHRcdHRyYW5zZm9ybXMgPSBwYXJhbS50cmFuc2Zvcm1zLFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0cGFyZW50TWF0cml4ID0gdHJhbnNmb3Jtc1t0cmFuc2Zvcm1zLmxlbmd0aCAtIDFdLFxuXHRcdFx0Z2xvYmFsTWF0cml4ID0gcGFyZW50TWF0cml4LmNsb25lKCkuY29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHRpZiAoIWdsb2JhbE1hdHJpeC5pc0ludmVydGlibGUoKSlcblx0XHRcdHJldHVybjtcblx0XHRpZiAodHJhY2tUcmFuc2Zvcm1zKSB7XG5cdFx0XHR0cmFuc2Zvcm1zLnB1c2godGhpcy5fZ2xvYmFsTWF0cml4ID0gZ2xvYmFsTWF0cml4KTtcblx0XHRcdGdsb2JhbE1hdHJpeC5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0fVxuXG5cdFx0dmFyIGJsZW5kTW9kZSA9IHRoaXMuX2JsZW5kTW9kZSxcblx0XHRcdG9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5LFxuXHRcdFx0bm9ybWFsQmxlbmQgPSBibGVuZE1vZGUgPT09ICdub3JtYWwnLFxuXHRcdFx0bmF0aXZlQmxlbmQgPSBCbGVuZE1vZGUubmF0aXZlTW9kZXNbYmxlbmRNb2RlXSxcblx0XHRcdGRpcmVjdCA9IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPT09IDFcblx0XHRcdFx0XHR8fCBwYXJhbS5jbGlwXG5cdFx0XHRcdFx0fHwgKG5hdGl2ZUJsZW5kIHx8IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPCAxKVxuXHRcdFx0XHRcdFx0JiYgdGhpcy5fY2FuQ29tcG9zaXRlKCksXG5cdFx0XHRtYWluQ3R4LCBpdGVtT2Zmc2V0LCBwcmV2T2Zmc2V0O1xuXHRcdGlmICghZGlyZWN0KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMocGFyZW50TWF0cml4KTtcblx0XHRcdGlmICghYm91bmRzLndpZHRoIHx8ICFib3VuZHMuaGVpZ2h0KVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRwcmV2T2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aXRlbU9mZnNldCA9IHBhcmFtLm9mZnNldCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKTtcblx0XHRcdG1haW5DdHggPSBjdHg7XG5cdFx0XHRjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KFxuXHRcdFx0XHRcdGJvdW5kcy5nZXRTaXplKCkuY2VpbCgpLmFkZChuZXcgU2l6ZSgxLCAxKSksXG5cdFx0XHRcdFx0cGFyYW0ucGl4ZWxSYXRpbyk7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKGRpcmVjdCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcblx0XHRcdGlmIChuYXRpdmVCbGVuZClcblx0XHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgtaXRlbU9mZnNldC54LCAtaXRlbU9mZnNldC55KTtcblx0XHR9XG5cdFx0KGRpcmVjdCA/IG1hdHJpeCA6IGdsb2JhbE1hdHJpeCkuYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRpZiAoIWRpcmVjdCAmJiBwYXJhbS5jbGlwSXRlbSlcblx0XHRcdHBhcmFtLmNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoeyBjbGlwOiB0cnVlIH0pKTtcblx0XHR0aGlzLl9kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0aWYgKHRyYWNrVHJhbnNmb3Jtcylcblx0XHRcdHRyYW5zZm9ybXMucG9wKCk7XG5cdFx0aWYgKHBhcmFtLmNsaXAgJiYgIXBhcmFtLmRvbnRGaW5pc2gpXG5cdFx0XHRjdHguY2xpcCgpO1xuXHRcdGlmICghZGlyZWN0KSB7XG5cdFx0XHRCbGVuZE1vZGUucHJvY2VzcyhibGVuZE1vZGUsIGN0eCwgbWFpbkN0eCwgb3BhY2l0eSxcblx0XHRcdFx0XHRpdGVtT2Zmc2V0LnN1YnRyYWN0KHByZXZPZmZzZXQpLm11bHRpcGx5KHBhcmFtLnBpeGVsUmF0aW8pKTtcblx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0XHRcdHBhcmFtLm9mZnNldCA9IHByZXZPZmZzZXQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSwgQmFzZS5lYWNoKFsnZG93bicsICdkcmFnJywgJ3VwJywgJ21vdmUnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzWydyZW1vdmVPbicgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc2ggPSB7fTtcblx0XHRoYXNoW25hbWVdID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVPbihoYXNoKTtcblx0fTtcbn0sIHtcblxuXHRyZW1vdmVPbjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmpbbmFtZV0pIHtcblx0XHRcdFx0dmFyIGtleSA9ICdtb3VzZScgKyBuYW1lLFxuXHRcdFx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRcdHNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldID0gc2V0c1trZXldIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV1bdGhpcy5faWRdID0gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pKTtcblxudmFyIEdyb3VwID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcm91cCcsXG5cdF9zZWxlY3RDaGlsZHJlbjogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyb3VwKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKVxuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuXHRcdF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cdFx0aWYgKGZsYWdzICYgKDIgfCAxMDI0KSkge1xuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRDbGlwSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fY2xpcEl0ZW07XG5cdFx0aWYgKGNsaXBJdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNsaXBJdGVtID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQuX2NsaXBNYXNrKSB7XG5cdFx0XHRcdFx0Y2xpcEl0ZW0gPSBjaGlsZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSBjbGlwSXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIGNsaXBJdGVtO1xuXHR9LFxuXG5cdGlzQ2xpcHBlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0fSxcblxuXHRzZXRDbGlwcGVkOiBmdW5jdGlvbihjbGlwcGVkKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0aWYgKGNoaWxkKVxuXHRcdFx0Y2hpbGQuc2V0Q2xpcE1hc2soY2xpcHBlZCk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR2YXIgY2xpcCA9IHBhcmFtLmNsaXAsXG5cdFx0XHRjbGlwSXRlbSA9ICFjbGlwICYmIHRoaXMuX2dldENsaXBJdGVtKCksXG5cdFx0XHRkcmF3ID0gdHJ1ZTtcblx0XHRwYXJhbSA9IHBhcmFtLmV4dGVuZCh7IGNsaXBJdGVtOiBjbGlwSXRlbSwgY2xpcDogZmFsc2UgfSk7XG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdFx0ZHJhdyA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRwYXJhbS5kb250U3RhcnQgPSBwYXJhbS5kb250RmluaXNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNsaXBJdGVtKSB7XG5cdFx0XHRjbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdGlmIChkcmF3KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoaXRlbSAhPT0gY2xpcEl0ZW0pXG5cdFx0XHRcdFx0aXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIExheWVyID0gR3JvdXAuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTGF5ZXInLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExheWVyKGFyZykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG5cdFx0XHRcdD8gbmV3IEJhc2UoYXJnKSBcblx0XHRcdFx0OiB7IGNoaWxkcmVuOiBBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMgfSxcblx0XHRcdGluc2VydCA9IHByb3BzLmluc2VydDtcblx0XHRwcm9wcy5pbnNlcnQgPSBmYWxzZTtcblx0XHRHcm91cC5jYWxsKHRoaXMsIHByb3BzKTtcblx0XHRpZiAoaW5zZXJ0IHx8IGluc2VydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9wcm9qZWN0LmFkZENoaWxkKHRoaXMpO1xuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlOiBmdW5jdGlvbiBfcmVtb3ZlKG5vdGlmeSkge1xuXHRcdGlmICh0aGlzLl9wYXJlbnQpXG5cdFx0XHRyZXR1cm4gX3JlbW92ZS5iYXNlLmNhbGwodGhpcywgbm90aWZ5KTtcblx0XHRpZiAodGhpcy5faW5kZXggIT0gbnVsbCkge1xuXHRcdFx0aWYgKHRoaXMuX3Byb2plY3QuYWN0aXZlTGF5ZXIgPT09IHRoaXMpXG5cdFx0XHRcdHRoaXMuX3Byb2plY3QuYWN0aXZlTGF5ZXIgPSB0aGlzLmdldE5leHRTaWJsaW5nKClcblx0XHRcdFx0XHRcdHx8IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cdFx0XHRCYXNlLnNwbGljZSh0aGlzLl9wcm9qZWN0LmxheWVycywgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbiBnZXROZXh0U2libGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gZ2V0TmV4dFNpYmxpbmcuYmFzZS5jYWxsKHRoaXMpXG5cdFx0XHRcdDogdGhpcy5fcHJvamVjdC5sYXllcnNbdGhpcy5faW5kZXggKyAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzU2libGluZzogZnVuY3Rpb24gZ2V0UHJldmlvdXNTaWJsaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBnZXRQcmV2aW91c1NpYmxpbmcuYmFzZS5jYWxsKHRoaXMpXG5cdFx0XHRcdDogdGhpcy5fcHJvamVjdC5sYXllcnNbdGhpcy5faW5kZXggLSAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uIGlzSW5zZXJ0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGlzSW5zZXJ0ZWQuYmFzZS5jYWxsKHRoaXMpIDogdGhpcy5faW5kZXggIT0gbnVsbDtcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJvamVjdC5hY3RpdmVMYXllciA9IHRoaXM7XG5cdH0sXG5cblx0X2luc2VydDogZnVuY3Rpb24gX2luc2VydChhYm92ZSwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBMYXllciAmJiAhaXRlbS5fcGFyZW50KSB7XG5cdFx0XHR0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRCYXNlLnNwbGljZShpdGVtLl9wcm9qZWN0LmxheWVycywgW3RoaXNdLFxuXHRcdFx0XHRcdGl0ZW0uX2luZGV4ICsgKGFib3ZlID8gMSA6IDApLCAwKTtcblx0XHRcdHRoaXMuX3NldFByb2plY3QoaXRlbS5fcHJvamVjdCwgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIF9pbnNlcnQuYmFzZS5jYWxsKHRoaXMsIGFib3ZlLCBpdGVtLCBfcHJlc2VydmUpO1xuXHR9XG59KTtcblxudmFyIFNoYXBlID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaGFwZScsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHR5cGU6IG51bGwsXG5cdFx0c2l6ZTogbnVsbCxcblx0XHRyYWRpdXM6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaGFwZShwcm9wcykge1xuXHRcdHRoaXMuX2luaXRpYWxpemUocHJvcHMpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gaXRlbS5fdHlwZVxuXHRcdFx0JiYgdGhpcy5fc2l6ZS5lcXVhbHMoaXRlbS5fc2l6ZSlcblx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3JhZGl1cywgaXRlbS5fcmFkaXVzKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgU2hhcGUoSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0VHlwZSh0aGlzLl90eXBlKTtcblx0XHRjb3B5LnNldFNpemUodGhpcy5fc2l6ZSk7XG5cdFx0Y29weS5zZXRSYWRpdXModGhpcy5fcmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcblx0fSxcblxuXHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0fSxcblxuXHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdH0sXG5cblx0Z2V0U2hhcGU6ICcjZ2V0VHlwZScsXG5cdHNldFNoYXBlOiAnI3NldFR5cGUnLFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAoIXRoaXMuX3NpemUpIHtcblx0XHRcdHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG5cdFx0fSBlbHNlIGlmICghdGhpcy5fc2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gU2l6ZS5taW4odGhpcy5fcmFkaXVzLCBzaXplLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQocmFkaXVzLndpZHRoLCByYWRpdXMuaGVpZ2h0KTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0d2lkdGggPSBoZWlnaHQgPSAod2lkdGggKyBoZWlnaHQpIC8gMjtcblx0XHRcdFx0dGhpcy5fcmFkaXVzID0gd2lkdGggLyAyO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldCh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByYWQgPSB0aGlzLl9yYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09ICdjaXJjbGUnXG5cdFx0XHRcdD8gcmFkXG5cdFx0XHRcdDogbmV3IExpbmtlZFNpemUocmFkLndpZHRoLCByYWQuaGVpZ2h0LCB0aGlzLCAnc2V0UmFkaXVzJyk7XG5cdH0sXG5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbihyYWRpdXMpIHtcblx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG5cdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRpZiAocmFkaXVzID09PSB0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBzaXplID0gcmFkaXVzICogMjtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMuX3NpemUuc2V0KHNpemUsIHNpemUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyYWRpdXMgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdGlmICghdGhpcy5fcmFkaXVzKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHJhZGl1cy5jbG9uZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX3JhZGl1cy5lcXVhbHMocmFkaXVzKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQocmFkaXVzLndpZHRoLCByYWRpdXMuaGVpZ2h0KTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBTaXplLm1heCh0aGlzLl9zaXplLCByYWRpdXMubXVsdGlwbHkoMikpO1xuXHRcdFx0XHRcdHRoaXMuX3NpemUuc2V0KHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChyYWRpdXMud2lkdGggKiAyLCByYWRpdXMuaGVpZ2h0ICogMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dG9QYXRoOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoW0Jhc2UuY2FwaXRhbGl6ZSh0aGlzLl90eXBlKV0oe1xuXHRcdFx0Y2VudGVyOiBuZXcgUG9pbnQoKSxcblx0XHRcdHNpemU6IHRoaXMuX3NpemUsXG5cdFx0XHRyYWRpdXM6IHRoaXMuX3JhZGl1cyxcblx0XHRcdGluc2VydDogZmFsc2Vcblx0XHR9KTtcblx0XHRwYXRoLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRwYXRoLnRyYW5zZm9ybSh0aGlzLl9tYXRyaXgpO1xuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXA7XG5cdFx0aWYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlIHx8IGRvbnRQYWludCkge1xuXHRcdFx0dmFyIHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0dHlwZSA9IHRoaXMuX3R5cGU7XG5cdFx0XHRpZiAoIXBhcmFtLmRvbnRTdGFydClcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdGN0eC5hcmMoMCwgMCwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcnggPSByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSByYWRpdXMuaGVpZ2h0LFxuXHRcdFx0XHRcdGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2O1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdFx0dmFyXHRjeCA9IHJ4ICoga2FwcGEsXG5cdFx0XHRcdFx0XHRjeSA9IHJ5ICoga2FwcGE7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbygtcngsIDApO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKC1yeCwgLWN5LCAtY3gsIC1yeSwgMCwgLXJ5KTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjeCwgLXJ5LCByeCwgLWN5LCByeCwgMCk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8ocngsIGN5LCBjeCwgcnksIDAsIHJ5KTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbygtY3gsIHJ5LCAtcngsIGN5LCAtcngsIDApO1xuXHRcdFx0XHR9IGVsc2UgeyBcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemUsXG5cdFx0XHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdFx0XHRpZiAocnggPT09IDAgJiYgcnkgPT09IDApIHtcblx0XHRcdFx0XHRcdGN0eC5yZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0a2FwcGEgPSAxIC0ga2FwcGE7XG5cdFx0XHRcdFx0XHR2YXIgeCA9IHdpZHRoIC8gMixcblx0XHRcdFx0XHRcdFx0eSA9IGhlaWdodCAvIDIsXG5cdFx0XHRcdFx0XHRcdGN4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRcdFx0Y3kgPSByeSAqIGthcHBhO1xuXHRcdFx0XHRcdFx0Y3R4Lm1vdmVUbygteCwgLXkgKyByeSk7XG5cdFx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbygteCwgLXkgKyBjeSwgLXggKyBjeCwgLXksIC14ICsgcngsIC15KTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oeCAtIHJ4LCAteSk7XG5cdFx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyh4IC0gY3gsIC15LCB4LCAteSArIGN5LCB4LCAteSArIHJ5KTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oeCwgeSAtIHJ5KTtcblx0XHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHkgLSBjeSwgeCAtIGN4LCB5LCB4IC0gcngsIHkpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbygteCArIHJ4LCB5KTtcblx0XHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKC14ICsgY3gsIHksIC14LCB5IC0gY3ksIC14LCB5IC0gcnkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdH1cblx0XHRpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdGN0eC5maWxsKHN0eWxlLmdldFdpbmRpbmdSdWxlKCkpO1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzU3Ryb2tlKVxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKTtcblx0XHRpZiAoZ2V0dGVyICE9PSAnZ2V0Qm91bmRzJyAmJiB0aGlzLmhhc1N0cm9rZSgpKVxuXHRcdFx0cmVjdCA9IHJlY3QuZXhwYW5kKHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpIDogcmVjdDtcblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHsgXG5cblx0ZnVuY3Rpb24gZ2V0Q29ybmVyQ2VudGVyKHRoYXQsIHBvaW50LCBleHBhbmQpIHtcblx0XHR2YXIgcmFkaXVzID0gdGhhdC5fcmFkaXVzO1xuXHRcdGlmICghcmFkaXVzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgaGFsZlNpemUgPSB0aGF0Ll9zaXplLmRpdmlkZSgyKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkaXIgPSBuZXcgUG9pbnQoaSAmIDEgPyAxIDogLTEsIGkgPiAxID8gMSA6IC0xKSxcblx0XHRcdFx0XHRjb3JuZXIgPSBkaXIubXVsdGlwbHkoaGFsZlNpemUpLFxuXHRcdFx0XHRcdGNlbnRlciA9IGNvcm5lci5zdWJ0cmFjdChkaXIubXVsdGlwbHkocmFkaXVzKSksXG5cdFx0XHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUoY29ybmVyLCBjZW50ZXIpO1xuXHRcdFx0XHRpZiAoKGV4cGFuZCA/IHJlY3QuZXhwYW5kKGV4cGFuZCkgOiByZWN0KS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIGNlbnRlcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpIHtcblx0XHR2YXIgYW5nbGUgPSBwb2ludC5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0d2lkdGggPSByYWRpdXMud2lkdGggKiAyLFxuXHRcdFx0aGVpZ2h0ID0gcmFkaXVzLmhlaWdodCAqIDIsXG5cdFx0XHR4ID0gd2lkdGggKiBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHR5ID0gaGVpZ2h0ICogTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHJldHVybiB3aWR0aCAqIGhlaWdodCAvICgyICogTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2NvbnRhaW5zOiBmdW5jdGlvbiBfY29udGFpbnMocG9pbnQpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNlbnRlclxuXHRcdFx0XHRcdFx0PyBwb2ludC5zdWJ0cmFjdChjZW50ZXIpLmRpdmlkZSh0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdFx0XHRcdC5nZXRMZW5ndGgoKSA8PSAxXG5cdFx0XHRcdFx0XHQ6IF9jb250YWlucy5iYXNlLmNhbGwodGhpcywgcG9pbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHBvaW50LmRpdmlkZSh0aGlzLnNpemUpLmdldExlbmd0aCgpIDw9IDAuNTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2hpdFRlc3Q6IGZ1bmN0aW9uIF9oaXRUZXN0KHBvaW50LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgaGl0ID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRcdHN0cm9rZVdpZHRoID0gdGhpcy5nZXRTdHJva2VXaWR0aCgpICsgMiAqIG9wdGlvbnMudG9sZXJhbmNlO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50LCBzdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0aWYgKGNlbnRlcikge1xuXHRcdFx0XHRcdFx0dmFyIHB0ID0gcG9pbnQuc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0XHRcdGhpdCA9IDIgKiBNYXRoLmFicyhwdC5nZXRMZW5ndGgoKVxuXHRcdFx0XHRcdFx0XHRcdC0gZ2V0RWxsaXBzZVJhZGl1cyhwdCwgcmFkaXVzKSkgPD0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCksXG5cdFx0XHRcdFx0XHRcdG91dGVyID0gcmVjdC5leHBhbmQoc3Ryb2tlV2lkdGgpLFxuXHRcdFx0XHRcdFx0XHRpbm5lciA9IHJlY3QuZXhwYW5kKC1zdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0XHRoaXQgPSBvdXRlci5fY29udGFpbnNQb2ludChwb2ludClcblx0XHRcdFx0XHRcdFx0XHQmJiAhaW5uZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKVxuXHRcdFx0XHRcdFx0cmFkaXVzID0gZ2V0RWxsaXBzZVJhZGl1cyhwb2ludCwgcmFkaXVzKTtcblx0XHRcdFx0XHRoaXQgPSAyICogTWF0aC5hYnMocG9pbnQuZ2V0TGVuZ3RoKCkgLSByYWRpdXMpXG5cdFx0XHRcdFx0XHRcdDw9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGl0XG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdzdHJva2UnLCB0aGlzKVxuXHRcdFx0XHRcdDogX2hpdFRlc3QuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBwb2ludCwgc2l6ZSwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIGl0ZW0gPSBuZXcgU2hhcGUoQmFzZS5nZXROYW1lZChhcmdzKSk7XG5cdFx0aXRlbS5fdHlwZSA9IHR5cGU7XG5cdFx0aXRlbS5fc2l6ZSA9IHNpemU7XG5cdFx0aXRlbS5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiBpdGVtLnRyYW5zbGF0ZShwb2ludCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdENpcmNsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnY2lyY2xlJywgY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMgKiAyKSwgcmFkaXVzLFxuXHRcdFx0XHRcdGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRcdFx0cmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ3JlY3RhbmdsZScsIHJlY3QuZ2V0Q2VudGVyKHRydWUpLFxuXHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKSwgcmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRFbGxpcHNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3VtZW50cyksXG5cdFx0XHRcdHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdlbGxpcHNlJywgZWxsaXBzZS5jZW50ZXIsIHJhZGl1cy5tdWx0aXBseSgyKSxcblx0XHRcdFx0XHRyYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdF9yZWFkRWxsaXBzZTogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIGNlbnRlcixcblx0XHRcdFx0cmFkaXVzO1xuXHRcdFx0aWYgKEJhc2UuaGFzTmFtZWQoYXJncywgJ3JhZGl1cycpKSB7XG5cdFx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyk7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyk7XG5cdFx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0XHRyYWRpdXMgPSByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgY2VudGVyOiBjZW50ZXIsIHJhZGl1czogcmFkaXVzIH07XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgUmFzdGVyID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSYXN0ZXInLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzR2V0dGVyOiAnZ2V0Qm91bmRzJyxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c291cmNlOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmFzdGVyKG9iamVjdCwgcG9zaXRpb24pIHtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUob2JqZWN0LFxuXHRcdFx0XHRwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpIHtcblx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFNvdXJjZShvYmplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRJbWFnZShvYmplY3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXRoaXMuX3NpemUpXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFNpemUoKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U291cmNlKCkgPT09IGl0ZW0uZ2V0U291cmNlKCk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCksXG5cdFx0XHRpbWFnZSA9IHRoaXMuX2ltYWdlLFxuXHRcdFx0Y2FudmFzID0gdGhpcy5fY2FudmFzO1xuXHRcdGlmIChpbWFnZSkge1xuXHRcdFx0Y29weS5zZXRJbWFnZShpbWFnZSk7XG5cdFx0fSBlbHNlIGlmIChjYW52YXMpIHtcblx0XHRcdHZhciBjb3B5Q2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHRoaXMuX3NpemUpO1xuXHRcdFx0Y29weUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuXHRcdFx0Y29weS5zZXRDYW52YXMoY29weUNhbnZhcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdFx0dGhpcy5zZXRDYW52YXMoQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpKTtcblx0XHRcdGlmIChlbGVtZW50KVxuXHRcdFx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGVsZW1lbnQsIDAsIDAsXG5cdFx0XHRcdFx0XHRzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS53aWR0aDtcblx0fSxcblxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplLmhlaWdodDtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS53aWR0aCA9PSAwICYmIHRoaXMuX3NpemUuaGVpZ2h0ID09IDA7XG5cdH0sXG5cblx0Z2V0UHBpOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0b3JpZyA9IG5ldyBQb2ludCgwLCAwKS50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdHUgPSBuZXcgUG9pbnQoMSwgMCkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyksXG5cdFx0XHR2ID0gbmV3IFBvaW50KDAsIDEpLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpO1xuXHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdDcyIC8gdS5nZXRMZW5ndGgoKSxcblx0XHRcdDcyIC8gdi5nZXRMZW5ndGgoKVxuXHRcdCk7XG5cdH0sXG5cblx0Z2V0SW1hZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcblx0fSxcblxuXHRzZXRJbWFnZTogZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXHRcdGlmIChpbWFnZS5nZXRDb250ZXh0KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBpbWFnZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBpbWFnZTtcblx0XHRcdHRoaXMuX2NhbnZhcyA9IG51bGw7XG5cdFx0fVxuXHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZShcblx0XHRcdFx0aW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLndpZHRoLFxuXHRcdFx0XHRpbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IGltYWdlLmhlaWdodCk7XG5cdFx0dGhpcy5fY29udGV4dCA9IG51bGw7XG5cdFx0dGhpcy5fY2hhbmdlZCg5IHwgNTEzKTtcblx0fSxcblxuXHRnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fY2FudmFzKSB7XG5cdFx0XHR2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCh0aGlzLl9zaXplKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbWFnZSlcblx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwKTtcblx0XHRcdFx0dGhpcy5fY2FudmFzID0gY3R4LmNhbnZhcztcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzO1xuXHR9LFxuXG5cdHNldENhbnZhczogJyNzZXRJbWFnZScsXG5cblx0Z2V0Q29udGV4dDogZnVuY3Rpb24obW9kaWZ5KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZXh0KVxuXHRcdFx0dGhpcy5fY29udGV4dCA9IHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAobW9kaWZ5KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDUxMyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHR9LFxuXG5cdHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblx0fSxcblxuXHRnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZSAmJiB0aGlzLl9pbWFnZS5zcmMgfHwgdGhpcy50b0RhdGFVUkwoKTtcblx0fSxcblxuXHRzZXRTb3VyY2U6IGZ1bmN0aW9uKHNyYykge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGltYWdlO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZGVkKCkge1xuXHRcdFx0dmFyIHZpZXcgPSB0aGF0LmdldFZpZXcoKTtcblx0XHRcdGlmICh2aWV3KSB7XG5cdFx0XHRcdHBhcGVyID0gdmlldy5fc2NvcGU7XG5cdFx0XHRcdHRoYXQuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdFx0XHR0aGF0LmZpcmUoJ2xvYWQnKTtcblx0XHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRcdGltYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3JjKSB8fCBuZXcgSW1hZ2UoKTtcblxuXHRcdGlmIChpbWFnZS5uYXR1cmFsV2lkdGggJiYgaW1hZ2UubmF0dXJhbEhlaWdodCkge1xuXHRcdFx0c2V0VGltZW91dChsb2FkZWQsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21FdmVudC5hZGQoaW1hZ2UsIHtcblx0XHRcdFx0bG9hZDogbG9hZGVkXG5cdFx0XHR9KTtcblx0XHRcdGlmICghaW1hZ2Uuc3JjKVxuXHRcdFx0XHRpbWFnZS5zcmMgPSBzcmM7XG5cdFx0fVxuXHRcdHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXMgfHwgdGhpcy5faW1hZ2U7XG5cdH0sXG5cblx0Z2V0U3ViQ2FudmFzOiBmdW5jdGlvbihyZWN0KSB7IFxuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQocmVjdC5nZXRTaXplKCkpO1xuXHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5nZXRDYW52YXMoKSwgcmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIGN0eC5jYW52YXM7XG5cdH0sXG5cblx0Z2V0U3ViUmFzdGVyOiBmdW5jdGlvbihyZWN0KSB7IFxuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJhc3Rlci5zZXRDYW52YXModGhpcy5nZXRTdWJDYW52YXMocmVjdCkpO1xuXHRcdHJhc3Rlci50cmFuc2xhdGUocmVjdC5nZXRDZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLmdldFNpemUoKS5kaXZpZGUoMikpKTtcblx0XHRyYXN0ZXIuX21hdHJpeC5wcmVDb25jYXRlbmF0ZSh0aGlzLl9tYXRyaXgpO1xuXHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcmFzdGVyO1xuXHR9LFxuXG5cdHRvRGF0YVVSTDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNyYyA9IHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYztcblx0XHRpZiAoL15kYXRhOi8udGVzdChzcmMpKVxuXHRcdFx0cmV0dXJuIHNyYztcblx0XHR2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcblx0XHRyZXR1cm4gY2FudmFzID8gY2FudmFzLnRvRGF0YVVSTCgpIDogbnVsbDtcblx0fSxcblxuXHRkcmF3SW1hZ2U6IGZ1bmN0aW9uKGltYWdlICkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGltYWdlLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRBdmVyYWdlQ29sb3I6IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdHZhciBib3VuZHMsIHBhdGg7XG5cdFx0aWYgKCFvYmplY3QpIHtcblx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBQYXRoSXRlbSkge1xuXHRcdFx0cGF0aCA9IG9iamVjdDtcblx0XHRcdGJvdW5kcyA9IG9iamVjdC5nZXRCb3VuZHMoKTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdC53aWR0aCkge1xuXHRcdFx0Ym91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0LngpIHtcblx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0LnggLSAwLjUsIG9iamVjdC55IC0gMC41LCAxLCAxKTtcblx0XHR9XG5cdFx0dmFyIHNhbXBsZVNpemUgPSAzMixcblx0XHRcdHdpZHRoID0gTWF0aC5taW4oYm91bmRzLndpZHRoLCBzYW1wbGVTaXplKSxcblx0XHRcdGhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5oZWlnaHQsIHNhbXBsZVNpemUpO1xuXHRcdHZhciBjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQ7XG5cdFx0aWYgKCFjdHgpIHtcblx0XHRcdGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoXG5cdFx0XHRcdFx0bmV3IFNpemUoc2FtcGxlU2l6ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNhbXBsZVNpemUgKyAxLCBzYW1wbGVTaXplICsgMSk7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKVxuXHRcdFx0XHQuc2NhbGUod2lkdGggLyBib3VuZHMud2lkdGgsIGhlaWdodCAvIGJvdW5kcy5oZWlnaHQpXG5cdFx0XHRcdC50cmFuc2xhdGUoLWJvdW5kcy54LCAtYm91bmRzLnkpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmIChwYXRoKVxuXHRcdFx0cGF0aC5kcmF3KGN0eCwgbmV3IEJhc2UoeyBjbGlwOiB0cnVlLCB0cmFuc2Zvcm1zOiBbbWF0cml4XSB9KSk7XG5cdFx0dGhpcy5fbWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLmdldEVsZW1lbnQoKSxcblx0XHRcdFx0LXRoaXMuX3NpemUud2lkdGggLyAyLCAtdGhpcy5fc2l6ZS5oZWlnaHQgLyAyKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHZhciBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAuNSwgMC41LCBNYXRoLmNlaWwod2lkdGgpLFxuXHRcdFx0XHRNYXRoLmNlaWwoaGVpZ2h0KSkuZGF0YSxcblx0XHRcdGNoYW5uZWxzID0gWzAsIDAsIDBdLFxuXHRcdFx0dG90YWwgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0dmFyIGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcblx0XHRcdHRvdGFsICs9IGFscGhhO1xuXHRcdFx0YWxwaGEgLz0gMjU1O1xuXHRcdFx0Y2hhbm5lbHNbMF0gKz0gcGl4ZWxzW2ldICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1sxXSArPSBwaXhlbHNbaSArIDFdICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1syXSArPSBwaXhlbHNbaSArIDJdICogYWxwaGE7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKVxuXHRcdFx0Y2hhbm5lbHNbaV0gLz0gdG90YWw7XG5cdFx0cmV0dXJuIHRvdGFsID8gQ29sb3IucmVhZChjaGFubmVscykgOiBudWxsO1xuXHR9LFxuXG5cdGdldFBpeGVsOiBmdW5jdGlvbihwb2ludCkgeyBcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocG9pbnQueCwgcG9pbnQueSwgMSwgMSkuZGF0YTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKCdyZ2InLCBbZGF0YVswXSAvIDI1NSwgZGF0YVsxXSAvIDI1NSwgZGF0YVsyXSAvIDI1NV0sXG5cdFx0XHRcdGRhdGFbM10gLyAyNTUpO1xuXHR9LFxuXG5cdHNldFBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbXBvbmVudHMgPSBjb2xvci5fY29udmVydCgncmdiJyksXG5cdFx0XHRhbHBoYSA9IGNvbG9yLl9hbHBoYSxcblx0XHRcdGN0eCA9IHRoaXMuZ2V0Q29udGV4dCh0cnVlKSxcblx0XHRcdGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMSwgMSksXG5cdFx0XHRkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0ZGF0YVswXSA9IGNvbXBvbmVudHNbMF0gKiAyNTU7XG5cdFx0ZGF0YVsxXSA9IGNvbXBvbmVudHNbMV0gKiAyNTU7XG5cdFx0ZGF0YVsyXSA9IGNvbXBvbmVudHNbMl0gKiAyNTU7XG5cdFx0ZGF0YVszXSA9IGFscGhhICE9IG51bGwgPyBhbHBoYSAqIDI1NSA6IDI1NTtcblx0XHRjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Y3JlYXRlSW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLmdldENvbnRleHQoKS5jcmVhdGVJbWFnZURhdGEoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGdldEltYWdlRGF0YTogZnVuY3Rpb24ocmVjdCkgeyBcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHJlY3QuaXNFbXB0eSgpKVxuXHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9LFxuXG5cdHNldEltYWdlRGF0YTogZnVuY3Rpb24oZGF0YSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLnB1dEltYWdlRGF0YShkYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpIDogcmVjdDtcblx0fSxcblxuXHRfaGl0VGVzdDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCgncGl4ZWwnLCB0aGF0LCB7XG5cdFx0XHRcdG9mZnNldDogcG9pbnQuYWRkKHRoYXQuX3NpemUuZGl2aWRlKDIpKS5yb3VuZCgpLFxuXHRcdFx0XHRjb2xvcjoge1xuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhhdC5nZXRQaXhlbCh0aGlzLm9mZnNldCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuX29wYWNpdHk7XG5cdFx0XHRjdHguZHJhd0ltYWdlKGVsZW1lbnQsXG5cdFx0XHRcdFx0LXRoaXMuX3NpemUud2lkdGggLyAyLCAtdGhpcy5fc2l6ZS5oZWlnaHQgLyAyKTtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG52YXIgUGxhY2VkU3ltYm9sID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQbGFjZWRTeW1ib2wnLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzR2V0dGVyOiB7IGdldEJvdW5kczogJ2dldFN0cm9rZUJvdW5kcycgfSxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c3ltYm9sOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGxhY2VkU3ltYm9sKGFyZzAsIGFyZzEpIHtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnMCxcblx0XHRcdFx0YXJnMSAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpXG5cdFx0XHR0aGlzLnNldFN5bWJvbChhcmcwIGluc3RhbmNlb2YgU3ltYm9sID8gYXJnMCA6IG5ldyBTeW1ib2woYXJnMCkpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fc3ltYm9sID09PSBpdGVtLl9zeW1ib2w7XG5cdH0sXG5cblx0Z2V0U3ltYm9sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3ltYm9sO1xuXHR9LFxuXG5cdHNldFN5bWJvbDogZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0dGhpcy5fc3ltYm9sID0gc3ltYm9sO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFBsYWNlZFN5bWJvbChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0Y29weS5zZXRTeW1ib2wodGhpcy5fc3ltYm9sKTtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3ltYm9sLl9kZWZpbml0aW9uLmlzRW1wdHkoKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3ltYm9sLl9kZWZpbml0aW9uLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLCBtYXRyaXgsXG5cdFx0XHRcdGNhY2hlSXRlbSk7XG5cdH0sXG5cblx0X2hpdFRlc3Q6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMuX3N5bWJvbC5fZGVmaW5pdGlvbi5oaXRUZXN0KHBvaW50LCBvcHRpb25zKTtcblx0XHRpZiAocmVzKVxuXHRcdFx0cmVzLml0ZW0gPSB0aGlzO1xuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR0aGlzLnN5bWJvbC5fZGVmaW5pdGlvbi5kcmF3KGN0eCwgcGFyYW0pO1xuXHR9XG5cbn0pO1xuXG52YXIgSGl0UmVzdWx0ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdIaXRSZXN1bHQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEhpdFJlc3VsdCh0eXBlLCBpdGVtLCB2YWx1ZXMpIHtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuaXRlbSA9IGl0ZW07XG5cdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0dmFsdWVzLmVudW1lcmFibGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5pbmplY3QodmFsdWVzKTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGdldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuX21lcmdlZCA/IG9wdGlvbnMgOiBuZXcgQmFzZSh7XG5cdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdHRvbGVyYW5jZTogcGFwZXIuc2V0dGluZ3MuaGl0VG9sZXJhbmNlLFxuXHRcdFx0XHRmaWxsOiAhb3B0aW9ucyxcblx0XHRcdFx0c3Ryb2tlOiAhb3B0aW9ucyxcblx0XHRcdFx0c2VnbWVudHM6ICFvcHRpb25zLFxuXHRcdFx0XHRoYW5kbGVzOiBmYWxzZSxcblx0XHRcdFx0ZW5kczogZmFsc2UsXG5cdFx0XHRcdGNlbnRlcjogZmFsc2UsXG5cdFx0XHRcdGJvdW5kczogZmFsc2UsXG5cdFx0XHRcdGd1aWRlczogZmFsc2UsXG5cdFx0XHRcdHNlbGVjdGVkOiBmYWxzZSxcblx0XHRcdFx0X21lcmdlZDogdHJ1ZVxuXHRcdFx0fSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFNlZ21lbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1NlZ21lbnQnLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTZWdtZW50KGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0cG9pbnQsIGhhbmRsZUluLCBoYW5kbGVPdXQ7XG5cdFx0aWYgKGNvdW50ID09PSAwKSB7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0aWYgKGFyZzAucG9pbnQpIHtcblx0XHRcdFx0cG9pbnQgPSBhcmcwLnBvaW50O1xuXHRcdFx0XHRoYW5kbGVJbiA9IGFyZzAuaGFuZGxlSW47XG5cdFx0XHRcdGhhbmRsZU91dCA9IGFyZzAuaGFuZGxlT3V0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnQgPSBhcmcwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDIgJiYgdHlwZW9mIGFyZzAgPT09ICdudW1iZXInKSB7XG5cdFx0XHRwb2ludCA9IGFyZ3VtZW50cztcblx0XHR9IGVsc2UgaWYgKGNvdW50IDw9IDMpIHtcblx0XHRcdHBvaW50ID0gYXJnMDtcblx0XHRcdGhhbmRsZUluID0gYXJnMTtcblx0XHRcdGhhbmRsZU91dCA9IGFyZzI7XG5cdFx0fSBlbHNlIHsgXG5cdFx0XHRwb2ludCA9IGFyZzAgIT09IHVuZGVmaW5lZCA/IFsgYXJnMCwgYXJnMSBdIDogbnVsbDtcblx0XHRcdGhhbmRsZUluID0gYXJnMiAhPT0gdW5kZWZpbmVkID8gWyBhcmcyLCBhcmczIF0gOiBudWxsO1xuXHRcdFx0aGFuZGxlT3V0ID0gYXJnNCAhPT0gdW5kZWZpbmVkID8gWyBhcmc0LCBhcmc1IF0gOiBudWxsO1xuXHRcdH1cblx0XHRuZXcgU2VnbWVudFBvaW50KHBvaW50LCB0aGlzLCAnX3BvaW50Jyk7XG5cdFx0bmV3IFNlZ21lbnRQb2ludChoYW5kbGVJbiwgdGhpcywgJ19oYW5kbGVJbicpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlT3V0LCB0aGlzLCAnX2hhbmRsZU91dCcpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5pc0xpbmVhcigpID8gdGhpcy5fcG9pbnRcblx0XHRcdFx0OiBbdGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0aWYgKCFwYXRoKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4LFxuXHRcdFx0Y3VydmVJbiwgY3VydmVPdXQ7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbilcblx0XHRcdFx0XHQmJiAoY3VydmVJbiA9IGN1cnZlc1tpbmRleCAtIDFdXG5cdFx0XHRcdFx0XHR8fCBwYXRoLl9jbG9zZWQgJiYgY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSkpXG5cdFx0XHRcdGN1cnZlSW4uX2NoYW5nZWQoKTtcblx0XHRcdGlmICgoIXBvaW50IHx8IHBvaW50ID09PSB0aGlzLl9wb2ludCB8fCBwb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0KVxuXHRcdFx0XHRcdCYmIChjdXJ2ZU91dCA9IGN1cnZlc1tpbmRleF0pKVxuXHRcdFx0XHRjdXJ2ZU91dC5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRwYXRoLl9jaGFuZ2VkKDI1KTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fcG9pbnQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlSW47XG5cdH0sXG5cblx0c2V0SGFuZGxlSW46IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9oYW5kbGVJbi5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlT3V0O1xuXHR9LFxuXG5cdHNldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX2hhbmRsZU91dC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0aXNMaW5lYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSAmJiB0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCk7XG5cdH0sXG5cblx0c2V0TGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9oYW5kbGVJbi5zZXQoMCwgMCk7XG5cdFx0dGhpcy5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0fSxcblxuXHRpc0NvbGluZWFyOiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0dmFyIG5leHQxID0gdGhpcy5nZXROZXh0KCksXG5cdFx0XHRuZXh0MiA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgbmV4dDEuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdCYmIHNlZ21lbnQuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBuZXh0Mi5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0JiYgbmV4dDEuX3BvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KS5pc0NvbGluZWFyKFxuXHRcdFx0XHRcdG5leHQyLl9wb2ludC5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHR9LFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZXYgPSB0aGlzLmdldFByZXZpb3VzKCksXG5cdFx0XHRuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG5cdFx0cmV0dXJuIHByZXYuX2hhbmRsZU91dC5pc1plcm8oKSAmJiB0aGlzLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0JiYgdGhpcy5faGFuZGxlT3V0LmlzWmVybygpICYmIG5leHQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHQmJiB0aGlzLl9wb2ludC5zdWJ0cmFjdChwcmV2Ll9wb2ludCkuaXNPcnRob2dvbmFsKFxuXHRcdFx0XHRcdG5leHQuX3BvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KSk7XG5cdH0sXG5cblx0aXNBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCksXG5cdFx0XHRoYW5kbGUxID0gdGhpcy5faGFuZGxlT3V0LFxuXHRcdFx0aGFuZGxlMiA9IG5leHQuX2hhbmRsZUluLFxuXHRcdFx0a2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzY7XG5cdFx0aWYgKGhhbmRsZTEuaXNPcnRob2dvbmFsKGhhbmRsZTIpKSB7XG5cdFx0XHR2YXIgZnJvbSA9IHRoaXMuX3BvaW50LFxuXHRcdFx0XHR0byA9IG5leHQuX3BvaW50LFxuXHRcdFx0XHRjb3JuZXIgPSBuZXcgTGluZShmcm9tLCBoYW5kbGUxLCB0cnVlKS5pbnRlcnNlY3QoXG5cdFx0XHRcdFx0XHRuZXcgTGluZSh0bywgaGFuZGxlMiwgdHJ1ZSksIHRydWUpO1xuXHRcdFx0cmV0dXJuIGNvcm5lciAmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTEuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdChmcm9tKS5nZXRMZW5ndGgoKSAtIGthcHBhKVxuXHRcdFx0XHQmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTIuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdCh0bykuZ2V0TGVuZ3RoKCkgLSBrYXBwYSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfc2VsZWN0aW9uU3RhdGU6IDAsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oX3BvaW50KSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGU7XG5cdFx0cmV0dXJuICFfcG9pbnQgPyAhIShzdGF0ZSAmIDcpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5fcG9pbnQgPyAhIShzdGF0ZSAmIDQpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAhIShzdGF0ZSAmIDEpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gISEoc3RhdGUgJiAyKVxuXHRcdFx0OiBmYWxzZTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIF9wb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHNlbGVjdGVkID0gISFzZWxlY3RlZCwgXG5cdFx0XHRzdGF0ZSA9IHRoaXMuX3NlbGVjdGlvblN0YXRlLFxuXHRcdFx0b2xkU3RhdGUgPSBzdGF0ZSxcblx0XHRcdGZsYWcgPSAhX3BvaW50ID8gN1xuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9wb2ludCA/IDRcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAxXG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dCA/IDJcblx0XHRcdFx0XHQ6IDA7XG5cdFx0aWYgKHNlbGVjdGVkKSB7XG5cdFx0XHRzdGF0ZSB8PSBmbGFnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGF0ZSAmPSB+ZmxhZztcblx0XHR9XG5cdFx0dGhpcy5fc2VsZWN0aW9uU3RhdGUgPSBzdGF0ZTtcblx0XHRpZiAocGF0aCAmJiBzdGF0ZSAhPT0gb2xkU3RhdGUpIHtcblx0XHRcdHBhdGguX3VwZGF0ZVNlbGVjdGlvbih0aGlzLCBvbGRTdGF0ZSwgc3RhdGUpO1xuXHRcdFx0cGF0aC5fY2hhbmdlZCgxMjkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl9pbmRleCA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGggfHwgbnVsbDtcblx0fSxcblxuXHRnZXRDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuXHRcdFx0aW5kZXggPSB0aGlzLl9pbmRleDtcblx0XHRpZiAocGF0aCkge1xuXHRcdFx0aWYgKGluZGV4ID4gMCAmJiAhcGF0aC5fY2xvc2VkXG5cdFx0XHRcdFx0JiYgaW5kZXggPT09IHBhdGguX3NlZ21lbnRzLmxlbmd0aCAtIDEpXG5cdFx0XHRcdGluZGV4LS07XG5cdFx0XHRyZXR1cm4gcGF0aC5nZXRDdXJ2ZXMoKVtpbmRleF0gfHwgbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmVcblx0XHRcdFx0PyBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZSwgdGhpcyA9PT0gY3VydmUuX3NlZ21lbnQxID8gMCA6IDEpXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRnZXROZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX3NlZ21lbnRzO1xuXHRcdHJldHVybiBzZWdtZW50cyAmJiAoc2VnbWVudHNbdGhpcy5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgc2VnbWVudHNbMF0pIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSkgfHwgbnVsbDtcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZU91dCwgdGhpcy5faGFuZGxlSW4pO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGggPyAhIXRoaXMuX3BhdGgucmVtb3ZlU2VnbWVudCh0aGlzLl9pbmRleCkgOiBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTZWdtZW50KHRoaXMuX3BvaW50LCB0aGlzLl9oYW5kbGVJbiwgdGhpcy5faGFuZGxlT3V0KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcblx0XHRyZXR1cm4gc2VnbWVudCA9PT0gdGhpcyB8fCBzZWdtZW50ICYmIHRoaXMuX2NsYXNzID09PSBzZWdtZW50Ll9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9wb2ludC5lcXVhbHMoc2VnbWVudC5fcG9pbnQpXG5cdFx0XHRcdCYmIHRoaXMuX2hhbmRsZUluLmVxdWFscyhzZWdtZW50Ll9oYW5kbGVJbilcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlT3V0LmVxdWFscyhzZWdtZW50Ll9oYW5kbGVPdXQpXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbICdwb2ludDogJyArIHRoaXMuX3BvaW50IF07XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZUluOiAnICsgdGhpcy5faGFuZGxlSW4pO1xuXHRcdGlmICghdGhpcy5faGFuZGxlT3V0LmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlT3V0OiAnICsgdGhpcy5faGFuZGxlT3V0KTtcblx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBuZXcgQXJyYXkoNiksIHRydWUpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKG1hdHJpeCwgY29vcmRzLCBjaGFuZ2UpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9wb2ludCxcblx0XHRcdGhhbmRsZUluID0gICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVJbiA6IG51bGwsXG5cdFx0XHRoYW5kbGVPdXQgPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2hhbmRsZU91dCA6IG51bGwsXG5cdFx0XHR4ID0gcG9pbnQuX3gsXG5cdFx0XHR5ID0gcG9pbnQuX3ksXG5cdFx0XHRpID0gMjtcblx0XHRjb29yZHNbMF0gPSB4O1xuXHRcdGNvb3Jkc1sxXSA9IHk7XG5cdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl94ICsgeDtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAoaGFuZGxlT3V0KSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feSArIHk7XG5cdFx0fVxuXHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCAwLCBjb29yZHMsIDAsIGkgLyAyKTtcblx0XHRcdHggPSBjb29yZHNbMF07XG5cdFx0XHR5ID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKGNoYW5nZSkge1xuXHRcdFx0XHRwb2ludC5feCA9IHg7XG5cdFx0XHRcdHBvaW50Ll95ID0geTtcblx0XHRcdFx0aSAgPSAyO1xuXHRcdFx0XHRpZiAoaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRoYW5kbGVJbi5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVJbi5feSA9IGNvb3Jkc1tpKytdIC0geTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0aGFuZGxlT3V0Ll94ID0gY29vcmRzW2krK10gLSB4O1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feSA9IGNvb3Jkc1tpKytdIC0geTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCFoYW5kbGVJbikge1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geDtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFoYW5kbGVPdXQpIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjb29yZHM7XG5cdH1cbn0pO1xuXG52YXIgU2VnbWVudFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudFBvaW50KHBvaW50LCBvd25lciwga2V5KSB7XG5cdFx0dmFyIHgsIHksIHNlbGVjdGVkO1xuXHRcdGlmICghcG9pbnQpIHtcblx0XHRcdHggPSB5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCh4ID0gcG9pbnRbMF0pICE9PSB1bmRlZmluZWQpIHsgXG5cdFx0XHR5ID0gcG9pbnRbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwdCA9IHBvaW50O1xuXHRcdFx0aWYgKCh4ID0gcHQueCkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0eCA9IHB0Lng7XG5cdFx0XHR9XG5cdFx0XHR5ID0gcHQueTtcblx0XHRcdHNlbGVjdGVkID0gcHQuc2VsZWN0ZWQ7XG5cdFx0fVxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0b3duZXJba2V5XSA9IHRoaXM7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcixcblx0XHRcdHggPSBmLm51bWJlcih0aGlzLl94KSxcblx0XHRcdHkgPSBmLm51bWJlcih0aGlzLl95KTtcblx0XHRyZXR1cm4gdGhpcy5pc1NlbGVjdGVkKClcblx0XHRcdFx0PyB7IHg6IHgsIHk6IHksIHNlbGVjdGVkOiB0cnVlIH1cblx0XHRcdFx0OiBbeCwgeV07XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMuX3gpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy5feSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fb3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRoaXMpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vd25lci5pc1NlbGVjdGVkKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIEN1cnZlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZScsXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmIChjb3VudCA9PT0gMykge1xuXHRcdFx0dGhpcy5fcGF0aCA9IGFyZzA7XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IGFyZzE7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IGFyZzI7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMCkge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudCgpO1xuXHRcdFx0dGhpcy5fc2VnbWVudDIgPSBuZXcgU2VnbWVudCgpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50MSk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDIpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDIpIHtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQoYXJnMCk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KGFyZzEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcG9pbnQxLCBoYW5kbGUxLCBoYW5kbGUyLCBwb2ludDI7XG5cdFx0XHRpZiAoY291bnQgPT09IDQpIHtcblx0XHRcdFx0cG9pbnQxID0gYXJnMDtcblx0XHRcdFx0aGFuZGxlMSA9IGFyZzE7XG5cdFx0XHRcdGhhbmRsZTIgPSBhcmcyO1xuXHRcdFx0XHRwb2ludDIgPSBhcmczO1xuXHRcdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gOCkge1xuXHRcdFx0XHRwb2ludDEgPSBbYXJnMCwgYXJnMV07XG5cdFx0XHRcdHBvaW50MiA9IFthcmc2LCBhcmc3XTtcblx0XHRcdFx0aGFuZGxlMSA9IFthcmcyIC0gYXJnMCwgYXJnMyAtIGFyZzFdO1xuXHRcdFx0XHRoYW5kbGUyID0gW2FyZzQgLSBhcmc2LCBhcmc1IC0gYXJnN107XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KHBvaW50MSwgbnVsbCwgaGFuZGxlMSk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KHBvaW50MiwgaGFuZGxlMiwgbnVsbCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9sZW5ndGggPSB0aGlzLl9ib3VuZHMgPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Z2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50MTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9wb2ludC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDIuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50MjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9wb2ludC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQ7XG5cdH0sXG5cblx0c2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZTI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW47XG5cdH0sXG5cblx0c2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MTtcblx0fSxcblxuXHRnZXRTZWdtZW50MjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyO1xuXHR9LFxuXG5cdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2luZGV4O1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcblx0XHRyZXR1cm4gY3VydmVzICYmIChjdXJ2ZXNbdGhpcy5fc2VnbWVudDEuX2luZGV4ICsgMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggLSAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSkgfHwgbnVsbDtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludDEoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0SGFuZGxlMigpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldFBvaW50MigpLmlzU2VsZWN0ZWQoKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLmdldFBvaW50MSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRIYW5kbGUyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0UG9pbnQyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFZhbHVlcyh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIsIG1hdHJpeCk7XG5cdH0sXG5cblx0Z2V0UG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdHBvaW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KGNvb3Jkc1tpXSwgY29vcmRzW2kgKyAxXSkpO1xuXHRcdHJldHVybiBwb2ludHM7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuaXNMaW5lYXIoKVxuXHRcdFx0XHQ/IHRoaXMuX3NlZ21lbnQyLl9wb2ludC5nZXREaXN0YW5jZSh0aGlzLl9zZWdtZW50MS5fcG9pbnQpXG5cdFx0XHRcdDogQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIDAsIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbGVuZ3RoO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRBcmVhKHRoaXMuZ2V0VmFsdWVzKCkpO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZShDdXJ2ZS5nZXRQYXJ0KHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKSk7XG5cdH0sXG5cblx0Z2V0UGFydExlbmd0aDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0JiYgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpO1xuXHR9LFxuXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNMaW5lYXIoKSAmJiBOdW1lcmljYWwuaXNaZXJvKFxuXHRcdFx0XHR0aGlzLl9zZWdtZW50MS5fcG9pbnQuX3kgLSB0aGlzLl9zZWdtZW50Mi5fcG9pbnQuX3kpO1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldEludGVyc2VjdGlvbnModGhpcy5nZXRWYWx1ZXMoKSwgY3VydmUuZ2V0VmFsdWVzKCksXG5cdFx0XHRcdHRoaXMsIGN1cnZlLCBbXSk7XG5cdH0sXG5cblx0X2dldFBhcmFtZXRlcjogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHJldHVybiBpc1BhcmFtZXRlclxuXHRcdFx0XHQ/IG9mZnNldFxuXHRcdFx0XHQ6IG9mZnNldCAmJiBvZmZzZXQuY3VydmUgPT09IHRoaXNcblx0XHRcdFx0XHQ/IG9mZnNldC5wYXJhbWV0ZXJcblx0XHRcdFx0XHQ6IG9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGlzUGFyYW1ldGVyID09PSB1bmRlZmluZWRcblx0XHRcdFx0XHRcdD8gMC41IFxuXHRcdFx0XHRcdFx0OiB0aGlzLmdldFBhcmFtZXRlckF0KG9mZnNldCwgMCk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyLCBpZ25vcmVMaW5lYXIpIHtcblx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5fZ2V0UGFyYW1ldGVyKG9mZnNldCwgaXNQYXJhbWV0ZXIpLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMSxcblx0XHRcdHJlcyA9IG51bGw7XG5cdFx0aWYgKHBhcmFtZXRlciA+IHRvbGVyYW5jZSAmJiBwYXJhbWV0ZXIgPCAxIC0gdG9sZXJhbmNlKSB7XG5cdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodGhpcy5nZXRWYWx1ZXMoKSwgcGFyYW1ldGVyKSxcblx0XHRcdFx0aXNMaW5lYXIgPSBpZ25vcmVMaW5lYXIgPyBmYWxzZSA6IHRoaXMuaXNMaW5lYXIoKSxcblx0XHRcdFx0bGVmdCA9IHBhcnRzWzBdLFxuXHRcdFx0XHRyaWdodCA9IHBhcnRzWzFdO1xuXG5cdFx0XHRpZiAoIWlzTGluZWFyKSB7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGxlZnRbMl0gLSBsZWZ0WzBdLFxuXHRcdFx0XHRcdFx0bGVmdFszXSAtIGxlZnRbMV0pO1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uc2V0KHJpZ2h0WzRdIC0gcmlnaHRbNl0sXG5cdFx0XHRcdFx0XHRyaWdodFs1XSAtIHJpZ2h0WzddKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHggPSBsZWZ0WzZdLCB5ID0gbGVmdFs3XSxcblx0XHRcdFx0c2VnbWVudCA9IG5ldyBTZWdtZW50KG5ldyBQb2ludCh4LCB5KSxcblx0XHRcdFx0XHRcdCFpc0xpbmVhciAmJiBuZXcgUG9pbnQobGVmdFs0XSAtIHgsIGxlZnRbNV0gLSB5KSxcblx0XHRcdFx0XHRcdCFpc0xpbmVhciAmJiBuZXcgUG9pbnQocmlnaHRbMl0gLSB4LCByaWdodFszXSAtIHkpKTtcblxuXHRcdFx0aWYgKHRoaXMuX3BhdGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3NlZ21lbnQxLl9pbmRleCA+IDAgJiYgdGhpcy5fc2VnbWVudDIuX2luZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fcGF0aC5hZGQoc2VnbWVudCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcGF0aC5pbnNlcnQodGhpcy5fc2VnbWVudDIuX2luZGV4LCBzZWdtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXMgPSB0aGlzOyBcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlbmQgPSB0aGlzLl9zZWdtZW50Mjtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIgPSBzZWdtZW50O1xuXHRcdFx0XHRyZXMgPSBuZXcgQ3VydmUoc2VnbWVudCwgZW5kKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoXG5cdFx0XHQ/IHRoaXMuX3BhdGguc3BsaXQodGhpcy5fc2VnbWVudDEuX2luZGV4LFxuXHRcdFx0XHRcdHRoaXMuX2dldFBhcmFtZXRlcihvZmZzZXQsIGlzUGFyYW1ldGVyKSlcblx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQyLnJldmVyc2UoKSwgdGhpcy5fc2VnbWVudDEucmV2ZXJzZSgpKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZW1vdmVkID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3BhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Mi5faGFuZGxlT3V0O1xuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnQyLnJlbW92ZSgpO1xuXHRcdFx0aWYgKHJlbW92ZWQpXG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGhhbmRsZU91dC54LCBoYW5kbGVPdXQueSk7XG5cdFx0fVxuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Mik7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50MTogJyArIHRoaXMuX3NlZ21lbnQxLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTE6ICcgKyB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0KTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTI6ICcgKyB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4pO1xuXHRcdHBhcnRzLnB1c2goJ3BvaW50MjogJyArIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuc3RhdGljczoge1xuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KSB7XG5cdFx0dmFyIHAxID0gc2VnbWVudDEuX3BvaW50LFxuXHRcdFx0aDEgPSBzZWdtZW50MS5faGFuZGxlT3V0LFxuXHRcdFx0aDIgPSBzZWdtZW50Mi5faGFuZGxlSW4sXG5cdFx0XHRwMiA9IHNlZ21lbnQyLl9wb2ludCxcblx0XHRcdHZhbHVlcyA9IFtcblx0XHRcdFx0cDEuX3gsIHAxLl95LFxuXHRcdFx0XHRwMS5feCArIGgxLl94LCBwMS5feSArIGgxLl95LFxuXHRcdFx0XHRwMi5feCArIGgyLl94LCBwMi5feSArIGgyLl95LFxuXHRcdFx0XHRwMi5feCwgcDIuX3lcblx0XHRcdF07XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXModmFsdWVzLCAwLCB2YWx1ZXMsIDAsIDYpO1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKHYsIHQsIHR5cGUpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblx0XHRcdHRvbGVyYW5jZSA9IDAuMDAwMDEsXG5cdFx0XHR4LCB5O1xuXG5cdFx0aWYgKHR5cGUgPT09IDAgJiYgKHQgPCB0b2xlcmFuY2UgfHwgdCA+IDEgLSB0b2xlcmFuY2UpKSB7XG5cdFx0XHR2YXIgaXNaZXJvID0gdCA8IHRvbGVyYW5jZTtcblx0XHRcdHggPSBpc1plcm8gPyBwMXggOiBwMng7XG5cdFx0XHR5ID0gaXNaZXJvID8gcDF5IDogcDJ5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY3ggPSAzICogKGMxeCAtIHAxeCksXG5cdFx0XHRcdGJ4ID0gMyAqIChjMnggLSBjMXgpIC0gY3gsXG5cdFx0XHRcdGF4ID0gcDJ4IC0gcDF4IC0gY3ggLSBieCxcblxuXHRcdFx0XHRjeSA9IDMgKiAoYzF5IC0gcDF5KSxcblx0XHRcdFx0YnkgPSAzICogKGMyeSAtIGMxeSkgLSBjeSxcblx0XHRcdFx0YXkgPSBwMnkgLSBwMXkgLSBjeSAtIGJ5O1xuXHRcdFx0aWYgKHR5cGUgPT09IDApIHtcblx0XHRcdFx0eCA9ICgoYXggKiB0ICsgYngpICogdCArIGN4KSAqIHQgKyBwMXg7XG5cdFx0XHRcdHkgPSAoKGF5ICogdCArIGJ5KSAqIHQgKyBjeSkgKiB0ICsgcDF5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHQgPCB0b2xlcmFuY2UgJiYgYzF4ID09PSBwMXggJiYgYzF5ID09PSBwMXlcblx0XHRcdFx0XHRcdHx8IHQgPiAxIC0gdG9sZXJhbmNlICYmIGMyeCA9PT0gcDJ4ICYmIGMyeSA9PT0gcDJ5KSB7XG5cdFx0XHRcdFx0eCA9IHAyeCAtIHAxeDtcblx0XHRcdFx0XHR5ID0gcDJ5IC0gcDF5O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQgPCB0b2xlcmFuY2UpIHtcblx0XHRcdFx0XHR4ID0gY3g7XG5cdFx0XHRcdFx0eSA9IGN5O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQgPiAxIC0gdG9sZXJhbmNlKSB7XG5cdFx0XHRcdFx0eCA9IDMgKiAocDJ4IC0gYzJ4KTtcblx0XHRcdFx0XHR5ID0gMyAqIChwMnkgLSBjMnkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHggPSAoMyAqIGF4ICogdCArIDIgKiBieCkgKiB0ICsgY3g7XG5cdFx0XHRcdFx0eSA9ICgzICogYXkgKiB0ICsgMiAqIGJ5KSAqIHQgKyBjeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdHZhciB4MiA9IDYgKiBheCAqIHQgKyAyICogYngsXG5cdFx0XHRcdFx0XHR5MiA9IDYgKiBheSAqIHQgKyAyICogYnk7XG5cdFx0XHRcdFx0cmV0dXJuICh4ICogeTIgLSB5ICogeDIpIC8gTWF0aC5wb3coeCAqIHggKyB5ICogeSwgMyAvIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlID09PSAyID8gbmV3IFBvaW50KHksIC14KSA6IG5ldyBQb2ludCh4LCB5KTtcblx0fSxcblxuXHRzdWJkaXZpZGU6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XTtcblx0XHRpZiAodCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dCA9IDAuNTtcblx0XHR2YXIgdSA9IDEgLSB0LFxuXHRcdFx0cDN4ID0gdSAqIHAxeCArIHQgKiBjMXgsIHAzeSA9IHUgKiBwMXkgKyB0ICogYzF5LFxuXHRcdFx0cDR4ID0gdSAqIGMxeCArIHQgKiBjMngsIHA0eSA9IHUgKiBjMXkgKyB0ICogYzJ5LFxuXHRcdFx0cDV4ID0gdSAqIGMyeCArIHQgKiBwMngsIHA1eSA9IHUgKiBjMnkgKyB0ICogcDJ5LFxuXHRcdFx0cDZ4ID0gdSAqIHAzeCArIHQgKiBwNHgsIHA2eSA9IHUgKiBwM3kgKyB0ICogcDR5LFxuXHRcdFx0cDd4ID0gdSAqIHA0eCArIHQgKiBwNXgsIHA3eSA9IHUgKiBwNHkgKyB0ICogcDV5LFxuXHRcdFx0cDh4ID0gdSAqIHA2eCArIHQgKiBwN3gsIHA4eSA9IHUgKiBwNnkgKyB0ICogcDd5O1xuXHRcdHJldHVybiBbXG5cdFx0XHRbcDF4LCBwMXksIHAzeCwgcDN5LCBwNngsIHA2eSwgcDh4LCBwOHldLCBcblx0XHRcdFtwOHgsIHA4eSwgcDd4LCBwN3ksIHA1eCwgcDV5LCBwMngsIHAyeV0gXG5cdFx0XTtcblx0fSxcblxuXHRzb2x2ZUN1YmljOiBmdW5jdGlvbiAodiwgY29vcmQsIHZhbCwgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0dmFyIHAxID0gdltjb29yZF0sXG5cdFx0XHRjMSA9IHZbY29vcmQgKyAyXSxcblx0XHRcdGMyID0gdltjb29yZCArIDRdLFxuXHRcdFx0cDIgPSB2W2Nvb3JkICsgNl0sXG5cdFx0XHRjID0gMyAqIChjMSAtIHAxKSxcblx0XHRcdGIgPSAzICogKGMyIC0gYzEpIC0gYyxcblx0XHRcdGEgPSBwMiAtIHAxIC0gYyAtIGI7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5zb2x2ZUN1YmljKGEsIGIsIGMsIHAxIC0gdmFsLCByb290cywgbWluLCBtYXgpO1xuXHR9LFxuXG5cdGdldFBhcmFtZXRlck9mOiBmdW5jdGlvbih2LCB4LCB5KSB7XG5cdFx0dmFyIHRvbGVyYW5jZSA9IDAuMDAwMDE7XG5cdFx0aWYgKE1hdGguYWJzKHZbMF0gLSB4KSA8IHRvbGVyYW5jZSAmJiBNYXRoLmFicyh2WzFdIC0geSkgPCB0b2xlcmFuY2UpXG5cdFx0XHRyZXR1cm4gMDtcblx0XHRpZiAoTWF0aC5hYnModls2XSAtIHgpIDwgdG9sZXJhbmNlICYmIE1hdGguYWJzKHZbN10gLSB5KSA8IHRvbGVyYW5jZSlcblx0XHRcdHJldHVybiAxO1xuXHRcdHZhciB0eHMgPSBbXSxcblx0XHRcdHR5cyA9IFtdLFxuXHRcdFx0c3ggPSBDdXJ2ZS5zb2x2ZUN1YmljKHYsIDAsIHgsIHR4cyksXG5cdFx0XHRzeSA9IEN1cnZlLnNvbHZlQ3ViaWModiwgMSwgeSwgdHlzKSxcblx0XHRcdHR4LCB0eTtcblx0XHRmb3IgKHZhciBjeCA9IDA7ICBzeCA9PSAtMSB8fCBjeCA8IHN4Oykge1xuXHRcdFx0aWYgKHN4ID09IC0xIHx8ICh0eCA9IHR4c1tjeCsrXSkgPj0gMCAmJiB0eCA8PSAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGN5ID0gMDsgc3kgPT0gLTEgfHwgY3kgPCBzeTspIHtcblx0XHRcdFx0XHRpZiAoc3kgPT0gLTEgfHwgKHR5ID0gdHlzW2N5KytdKSA+PSAwICYmIHR5IDw9IDEpIHtcblx0XHRcdFx0XHRcdGlmIChzeCA9PSAtMSkgdHggPSB0eTtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHN5ID09IC0xKSB0eSA9IHR4O1xuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKHR4IC0gdHkpIDwgdG9sZXJhbmNlKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKHR4ICsgdHkpICogMC41O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3ggPT0gLTEpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKHYsIGZyb20sIHRvKSB7XG5cdFx0aWYgKGZyb20gPiAwKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCBmcm9tKVsxXTsgXG5cdFx0aWYgKHRvIDwgMSlcblx0XHRcdHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgKHRvIC0gZnJvbSkgLyAoMSAtIGZyb20pKVswXTsgXG5cdFx0cmV0dXJuIHY7XG5cdH0sXG5cblx0aXNMaW5lYXI6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gaXNaZXJvKHZbMF0gLSB2WzJdKSAmJiBpc1plcm8odlsxXSAtIHZbM10pXG5cdFx0XHRcdCYmIGlzWmVybyh2WzRdIC0gdls2XSkgJiYgaXNaZXJvKHZbNV0gLSB2WzddKTtcblx0fSxcblxuXHRpc0ZsYXRFbm91Z2g6IGZ1bmN0aW9uKHYsIHRvbGVyYW5jZSkge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXHRcdFx0dXggPSAzICogYzF4IC0gMiAqIHAxeCAtIHAyeCxcblx0XHRcdHV5ID0gMyAqIGMxeSAtIDIgKiBwMXkgLSBwMnksXG5cdFx0XHR2eCA9IDMgKiBjMnggLSAyICogcDJ4IC0gcDF4LFxuXHRcdFx0dnkgPSAzICogYzJ5IC0gMiAqIHAyeSAtIHAxeTtcblx0XHRyZXR1cm4gTWF0aC5tYXgodXggKiB1eCwgdnggKiB2eCkgKyBNYXRoLm1heCh1eSAqIHV5LCB2eSAqIHZ5KVxuXHRcdFx0XHQ8IDEwICogdG9sZXJhbmNlICogdG9sZXJhbmNlO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XTtcblx0XHRyZXR1cm4gKCAgMy4wICogYzF5ICogcDF4IC0gMS41ICogYzF5ICogYzJ4XG5cdFx0XHRcdC0gMS41ICogYzF5ICogcDJ4IC0gMy4wICogcDF5ICogYzF4XG5cdFx0XHRcdC0gMS41ICogcDF5ICogYzJ4IC0gMC41ICogcDF5ICogcDJ4XG5cdFx0XHRcdCsgMS41ICogYzJ5ICogcDF4ICsgMS41ICogYzJ5ICogYzF4XG5cdFx0XHRcdC0gMy4wICogYzJ5ICogcDJ4ICsgMC41ICogcDJ5ICogcDF4XG5cdFx0XHRcdCsgMS41ICogcDJ5ICogYzF4ICsgMy4wICogcDJ5ICogYzJ4KSAvIDEwO1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24odikge1xuXHRcdHZhciBtaW4gPSB2LnNsaWNlKDAsIDIpLCBcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpLCBcblx0XHRcdHJvb3RzID0gWzAsIDBdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKVxuXHRcdFx0Q3VydmUuX2FkZEJvdW5kcyh2W2ldLCB2W2kgKyAyXSwgdltpICsgNF0sIHZbaSArIDZdLFxuXHRcdFx0XHRcdGksIDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcblx0fSxcblxuXHRfYWRkQm91bmRzOiBmdW5jdGlvbih2MCwgdjEsIHYyLCB2MywgY29vcmQsIHBhZGRpbmcsIG1pbiwgbWF4LCByb290cykge1xuXHRcdGZ1bmN0aW9uIGFkZCh2YWx1ZSwgcGFkZGluZykge1xuXHRcdFx0dmFyIGxlZnQgPSB2YWx1ZSAtIHBhZGRpbmcsXG5cdFx0XHRcdHJpZ2h0ID0gdmFsdWUgKyBwYWRkaW5nO1xuXHRcdFx0aWYgKGxlZnQgPCBtaW5bY29vcmRdKVxuXHRcdFx0XHRtaW5bY29vcmRdID0gbGVmdDtcblx0XHRcdGlmIChyaWdodCA+IG1heFtjb29yZF0pXG5cdFx0XHRcdG1heFtjb29yZF0gPSByaWdodDtcblx0XHR9XG5cdFx0dmFyIGEgPSAzICogKHYxIC0gdjIpIC0gdjAgKyB2Myxcblx0XHRcdGIgPSAyICogKHYwICsgdjIpIC0gNCAqIHYxLFxuXHRcdFx0YyA9IHYxIC0gdjAsXG5cdFx0XHRjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cyksXG5cdFx0XHR0TWluID0gMC4wMDAwMSxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRhZGQodjMsIDApO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0dmFyIHQgPSByb290c1tpXSxcblx0XHRcdFx0dSA9IDEgLSB0O1xuXHRcdFx0aWYgKHRNaW4gPCB0ICYmIHQgPCB0TWF4KVxuXHRcdFx0XHRhZGQodSAqIHUgKiB1ICogdjBcblx0XHRcdFx0XHQrIDMgKiB1ICogdSAqIHQgKiB2MVxuXHRcdFx0XHRcdCsgMyAqIHUgKiB0ICogdCAqIHYyXG5cdFx0XHRcdFx0KyB0ICogdCAqIHQgKiB2Myxcblx0XHRcdFx0XHRwYWRkaW5nKTtcblx0XHR9XG5cdH1cbn19LCBCYXNlLmVhY2goWydnZXRCb3VuZHMnLCAnZ2V0U3Ryb2tlQm91bmRzJywgJ2dldEhhbmRsZUJvdW5kcycsICdnZXRSb3VnaEJvdW5kcyddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHRcdHRoaXMuX2JvdW5kcyA9IHt9O1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kc1tuYW1lXTtcblx0XHRcdGlmICghYm91bmRzKSB7XG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuX2JvdW5kc1tuYW1lXSA9IFBhdGhbbmFtZV0oW3RoaXMuX3NlZ21lbnQxLFxuXHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudDJdLCBmYWxzZSwgdGhpcy5fcGF0aC5nZXRTdHlsZSgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3VuZHMuY2xvbmUoKTtcblx0XHR9O1xuXHR9LFxue1xuXG59KSwgQmFzZS5lYWNoKFsnZ2V0UG9pbnQnLCAnZ2V0VGFuZ2VudCcsICdnZXROb3JtYWwnLCAnZ2V0Q3VydmF0dXJlJ10sXG5cdGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKTtcblx0XHRcdHJldHVybiBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIGlzUGFyYW1ldGVyXG5cdFx0XHRcdFx0PyBvZmZzZXQgOiBDdXJ2ZS5nZXRQYXJhbWV0ZXJBdCh2YWx1ZXMsIG9mZnNldCwgMCksIGluZGV4KTtcblx0XHR9O1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbihwYXJhbWV0ZXIpIHtcblx0XHRcdHJldHVybiBDdXJ2ZS5ldmFsdWF0ZSh0aGlzLmdldFZhbHVlcygpLCBwYXJhbWV0ZXIsIGluZGV4KTtcblx0XHR9O1xuXHR9LFxue1xuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0LCBzdGFydCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJBdCh0aGlzLmdldFZhbHVlcygpLCBvZmZzZXQsXG5cdFx0XHRcdHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IG9mZnNldCA8IDAgPyAxIDogMCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6IGZ1bmN0aW9uKHBvaW50KSB7IFxuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5nZXRWYWx1ZXMoKSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdGlmICghaXNQYXJhbWV0ZXIpXG5cdFx0XHRvZmZzZXQgPSB0aGlzLmdldFBhcmFtZXRlckF0KG9mZnNldCk7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIG9mZnNldCk7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24ocG9pbnQpIHsgXG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0dCA9IHRoaXMuZ2V0UGFyYW1ldGVyT2YocG9pbnQpO1xuXHRcdHJldHVybiB0ICE9IG51bGwgPyBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0KSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbihwb2ludCkgeyBcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0Y291bnQgPSAxMDAsXG5cdFx0XHRtaW5EaXN0ID0gSW5maW5pdHksXG5cdFx0XHRtaW5UID0gMDtcblxuXHRcdGZ1bmN0aW9uIHJlZmluZSh0KSB7XG5cdFx0XHRpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuXHRcdFx0XHR2YXIgZGlzdCA9IHBvaW50LmdldERpc3RhbmNlKFxuXHRcdFx0XHRcdFx0Q3VydmUuZXZhbHVhdGUodmFsdWVzLCB0LCAwKSwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChkaXN0IDwgbWluRGlzdCkge1xuXHRcdFx0XHRcdG1pbkRpc3QgPSBkaXN0O1xuXHRcdFx0XHRcdG1pblQgPSB0O1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKylcblx0XHRcdHJlZmluZShpIC8gY291bnQpO1xuXG5cdFx0dmFyIHN0ZXAgPSAxIC8gKGNvdW50ICogMik7XG5cdFx0d2hpbGUgKHN0ZXAgPiAwLjAwMDAxKSB7XG5cdFx0XHRpZiAoIXJlZmluZShtaW5UIC0gc3RlcCkgJiYgIXJlZmluZShtaW5UICsgc3RlcCkpXG5cdFx0XHRcdHN0ZXAgLz0gMjtcblx0XHR9XG5cdFx0dmFyIHB0ID0gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCBtaW5ULCAwKTtcblx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgbWluVCwgcHQsIG51bGwsIG51bGwsIG51bGwsXG5cdFx0XHRcdHBvaW50LmdldERpc3RhbmNlKHB0KSk7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpLmdldFBvaW50KCk7XG5cdH1cblxufSksXG5uZXcgZnVuY3Rpb24oKSB7IFxuXG5cdGZ1bmN0aW9uIGdldExlbmd0aEludGVncmFuZCh2KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cblx0XHRcdGF4ID0gOSAqIChjMXggLSBjMngpICsgMyAqIChwMnggLSBwMXgpLFxuXHRcdFx0YnggPSA2ICogKHAxeCArIGMyeCkgLSAxMiAqIGMxeCxcblx0XHRcdGN4ID0gMyAqIChjMXggLSBwMXgpLFxuXG5cdFx0XHRheSA9IDkgKiAoYzF5IC0gYzJ5KSArIDMgKiAocDJ5IC0gcDF5KSxcblx0XHRcdGJ5ID0gNiAqIChwMXkgKyBjMnkpIC0gMTIgKiBjMXksXG5cdFx0XHRjeSA9IDMgKiAoYzF5IC0gcDF5KTtcblxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgZHggPSAoYXggKiB0ICsgYngpICogdCArIGN4LFxuXHRcdFx0XHRkeSA9IChheSAqIHQgKyBieSkgKiB0ICsgY3k7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SXRlcmF0aW9ucyhhLCBiKSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KDIsIE1hdGgubWluKDE2LCBNYXRoLmNlaWwoTWF0aC5hYnMoYiAtIGEpICogMzIpKSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHN0YXRpY3M6IHRydWUsXG5cblx0XHRnZXRMZW5ndGg6IGZ1bmN0aW9uKHYsIGEsIGIpIHtcblx0XHRcdGlmIChhID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGEgPSAwO1xuXHRcdFx0aWYgKGIgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YiA9IDE7XG5cdFx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRcdGlmIChhID09PSAwICYmIGIgPT09IDFcblx0XHRcdFx0XHQmJiBpc1plcm8odlswXSAtIHZbMl0pICYmIGlzWmVybyh2WzFdIC0gdlszXSlcblx0XHRcdFx0XHQmJiBpc1plcm8odls2XSAtIHZbNF0pICYmIGlzWmVybyh2WzddIC0gdls1XSkpIHtcblx0XHRcdFx0dmFyIGR4ID0gdls2XSAtIHZbMF0sIFxuXHRcdFx0XHRcdGR5ID0gdls3XSAtIHZbMV07IFxuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdH1cblx0XHRcdHZhciBkcyA9IGdldExlbmd0aEludGVncmFuZCh2KTtcblx0XHRcdHJldHVybiBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBhLCBiLCBnZXRJdGVyYXRpb25zKGEsIGIpKTtcblx0XHR9LFxuXG5cdFx0Z2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKHYsIG9mZnNldCwgc3RhcnQpIHtcblx0XHRcdGlmIChvZmZzZXQgPT09IDApXG5cdFx0XHRcdHJldHVybiBzdGFydDtcblx0XHRcdHZhciBmb3J3YXJkID0gb2Zmc2V0ID4gMCxcblx0XHRcdFx0YSA9IGZvcndhcmQgPyBzdGFydCA6IDAsXG5cdFx0XHRcdGIgPSBmb3J3YXJkID8gMSA6IHN0YXJ0LFxuXHRcdFx0XHRvZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpLFxuXHRcdFx0XHRkcyA9IGdldExlbmd0aEludGVncmFuZCh2KSxcblx0XHRcdFx0cmFuZ2VMZW5ndGggPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBhLCBiLFxuXHRcdFx0XHRcdFx0Z2V0SXRlcmF0aW9ucyhhLCBiKSk7XG5cdFx0XHRpZiAob2Zmc2V0ID49IHJhbmdlTGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gZm9yd2FyZCA/IGIgOiBhO1xuXHRcdFx0dmFyIGd1ZXNzID0gb2Zmc2V0IC8gcmFuZ2VMZW5ndGgsXG5cdFx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0XHRmdW5jdGlvbiBmKHQpIHtcblx0XHRcdFx0dmFyIGNvdW50ID0gZ2V0SXRlcmF0aW9ucyhzdGFydCwgdCk7XG5cdFx0XHRcdGxlbmd0aCArPSBzdGFydCA8IHRcblx0XHRcdFx0XHRcdD8gTnVtZXJpY2FsLmludGVncmF0ZShkcywgc3RhcnQsIHQsIGNvdW50KVxuXHRcdFx0XHRcdFx0OiAtTnVtZXJpY2FsLmludGVncmF0ZShkcywgdCwgc3RhcnQsIGNvdW50KTtcblx0XHRcdFx0c3RhcnQgPSB0O1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcyxcblx0XHRcdFx0XHRmb3J3YXJkID8gYSArIGd1ZXNzIDogYiAtIGd1ZXNzLCBcblx0XHRcdFx0XHRhLCBiLCAxNiwgMC4wMDAwMSk7XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkgeyBcblx0ZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjdXJ2ZTEsIHQxLCBwb2ludDEsIGN1cnZlMiwgdDIsXG5cdFx0XHRwb2ludDIpIHtcblx0XHR2YXIgbG9jID0gbmV3IEN1cnZlTG9jYXRpb24oY3VydmUxLCB0MSwgcG9pbnQxLCBjdXJ2ZTIsIHQyLCBwb2ludDIpO1xuXHRcdGlmICghaW5jbHVkZSB8fCBpbmNsdWRlKGxvYykpXG5cdFx0XHRsb2NhdGlvbnMucHVzaChsb2MpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgsIG9sZFREaWZmLCByZXZlcnNlLCByZWN1cnNpb24pIHtcblx0XHRpZiAocmVjdXJzaW9uID4gMjApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHEweCA9IHYyWzBdLCBxMHkgPSB2MlsxXSwgcTN4ID0gdjJbNl0sIHEzeSA9IHYyWzddLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMSxcblx0XHRcdGh1bGxFcHNpbG9uID0gMWUtOSxcblx0XHRcdGdldFNpZ25lZERpc3RhbmNlID0gTGluZS5nZXRTaWduZWREaXN0YW5jZSxcblx0XHRcdGQxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MlsyXSwgdjJbM10pIHx8IDAsXG5cdFx0XHRkMiA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbNF0sIHYyWzVdKSB8fCAwLFxuXHRcdFx0ZmFjdG9yID0gZDEgKiBkMiA+IDAgPyAzIC8gNCA6IDQgLyA5LFxuXHRcdFx0ZE1pbiA9IGZhY3RvciAqIE1hdGgubWluKDAsIGQxLCBkMiksXG5cdFx0XHRkTWF4ID0gZmFjdG9yICogTWF0aC5tYXgoMCwgZDEsIGQyKSxcblx0XHRcdGRwMCA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMF0sIHYxWzFdKSxcblx0XHRcdGRwMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMl0sIHYxWzNdKSxcblx0XHRcdGRwMiA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNF0sIHYxWzVdKSxcblx0XHRcdGRwMyA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNl0sIHYxWzddKSxcblx0XHRcdHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmO1xuXHRcdGlmIChxMHggPT09IHEzeCAmJiB1TWF4IC0gdU1pbiA8PSBodWxsRXBzaWxvbiAmJiByZWN1cnNpb24gPiAzKSB7XG5cdFx0XHR0TWluTmV3ID0gKHRNYXggKyB0TWluKSAvIDI7XG5cdFx0XHR0TWF4TmV3ID0gdE1pbk5ldztcblx0XHRcdHREaWZmID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGh1bGwgPSBnZXRDb252ZXhIdWxsKGRwMCwgZHAxLCBkcDIsIGRwMyksXG5cdFx0XHRcdHRvcCA9IGh1bGxbMF0sXG5cdFx0XHRcdGJvdHRvbSA9IGh1bGxbMV0sXG5cdFx0XHRcdHRNaW5DbGlwLCB0TWF4Q2xpcDtcblx0XHRcdHRNaW5DbGlwID0gY2xpcENvbnZleEh1bGwodG9wLCBib3R0b20sIGRNaW4sIGRNYXgpO1xuXHRcdFx0dG9wLnJldmVyc2UoKTtcblx0XHRcdGJvdHRvbS5yZXZlcnNlKCk7XG5cdFx0XHR0TWF4Q2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcCwgYm90dG9tLCBkTWluLCBkTWF4KTtcblx0XHRcdGlmICh0TWluQ2xpcCA9PSBudWxsIHx8IHRNYXhDbGlwID09IG51bGwpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdHYxID0gQ3VydmUuZ2V0UGFydCh2MSwgdE1pbkNsaXAsIHRNYXhDbGlwKTtcblx0XHRcdHREaWZmID0gdE1heENsaXAgLSB0TWluQ2xpcDtcblx0XHRcdHRNaW5OZXcgPSB0TWF4ICogdE1pbkNsaXAgKyB0TWluICogKDEgLSB0TWluQ2xpcCk7XG5cdFx0XHR0TWF4TmV3ID0gdE1heCAqIHRNYXhDbGlwICsgdE1pbiAqICgxIC0gdE1heENsaXApO1xuXHRcdH1cblx0XHRpZiAob2xkVERpZmYgPiAwLjggJiYgdERpZmYgPiAwLjgpIHtcblx0XHRcdGlmICh0TWF4TmV3IC0gdE1pbk5ldyA+IHVNYXggLSB1TWluKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgMC41KSxcblx0XHRcdFx0XHR0ID0gdE1pbk5ldyArICh0TWF4TmV3IC0gdE1pbk5ldykgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzBdLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzFdLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHQsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MiwgMC41KSxcblx0XHRcdFx0XHR0ID0gdU1pbiArICh1TWF4IC0gdU1pbikgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMF0sIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHQsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMV0sIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHQsIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKE1hdGgubWF4KHVNYXggLSB1TWluLCB0TWF4TmV3IC0gdE1pbk5ldykgPCB0b2xlcmFuY2UpIHtcblx0XHRcdHZhciB0MSA9IHRNaW5OZXcgKyAodE1heE5ldyAtIHRNaW5OZXcpIC8gMixcblx0XHRcdFx0dDIgPSB1TWluICsgKHVNYXggLSB1TWluKSAvIDI7XG5cdFx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRjdXJ2ZTIsIHQyLCBDdXJ2ZS5ldmFsdWF0ZSh2MiwgdDIsIDApLFxuXHRcdFx0XHRcdFx0Y3VydmUxLCB0MSwgQ3VydmUuZXZhbHVhdGUodjEsIHQxLCAwKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRjdXJ2ZTEsIHQxLCBDdXJ2ZS5ldmFsdWF0ZSh2MSwgdDEsIDApLFxuXHRcdFx0XHRcdFx0Y3VydmUyLCB0MiwgQ3VydmUuZXZhbHVhdGUodjIsIHQyLCAwKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgXG5cdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnModjIsIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbnZleEh1bGwoZHEwLCBkcTEsIGRxMiwgZHEzKSB7XG5cdFx0dmFyIHAwID0gWyAwLCBkcTAgXSxcblx0XHRcdHAxID0gWyAxIC8gMywgZHExIF0sXG5cdFx0XHRwMiA9IFsgMiAvIDMsIGRxMiBdLFxuXHRcdFx0cDMgPSBbIDEsIGRxMyBdLFxuXHRcdFx0Z2V0U2lnbmVkRGlzdGFuY2UgPSBMaW5lLmdldFNpZ25lZERpc3RhbmNlLFxuXHRcdFx0ZGlzdDEgPSBnZXRTaWduZWREaXN0YW5jZSgwLCBkcTAsIDEsIGRxMywgMSAvIDMsIGRxMSksXG5cdFx0XHRkaXN0MiA9IGdldFNpZ25lZERpc3RhbmNlKDAsIGRxMCwgMSwgZHEzLCAyIC8gMywgZHEyKSxcblx0XHRcdGZsaXAgPSBmYWxzZSxcblx0XHRcdGh1bGw7XG5cdFx0aWYgKGRpc3QxICogZGlzdDIgPCAwKSB7XG5cdFx0XHRodWxsID0gW1twMCwgcDEsIHAzXSwgW3AwLCBwMiwgcDNdXTtcblx0XHRcdGZsaXAgPSBkaXN0MSA8IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwbWF4LCBjcm9zcyA9IDAsXG5cdFx0XHRcdGRpc3RaZXJvID0gZGlzdDEgPT09IDAgfHwgZGlzdDIgPT09IDA7XG5cdFx0XHRpZiAoTWF0aC5hYnMoZGlzdDEpID4gTWF0aC5hYnMoZGlzdDIpKSB7XG5cdFx0XHRcdHBtYXggPSBwMTtcblx0XHRcdFx0Y3Jvc3MgPSAoZHEzIC0gZHEyIC0gKGRxMyAtIGRxMCkgLyAzKVxuXHRcdFx0XHRcdFx0KiAoMiAqIChkcTMgLSBkcTIpIC0gZHEzICsgZHExKSAvIDM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwbWF4ID0gcDI7XG5cdFx0XHRcdGNyb3NzID0gKGRxMSAtIGRxMCArIChkcTAgLSBkcTMpIC8gMylcblx0XHRcdFx0XHRcdCogKC0yICogKGRxMCAtIGRxMSkgKyBkcTAgLSBkcTIpIC8gMztcblx0XHRcdH1cblx0XHRcdGh1bGwgPSBjcm9zcyA8IDAgfHwgZGlzdFplcm9cblx0XHRcdFx0XHQ/IFtbcDAsIHBtYXgsIHAzXSwgW3AwLCBwM11dXG5cdFx0XHRcdFx0OiBbW3AwLCBwMSwgcDIsIHAzXSwgW3AwLCBwM11dO1xuXHRcdFx0ZmxpcCA9IGRpc3QxID8gZGlzdDEgPCAwIDogZGlzdDIgPCAwO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxpcCA/IGh1bGwucmV2ZXJzZSgpIDogaHVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsKGh1bGxUb3AsIGh1bGxCb3R0b20sIGRNaW4sIGRNYXgpIHtcblx0XHR2YXIgdFByb3h5LFxuXHRcdFx0dFZhbCA9IG51bGwsXG5cdFx0XHRweCwgcHksXG5cdFx0XHRxeCwgcXk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBodWxsQm90dG9tLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcblx0XHRcdHB5ID0gaHVsbEJvdHRvbVtpXVsxXTtcblx0XHRcdHF5ID0gaHVsbEJvdHRvbVtpICsgMV1bMV07XG5cdFx0XHRpZiAocHkgPCBxeSkge1xuXHRcdFx0XHR0UHJveHkgPSBudWxsO1xuXHRcdFx0fSBlbHNlIGlmIChxeSA8PSBkTWF4KSB7XG5cdFx0XHRcdHB4ID0gaHVsbEJvdHRvbVtpXVswXTtcblx0XHRcdFx0cXggPSBodWxsQm90dG9tW2kgKyAxXVswXTtcblx0XHRcdFx0dFByb3h5ID0gcHggKyAoZE1heCAgLSBweSkgKiAocXggLSBweCkgLyAocXkgLSBweSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpZiAoaHVsbFRvcFswXVsxXSA8PSBkTWF4KVxuXHRcdFx0dFByb3h5ID0gaHVsbFRvcFswXVswXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGh1bGxUb3AubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0cHkgPSBodWxsVG9wW2ldWzFdO1xuXHRcdFx0cXkgPSBodWxsVG9wW2kgKyAxXVsxXTtcblx0XHRcdGlmIChweSA+PSBkTWluKSB7XG5cdFx0XHRcdHRWYWwgPSB0UHJveHk7XG5cdFx0XHR9IGVsc2UgaWYgKHB5ID4gcXkpIHtcblx0XHRcdFx0dFZhbCA9IG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKHF5ID49IGRNaW4pIHtcblx0XHRcdFx0cHggPSBodWxsVG9wW2ldWzBdO1xuXHRcdFx0XHRxeCA9IGh1bGxUb3BbaSArIDFdWzBdO1xuXHRcdFx0XHR0VmFsID0gcHggKyAoZE1pbiAgLSBweSkgKiAocXggLSBweCkgLyAocXkgLSBweSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm4gdFZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnModjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLFxuXHRcdFx0aW5jbHVkZSkge1xuXHRcdHZhciBmbGlwID0gQ3VydmUuaXNMaW5lYXIodjEpLFxuXHRcdFx0dmMgPSBmbGlwID8gdjIgOiB2MSxcblx0XHRcdHZsID0gZmxpcCA/IHYxIDogdjIsXG5cdFx0XHRseDEgPSB2bFswXSwgbHkxID0gdmxbMV0sXG5cdFx0XHRseDIgPSB2bFs2XSwgbHkyID0gdmxbN10sXG5cdFx0XHRsZHggPSBseDIgLSBseDEsXG5cdFx0XHRsZHkgPSBseTIgLSBseTEsXG5cdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoLWxkeSwgbGR4KSxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHJseDIgPSBsZHggKiBjb3MgLSBsZHkgKiBzaW4sXG5cdFx0XHRydmwgPSBbMCwgMCwgMCwgMCwgcmx4MiwgMCwgcmx4MiwgMF0sXG5cdFx0XHRydmMgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG5cdFx0XHR2YXIgeCA9IHZjW2ldIC0gbHgxLFxuXHRcdFx0XHR5ID0gdmNbaSArIDFdIC0gbHkxO1xuXHRcdFx0cnZjLnB1c2goXG5cdFx0XHRcdHggKiBjb3MgLSB5ICogc2luLFxuXHRcdFx0XHR5ICogY29zICsgeCAqIHNpbik7XG5cdFx0fVxuXHRcdHZhciByb290cyA9IFtdLFxuXHRcdFx0Y291bnQgPSBDdXJ2ZS5zb2x2ZUN1YmljKHJ2YywgMSwgMCwgcm9vdHMsIDAsIDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0dmFyIHRjID0gcm9vdHNbaV0sXG5cdFx0XHRcdHggPSBDdXJ2ZS5ldmFsdWF0ZShydmMsIHRjLCAwKS54O1xuXHRcdFx0aWYgKHggPj0gMCAmJiB4IDw9IHJseDIpIHtcblx0XHRcdFx0dmFyIHRsID0gQ3VydmUuZ2V0UGFyYW1ldGVyT2YocnZsLCB4LCAwKSxcblx0XHRcdFx0XHR0MSA9IGZsaXAgPyB0bCA6IHRjLFxuXHRcdFx0XHRcdHQyID0gZmxpcCA/IHRjIDogdGw7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGN1cnZlMSwgdDEsIEN1cnZlLmV2YWx1YXRlKHYxLCB0MSwgMCksXG5cdFx0XHRcdFx0XHRjdXJ2ZTIsIHQyLCBDdXJ2ZS5ldmFsdWF0ZSh2MiwgdDIsIDApKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRMaW5lSW50ZXJzZWN0aW9uKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuXHRcdHZhciBwb2ludCA9IExpbmUuaW50ZXJzZWN0KFxuXHRcdFx0XHR2MVswXSwgdjFbMV0sIHYxWzZdLCB2MVs3XSxcblx0XHRcdFx0djJbMF0sIHYyWzFdLCB2Mls2XSwgdjJbN10pO1xuXHRcdGlmIChwb2ludCkge1xuXHRcdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0XHR5ID0gcG9pbnQueTtcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRjdXJ2ZTEsIEN1cnZlLmdldFBhcmFtZXRlck9mKHYxLCB4LCB5KSwgcG9pbnQsXG5cdFx0XHRcdFx0Y3VydmUyLCBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2MiwgeCwgeSksIHBvaW50KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cdFx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24odjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0XHR2YXIgbGluZWFyMSA9IEN1cnZlLmlzTGluZWFyKHYxKSxcblx0XHRcdFx0bGluZWFyMiA9IEN1cnZlLmlzTGluZWFyKHYyKTtcblx0XHRcdChsaW5lYXIxICYmIGxpbmVhcjJcblx0XHRcdFx0PyBhZGRMaW5lSW50ZXJzZWN0aW9uXG5cdFx0XHRcdDogbGluZWFyMSB8fCBsaW5lYXIyXG5cdFx0XHRcdFx0PyBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0OiBhZGRDdXJ2ZUludGVyc2VjdGlvbnMpKFxuXHRcdFx0XHRcdFx0djEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0MCwgMSwgMCwgMSwgMCwgZmFsc2UsIDApO1xuXHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHR9XG5cdH19O1xufSk7XG5cbnZhciBDdXJ2ZUxvY2F0aW9uID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZUxvY2F0aW9uJyxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmVMb2NhdGlvbihjdXJ2ZSwgcGFyYW1ldGVyLCBwb2ludCwgX2N1cnZlMixcblx0XHRcdF9wYXJhbWV0ZXIyLCBfcG9pbnQyLCBfZGlzdGFuY2UpIHtcblx0XHR0aGlzLl9pZCA9IEN1cnZlTG9jYXRpb24uX2lkID0gKEN1cnZlTG9jYXRpb24uX2lkIHx8IDApICsgMTtcblx0XHR0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuXHRcdHRoaXMuX3NlZ21lbnQxID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdHRoaXMuX3NlZ21lbnQyID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50O1xuXHRcdHRoaXMuX2N1cnZlMiA9IF9jdXJ2ZTI7XG5cdFx0dGhpcy5fcGFyYW1ldGVyMiA9IF9wYXJhbWV0ZXIyO1xuXHRcdHRoaXMuX3BvaW50MiA9IF9wb2ludDI7XG5cdFx0dGhpcy5fZGlzdGFuY2UgPSBfZGlzdGFuY2U7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDogZnVuY3Rpb24oX3ByZWZlckZpcnN0KSB7XG5cdFx0aWYgKCF0aGlzLl9zZWdtZW50KSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0XHRpZiAocGFyYW1ldGVyID09PSAxKSB7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlciA9PT0gMCB8fCBfcHJlZmVyRmlyc3QpIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MTtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50ID0gY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpXG5cdFx0XHRcdFx0PCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHBhcmFtZXRlciwgMSlcblx0XHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQxXG5cdFx0XHRcdFx0XHQ6IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQ7XG5cdH0sXG5cblx0Z2V0Q3VydmU6IGZ1bmN0aW9uKF91bmNhY2hlZCkge1xuXHRcdGlmICghdGhpcy5fY3VydmUgfHwgX3VuY2FjaGVkKSB7XG5cdFx0XHR0aGlzLl9jdXJ2ZSA9IHRoaXMuX3NlZ21lbnQxLmdldEN1cnZlKCk7XG5cdFx0XHRpZiAodGhpcy5fY3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5fcG9pbnQpID09IG51bGwpXG5cdFx0XHRcdHRoaXMuX2N1cnZlID0gdGhpcy5fc2VnbWVudDIuZ2V0UHJldmlvdXMoKS5nZXRDdXJ2ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY3VydmU7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5faW50ZXJzZWN0aW9uO1xuXHRcdGlmICghaW50ZXJzZWN0aW9uICYmIHRoaXMuX2N1cnZlMikge1xuXHRcdFx0dmFyIHBhcmFtID0gdGhpcy5fcGFyYW1ldGVyMjtcblx0XHRcdHRoaXMuX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbiA9IG5ldyBDdXJ2ZUxvY2F0aW9uKFxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlMiwgcGFyYW0sIHRoaXMuX3BvaW50MiB8fCB0aGlzLl9wb2ludCwgdGhpcyk7XG5cdFx0XHRpbnRlcnNlY3Rpb24uX2ludGVyc2VjdGlvbiA9IHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb247XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5fcGF0aDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5nZXRJbmRleCgpO1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLmdldFBhdGgoKTtcblx0XHRyZXR1cm4gcGF0aCAmJiBwYXRoLl9nZXRPZmZzZXQodGhpcyk7XG5cdH0sXG5cblx0Z2V0Q3VydmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKF91bmNhY2hlZCkge1xuXHRcdGlmICgodGhpcy5fcGFyYW1ldGVyID09IG51bGwgfHwgX3VuY2FjaGVkKSAmJiB0aGlzLl9wb2ludCkge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZShfdW5jYWNoZWQgJiYgdGhpcy5fcG9pbnQpO1xuXHRcdFx0dGhpcy5fcGFyYW1ldGVyID0gY3VydmUgJiYgY3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5fcG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcGFyYW1ldGVyO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbihfdW5jYWNoZWQpIHtcblx0XHRpZiAoKCF0aGlzLl9wb2ludCB8fCBfdW5jYWNoZWQpICYmIHRoaXMuX3BhcmFtZXRlciAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0XHR0aGlzLl9wb2ludCA9IGN1cnZlICYmIGN1cnZlLmdldFBvaW50QXQodGhpcy5fcGFyYW1ldGVyLCB0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50O1xuXHR9LFxuXG5cdGdldFRhbmdlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpLFxuXHRcdFx0Y3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlLmdldFRhbmdlbnRBdChwYXJhbWV0ZXIsIHRydWUpO1xuXHR9LFxuXG5cdGdldE5vcm1hbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCksXG5cdFx0XHRjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gcGFyYW1ldGVyICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmUuZ2V0Tm9ybWFsQXQocGFyYW1ldGVyLCB0cnVlKTtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Rpc3RhbmNlO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSh0cnVlKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuZGl2aWRlKHRoaXMuZ2V0UGFyYW1ldGVyKHRydWUpLCB0cnVlKTtcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSh0cnVlKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuc3BsaXQodGhpcy5nZXRQYXJhbWV0ZXIodHJ1ZSksIHRydWUpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24obG9jKSB7XG5cdFx0dmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0cmV0dXJuIHRoaXMgPT09IGxvY1xuXHRcdFx0XHR8fCBsb2Ncblx0XHRcdFx0XHQmJiB0aGlzLl9jdXJ2ZSA9PT0gbG9jLl9jdXJ2ZVxuXHRcdFx0XHRcdCYmIHRoaXMuX2N1cnZlMiA9PT0gbG9jLl9jdXJ2ZTJcblx0XHRcdFx0XHQmJiBpc1plcm8odGhpcy5fcGFyYW1ldGVyIC0gbG9jLl9wYXJhbWV0ZXIpXG5cdFx0XHRcdFx0JiYgaXNaZXJvKHRoaXMuX3BhcmFtZXRlcjIgLSBsb2MuX3BhcmFtZXRlcjIpXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbXSxcblx0XHRcdHBvaW50ID0gdGhpcy5nZXRQb2ludCgpLFxuXHRcdFx0ZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRpZiAocG9pbnQpXG5cdFx0XHRwYXJ0cy5wdXNoKCdwb2ludDogJyArIHBvaW50KTtcblx0XHR2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG5cdFx0aWYgKGluZGV4ICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdpbmRleDogJyArIGluZGV4KTtcblx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRpZiAocGFyYW1ldGVyICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdwYXJhbWV0ZXI6ICcgKyBmLm51bWJlcihwYXJhbWV0ZXIpKTtcblx0XHRpZiAodGhpcy5fZGlzdGFuY2UgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2Rpc3RhbmNlOiAnICsgZi5udW1iZXIodGhpcy5fZGlzdGFuY2UpKTtcblx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFBhdGhJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoSXRlbScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGF0aEl0ZW0oKSB7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24ocGF0aCwgX2V4cGFuZCkge1xuXHRcdGlmICh0aGlzID09PSBwYXRoKVxuXHRcdFx0cGF0aCA9IG51bGw7XG5cdFx0aWYgKHBhdGggJiYgIXRoaXMuZ2V0Qm91bmRzKCkudG91Y2hlcyhwYXRoLmdldEJvdW5kcygpKSlcblx0XHRcdHJldHVybiBbXTtcblx0XHR2YXIgbG9jYXRpb25zID0gW10sXG5cdFx0XHRjdXJ2ZXMxID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdGN1cnZlczIgPSBwYXRoID8gcGF0aC5nZXRDdXJ2ZXMoKSA6IGN1cnZlczEsXG5cdFx0XHRtYXRyaXgxID0gdGhpcy5fbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKSxcblx0XHRcdG1hdHJpeDIgPSBwYXRoID8gcGF0aC5fbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKSA6IG1hdHJpeDEsXG5cdFx0XHRsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG5cdFx0XHRsZW5ndGgyID0gcGF0aCA/IGN1cnZlczIubGVuZ3RoIDogbGVuZ3RoMSxcblx0XHRcdHZhbHVlczIgPSBbXSxcblx0XHRcdE1JTiA9IDFlLTExLFxuXHRcdFx0TUFYID0gMSAtIDFlLTExO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKVxuXHRcdFx0dmFsdWVzMltpXSA9IGN1cnZlczJbaV0uZ2V0VmFsdWVzKG1hdHJpeDIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUxID0gY3VydmVzMVtpXSxcblx0XHRcdFx0dmFsdWVzMSA9IHBhdGggPyBjdXJ2ZTEuZ2V0VmFsdWVzKG1hdHJpeDEpIDogdmFsdWVzMltpXTtcblx0XHRcdGlmICghcGF0aCkge1xuXHRcdFx0XHR2YXIgc2VnMSA9IGN1cnZlMS5nZXRTZWdtZW50MSgpLFxuXHRcdFx0XHRcdHNlZzIgPSBjdXJ2ZTEuZ2V0U2VnbWVudDIoKSxcblx0XHRcdFx0XHRoMSA9IHNlZzEuX2hhbmRsZU91dCxcblx0XHRcdFx0XHRoMiA9IHNlZzIuX2hhbmRsZUluO1xuXHRcdFx0XHRpZiAobmV3IExpbmUoc2VnMS5fcG9pbnQuc3VidHJhY3QoaDEpLCBoMS5tdWx0aXBseSgyKSwgdHJ1ZSlcblx0XHRcdFx0XHRcdC5pbnRlcnNlY3QobmV3IExpbmUoc2VnMi5fcG9pbnQuc3VidHJhY3QoaDIpLFxuXHRcdFx0XHRcdFx0aDIubXVsdGlwbHkoMiksIHRydWUpLCBmYWxzZSkpIHtcblx0XHRcdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodmFsdWVzMSk7XG5cdFx0XHRcdFx0Q3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdHBhcnRzWzBdLCBwYXJ0c1sxXSwgY3VydmUxLCBjdXJ2ZTEsIGxvY2F0aW9ucyxcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKGxvYykge1xuXHRcdFx0XHRcdFx0XHRpZiAobG9jLl9wYXJhbWV0ZXIgPD0gTUFYKSB7XG5cdFx0XHRcdFx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIgLz0gMjtcblx0XHRcdFx0XHRcdFx0XHRsb2MuX3BhcmFtZXRlcjIgPSAwLjUgKyBsb2MuX3BhcmFtZXRlcjIgLyAyO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaiA9IHBhdGggPyAwIDogaSArIDE7IGogPCBsZW5ndGgyOyBqKyspIHtcblx0XHRcdFx0Q3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2YWx1ZXMxLCB2YWx1ZXMyW2pdLCBjdXJ2ZTEsIGN1cnZlczJbal0sIGxvY2F0aW9ucyxcblx0XHRcdFx0XHQhcGF0aCAmJiAoaiA9PT0gaSArIDEgfHwgaiA9PT0gbGVuZ3RoMiAtIDEgJiYgaSA9PT0gMClcblx0XHRcdFx0XHRcdCYmIGZ1bmN0aW9uKGxvYykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdCA9IGxvYy5fcGFyYW1ldGVyO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdCA+PSBNSU4gJiYgdCA8PSBNQVg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBsYXN0ID0gbG9jYXRpb25zLmxlbmd0aCAtIDE7XG5cdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgbG9jID0gbG9jYXRpb25zW2ldLFxuXHRcdFx0XHRuZXh0ID0gbG9jLl9jdXJ2ZS5nZXROZXh0KCksXG5cdFx0XHRcdG5leHQyID0gbG9jLl9jdXJ2ZTIuZ2V0TmV4dCgpO1xuXHRcdFx0aWYgKG5leHQgJiYgbG9jLl9wYXJhbWV0ZXIgPj0gTUFYKSB7XG5cdFx0XHRcdGxvYy5fcGFyYW1ldGVyID0gMDtcblx0XHRcdFx0bG9jLl9jdXJ2ZSA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAobmV4dDIgJiYgbG9jLl9wYXJhbWV0ZXIyID49IE1BWCkge1xuXHRcdFx0XHRsb2MuX3BhcmFtZXRlcjIgPSAwO1xuXHRcdFx0XHRsb2MuX2N1cnZlMiA9IG5leHQyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbXBhcmUobG9jMSwgbG9jMikge1xuXHRcdFx0dmFyIHBhdGgxID0gbG9jMS5nZXRQYXRoKCksXG5cdFx0XHRcdHBhdGgyID0gbG9jMi5nZXRQYXRoKCk7XG5cdFx0XHRyZXR1cm4gcGF0aDEgPT09IHBhdGgyXG5cdFx0XHRcdFx0PyAobG9jMS5nZXRJbmRleCgpICsgbG9jMS5nZXRQYXJhbWV0ZXIoKSlcblx0XHRcdFx0XHRcdFx0LSAobG9jMi5nZXRJbmRleCgpICsgbG9jMi5nZXRQYXJhbWV0ZXIoKSlcblx0XHRcdFx0XHQ6IHBhdGgxLl9pZCAtIHBhdGgyLl9pZDtcblx0XHR9XG5cblx0XHRpZiAobGFzdCA+IDApIHtcblx0XHRcdGxvY2F0aW9ucy5zb3J0KGNvbXBhcmUpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmIChsb2NhdGlvbnNbaV0uZXF1YWxzKGxvY2F0aW9uc1tpID09PSAwID8gbGFzdCA6IGkgLSAxXSkpIHtcblx0XHRcdFx0XHRsb2NhdGlvbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdGxhc3QtLTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoX2V4cGFuZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPj0gMDsgaS0tKVxuXHRcdFx0XHRsb2NhdGlvbnMucHVzaChsb2NhdGlvbnNbaV0uZ2V0SW50ZXJzZWN0aW9uKCkpO1xuXHRcdFx0bG9jYXRpb25zLnNvcnQoY29tcGFyZSk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdH0sXG5cblx0c2V0UGF0aERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblxuXHRcdHZhciBwYXJ0cyA9IGRhdGEubWF0Y2goL1ttbGh2Y3NxdGF6XVtebWxodmNzcXRhel0qL2lnKSxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdHJlbGF0aXZlID0gZmFsc2UsXG5cdFx0XHRwcmV2aW91cyxcblx0XHRcdGNvbnRyb2wsXG5cdFx0XHRjdXJyZW50ID0gbmV3IFBvaW50KCksXG5cdFx0XHRzdGFydCA9IG5ldyBQb2ludCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29vcmQoaW5kZXgsIGNvb3JkKSB7XG5cdFx0XHR2YXIgdmFsID0gK2Nvb3Jkc1tpbmRleF07XG5cdFx0XHRpZiAocmVsYXRpdmUpXG5cdFx0XHRcdHZhbCArPSBjdXJyZW50W2Nvb3JkXTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UG9pbnQoaW5kZXgpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdGdldENvb3JkKGluZGV4LCAneCcpLFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCArIDEsICd5Jylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbGVhcigpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHNbaV0sXG5cdFx0XHRcdGNvbW1hbmQgPSBwYXJ0WzBdLFxuXHRcdFx0XHRsb3dlciA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvb3JkcyA9IHBhcnQubWF0Y2goL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoO1xuXHRcdFx0cmVsYXRpdmUgPSBjb21tYW5kID09PSBsb3dlcjtcblx0XHRcdGlmIChwcmV2aW91cyA9PT0gJ3onICYmICEvW216XS8udGVzdChsb3dlcikpXG5cdFx0XHRcdHRoaXMubW92ZVRvKGN1cnJlbnQgPSBzdGFydCk7XG5cdFx0XHRzd2l0Y2ggKGxvd2VyKSB7XG5cdFx0XHRjYXNlICdtJzpcblx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHR2YXIgbW92ZSA9IGxvd2VyID09PSAnbSc7XG5cdFx0XHRcdGlmIChtb3ZlICYmIHByZXZpb3VzICYmIHByZXZpb3VzICE9PSAneicpXG5cdFx0XHRcdFx0dGhpcy5jbG9zZVBhdGgodHJ1ZSk7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpXG5cdFx0XHRcdFx0dGhpc1tqID09PSAwICYmIG1vdmUgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGlmIChtb3ZlKVxuXHRcdFx0XHRcdHN0YXJ0ID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdoJzpcblx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHR2YXIgY29vcmQgPSBsb3dlciA9PT0gJ2gnID8gJ3gnIDogJ3knO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y3VycmVudFtjb29yZF0gPSBnZXRDb29yZChqLCBjb29yZCk7XG5cdFx0XHRcdFx0dGhpcy5saW5lVG8oY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDYpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Z2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqICsgMiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgNCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0L1tjc10vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9ICgvW3F0XS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50KSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDcpIHtcblx0XHRcdFx0XHR0aGlzLmFyY1RvKGN1cnJlbnQgPSBnZXRQb2ludChqICsgNSksXG5cdFx0XHRcdFx0XHRcdG5ldyBTaXplKCtjb29yZHNbMF0sICtjb29yZHNbMV0pLFxuXHRcdFx0XHRcdFx0XHQrY29vcmRzWzJdLCArY29vcmRzWzRdLCArY29vcmRzWzNdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3onOlxuXHRcdFx0XHR0aGlzLmNsb3NlUGF0aCh0cnVlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcblx0fSxcblxuXHRfY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHdpbmRpbmcgPSB0aGlzLl9nZXRXaW5kaW5nKHBvaW50LCBmYWxzZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuICEhKHRoaXMuZ2V0V2luZGluZ1J1bGUoKSA9PT0gJ2V2ZW5vZGQnID8gd2luZGluZyAmIDEgOiB3aW5kaW5nKTtcblx0fVxuXG59KTtcblxudmFyIFBhdGggPSBQYXRoSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoJyxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHNlZ21lbnRzOiBbXSxcblx0XHRjbG9zZWQ6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGF0aChhcmcpIHtcblx0XHR0aGlzLl9jbG9zZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9zZWdtZW50cyA9IFtdO1xuXHRcdHZhciBzZWdtZW50cyA9IEFycmF5LmlzQXJyYXkoYXJnKVxuXHRcdFx0PyB0eXBlb2YgYXJnWzBdID09PSAnb2JqZWN0J1xuXHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHQ6IGFyZ3VtZW50c1xuXHRcdFx0OiBhcmcgJiYgKGFyZy5zaXplID09PSB1bmRlZmluZWQgJiYgKGFyZy54ICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHR8fCBhcmcucG9pbnQgIT09IHVuZGVmaW5lZCkpXG5cdFx0XHRcdD8gYXJndW1lbnRzXG5cdFx0XHRcdDogbnVsbDtcblx0XHRpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2N1cnZlcyA9IHVuZGVmaW5lZDsgXG5cdFx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IDA7XG5cdFx0XHRpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdFx0YXJnID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U2VnbWVudHModGhpcy5fc2VnbWVudHMpO1xuXHRcdGNvcHkuX2Nsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Ll9jbG9ja3dpc2UgPSB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0cGFyZW50Ll9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2Nsb2Nrd2lzZSA9IHVuZGVmaW5lZDtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZXMgJiYgIShmbGFncyAmIDE2KSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2ldLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tb25vQ3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoZmxhZ3MgJiAzMikge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRyZXR1cm4gKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCA/IHBhcmVudCA6IHRoaXMpLl9zdHlsZTtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzO1xuXHR9LFxuXG5cdHNldFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBmdWxseVNlbGVjdGVkID0gdGhpcy5pc0Z1bGx5U2VsZWN0ZWQoKTtcblx0XHR0aGlzLl9zZWdtZW50cy5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gMDtcblx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApXG5cdFx0XHR0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG5cdFx0aWYgKGZ1bGx5U2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbMF07XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c1t0aGlzLl9zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGlmICghY3VydmVzKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdFx0Y3VydmVzW2ldID0gbmV3IEN1cnZlKHRoaXMsIHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXSk7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q3VydmVzKClbMF07XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRyZXR1cm4gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0fSxcblxuXHRzZXRDbG9zZWQ6IGZ1bmN0aW9uKGNsb3NlZCkge1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgIT0gKGNsb3NlZCA9ICEhY2xvc2VkKSkge1xuXHRcdFx0dGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdFx0aWYgKHRoaXMuX2N1cnZlcykge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY3VydmVzLmxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRcdGlmIChjbG9zZWQpXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2xlbmd0aCAtIDFdID0gbmV3IEN1cnZlKHRoaXMsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50c1tsZW5ndGggLSAxXSwgdGhpcy5fc2VnbWVudHNbMF0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0fVxuXHR9XG59LCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlLFxuXHRcdFx0cGFydHMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGFkZEN1cnZlKHNlZzEsIHNlZzIsIHNraXBMaW5lKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gc2VnMS5fcG9pbnQsXG5cdFx0XHRcdHBvaW50MiA9IHNlZzIuX3BvaW50LFxuXHRcdFx0XHRoYW5kbGUxID0gc2VnMS5faGFuZGxlT3V0LFxuXHRcdFx0XHRoYW5kbGUyID0gc2VnMi5faGFuZGxlSW47XG5cdFx0XHRpZiAoaGFuZGxlMS5pc1plcm8oKSAmJiBoYW5kbGUyLmlzWmVybygpKSB7XG5cdFx0XHRcdGlmICghc2tpcExpbmUpIHtcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdMJyArIGYucG9pbnQocG9pbnQyLCBfcHJlY2lzaW9uKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlbmQgPSBwb2ludDIuc3VidHJhY3QocG9pbnQxKTtcblx0XHRcdFx0cGFydHMucHVzaCgnYycgKyBmLnBvaW50KGhhbmRsZTEsIF9wcmVjaXNpb24pXG5cdFx0XHRcdFx0XHQrICcgJyArIGYucG9pbnQoZW5kLmFkZChoYW5kbGUyKSwgX3ByZWNpc2lvbilcblx0XHRcdFx0XHRcdCsgJyAnICsgZi5wb2ludChlbmQsIF9wcmVjaXNpb24pKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdHBhcnRzLnB1c2goJ00nICsgZi5wb2ludChzZWdtZW50c1swXS5fcG9pbnQpKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aCAgLSAxOyBpIDwgbDsgaSsrKVxuXHRcdFx0YWRkQ3VydmUoc2VnbWVudHNbaV0sIHNlZ21lbnRzW2kgKyAxXSwgZmFsc2UpO1xuXHRcdGlmICh0aGlzLl9jbG9zZWQpIHtcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLCBzZWdtZW50c1swXSwgdHJ1ZSk7XG5cdFx0XHRwYXJ0cy5wdXNoKCd6Jyk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCcnKTtcblx0fVxufSwge1xuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50cy5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0aXNQb2x5Z29uOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKCF0aGlzLl9zZWdtZW50c1tpXS5pc0xpbmVhcigpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fc2VnbWVudHNbaV0uX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCB0cnVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfYWRkOiBmdW5jdGlvbihzZWdzLCBpbmRleCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0YW1vdW50ID0gc2Vncy5sZW5ndGgsXG5cdFx0XHRhcHBlbmQgPSBpbmRleCA9PSBudWxsLFxuXHRcdFx0aW5kZXggPSBhcHBlbmQgPyBzZWdtZW50cy5sZW5ndGggOiBpbmRleDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ3NbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fcGF0aClcblx0XHRcdFx0c2VnbWVudCA9IHNlZ3NbaV0gPSBzZWdtZW50LmNsb25lKCk7XG5cdFx0XHRzZWdtZW50Ll9wYXRoID0gdGhpcztcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gaW5kZXggKyBpO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgMCwgc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpO1xuXHRcdH1cblx0XHRpZiAoYXBwZW5kKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBzZWdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VnbWVudHMuc3BsaWNlLmFwcGx5KHNlZ21lbnRzLCBbaW5kZXgsIDBdLmNvbmNhdChzZWdzKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZXMgfHwgc2Vncy5fY3VydmVzKSB7XG5cdFx0XHRpZiAoIWN1cnZlcylcblx0XHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzID0gW107XG5cdFx0XHR2YXIgZnJvbSA9IGluZGV4ID4gMCA/IGluZGV4IC0gMSA6IGluZGV4LFxuXHRcdFx0XHRzdGFydCA9IGZyb20sXG5cdFx0XHRcdHRvID0gTWF0aC5taW4oZnJvbSArIGFtb3VudCwgdGhpcy5fY291bnRDdXJ2ZXMoKSk7XG5cdFx0XHRpZiAoc2Vncy5fY3VydmVzKSB7XG5cdFx0XHRcdGN1cnZlcy5zcGxpY2UuYXBwbHkoY3VydmVzLCBbZnJvbSwgMF0uY29uY2F0KHNlZ3MuX2N1cnZlcykpO1xuXHRcdFx0XHRzdGFydCArPSBzZWdzLl9jdXJ2ZXMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgdG87IGkrKylcblx0XHRcdFx0Y3VydmVzLnNwbGljZShpLCAwLCBuZXcgQ3VydmUodGhpcywgbnVsbCwgbnVsbCkpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGZyb20sIHRvKTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblx0X2FkanVzdEN1cnZlczogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGN1cnZlO1xuXHRcdGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuXHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRjdXJ2ZS5fcGF0aCA9IHRoaXM7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tpXTtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlID0gY3VydmVzW3RoaXMuX2Nsb3NlZCAmJiBmcm9tID09PSAwID8gc2VnbWVudHMubGVuZ3RoIC0gMVxuXHRcdFx0XHQ6IGZyb20gLSAxXSlcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2Zyb21dIHx8IHNlZ21lbnRzWzBdO1xuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1t0b10pXG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1t0b107XG5cdH0sXG5cblx0X2NvdW50Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiAhdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oc2VnbWVudDEgKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzKSBdKVswXTtcblx0fSxcblxuXHRpbnNlcnQ6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50MSApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJ1xuXHRcdFx0PyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKGFyZ3VtZW50cywgMSksIGluZGV4KVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuXHR9LFxuXG5cdGluc2VydFNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4ICkge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudHM6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpKTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50czogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpLCBpbmRleCk7XG5cdH0sXG5cblx0cmVtb3ZlU2VnbWVudDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgaW5kZXggKyAxKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnRzOiBmdW5jdGlvbihmcm9tLCB0bywgX2luY2x1ZGVDdXJ2ZXMpIHtcblx0XHRmcm9tID0gZnJvbSB8fCAwO1xuXHRcdHRvID0gQmFzZS5waWNrKHRvLCB0aGlzLl9zZWdtZW50cy5sZW5ndGgpO1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0Y291bnQgPSBzZWdtZW50cy5sZW5ndGgsIFxuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnRzLnNwbGljZShmcm9tLCB0byAtIGZyb20pLFxuXHRcdFx0YW1vdW50ID0gcmVtb3ZlZC5sZW5ndGg7XG5cdFx0aWYgKCFhbW91bnQpXG5cdFx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHJlbW92ZWRbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSwgMCk7XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IHNlZ21lbnQuX3BhdGggPSBudWxsO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gZnJvbSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0dmFyIGluZGV4ID0gZnJvbSA+IDAgJiYgdG8gPT09IGNvdW50ICsgKHRoaXMuX2Nsb3NlZCA/IDEgOiAwKVxuXHRcdFx0XHRcdD8gZnJvbSAtIDFcblx0XHRcdFx0XHQ6IGZyb20sXG5cdFx0XHRcdGN1cnZlcyA9IGN1cnZlcy5zcGxpY2UoaW5kZXgsIGFtb3VudCk7XG5cdFx0XHRpZiAoX2luY2x1ZGVDdXJ2ZXMpXG5cdFx0XHRcdHJlbW92ZWQuX2N1cnZlcyA9IGN1cnZlcy5zbGljZSgxKTtcblx0XHRcdHRoaXMuX2FkanVzdEN1cnZlcyhpbmRleCwgaW5kZXgpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbGVhcjogJyNyZW1vdmVTZWdtZW50cycsXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZCAmJiBsZW5ndGggPiAwICYmIHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlXG5cdFx0XHRcdD09PSBsZW5ndGggKiA3O1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5fc2VsZWN0U2VnbWVudHModHJ1ZSk7XG5cdFx0dGhpcy5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIHNldFNlbGVjdGVkKHNlbGVjdGVkKSB7XG5cdFx0aWYgKCFzZWxlY3RlZClcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKGZhbHNlKTtcblx0XHRzZXRTZWxlY3RlZC5iYXNlLmNhbGwodGhpcywgc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdF9zZWxlY3RTZWdtZW50czogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gc2VsZWN0ZWRcblx0XHRcdFx0PyBsZW5ndGggKiA3IDogMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0dGhpcy5fc2VnbWVudHNbaV0uX3NlbGVjdGlvblN0YXRlID0gc2VsZWN0ZWRcblx0XHRcdFx0XHQ/IDcgOiAwO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKHNlZ21lbnQsIG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuXHRcdHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG5cdFx0dmFyIHRvdGFsID0gdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgKz0gbmV3U3RhdGUgLSBvbGRTdGF0ZTtcblx0XHRpZiAodG90YWwgPiAwKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRmbGF0dGVuOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHZhciBmbGF0dGVuZXIgPSBuZXcgUGF0aEZsYXR0ZW5lcih0aGlzKSxcblx0XHRcdHBvcyA9IDAsXG5cdFx0XHRzdGVwID0gZmxhdHRlbmVyLmxlbmd0aCAvIE1hdGguY2VpbChmbGF0dGVuZXIubGVuZ3RoIC8gbWF4RGlzdGFuY2UpLFxuXHRcdFx0ZW5kID0gZmxhdHRlbmVyLmxlbmd0aCArICh0aGlzLl9jbG9zZWQgPyAtc3RlcCA6IHN0ZXApIC8gMjtcblx0XHR2YXIgc2VnbWVudHMgPSBbXTtcblx0XHR3aGlsZSAocG9zIDw9IGVuZCkge1xuXHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChmbGF0dGVuZXIuZXZhbHVhdGUocG9zLCAwKSkpO1xuXHRcdFx0cG9zICs9IHN0ZXA7XG5cdFx0fVxuXHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHR9LFxuXG5cdHJlZHVjZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0Zm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0aWYgKGN1cnZlLmlzTGluZWFyKCkgJiYgY3VydmUuZ2V0TGVuZ3RoKCkgPT09IDApXG5cdFx0XHRcdGN1cnZlLnJlbW92ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzaW1wbGlmeTogZnVuY3Rpb24odG9sZXJhbmNlKSB7XG5cdFx0aWYgKHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA+IDIpIHtcblx0XHRcdHZhciBmaXR0ZXIgPSBuZXcgUGF0aEZpdHRlcih0aGlzLCB0b2xlcmFuY2UgfHwgMi41KTtcblx0XHRcdHRoaXMuc2V0U2VnbWVudHMoZml0dGVyLmZpdCgpKTtcblx0XHR9XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKGluZGV4LCBwYXJhbWV0ZXIpIHtcblx0XHRpZiAocGFyYW1ldGVyID09PSBudWxsKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR2YXIgYXJnID0gaW5kZXg7XG5cdFx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpXG5cdFx0XHRcdGFyZyA9IHRoaXMuZ2V0TG9jYXRpb25BdChhcmcpO1xuXHRcdFx0aW5kZXggPSBhcmcuaW5kZXg7XG5cdFx0XHRwYXJhbWV0ZXIgPSBhcmcucGFyYW1ldGVyO1xuXHRcdH1cblx0XHR2YXIgdG9sZXJhbmNlID0gMC4wMDAwMTtcblx0XHRpZiAocGFyYW1ldGVyID49IDEgLSB0b2xlcmFuY2UpIHtcblx0XHRcdGluZGV4Kys7XG5cdFx0XHRwYXJhbWV0ZXItLTtcblx0XHR9XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0aWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBjdXJ2ZXMubGVuZ3RoKSB7XG5cdFx0XHRpZiAocGFyYW1ldGVyID4gdG9sZXJhbmNlKSB7XG5cdFx0XHRcdGN1cnZlc1tpbmRleCsrXS5kaXZpZGUocGFyYW1ldGVyLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHZhciBzZWdzID0gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgdGhpcy5fc2VnbWVudHMubGVuZ3RoLCB0cnVlKSxcblx0XHRcdFx0cGF0aDtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHtcblx0XHRcdFx0dGhpcy5zZXRDbG9zZWQoZmFsc2UpO1xuXHRcdFx0XHRwYXRoID0gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7XG5cdFx0XHRcdHBhdGggPSB0aGlzLl9jbG9uZShuZXcgUGF0aCgpLmluc2VydEFib3ZlKHRoaXMsIHRydWUpKTtcblx0XHRcdH1cblx0XHRcdHBhdGguX2FkZChzZWdzLCAwKTtcblx0XHRcdHRoaXMuYWRkU2VnbWVudChzZWdzWzBdKTtcblx0XHRcdHJldHVybiBwYXRoO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2Nsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0cmV0dXJuIHRoaXMuX2Nsb2Nrd2lzZTtcblx0XHRyZXR1cm4gUGF0aC5pc0Nsb2Nrd2lzZSh0aGlzLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0c2V0Q2xvY2t3aXNlOiBmdW5jdGlvbihjbG9ja3dpc2UpIHtcblx0XHRpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9IChjbG9ja3dpc2UgPSAhIWNsb2Nrd2lzZSkpXG5cdFx0XHR0aGlzLnJldmVyc2UoKTtcblx0XHR0aGlzLl9jbG9ja3dpc2UgPSBjbG9ja3dpc2U7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudHMucmV2ZXJzZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0dmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dCA9IGhhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpO1xuXHRcdH1cblx0XHR0aGlzLl9jdXJ2ZXMgPSBudWxsO1xuXHRcdGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdHRoaXMuX2Nsb2Nrd2lzZSA9ICF0aGlzLl9jbG9ja3dpc2U7XG5cdH0sXG5cblx0am9pbjogZnVuY3Rpb24ocGF0aCkge1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdFx0bGFzdDEgPSB0aGlzLmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKGxhc3QxLl9wb2ludC5lcXVhbHMobGFzdDIuX3BvaW50KSlcblx0XHRcdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0XHR2YXIgZmlyc3QxLFxuXHRcdFx0XHRmaXJzdDIgPSBwYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKGxhc3QxLl9wb2ludC5lcXVhbHMoZmlyc3QyLl9wb2ludCkpIHtcblx0XHRcdFx0bGFzdDEuc2V0SGFuZGxlT3V0KGZpcnN0Mi5faGFuZGxlT3V0KTtcblx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpcnN0MSA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRcdGlmIChmaXJzdDEuX3BvaW50LmVxdWFscyhmaXJzdDIuX3BvaW50KSlcblx0XHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdFx0bGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cdFx0XHRcdGlmIChmaXJzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKSB7XG5cdFx0XHRcdFx0Zmlyc3QxLnNldEhhbmRsZUluKGxhc3QyLl9oYW5kbGVJbik7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpLCAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLmNsb3NlZClcblx0XHRcdFx0dGhpcy5fYWRkKFtzZWdtZW50c1swXV0pO1xuXHRcdFx0cGF0aC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKSxcblx0XHRcdGxhc3QgPSB0aGlzLmdldExhc3RTZWdtZW50KCk7XG5cdFx0aWYgKGZpcnN0ICE9PSBsYXN0ICYmIGZpcnN0Ll9wb2ludC5lcXVhbHMobGFzdC5fcG9pbnQpKSB7XG5cdFx0XHRmaXJzdC5zZXRIYW5kbGVJbihsYXN0Ll9oYW5kbGVJbik7XG5cdFx0XHRsYXN0LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2xlbmd0aCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0dmFyIGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGFyZWEgKz0gY3VydmVzW2ldLmdldEFyZWEoKTtcblx0XHRyZXR1cm4gYXJlYTtcblx0fSxcblxuXHRfZ2V0T2Zmc2V0OiBmdW5jdGlvbihsb2NhdGlvbikge1xuXHRcdHZhciBpbmRleCA9IGxvY2F0aW9uICYmIGxvY2F0aW9uLmdldEluZGV4KCk7XG5cdFx0aWYgKGluZGV4ICE9IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuXHRcdFx0XHRvZmZzZXQgKz0gY3VydmVzW2ldLmdldExlbmd0aCgpO1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2luZGV4XSxcblx0XHRcdFx0cGFyYW1ldGVyID0gbG9jYXRpb24uZ2V0UGFyYW1ldGVyKCk7XG5cdFx0XHRpZiAocGFyYW1ldGVyID4gMClcblx0XHRcdFx0b2Zmc2V0ICs9IGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKTtcblx0XHRcdHJldHVybiBvZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uKHBvaW50KSB7IFxuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9jID0gY3VydmVzW2ldLmdldExvY2F0aW9uT2YocG9pbnQpO1xuXHRcdFx0aWYgKGxvYylcblx0XHRcdFx0cmV0dXJuIGxvYztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0bGVuZ3RoID0gMDtcblx0XHRpZiAoaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciBpbmRleCA9IH5+b2Zmc2V0OyBcblx0XHRcdHJldHVybiBjdXJ2ZXNbaW5kZXhdLmdldExvY2F0aW9uQXQob2Zmc2V0IC0gaW5kZXgsIHRydWUpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzdGFydCA9IGxlbmd0aCxcblx0XHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRsZW5ndGggKz0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAobGVuZ3RoID4gb2Zmc2V0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRMb2NhdGlvbkF0KG9mZnNldCAtIHN0YXJ0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9mZnNldCA8PSB0aGlzLmdldExlbmd0aCgpKVxuXHRcdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0sIDEpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldFBvaW50QXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KG9mZnNldCwgaXNQYXJhbWV0ZXIpO1xuXHRcdHJldHVybiBsb2MgJiYgbG9jLmdldFBvaW50KCk7XG5cdH0sXG5cblx0Z2V0VGFuZ2VudEF0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChvZmZzZXQsIGlzUGFyYW1ldGVyKTtcblx0XHRyZXR1cm4gbG9jICYmIGxvYy5nZXRUYW5nZW50KCk7XG5cdH0sXG5cblx0Z2V0Tm9ybWFsQXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KG9mZnNldCwgaXNQYXJhbWV0ZXIpO1xuXHRcdHJldHVybiBsb2MgJiYgbG9jLmdldE5vcm1hbCgpO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RMb2NhdGlvbjogZnVuY3Rpb24ocG9pbnQpIHsgXG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pbkxvYyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9jID0gY3VydmVzW2ldLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cdFx0XHRpZiAobG9jLl9kaXN0YW5jZSA8IG1pbkRpc3QpIHtcblx0XHRcdFx0bWluRGlzdCA9IGxvYy5fZGlzdGFuY2U7XG5cdFx0XHRcdG1pbkxvYyA9IGxvYztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1pbkxvYztcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7IFxuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpLmdldFBvaW50KCk7XG5cdH0sXG5cblx0dG9TaGFwZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0aWYgKCF0aGlzLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0dHlwZSxcblx0XHRcdHNpemUsXG5cdFx0XHRyYWRpdXMsXG5cdFx0XHR0b3BDZW50ZXI7XG5cblx0XHRmdW5jdGlvbiBpc0NvbGluZWFyKGksIGopIHtcblx0XHRcdHJldHVybiBzZWdtZW50c1tpXS5pc0NvbGluZWFyKHNlZ21lbnRzW2pdKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc09ydGhvZ29uYWwoaSkge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLmlzT3J0aG9nb25hbCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQXJjKGkpIHtcblx0XHRcdHJldHVybiBzZWdtZW50c1tpXS5pc0FyYygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERpc3RhbmNlKGksIGopIHtcblx0XHRcdHJldHVybiBzZWdtZW50c1tpXS5fcG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudHNbal0uX3BvaW50KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5pc1BvbHlnb24oKSAmJiBzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNDb2xpbmVhcigwLCAyKSAmJiBpc0NvbGluZWFyKDEsIDMpICYmIGlzT3J0aG9nb25hbCgxKSkge1xuXHRcdFx0dHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCAzKSwgZ2V0RGlzdGFuY2UoMCwgMSkpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbMV0uX3BvaW50LmFkZChzZWdtZW50c1syXS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gOCAmJiBpc0FyYygwKSAmJiBpc0FyYygyKSAmJiBpc0FyYyg0KVxuXHRcdFx0XHQmJiBpc0FyYyg2KSAmJiBpc0NvbGluZWFyKDEsIDUpICYmIGlzQ29saW5lYXIoMywgNykpIHtcblx0XHRcdHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMSwgNiksIGdldERpc3RhbmNlKDAsIDMpKTtcblx0XHRcdHJhZGl1cyA9IHNpemUuc3VidHJhY3QobmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgNyksXG5cdFx0XHRcdFx0Z2V0RGlzdGFuY2UoMSwgMikpKS5kaXZpZGUoMik7XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1szXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzRdLl9wb2ludCkuZGl2aWRlKDIpO1xuXHRcdH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA0XG5cdFx0XHRcdCYmIGlzQXJjKDApICYmIGlzQXJjKDEpICYmIGlzQXJjKDIpICYmIGlzQXJjKDMpKSB7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhnZXREaXN0YW5jZSgwLCAyKSAtIGdldERpc3RhbmNlKDEsIDMpKSkge1xuXHRcdFx0XHR0eXBlID0gU2hhcGUuQ2lyY2xlO1xuXHRcdFx0XHRyYWRpdXMgPSBnZXREaXN0YW5jZSgwLCAyKSAvIDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gU2hhcGUuRWxsaXBzZTtcblx0XHRcdFx0cmFkaXVzID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMiwgMCkgLyAyLCBnZXREaXN0YW5jZSgzLCAxKSAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbMV0uX3BvaW50O1xuXHRcdH1cblxuXHRcdGlmICh0eXBlKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKSxcblx0XHRcdFx0c2hhcGUgPSBuZXcgdHlwZSh7XG5cdFx0XHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0c2hhcGUucm90YXRlKHRvcENlbnRlci5zdWJ0cmFjdChjZW50ZXIpLmdldEFuZ2xlKCkgKyA5MCk7XG5cdFx0XHRzaGFwZS5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0XHRpZiAoaW5zZXJ0IHx8IGluc2VydCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRzaGFwZS5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdHJldHVybiBzaGFwZTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0X2hpdFRlc3Q6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0c3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyxcblx0XHRcdHN0cm9rZVBhZGRpbmcgPSB0b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0am9pbiwgY2FwLCBtaXRlckxpbWl0LFxuXHRcdFx0YXJlYSwgbG9jLCByZXMsXG5cdFx0XHRoYXNTdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGhhc0ZpbGwgPSBvcHRpb25zLmZpbGwgJiYgc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0cmFkaXVzID0gaGFzU3Ryb2tlID8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDJcblx0XHRcdFx0XHQ6IGhhc0ZpbGwgPyAwIDogbnVsbDtcblx0XHRpZiAocmFkaXVzICE9IG51bGwpIHtcblx0XHRcdGlmIChyYWRpdXMgPiAwKSB7XG5cdFx0XHRcdGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCk7XG5cdFx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpO1xuXHRcdFx0XHRtaXRlckxpbWl0ID0gcmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0XHRzdHJva2VQYWRkaW5nID0gdG9sZXJhbmNlUGFkZGluZy5hZGQobmV3IFBvaW50KHJhZGl1cywgcmFkaXVzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqb2luID0gY2FwID0gJ3JvdW5kJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0Nsb3NlRW5vdWdoKHB0LCBwYWRkaW5nKSB7XG5cdFx0XHRyZXR1cm4gcG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZShwYWRkaW5nKS5sZW5ndGggPD0gMTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHB0LCBuYW1lKSB7XG5cdFx0XHRpZiAoIW9wdGlvbnMuc2VsZWN0ZWQgfHwgcHQuaXNTZWxlY3RlZCgpKSB7XG5cdFx0XHRcdHZhciBhbmNob3IgPSBzZWcuX3BvaW50O1xuXHRcdFx0XHRpZiAocHQgIT09IGFuY2hvcilcblx0XHRcdFx0XHRwdCA9IHB0LmFkZChhbmNob3IpO1xuXHRcdFx0XHRpZiAoaXNDbG9zZUVub3VnaChwdCwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdChuYW1lLCB0aGF0LCB7XG5cdFx0XHRcdFx0XHRzZWdtZW50OiBzZWcsXG5cdFx0XHRcdFx0XHRwb2ludDogcHRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50cyhzZWcsIGVuZHMpIHtcblx0XHRcdHJldHVybiAoZW5kcyB8fCBvcHRpb25zLnNlZ21lbnRzKVxuXHRcdFx0XHQmJiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5fcG9pbnQsICdzZWdtZW50Jylcblx0XHRcdFx0fHwgKCFlbmRzICYmIG9wdGlvbnMuaGFuZGxlcykgJiYgKFxuXHRcdFx0XHRcdGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVJbiwgJ2hhbmRsZS1pbicpIHx8XG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZU91dCwgJ2hhbmRsZS1vdXQnKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkVG9BcmVhKHBvaW50KSB7XG5cdFx0XHRhcmVhLmFkZChwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpIHtcblx0XHRcdGlmIChqb2luICE9PSAncm91bmQnIHx8IGNhcCAhPT0gJ3JvdW5kJykge1xuXHRcdFx0XHRhcmVhID0gbmV3IFBhdGgoeyBpbnRlcm5hbDogdHJ1ZSwgY2xvc2VkOiB0cnVlIH0pO1xuXHRcdFx0XHRpZiAoY2xvc2VkIHx8IHNlZ21lbnQuX2luZGV4ID4gMFxuXHRcdFx0XHRcdFx0JiYgc2VnbWVudC5faW5kZXggPCBudW1TZWdtZW50cyAtIDEpIHtcblx0XHRcdFx0XHRpZiAoam9pbiAhPT0gJ3JvdW5kJyAmJiAoc2VnbWVudC5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHRcdFx0fHwgc2VnbWVudC5faGFuZGxlT3V0LmlzWmVybygpKSlcblx0XHRcdFx0XHRcdFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsXG5cdFx0XHRcdFx0XHRcdFx0YWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjYXAgIT09ICdyb3VuZCcpIHtcblx0XHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhcmVhLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRcdHZhciBsb2M7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZWEuY29udGFpbnMocG9pbnQpXG5cdFx0XHRcdFx0XHR8fCAobG9jID0gYXJlYS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpKVxuXHRcdFx0XHRcdFx0XHQmJiBpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCB0b2xlcmFuY2VQYWRkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlzQ2xvc2VFbm91Z2goc2VnbWVudC5fcG9pbnQsIHN0cm9rZVBhZGRpbmcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmVuZHMgJiYgIW9wdGlvbnMuc2VnbWVudHMgJiYgIWNsb3NlZCkge1xuXHRcdFx0aWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1swXSwgdHJ1ZSlcblx0XHRcdFx0XHR8fCBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbbnVtU2VnbWVudHMgLSAxXSwgdHJ1ZSkpXG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnNlZ21lbnRzIHx8IG9wdGlvbnMuaGFuZGxlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKVxuXHRcdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW2ldKSlcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblx0XHRpZiAocmFkaXVzICE9IG51bGwpIHtcblx0XHRcdGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MpIHtcblx0XHRcdFx0dmFyIHBhcmFtZXRlciA9IGxvYy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdFx0aWYgKHBhcmFtZXRlciA9PT0gMCB8fCBwYXJhbWV0ZXIgPT09IDEgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG5cdFx0XHRcdFx0aWYgKCFjaGVja1NlZ21lbnRTdHJva2UobG9jLmdldFNlZ21lbnQoKSkpXG5cdFx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2UgIGlmICghaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWxvYyAmJiBqb2luID09PSAnbWl0ZXInICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdGlmIChwb2ludC5nZXREaXN0YW5jZShzZWdtZW50Ll9wb2ludCkgPD0gbWl0ZXJMaW1pdFxuXHRcdFx0XHRcdFx0XHQmJiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkpIHtcblx0XHRcdFx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gIWxvYyAmJiBoYXNGaWxsICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KSB8fCBsb2MgJiYgIWhhc1N0cm9rZVxuXHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKVxuXHRcdFx0XHQ6IGxvY1xuXHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdCgnc3Ryb2tlJywgdGhpcywge1xuXHRcdFx0XHRcdFx0bG9jYXRpb246IGxvYyxcblx0XHRcdFx0XHRcdHBvaW50OiBsb2MuZ2V0UG9pbnQoKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0OiBudWxsO1xuXHR9XG5cbn0sIG5ldyBmdW5jdGlvbigpIHsgXG5cblx0ZnVuY3Rpb24gZHJhd0hhbmRsZXMoY3R4LCBzZWdtZW50cywgbWF0cml4LCBzaXplKSB7XG5cdFx0dmFyIGhhbGYgPSBzaXplIC8gMjtcblxuXHRcdGZ1bmN0aW9uIGRyYXdIYW5kbGUoaW5kZXgpIHtcblx0XHRcdHZhciBoWCA9IGNvb3Jkc1tpbmRleF0sXG5cdFx0XHRcdGhZID0gY29vcmRzW2luZGV4ICsgMV07XG5cdFx0XHRpZiAocFggIT0gaFggfHwgcFkgIT0gaFkpIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHBYLCBwWSk7XG5cdFx0XHRcdGN0eC5saW5lVG8oaFgsIGhZKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmMoaFgsIGhZLCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSxcblx0XHRcdFx0cFggPSBjb29yZHNbMF0sXG5cdFx0XHRcdHBZID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKHN0YXRlICYgMSlcblx0XHRcdFx0ZHJhd0hhbmRsZSgyKTtcblx0XHRcdGlmIChzdGF0ZSAmIDIpXG5cdFx0XHRcdGRyYXdIYW5kbGUoNCk7XG5cdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmLCBwWSAtIGhhbGYsIHNpemUsIHNpemUpO1xuXHRcdFx0aWYgKCEoc3RhdGUgJiA0KSkge1xuXHRcdFx0XHR2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gaGFsZiArIDEsIHBZIC0gaGFsZiArIDEsIHNpemUgLSAyLCBzaXplIC0gMik7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1NlZ21lbnRzKGN0eCwgcGF0aCwgbWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NlZ21lbnQoaSkge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdFx0Y3VyWCA9IGNvb3Jkc1swXTtcblx0XHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50O1xuXHRcdFx0XHRjdXJYID0gcG9pbnQuX3g7XG5cdFx0XHRcdGN1clkgPSBwb2ludC5feTtcblx0XHRcdH1cblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRjdHgubW92ZVRvKGN1clgsIGN1clkpO1xuXHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdGluWCA9IGNvb3Jkc1syXTtcblx0XHRcdFx0XHRpblkgPSBjb29yZHNbM107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGhhbmRsZSA9IHNlZ21lbnQuX2hhbmRsZUluO1xuXHRcdFx0XHRcdGluWCA9IGN1clggKyBoYW5kbGUuX3g7XG5cdFx0XHRcdFx0aW5ZID0gY3VyWSArIGhhbmRsZS5feTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW5YID09IGN1clggJiYgaW5ZID09IGN1clkgJiYgb3V0WCA9PSBwcmV2WCAmJiBvdXRZID09IHByZXZZKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhvdXRYLCBvdXRZLCBpblgsIGluWSwgY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdFx0b3V0WSA9IGNvb3Jkc1s1XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRcdG91dFggPSBwcmV2WCArIGhhbmRsZS5feDtcblx0XHRcdFx0b3V0WSA9IHByZXZZICsgaGFuZGxlLl95O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRkcmF3U2VnbWVudChpKTtcblx0XHRpZiAocGF0aC5fY2xvc2VkICYmIGxlbmd0aCA+IDApXG5cdFx0XHRkcmF3U2VnbWVudCgwKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHRcdHZhciBkb250U3RhcnQgPSBwYXJhbS5kb250U3RhcnQsXG5cdFx0XHRcdGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcDtcblx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdHZhciBzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdFx0aGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRcdGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuXHRcdFx0XHRkYXNoTGVuZ3RoID0gIXBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCAmJiBoYXNTdHJva2Vcblx0XHRcdFx0XHRcdCYmIGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRmdW5jdGlvbiBnZXRPZmZzZXQoaSkge1xuXHRcdFx0XHRyZXR1cm4gZGFzaEFycmF5WygoaSAlIGRhc2hMZW5ndGgpICsgZGFzaExlbmd0aCkgJSBkYXNoTGVuZ3RoXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkb250U3RhcnQgJiYgdGhpcy5fY3VycmVudFBhdGgpIHtcblx0XHRcdFx0Y3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG5cdFx0XHR9IGVsc2UgaWYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlICYmICFkYXNoTGVuZ3RoIHx8IGRvbnRQYWludCkge1xuXHRcdFx0XHRkcmF3U2VnbWVudHMoY3R4LCB0aGlzKTtcblx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG5cdFx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRcdGN0eC5maWxsKHN0eWxlLmdldFdpbmRpbmdSdWxlKCkpO1xuXHRcdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGFzU3Ryb2tlKSB7XG5cdFx0XHRcdFx0aWYgKGRhc2hMZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHR2YXIgZmxhdHRlbmVyID0gbmV3IFBhdGhGbGF0dGVuZXIodGhpcyksXG5cdFx0XHRcdFx0XHRcdGxlbmd0aCA9IGZsYXR0ZW5lci5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGZyb20gPSAtc3R5bGUuZ2V0RGFzaE9mZnNldCgpLCB0byxcblx0XHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHRmcm9tID0gZnJvbSAlIGxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tID4gMCkge1xuXHRcdFx0XHRcdFx0XHRmcm9tIC09IGdldE9mZnNldChpLS0pICsgZ2V0T2Zmc2V0KGktLSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR0byA9IGZyb20gKyBnZXRPZmZzZXQoaSsrKTtcblx0XHRcdFx0XHRcdFx0aWYgKGZyb20gPiAwIHx8IHRvID4gMClcblx0XHRcdFx0XHRcdFx0XHRmbGF0dGVuZXIuZHJhd1BhcnQoY3R4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRNYXRoLm1heChmcm9tLCAwKSwgTWF0aC5tYXgodG8sIDApKTtcblx0XHRcdFx0XHRcdFx0ZnJvbSA9IHRvICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCkge1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgbWF0cml4KTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGRyYXdIYW5kbGVzKGN0eCwgdGhpcy5fc2VnbWVudHMsIG1hdHJpeCwgcGFwZXIuc2V0dGluZ3MuaGFuZGxlU2l6ZSk7XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkgeyBcblxuXHRmdW5jdGlvbiBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKSB7XG5cdFx0dmFyIG4gPSByaHMubGVuZ3RoLFxuXHRcdFx0eCA9IFtdLCBcblx0XHRcdHRtcCA9IFtdLCBcblx0XHRcdGIgPSAyO1xuXHRcdHhbMF0gPSByaHNbMF0gLyBiO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHR0bXBbaV0gPSAxIC8gYjtcblx0XHRcdGIgPSAoaSA8IG4gLSAxID8gNCA6IDIpIC0gdG1wW2ldO1xuXHRcdFx0eFtpXSA9IChyaHNbaV0gLSB4W2kgLSAxXSkgLyBiO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHRcdFx0eFtuIC0gaSAtIDFdIC09IHRtcFtuIC0gaV0gKiB4W24gLSBpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHg7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNtb290aDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdFx0c2l6ZSA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuXHRcdFx0XHRuID0gc2l6ZSxcblx0XHRcdFx0b3ZlcmxhcCA9IDA7XG5cdFx0XHRpZiAoc2l6ZSA8PSAyKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdG92ZXJsYXAgPSBNYXRoLm1pbihzaXplLCA0KTtcblx0XHRcdFx0biArPSBNYXRoLm1pbihzaXplLCBvdmVybGFwKSAqIDI7XG5cdFx0XHR9XG5cdFx0XHR2YXIga25vdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuXHRcdFx0XHRrbm90c1tpICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdFx0a25vdHNbaV0gPSBzZWdtZW50c1tpICsgc2l6ZSAtIG92ZXJsYXBdLl9wb2ludDtcblx0XHRcdFx0XHRrbm90c1tpICsgc2l6ZSArIG92ZXJsYXBdID0gc2VnbWVudHNbaV0uX3BvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuLS07XG5cdFx0XHR9XG5cdFx0XHR2YXIgcmhzID0gW107XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbiAtIDE7IGkrKylcblx0XHRcdFx0cmhzW2ldID0gNCAqIGtub3RzW2ldLl94ICsgMiAqIGtub3RzW2kgKyAxXS5feDtcblx0XHRcdHJoc1swXSA9IGtub3RzWzBdLl94ICsgMiAqIGtub3RzWzFdLl94O1xuXHRcdFx0cmhzW24gLSAxXSA9IDMgKiBrbm90c1tuIC0gMV0uX3g7XG5cdFx0XHR2YXIgeCA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG4gLSAxOyBpKyspXG5cdFx0XHRcdHJoc1tpXSA9IDQgKiBrbm90c1tpXS5feSArIDIgKiBrbm90c1tpICsgMV0uX3k7XG5cdFx0XHRyaHNbMF0gPSBrbm90c1swXS5feSArIDIgKiBrbm90c1sxXS5feTtcblx0XHRcdHJoc1tuIC0gMV0gPSAzICoga25vdHNbbiAtIDFdLl95O1xuXHRcdFx0dmFyIHkgPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgaiA9IHNpemU7IGkgPCBvdmVybGFwOyBpKyssIGorKykge1xuXHRcdFx0XHRcdHZhciBmMSA9IGkgLyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0ZjIgPSAxIC0gZjEsXG5cdFx0XHRcdFx0XHRpZSA9IGkgKyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0amUgPSBqICsgb3ZlcmxhcDtcblx0XHRcdFx0XHR4W2pdID0geFtpXSAqIGYxICsgeFtqXSAqIGYyO1xuXHRcdFx0XHRcdHlbal0gPSB5W2ldICogZjEgKyB5W2pdICogZjI7XG5cdFx0XHRcdFx0eFtqZV0gPSB4W2llXSAqIGYyICsgeFtqZV0gKiBmMTtcblx0XHRcdFx0XHR5W2plXSA9IHlbaWVdICogZjIgKyB5W2plXSAqIGYxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG4tLTtcblx0XHRcdH1cblx0XHRcdHZhciBoYW5kbGVJbiA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBpID0gb3ZlcmxhcDsgaSA8PSBuIC0gb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaSAtIG92ZXJsYXBdO1xuXHRcdFx0XHRpZiAoaGFuZGxlSW4pXG5cdFx0XHRcdFx0c2VnbWVudC5zZXRIYW5kbGVJbihoYW5kbGVJbi5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHRcdFx0XHRpZiAoaSA8IG4pIHtcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZU91dChcblx0XHRcdFx0XHRcdFx0bmV3IFBvaW50KHhbaV0sIHlbaV0pLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHRcdFx0aGFuZGxlSW4gPSBpIDwgbiAtIDFcblx0XHRcdFx0XHRcdFx0PyBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGtub3RzW2kgKyAxXS5feCAtIHhbaSArIDFdLFxuXHRcdFx0XHRcdFx0XHRcdDIgKiBrbm90c1tpICsgMV0uX3kgLSB5W2kgKyAxXSlcblx0XHRcdFx0XHRcdFx0OiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0KGtub3RzW25dLl94ICsgeFtuIC0gMV0pIC8gMixcblx0XHRcdFx0XHRcdFx0XHQoa25vdHNbbl0uX3kgKyB5W24gLSAxXSkgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCAmJiBoYW5kbGVJbikge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkgeyBcblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFNlZ21lbnQodGhhdCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoYXQuX3NlZ21lbnRzO1xuXHRcdGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIG1vdmVUbygpIGNvbW1hbmQgZmlyc3QnKTtcblx0XHRyZXR1cm4gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdG1vdmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRcdGlmIChzZWdtZW50cy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdHRoaXMucmVtb3ZlU2VnbWVudCgwKTtcblx0XHRcdGlmICghc2VnbWVudHMubGVuZ3RoKVxuXHRcdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRtb3ZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtb3ZlQnkoKSBpcyB1bnN1cHBvcnRlZCBvbiBQYXRoIGl0ZW1zLicpO1xuXHRcdH0sXG5cblx0XHRsaW5lVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKSBdKTtcblx0XHR9LFxuXG5cdFx0Y3ViaWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRoYW5kbGUyID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpO1xuXHRcdFx0Y3VycmVudC5zZXRIYW5kbGVPdXQoaGFuZGxlMS5zdWJ0cmFjdChjdXJyZW50Ll9wb2ludCkpO1xuXHRcdFx0dGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQodG8sIGhhbmRsZTIuc3VidHJhY3QodG8pKSBdKTtcblx0XHR9LFxuXG5cdFx0cXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRoYW5kbGUuYWRkKGN1cnJlbnQuc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHRoYW5kbGUuYWRkKHRvLnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSxcblx0XHRcdFx0dG9cblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGN1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRocm91Z2ggPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0ID0gQmFzZS5waWNrKEJhc2UucmVhZChhcmd1bWVudHMpLCAwLjUpLFxuXHRcdFx0XHR0MSA9IDEgLSB0LFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50LFxuXHRcdFx0XHRoYW5kbGUgPSB0aHJvdWdoLnN1YnRyYWN0KGN1cnJlbnQubXVsdGlwbHkodDEgKiB0MSkpXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHRvLm11bHRpcGx5KHQgKiB0KSkuZGl2aWRlKDIgKiB0ICogdDEpO1xuXHRcdFx0aWYgKGhhbmRsZS5pc05hTigpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J0Nhbm5vdCBwdXQgYSBjdXJ2ZSB0aHJvdWdoIHBvaW50cyB3aXRoIHBhcmFtZXRlciA9ICcgKyB0KTtcblx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhoYW5kbGUsIHRvKTtcblx0XHR9LFxuXG5cdFx0YXJjVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKSxcblx0XHRcdFx0ZnJvbSA9IGN1cnJlbnQuX3BvaW50LFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dGhyb3VnaCxcblx0XHRcdFx0cGVlayA9IEJhc2UucGVlayhhcmd1bWVudHMpLFxuXHRcdFx0XHRjbG9ja3dpc2UgPSBCYXNlLnBpY2socGVlaywgdHJ1ZSksXG5cdFx0XHRcdGNlbnRlciwgZXh0ZW50LCB2ZWN0b3IsIG1hdHJpeDtcblx0XHRcdGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dmFyIG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdHRocm91Z2ggPSBtaWRkbGUuYWRkKG1pZGRsZS5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoXG5cdFx0XHRcdFx0XHRjbG9ja3dpc2UgPyAtOTAgOiA5MCkpO1xuXHRcdFx0fSBlbHNlIGlmIChCYXNlLnJlbWFpbihhcmd1bWVudHMpIDw9IDIpIHtcblx0XHRcdFx0dGhyb3VnaCA9IHRvO1xuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0aWYgKHJhZGl1cy5pc1plcm8oKSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHR2YXIgcm90YXRpb24gPSBCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRjbG9ja3dpc2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdGxhcmdlID0gISFCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdHB0ID0gZnJvbS5zdWJ0cmFjdChtaWRkbGUpLnJvdGF0ZSgtcm90YXRpb24pLFxuXHRcdFx0XHRcdHggPSBwdC54LFxuXHRcdFx0XHRcdHkgPSBwdC55LFxuXHRcdFx0XHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdFx0XHRcdEVQU0lMT04gPSAxZS0xMSxcblx0XHRcdFx0XHRyeCA9IGFicyhyYWRpdXMud2lkdGgpLFxuXHRcdFx0XHRcdHJ5ID0gYWJzKHJhZGl1cy5oZWlnaHQpLFxuXHRcdFx0XHRcdHJ4U3EgPSByeCAqIHJ4LFxuXHRcdFx0XHRcdHJ5U3EgPSByeSAqIHJ5LFxuXHRcdFx0XHRcdHhTcSA9ICB4ICogeCxcblx0XHRcdFx0XHR5U3EgPSAgeSAqIHk7XG5cdFx0XHRcdHZhciBmYWN0b3IgPSBNYXRoLnNxcnQoeFNxIC8gcnhTcSArIHlTcSAvIHJ5U3EpO1xuXHRcdFx0XHRpZiAoZmFjdG9yID4gMSkge1xuXHRcdFx0XHRcdHJ4ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeSAqPSBmYWN0b3I7XG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcng7XG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmFjdG9yID0gKHJ4U3EgKiByeVNxIC0gcnhTcSAqIHlTcSAtIHJ5U3EgKiB4U3EpIC9cblx0XHRcdFx0XHRcdChyeFNxICogeVNxICsgcnlTcSAqIHhTcSk7XG5cdFx0XHRcdGlmIChhYnMoZmFjdG9yKSA8IEVQU0lMT04pXG5cdFx0XHRcdFx0ZmFjdG9yID0gMDtcblx0XHRcdFx0aWYgKGZhY3RvciA8IDApXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG5cdFx0XHRcdGNlbnRlciA9IG5ldyBQb2ludChyeCAqIHkgLyByeSwgLXJ5ICogeCAvIHJ4KVxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5KChsYXJnZSA9PT0gY2xvY2t3aXNlID8gLTEgOiAxKVxuXHRcdFx0XHRcdFx0XHQqIE1hdGguc3FydChmYWN0b3IpKVxuXHRcdFx0XHRcdFx0LnJvdGF0ZShyb3RhdGlvbikuYWRkKG1pZGRsZSk7XG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoY2VudGVyKS5yb3RhdGUocm90YXRpb24pXG5cdFx0XHRcdFx0XHQuc2NhbGUocngsIHJ5KTtcblx0XHRcdFx0dmVjdG9yID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKGZyb20pO1xuXHRcdFx0XHRleHRlbnQgPSB2ZWN0b3IuZ2V0RGlyZWN0ZWRBbmdsZShtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0odG8pKTtcblx0XHRcdFx0aWYgKCFjbG9ja3dpc2UgJiYgZXh0ZW50ID4gMClcblx0XHRcdFx0XHRleHRlbnQgLT0gMzYwO1xuXHRcdFx0XHRlbHNlIGlmIChjbG9ja3dpc2UgJiYgZXh0ZW50IDwgMClcblx0XHRcdFx0XHRleHRlbnQgKz0gMzYwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRocm91Z2gpIHtcblx0XHRcdFx0dmFyIGwxID0gbmV3IExpbmUoZnJvbS5hZGQodGhyb3VnaCkuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0aHJvdWdoLnN1YnRyYWN0KGZyb20pLnJvdGF0ZSg5MCksIHRydWUpLFxuXHRcdFx0XHRcdGwyID0gbmV3IExpbmUodGhyb3VnaC5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRcdFx0dG8uc3VidHJhY3QodGhyb3VnaCkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bGluZSA9IG5ldyBMaW5lKGZyb20sIHRvKSxcblx0XHRcdFx0XHR0aHJvdWdoU2lkZSA9IGxpbmUuZ2V0U2lkZSh0aHJvdWdoKTtcblx0XHRcdFx0Y2VudGVyID0gbDEuaW50ZXJzZWN0KGwyLCB0cnVlKTtcblx0XHRcdFx0aWYgKCFjZW50ZXIpIHtcblx0XHRcdFx0XHRpZiAoIXRocm91Z2hTaWRlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMubGluZVRvKHRvKTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ZWN0b3IgPSBmcm9tLnN1YnRyYWN0KGNlbnRlcik7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKHRvLnN1YnRyYWN0KGNlbnRlcikpO1xuXHRcdFx0XHR2YXIgY2VudGVyU2lkZSA9IGxpbmUuZ2V0U2lkZShjZW50ZXIpO1xuXHRcdFx0XHRpZiAoY2VudGVyU2lkZSA9PT0gMCkge1xuXHRcdFx0XHRcdGV4dGVudCA9IHRocm91Z2hTaWRlICogTWF0aC5hYnMoZXh0ZW50KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aHJvdWdoU2lkZSA9PT0gY2VudGVyU2lkZSkge1xuXHRcdFx0XHRcdGV4dGVudCArPSBleHRlbnQgPCAwID8gMzYwIDogLTM2MDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGV4dCA9IE1hdGguYWJzKGV4dGVudCksXG5cdFx0XHRcdGNvdW50ID0gIGV4dCA+PSAzNjAgPyA0IDogTWF0aC5jZWlsKGV4dCAvIDkwKSxcblx0XHRcdFx0aW5jID0gZXh0ZW50IC8gY291bnQsXG5cdFx0XHRcdGhhbGYgPSBpbmMgKiBNYXRoLlBJIC8gMzYwLFxuXHRcdFx0XHR6ID0gNCAvIDMgKiBNYXRoLnNpbihoYWxmKSAvICgxICsgTWF0aC5jb3MoaGFsZikpLFxuXHRcdFx0XHRzZWdtZW50cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKykge1xuXHRcdFx0XHR2YXIgcHQgPSB0byxcblx0XHRcdFx0XHRvdXQgPSBudWxsO1xuXHRcdFx0XHRpZiAoaSA8IGNvdW50KSB7XG5cdFx0XHRcdFx0b3V0ID0gdmVjdG9yLnJvdGF0ZSg5MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0cHQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvcik7XG5cdFx0XHRcdFx0XHRvdXQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQob3V0KSlcblx0XHRcdFx0XHRcdFx0XHQuc3VidHJhY3QocHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdCA9IGNlbnRlci5hZGQodmVjdG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChvdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBfaW4gPSB2ZWN0b3Iucm90YXRlKC05MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0X2luID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKF9pbikpXG5cdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwdCwgX2luLCBvdXQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ZWN0b3IgPSB2ZWN0b3Iucm90YXRlKGluYyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMpO1xuXHRcdH0sXG5cblx0XHRsaW5lQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5saW5lVG8oY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0Y3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBhcmFtZXRlciA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdXJ2ZVRvKGN1cnJlbnQuYWRkKHRocm91Z2gpLCBjdXJyZW50LmFkZCh0byksIHBhcmFtZXRlcik7XG5cdFx0fSxcblxuXHRcdGN1YmljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUxKSwgY3VycmVudC5hZGQoaGFuZGxlMiksXG5cdFx0XHRcdFx0Y3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0cXVhZHJhdGljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUpLCBjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRhcmNCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0cG9pbnQgPSBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3VtZW50cykpLFxuXHRcdFx0XHRjbG9ja3dpc2UgPSBCYXNlLnBpY2soQmFzZS5wZWVrKGFyZ3VtZW50cyksIHRydWUpO1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjbG9ja3dpc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0XHRpZiAoam9pbilcblx0XHRcdFx0dGhpcy5qb2luKCk7XG5cdFx0fVxuXHR9O1xufSwgeyAgXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHRyZXR1cm4gUGF0aFtnZXR0ZXJdKHRoaXMuX3NlZ21lbnRzLCB0aGlzLl9jbG9zZWQsIHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdFx0bWF0cml4KTtcblx0fSxcblxuc3RhdGljczoge1xuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHR2YXIgc3VtID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHYgPSBDdXJ2ZS5nZXRWYWx1ZXMoXG5cdFx0XHRcdFx0c2VnbWVudHNbaV0sIHNlZ21lbnRzW2kgKyAxIDwgbCA/IGkgKyAxIDogMF0pO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDI7IGogPCA4OyBqICs9IDIpXG5cdFx0XHRcdHN1bSArPSAodltqIC0gMl0gLSB2W2pdKSAqICh2W2ogKyAxXSArIHZbaiAtIDFdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN1bSA+IDA7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBzdHJva2VQYWRkaW5nKSB7XG5cdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF07XG5cdFx0aWYgKCFmaXJzdClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHByZXZDb29yZHMgPSBmaXJzdC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBuZXcgQXJyYXkoNiksIGZhbHNlKSxcblx0XHRcdG1pbiA9IHByZXZDb29yZHMuc2xpY2UoMCwgMiksIFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksIFxuXHRcdFx0cm9vdHMgPSBuZXcgQXJyYXkoMik7XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzU2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0XHRcdFx0Q3VydmUuX2FkZEJvdW5kcyhcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2ldLCBcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2kgKyA0XSwgXG5cdFx0XHRcdFx0Y29vcmRzW2kgKyAyXSwgXG5cdFx0XHRcdFx0Y29vcmRzW2ldLCBcblx0XHRcdFx0XHRpLCBzdHJva2VQYWRkaW5nID8gc3Ryb2tlUGFkZGluZ1tpXSA6IDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG1wID0gcHJldkNvb3Jkcztcblx0XHRcdHByZXZDb29yZHMgPSBjb29yZHM7XG5cdFx0XHRjb29yZHMgPSB0bXA7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRwcm9jZXNzU2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKGNsb3NlZClcblx0XHRcdHByb2Nlc3NTZWdtZW50KGZpcnN0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdGdldFN0cm9rZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCkge1xuXHRcdGlmICghc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRyZXR1cm4gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCk7XG5cdFx0dmFyIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIChjbG9zZWQgPyAwIDogMSksXG5cdFx0XHRyYWRpdXMgPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMixcblx0XHRcdHBhZGRpbmcgPSBQYXRoLl9nZXRQZW5QYWRkaW5nKHJhZGl1cywgbWF0cml4KSxcblx0XHRcdGJvdW5kcyA9IFBhdGguZ2V0Qm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHBhZGRpbmcpLFxuXHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0bWl0ZXJMaW1pdCA9IHJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHR2YXIgam9pbkJvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFNpemUocGFkZGluZykubXVsdGlwbHkoMikpO1xuXG5cdFx0ZnVuY3Rpb24gYWRkKHBvaW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMuaW5jbHVkZShtYXRyaXhcblx0XHRcdFx0PyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvaW50LCBwb2ludCkgOiBwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkUm91bmQoc2VnbWVudCkge1xuXHRcdFx0Ym91bmRzID0gYm91bmRzLnVuaXRlKGpvaW5Cb3VuZHMuc2V0Q2VudGVyKG1hdHJpeFxuXHRcdFx0XHQ/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQoc2VnbWVudC5fcG9pbnQpIDogc2VnbWVudC5fcG9pbnQpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRKb2luKHNlZ21lbnQsIGpvaW4pIHtcblx0XHRcdHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Ll9oYW5kbGVPdXRcblx0XHRcdGlmIChqb2luID09PSAncm91bmQnIHx8ICFoYW5kbGVJbi5pc1plcm8oKSAmJiAhaGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdFx0JiYgaGFuZGxlSW4uaXNDb2xpbmVhcihoYW5kbGVPdXQpKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgYWRkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRDYXAoc2VnbWVudCwgY2FwKSB7XG5cdFx0XHRpZiAoY2FwID09PSAncm91bmQnKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzW2ldLCBqb2luKTtcblx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzWzBdLCBqb2luKTtcblx0XHR9IGVsc2UgaWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZENhcChzZWdtZW50c1swXSwgY2FwKTtcblx0XHRcdGFkZENhcChzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSwgY2FwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHRfZ2V0UGVuUGFkZGluZzogZnVuY3Rpb24ocmFkaXVzLCBtYXRyaXgpIHtcblx0XHRpZiAoIW1hdHJpeClcblx0XHRcdHJldHVybiBbcmFkaXVzLCByYWRpdXNdO1xuXHRcdHZhciBteCA9IG1hdHJpeC5zaGlmdGxlc3MoKSxcblx0XHRcdGhvciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQocmFkaXVzLCAwKSksXG5cdFx0XHR2ZXIgPSBteC50cmFuc2Zvcm0obmV3IFBvaW50KDAsIHJhZGl1cykpLFxuXHRcdFx0cGhpID0gaG9yLmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHRhID0gaG9yLmdldExlbmd0aCgpLFxuXHRcdFx0YiA9IHZlci5nZXRMZW5ndGgoKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4ocGhpKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKHBoaSksXG5cdFx0XHR0YW4gPSBNYXRoLnRhbihwaGkpLFxuXHRcdFx0dHggPSAtTWF0aC5hdGFuKGIgKiB0YW4gLyBhKSxcblx0XHRcdHR5ID0gTWF0aC5hdGFuKGIgLyAodGFuICogYSkpO1xuXHRcdHJldHVybiBbTWF0aC5hYnMoYSAqIE1hdGguY29zKHR4KSAqIGNvcyAtIGIgKiBNYXRoLnNpbih0eCkgKiBzaW4pLFxuXHRcdFx0XHRNYXRoLmFicyhiICogTWF0aC5zaW4odHkpICogY29zICsgYSAqIE1hdGguY29zKHR5KSAqIHNpbildO1xuXHR9LFxuXG5cdF9hZGRCZXZlbEpvaW46IGZ1bmN0aW9uKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgYWRkUG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgY3VydmUyID0gc2VnbWVudC5nZXRDdXJ2ZSgpLFxuXHRcdFx0Y3VydmUxID0gY3VydmUyLmdldFByZXZpb3VzKCksXG5cdFx0XHRwb2ludCA9IGN1cnZlMi5nZXRQb2ludEF0KDAsIHRydWUpLFxuXHRcdFx0bm9ybWFsMSA9IGN1cnZlMS5nZXROb3JtYWxBdCgxLCB0cnVlKSxcblx0XHRcdG5vcm1hbDIgPSBjdXJ2ZTIuZ2V0Tm9ybWFsQXQoMCwgdHJ1ZSksXG5cdFx0XHRzdGVwID0gbm9ybWFsMS5nZXREaXJlY3RlZEFuZ2xlKG5vcm1hbDIpIDwgMCA/IC1yYWRpdXMgOiByYWRpdXM7XG5cdFx0bm9ybWFsMS5zZXRMZW5ndGgoc3RlcCk7XG5cdFx0bm9ybWFsMi5zZXRMZW5ndGgoc3RlcCk7XG5cdFx0aWYgKGFyZWEpIHtcblx0XHRcdGFkZFBvaW50KHBvaW50KTtcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cdFx0fVxuXHRcdGlmIChqb2luID09PSAnbWl0ZXInKSB7XG5cdFx0XHR2YXIgY29ybmVyID0gbmV3IExpbmUoXG5cdFx0XHRcdFx0cG9pbnQuYWRkKG5vcm1hbDEpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMS55LCBub3JtYWwxLngpLCB0cnVlXG5cdFx0XHRcdCkuaW50ZXJzZWN0KG5ldyBMaW5lKFxuXHRcdFx0XHRcdHBvaW50LmFkZChub3JtYWwyKSxcblx0XHRcdFx0XHRuZXcgUG9pbnQoLW5vcm1hbDIueSwgbm9ybWFsMi54KSwgdHJ1ZVxuXHRcdFx0XHQpLCB0cnVlKTtcblx0XHRcdGlmIChjb3JuZXIgJiYgcG9pbnQuZ2V0RGlzdGFuY2UoY29ybmVyKSA8PSBtaXRlckxpbWl0KSB7XG5cdFx0XHRcdGFkZFBvaW50KGNvcm5lcik7XG5cdFx0XHRcdGlmICghYXJlYSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghYXJlYSlcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDIpKTtcblx0fSxcblxuXHRfYWRkU3F1YXJlQ2FwOiBmdW5jdGlvbihzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkUG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludCxcblx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKSxcblx0XHRcdG5vcm1hbCA9IGxvYy5nZXROb3JtYWwoKS5ub3JtYWxpemUocmFkaXVzKTtcblx0XHRpZiAoYXJlYSkge1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdFx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0fVxuXHRcdGlmIChjYXAgPT09ICdzcXVhcmUnKVxuXHRcdFx0cG9pbnQgPSBwb2ludC5hZGQobm9ybWFsLnJvdGF0ZShsb2MuZ2V0UGFyYW1ldGVyKCkgPT0gMCA/IC05MCA6IDkwKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuXHRcdGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgc3Ryb2tlUGFkZGluZyxcblx0XHRcdGpvaW5QYWRkaW5nKSB7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHgxID0gSW5maW5pdHksXG5cdFx0XHR4MiA9IC14MSxcblx0XHRcdHkxID0geDEsXG5cdFx0XHR5MiA9IHgyO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG5cdFx0XHRcdHZhciBwYWRkaW5nID0gaiA9PSAwID8gam9pblBhZGRpbmcgOiBzdHJva2VQYWRkaW5nLFxuXHRcdFx0XHRcdHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmdbMF0gOiAwLFxuXHRcdFx0XHRcdHBhZGRpbmdZID0gcGFkZGluZyA/IHBhZGRpbmdbMV0gOiAwLFxuXHRcdFx0XHRcdHggPSBjb29yZHNbal0sXG5cdFx0XHRcdFx0eSA9IGNvb3Jkc1tqICsgMV0sXG5cdFx0XHRcdFx0eG4gPSB4IC0gcGFkZGluZ1gsXG5cdFx0XHRcdFx0eHggPSB4ICsgcGFkZGluZ1gsXG5cdFx0XHRcdFx0eW4gPSB5IC0gcGFkZGluZ1ksXG5cdFx0XHRcdFx0eXggPSB5ICsgcGFkZGluZ1k7XG5cdFx0XHRcdGlmICh4biA8IHgxKSB4MSA9IHhuO1xuXHRcdFx0XHRpZiAoeHggPiB4MikgeDIgPSB4eDtcblx0XHRcdFx0aWYgKHluIDwgeTEpIHkxID0geW47XG5cdFx0XHRcdGlmICh5eCA+IHkyKSB5MiA9IHl4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGdldFJvdWdoQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KSB7XG5cdFx0dmFyIHN0cm9rZVJhZGl1cyA9IHN0eWxlLmhhc1N0cm9rZSgpID8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIgOiAwLFxuXHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cztcblx0XHRpZiAoc3Ryb2tlUmFkaXVzID4gMCkge1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUpvaW4oKSA9PT0gJ21pdGVyJylcblx0XHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdGlmIChzdHlsZS5nZXRTdHJva2VDYXAoKSA9PT0gJ3NxdWFyZScpXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBNYXRoLm1heChqb2luUmFkaXVzLCBzdHJva2VSYWRpdXMgKiBNYXRoLnNxcnQoMikpO1xuXHRcdH1cblx0XHRyZXR1cm4gUGF0aC5nZXRIYW5kbGVCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCxcblx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZyhzdHJva2VSYWRpdXMsIG1hdHJpeCksXG5cdFx0XHRcdFBhdGguX2dldFBlblBhZGRpbmcoam9pblJhZGl1cywgbWF0cml4KSk7XG5cdH1cbn19KTtcblxuUGF0aC5pbmplY3QoeyBzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdGVsbGlwc2VTZWdtZW50cyA9IFtcblx0XHRcdG5ldyBTZWdtZW50KFstMSwgMF0sIFswLCBrYXBwYSBdLCBbMCwgLWthcHBhXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgLTFdLCBbLWthcHBhLCAwXSwgW2thcHBhLCAwIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzEsIDBdLCBbMCwgLWthcHBhXSwgWzAsIGthcHBhIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzAsIDFdLCBba2FwcGEsIDAgXSwgWy1rYXBwYSwgMF0pXG5cdFx0XTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRoKHNlZ21lbnRzLCBjbG9zZWQsIGFyZ3MpIHtcblx0XHR2YXIgcHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3MpLFxuXHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2UgJiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdHBhdGguX2FkZChzZWdtZW50cyk7XG5cdFx0cGF0aC5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gbmV3IEFycmF5KDQpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IGVsbGlwc2VTZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoXG5cdFx0XHRcdHNlZ21lbnQuX3BvaW50Lm11bHRpcGx5KHJhZGl1cykuYWRkKGNlbnRlciksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZUluLm11bHRpcGx5KHJhZGl1cyksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dC5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdExpbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoW1xuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpKSxcblx0XHRcdFx0bmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJykpXG5cdFx0XHRdLCBmYWxzZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Q2lyY2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMpLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnLCAwLFxuXHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdFx0YmwgPSByZWN0LmdldEJvdHRvbUxlZnQodHJ1ZSksXG5cdFx0XHRcdHRsID0gcmVjdC5nZXRUb3BMZWZ0KHRydWUpLFxuXHRcdFx0XHR0ciA9IHJlY3QuZ2V0VG9wUmlnaHQodHJ1ZSksXG5cdFx0XHRcdGJyID0gcmVjdC5nZXRCb3R0b21SaWdodCh0cnVlKSxcblx0XHRcdFx0c2VnbWVudHM7XG5cdFx0XHRpZiAoIXJhZGl1cyB8fCByYWRpdXMuaXNaZXJvKCkpIHtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ciksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIpXG5cdFx0XHRcdF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihyYWRpdXMsIHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0XHR2YXIgcnggPSByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSByYWRpdXMuaGVpZ2h0LFxuXHRcdFx0XHRcdGh4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRoeSA9IHJ5ICoga2FwcGE7XG5cdFx0XHRcdHNlZ21lbnRzID0gW1xuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLmFkZChyeCwgMCksIG51bGwsIFstaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibC5zdWJ0cmFjdCgwLCByeSksIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZCgwLCByeSksIG51bGwsIFswLCAtaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bC5hZGQocngsIDApLCBbLWh4LCAwXSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIuc3VidHJhY3QocngsIDApLCBudWxsLCBbaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5hZGQoMCwgcnkpLCBbMCwgLWh5XSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIuc3VidHJhY3QoMCwgcnkpLCBudWxsLCBbMCwgaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdChyeCwgMCksIFtoeCwgMF0pXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Um91bmRSZWN0YW5nbGU6ICcjUmVjdGFuZ2xlJyxcblxuXHRcdEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBjcmVhdGVFbGxpcHNlKGVsbGlwc2UuY2VudGVyLCBlbGxpcHNlLnJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0T3ZhbDogJyNFbGxpcHNlJyxcblxuXHRcdEFyYzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZnJvbSA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG5cdFx0XHRcdHRocm91Z2ggPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndGhyb3VnaCcpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpLFxuXHRcdFx0XHRwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdHBhdGgubW92ZVRvKGZyb20pO1xuXHRcdFx0cGF0aC5hcmNUbyh0aHJvdWdoLCB0byk7XG5cdFx0XHRyZXR1cm4gcGF0aC5zZXQocHJvcHMpO1xuXHRcdH0sXG5cblx0XHRSZWd1bGFyUG9seWdvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRzaWRlcyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3NpZGVzJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRzdGVwID0gMzYwIC8gc2lkZXMsXG5cdFx0XHRcdHRocmVlID0gIShzaWRlcyAlIDMpLFxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgdGhyZWUgPyAtcmFkaXVzIDogcmFkaXVzKSxcblx0XHRcdFx0b2Zmc2V0ID0gdGhyZWUgPyAtMSA6IDAuNSxcblx0XHRcdFx0c2VnbWVudHMgPSBuZXcgQXJyYXkoc2lkZXMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQoXG5cdFx0XHRcdFx0dmVjdG9yLnJvdGF0ZSgoaSArIG9mZnNldCkgKiBzdGVwKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFN0YXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cG9pbnRzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncG9pbnRzJykgKiAyLFxuXHRcdFx0XHRyYWRpdXMxID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzMScpLFxuXHRcdFx0XHRyYWRpdXMyID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzMicpLFxuXHRcdFx0XHRzdGVwID0gMzYwIC8gcG9pbnRzLFxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgLTEpLFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShwb2ludHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHM7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChjZW50ZXIuYWRkKHZlY3Rvci5yb3RhdGUoc3RlcCAqIGkpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoaSAlIDIgPyByYWRpdXMyIDogcmFkaXVzMSkpKTtcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIENvbXBvdW5kUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0NvbXBvdW5kUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjaGlsZHJlbjogW11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb21wb3VuZFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpIHtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbiBpbnNlcnRDaGlsZHJlbihpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSkge1xuXHRcdGl0ZW1zID0gaW5zZXJ0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIGluZGV4LCBpdGVtcywgX3ByZXNlcnZlLCBQYXRoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9ICFfcHJlc2VydmUgJiYgaXRlbXMgJiYgaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0aWYgKGl0ZW0uX2Nsb2Nrd2lzZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRpdGVtLnNldENsb2Nrd2lzZShpdGVtLl9pbmRleCA9PT0gMCk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLnJldmVyc2UoKTtcblx0fSxcblxuXHRzbW9vdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fY2hpbGRyZW5baV0uc21vb3RoKCk7XG5cdH0sXG5cblx0aXNDbG9ja3dpc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBjaGlsZCAmJiBjaGlsZC5pc0Nsb2Nrd2lzZSgpO1xuXHR9LFxuXG5cdHNldENsb2Nrd2lzZTogZnVuY3Rpb24oY2xvY2t3aXNlKSB7XG5cdFx0aWYgKHRoaXMuaXNDbG9ja3dpc2UoKSAhPT0gISFjbG9ja3dpc2UpXG5cdFx0XHR0aGlzLnJldmVyc2UoKTtcblx0fSxcblxuXHRnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdFNlZ21lbnQoKTtcblx0fSxcblxuXHRnZXRMYXN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXHRcdHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0TGFzdFNlZ21lbnQoKTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0Y3VydmVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjdXJ2ZXMucHVzaC5hcHBseShjdXJ2ZXMsIGNoaWxkcmVuW2ldLmdldEN1cnZlcygpKTtcblx0XHRyZXR1cm4gY3VydmVzO1xuXHR9LFxuXG5cdGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdEN1cnZlKCk7XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRGaXJzdEN1cnZlKCk7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRhcmVhID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGFyZWEgKz0gY2hpbGRyZW5baV0uZ2V0QXJlYSgpO1xuXHRcdHJldHVybiBhcmVhO1xuXHR9XG59LCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRwYXRocyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0cGF0aHMucHVzaChjaGlsZHJlbltpXS5nZXRQYXRoRGF0YShfcHJlY2lzaW9uKSk7XG5cdFx0cmV0dXJuIHBhdGhzLmpvaW4oJyAnKTtcblx0fVxufSwge1xuXHRfZ2V0Q2hpbGRIaXRUZXN0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zLnR5cGUgPT09ICdwYXRoJ1xuXHRcdFx0XHQ/IG9wdGlvbnNcblx0XHRcdFx0OiBuZXcgQmFzZShvcHRpb25zLCB7IGZpbGw6IGZhbHNlIH0pO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybjtcblxuXHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0Y3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgZG9udFN0YXJ0OiB0cnVlLCBkb250RmluaXNoOiB0cnVlIH0pO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0XHR0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcblx0XHR9XG5cblx0XHRpZiAoIXBhcmFtLmNsaXApIHtcblx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG5cdFx0XHRpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG5cdFx0XHRcdGN0eC5maWxsKHN0eWxlLmdldFdpbmRpbmdSdWxlKCkpO1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXdTZWxlY3RlZDogZnVuY3Rpb24oY3R4LCBtYXRyaXgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdG14ID0gY2hpbGQuX21hdHJpeDtcblx0XHRcdGNoaWxkLl9kcmF3U2VsZWN0ZWQoY3R4LCBteC5pc0lkZW50aXR5KCkgPyBtYXRyaXhcblx0XHRcdFx0XHQ6IG1hdHJpeC5jbG9uZSgpLmNvbmNhdGVuYXRlKGNoaWxkLl9tYXRyaXgpKTtcblx0XHR9XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHsgXG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRQYXRoKHRoYXQsIGNoZWNrKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhhdC5fY2hpbGRyZW47XG5cdFx0aWYgKGNoZWNrICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHZhciBmaWVsZHMgPSB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcyksXG5cdFx0XHRcdHBhdGggPSBjdXJyZW50ICYmIGN1cnJlbnQuaXNFbXB0eSgpID8gY3VycmVudCA6IG5ldyBQYXRoKCk7XG5cdFx0XHRpZiAocGF0aCAhPT0gY3VycmVudClcblx0XHRcdFx0dGhpcy5hZGRDaGlsZChwYXRoKTtcblx0XHRcdHBhdGgubW92ZVRvLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLFxuXHRcdFx0XHRsYXN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5tb3ZlVG8obGFzdCA/IHBvaW50LmFkZChsYXN0Ll9wb2ludCkgOiBwb2ludCk7XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuXHRcdFx0Z2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSkuY2xvc2VQYXRoKGpvaW4pO1xuXHRcdH1cblx0fTtcblxuXHRCYXNlLmVhY2goWydsaW5lVG8nLCAnY3ViaWNDdXJ2ZVRvJywgJ3F1YWRyYXRpY0N1cnZlVG8nLCAnY3VydmVUbycsICdhcmNUbycsXG5cdFx0XHQnbGluZUJ5JywgJ2N1YmljQ3VydmVCeScsICdxdWFkcmF0aWNDdXJ2ZUJ5JywgJ2N1cnZlQnknLCAnYXJjQnknXSxcblx0XHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRmaWVsZHNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBwYXRoID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0cGF0aFtrZXldLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdCk7XG5cblx0cmV0dXJuIGZpZWxkcztcbn0pO1xuXG5QYXRoSXRlbS5pbmplY3QobmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBjb21wdXRlQm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdG9yLCBzdWJ0cmFjdCkge1xuXHRcdGZ1bmN0aW9uIHByZXBhcmVQYXRoKHBhdGgpIHtcblx0XHRcdHJldHVybiBwYXRoLmNsb25lKGZhbHNlKS5yZWR1Y2UoKS5yZW9yaWVudCgpLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHR9XG5cblx0XHR2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEpLFxuXHRcdFx0X3BhdGgyID0gcGF0aDIgJiYgcGF0aDEgIT09IHBhdGgyICYmIHByZXBhcmVQYXRoKHBhdGgyKTtcblx0XHRpZiAoIV9wYXRoMS5pc0Nsb2Nrd2lzZSgpKVxuXHRcdFx0X3BhdGgxLnJldmVyc2UoKTtcblx0XHRpZiAoX3BhdGgyICYmICEoc3VidHJhY3QgXiBfcGF0aDIuaXNDbG9ja3dpc2UoKSkpXG5cdFx0XHRfcGF0aDIucmV2ZXJzZSgpO1xuXHRcdHNwbGl0UGF0aChfcGF0aDEuZ2V0SW50ZXJzZWN0aW9ucyhfcGF0aDIsIHRydWUpKTtcblxuXHRcdHZhciBjaGFpbiA9IFtdLFxuXHRcdFx0d2luZGluZ3MgPSBbXSxcblx0XHRcdGxlbmd0aHMgPSBbXSxcblx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRtb25vQ3VydmVzID0gW107XG5cblx0XHRmdW5jdGlvbiBjb2xsZWN0KHBhdGhzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgcGF0aCA9IHBhdGhzW2ldO1xuXHRcdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBwYXRoLl9zZWdtZW50cyk7XG5cdFx0XHRcdG1vbm9DdXJ2ZXMucHVzaC5hcHBseShtb25vQ3VydmVzLCBwYXRoLl9nZXRNb25vQ3VydmVzKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbGxlY3QoX3BhdGgxLl9jaGlsZHJlbiB8fCBbX3BhdGgxXSk7XG5cdFx0aWYgKF9wYXRoMilcblx0XHRcdGNvbGxlY3QoX3BhdGgyLl9jaGlsZHJlbiB8fCBbX3BhdGgyXSk7XG5cdFx0c2VnbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIgX2EgPSBhLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdF9iID0gYi5faW50ZXJzZWN0aW9uO1xuXHRcdFx0cmV0dXJuICFfYSAmJiAhX2IgfHwgX2EgJiYgX2IgPyAwIDogX2EgPyAtMSA6IDE7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fd2luZGluZyAhPSBudWxsKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGNoYWluLmxlbmd0aCA9IHdpbmRpbmdzLmxlbmd0aCA9IGxlbmd0aHMubGVuZ3RoID0gMDtcblx0XHRcdHZhciB0b3RhbExlbmd0aCA9IDAsXG5cdFx0XHRcdHN0YXJ0U2VnID0gc2VnbWVudDtcblx0XHRcdGRvIHtcblx0XHRcdFx0Y2hhaW4ucHVzaChzZWdtZW50KTtcblx0XHRcdFx0bGVuZ3Rocy5wdXNoKHRvdGFsTGVuZ3RoICs9IHNlZ21lbnQuZ2V0Q3VydmUoKS5nZXRMZW5ndGgoKSk7XG5cdFx0XHRcdHNlZ21lbnQgPSBzZWdtZW50LmdldE5leHQoKTtcblx0XHRcdH0gd2hpbGUgKHNlZ21lbnQgJiYgIXNlZ21lbnQuX2ludGVyc2VjdGlvbiAmJiBzZWdtZW50ICE9PSBzdGFydFNlZyk7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdG90YWxMZW5ndGggKiBNYXRoLnJhbmRvbSgpLFxuXHRcdFx0XHRcdGFtb3VudCA9IGxlbmd0aHMubGVuZ3RoLFxuXHRcdFx0XHRcdGsgPSAwO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKGxlbmd0aHNba10gPj0gbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoayA+IDApXG5cdFx0XHRcdFx0XHRcdGxlbmd0aCAtPSBsZW5ndGhzW2sgLSAxXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoKytrIDwgYW1vdW50KTtcblx0XHRcdFx0dmFyIGN1cnZlID0gY2hhaW5ba10uZ2V0Q3VydmUoKSxcblx0XHRcdFx0XHRwb2ludCA9IGN1cnZlLmdldFBvaW50QXQobGVuZ3RoKSxcblx0XHRcdFx0XHRob3IgPSBjdXJ2ZS5pc0hvcml6b250YWwoKSxcblx0XHRcdFx0XHRwYXRoID0gY3VydmUuX3BhdGg7XG5cdFx0XHRcdGlmIChwYXRoLl9wYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG5cdFx0XHRcdFx0cGF0aCA9IHBhdGguX3BhcmVudDtcblx0XHRcdFx0d2luZGluZ3Nbal0gPSBzdWJ0cmFjdCAmJiBfcGF0aDJcblx0XHRcdFx0XHRcdCYmIChwYXRoID09PSBfcGF0aDEgJiYgX3BhdGgyLl9nZXRXaW5kaW5nKHBvaW50LCBob3IpXG5cdFx0XHRcdFx0XHR8fCBwYXRoID09PSBfcGF0aDIgJiYgIV9wYXRoMS5fZ2V0V2luZGluZyhwb2ludCwgaG9yKSlcblx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0OiBnZXRXaW5kaW5nKHBvaW50LCBtb25vQ3VydmVzLCBob3IpO1xuXHRcdFx0fVxuXHRcdFx0d2luZGluZ3Muc29ydCgpO1xuXHRcdFx0dmFyIHdpbmRpbmcgPSB3aW5kaW5nc1sxXTtcblx0XHRcdGZvciAodmFyIGogPSBjaGFpbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcblx0XHRcdFx0Y2hhaW5bal0uX3dpbmRpbmcgPSB3aW5kaW5nO1xuXHRcdH1cblx0XHR2YXIgcmVzdWx0ID0gbmV3IENvbXBvdW5kUGF0aCgpO1xuXHRcdHJlc3VsdC5hZGRDaGlsZHJlbih0cmFjZVBhdGhzKHNlZ21lbnRzLCBvcGVyYXRvciksIHRydWUpO1xuXHRcdF9wYXRoMS5yZW1vdmUoKTtcblx0XHRpZiAoX3BhdGgyKVxuXHRcdFx0X3BhdGgyLnJlbW92ZSgpO1xuXHRcdHJldHVybiByZXN1bHQucmVkdWNlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzcGxpdFBhdGgoaW50ZXJzZWN0aW9ucykge1xuXHRcdHZhciBUT0xFUkFOQ0UgPSAwLjAwMDAxLFxuXHRcdFx0bGluZWFyU2VnbWVudHM7XG5cblx0XHRmdW5jdGlvbiByZXNldExpbmVhcigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZWFyU2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gbGluZWFyU2VnbWVudHNbaV07XG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dC5zZXQoMCwgMCk7XG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZUluLnNldCgwLCAwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gaW50ZXJzZWN0aW9ucy5sZW5ndGggLSAxLCBjdXJ2ZSwgcHJldkxvYzsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBsb2MgPSBpbnRlcnNlY3Rpb25zW2ldLFxuXHRcdFx0XHR0ID0gbG9jLl9wYXJhbWV0ZXI7XG5cdFx0XHRpZiAocHJldkxvYyAmJiBwcmV2TG9jLl9jdXJ2ZSA9PT0gbG9jLl9jdXJ2ZVxuXHRcdFx0XHRcdCYmIHByZXZMb2MuX3BhcmFtZXRlciA+IDApIHtcblx0XHRcdFx0dCAvPSBwcmV2TG9jLl9wYXJhbWV0ZXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAobGluZWFyU2VnbWVudHMpXG5cdFx0XHRcdFx0cmVzZXRMaW5lYXIoKTtcblx0XHRcdFx0Y3VydmUgPSBsb2MuX2N1cnZlO1xuXHRcdFx0XHRsaW5lYXJTZWdtZW50cyA9IGN1cnZlLmlzTGluZWFyKCkgJiYgW107XG5cdFx0XHR9XG5cdFx0XHR2YXIgbmV3Q3VydmUsXG5cdFx0XHRcdHNlZ21lbnQ7XG5cdFx0XHRpZiAobmV3Q3VydmUgPSBjdXJ2ZS5kaXZpZGUodCwgdHJ1ZSwgdHJ1ZSkpIHtcblx0XHRcdFx0c2VnbWVudCA9IG5ld0N1cnZlLl9zZWdtZW50MTtcblx0XHRcdFx0Y3VydmUgPSBuZXdDdXJ2ZS5nZXRQcmV2aW91cygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VnbWVudCA9IHQgPCBUT0xFUkFOQ0Vcblx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdDogdCA+IDEgLSBUT0xFUkFOQ0Vcblx0XHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQyXG5cdFx0XHRcdFx0XHQ6IGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgdCkgPCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHQsIDEpXG5cdFx0XHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQxXG5cdFx0XHRcdFx0XHRcdDogY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fVxuXHRcdFx0c2VnbWVudC5faW50ZXJzZWN0aW9uID0gbG9jLmdldEludGVyc2VjdGlvbigpO1xuXHRcdFx0bG9jLl9zZWdtZW50ID0gc2VnbWVudDtcblx0XHRcdGlmIChsaW5lYXJTZWdtZW50cylcblx0XHRcdFx0bGluZWFyU2VnbWVudHMucHVzaChzZWdtZW50KTtcblx0XHRcdHByZXZMb2MgPSBsb2M7XG5cdFx0fVxuXHRcdGlmIChsaW5lYXJTZWdtZW50cylcblx0XHRcdHJlc2V0TGluZWFyKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsIGhvcml6b250YWwsIHRlc3RDb250YWlucykge1xuXHRcdHZhciBUT0xFUkFOQ0UgPSAwLjAwMDAxLFxuXHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueSxcblx0XHRcdHdpbmRMZWZ0ID0gMCxcblx0XHRcdHdpbmRSaWdodCA9IDAsXG5cdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRNQVggPSAxIC0gVE9MRVJBTkNFO1xuXHRcdGlmIChob3Jpem9udGFsKSB7XG5cdFx0XHR2YXIgeVRvcCA9IC1JbmZpbml0eSxcblx0XHRcdFx0eUJvdHRvbSA9IEluZmluaXR5LFxuXHRcdFx0XHR5QmVmb3JlID0geSAtIFRPTEVSQU5DRSxcblx0XHRcdFx0eUFmdGVyID0geSArIFRPTEVSQU5DRTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcblx0XHRcdFx0aWYgKEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAwLCB4LCByb290cywgMCwgMSkgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgeTAgPSBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHJvb3RzW2pdLCAwKS55O1xuXHRcdFx0XHRcdFx0aWYgKHkwIDwgeUJlZm9yZSAmJiB5MCA+IHlUb3ApIHtcblx0XHRcdFx0XHRcdFx0eVRvcCA9IHkwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh5MCA+IHlBZnRlciAmJiB5MCA8IHlCb3R0b20pIHtcblx0XHRcdFx0XHRcdFx0eUJvdHRvbSA9IHkwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0eVRvcCA9ICh5VG9wICsgeSkgLyAyO1xuXHRcdFx0eUJvdHRvbSA9ICh5Qm90dG9tICsgeSkgLyAyO1xuXHRcdFx0aWYgKHlUb3AgPiAtSW5maW5pdHkpXG5cdFx0XHRcdHdpbmRMZWZ0ID0gZ2V0V2luZGluZyhuZXcgUG9pbnQoeCwgeVRvcCksIGN1cnZlcyk7XG5cdFx0XHRpZiAoeUJvdHRvbSA8IEluZmluaXR5KVxuXHRcdFx0XHR3aW5kUmlnaHQgPSBnZXRXaW5kaW5nKG5ldyBQb2ludCh4LCB5Qm90dG9tKSwgY3VydmVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHhCZWZvcmUgPSB4IC0gVE9MRVJBTkNFLFxuXHRcdFx0XHR4QWZ0ZXIgPSB4ICsgVE9MRVJBTkNFO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpXSxcblx0XHRcdFx0XHR2YWx1ZXMgPSBjdXJ2ZS52YWx1ZXMsXG5cdFx0XHRcdFx0d2luZGluZyA9IGN1cnZlLndpbmRpbmcsXG5cdFx0XHRcdFx0bmV4dCA9IGN1cnZlLm5leHQ7XG5cdFx0XHRcdGlmICh3aW5kaW5nICYmICh3aW5kaW5nID09PSAxXG5cdFx0XHRcdFx0XHQmJiB5ID49IHZhbHVlc1sxXSAmJiB5IDw9IHZhbHVlc1s3XVxuXHRcdFx0XHRcdFx0fHwgeSA+PSB2YWx1ZXNbN10gJiYgeSA8PSB2YWx1ZXNbMV0pXG5cdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHksIHJvb3RzLCAwLFxuXHRcdFx0XHRcdFx0IW5leHQud2luZGluZyAmJiBuZXh0LnZhbHVlc1sxXSA9PT0geSA/IDEgOiBNQVgpID09PSAxKXtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdLFxuXHRcdFx0XHRcdFx0eDAgPSBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHQsIDApLngsXG5cdFx0XHRcdFx0XHRzbG9wZSA9IEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgdCwgMSkueTtcblx0XHRcdFx0XHRpZiAoYWJzKHNsb3BlKSA8IFRPTEVSQU5DRSAmJiAhQ3VydmUuaXNMaW5lYXIodmFsdWVzKVxuXHRcdFx0XHRcdFx0XHR8fCB0IDwgVE9MRVJBTkNFICYmIHNsb3BlICogQ3VydmUuZXZhbHVhdGUoXG5cdFx0XHRcdFx0XHRcdFx0Y3VydmUucHJldmlvdXMudmFsdWVzLCB0LCAxKS55IDwgMCkge1xuXHRcdFx0XHRcdFx0aWYgKHRlc3RDb250YWlucyAmJiB4MCA+PSB4QmVmb3JlICYmIHgwIDw9IHhBZnRlcikge1xuXHRcdFx0XHRcdFx0XHQrK3dpbmRMZWZ0O1xuXHRcdFx0XHRcdFx0XHQrK3dpbmRSaWdodDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHgwIDw9IHhCZWZvcmUpIHtcblx0XHRcdFx0XHRcdHdpbmRMZWZ0ICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh4MCA+PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdHdpbmRSaWdodCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gTWF0aC5tYXgoYWJzKHdpbmRMZWZ0KSwgYWJzKHdpbmRSaWdodCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0b3IsIHNlbGZPcCkge1xuXHRcdG9wZXJhdG9yID0gb3BlcmF0b3IgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdHZhciBwYXRocyA9IFtdLFxuXHRcdFx0WkVSTyA9IDFlLTMsXG5cdFx0XHRPTkUgPSAxIC0gMWUtMztcblx0XHRmb3IgKHZhciBpID0gMCwgc2VnLCBzdGFydFNlZywgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnID0gc3RhcnRTZWcgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChzZWcuX3Zpc2l0ZWQgfHwgIW9wZXJhdG9yKHNlZy5fd2luZGluZykpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCksXG5cdFx0XHRcdGludGVyID0gc2VnLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdHN0YXJ0SW50ZXJTZWcgPSBpbnRlciAmJiBpbnRlci5fc2VnbWVudCxcblx0XHRcdFx0YWRkZWQgPSBmYWxzZSwgXG5cdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHZhciBoYW5kbGVJbiA9IGRpciA+IDAgPyBzZWcuX2hhbmRsZUluIDogc2VnLl9oYW5kbGVPdXQsXG5cdFx0XHRcdFx0aGFuZGxlT3V0ID0gZGlyID4gMCA/IHNlZy5faGFuZGxlT3V0IDogc2VnLl9oYW5kbGVJbixcblx0XHRcdFx0XHRpbnRlclNlZztcblx0XHRcdFx0aWYgKGFkZGVkICYmICghb3BlcmF0b3Ioc2VnLl93aW5kaW5nKSB8fCBzZWxmT3ApXG5cdFx0XHRcdFx0XHQmJiAoaW50ZXIgPSBzZWcuX2ludGVyc2VjdGlvbilcblx0XHRcdFx0XHRcdCYmIChpbnRlclNlZyA9IGludGVyLl9zZWdtZW50KVxuXHRcdFx0XHRcdFx0JiYgaW50ZXJTZWcgIT09IHN0YXJ0U2VnKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGZPcCkge1xuXHRcdFx0XHRcdFx0c2VnLl92aXNpdGVkID0gaW50ZXJTZWcuX3Zpc2l0ZWQ7XG5cdFx0XHRcdFx0XHRzZWcgPSBpbnRlclNlZztcblx0XHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBjMSA9IHNlZy5nZXRDdXJ2ZSgpO1xuXHRcdFx0XHRcdFx0aWYgKGRpciA+IDApXG5cdFx0XHRcdFx0XHRcdGMxID0gYzEuZ2V0UHJldmlvdXMoKTtcblx0XHRcdFx0XHRcdHZhciB0MSA9IGMxLmdldFRhbmdlbnRBdChkaXIgPCAxID8gWkVSTyA6IE9ORSwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdGM0ID0gaW50ZXJTZWcuZ2V0Q3VydmUoKSxcblx0XHRcdFx0XHRcdFx0YzMgPSBjNC5nZXRQcmV2aW91cygpLFxuXHRcdFx0XHRcdFx0XHR0MyA9IGMzLmdldFRhbmdlbnRBdChPTkUsIHRydWUpLFxuXHRcdFx0XHRcdFx0XHR0NCA9IGM0LmdldFRhbmdlbnRBdChaRVJPLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0dzMgPSB0MS5jcm9zcyh0MyksXG5cdFx0XHRcdFx0XHRcdHc0ID0gdDEuY3Jvc3ModDQpO1xuXHRcdFx0XHRcdFx0aWYgKHczICogdzQgIT09IDApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnZlID0gdzMgPCB3NCA/IGMzIDogYzQsXG5cdFx0XHRcdFx0XHRcdFx0bmV4dEN1cnZlID0gb3BlcmF0b3IoY3VydmUuX3NlZ21lbnQxLl93aW5kaW5nKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBjdXJ2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0OiB3MyA8IHc0ID8gYzQgOiBjMyxcblx0XHRcdFx0XHRcdFx0XHRuZXh0U2VnID0gbmV4dEN1cnZlLl9zZWdtZW50MTtcblx0XHRcdFx0XHRcdFx0ZGlyID0gbmV4dEN1cnZlID09PSBjMyA/IC0xIDogMTtcblx0XHRcdFx0XHRcdFx0aWYgKG5leHRTZWcuX3Zpc2l0ZWQgJiYgc2VnLl9wYXRoICE9PSBuZXh0U2VnLl9wYXRoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHx8ICFvcGVyYXRvcihuZXh0U2VnLl93aW5kaW5nKSkge1xuXHRcdFx0XHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VnLl92aXNpdGVkID0gaW50ZXJTZWcuX3Zpc2l0ZWQ7XG5cdFx0XHRcdFx0XHRcdFx0c2VnID0gaW50ZXJTZWc7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5leHRTZWcuX3Zpc2l0ZWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBkaXIgPiAwID8gc2VnLl9oYW5kbGVPdXQgOiBzZWcuX2hhbmRsZUluO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhdGguYWRkKG5ldyBTZWdtZW50KHNlZy5fcG9pbnQsIGFkZGVkICYmIGhhbmRsZUluLCBoYW5kbGVPdXQpKTtcblx0XHRcdFx0YWRkZWQgPSB0cnVlO1xuXHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSB0cnVlO1xuXHRcdFx0XHRzZWcgPSBkaXIgPiAwID8gc2VnLmdldE5leHQoKSA6IHNlZy4gZ2V0UHJldmlvdXMoKTtcblx0XHRcdH0gd2hpbGUgKHNlZyAmJiAhc2VnLl92aXNpdGVkXG5cdFx0XHRcdFx0JiYgc2VnICE9PSBzdGFydFNlZyAmJiBzZWcgIT09IHN0YXJ0SW50ZXJTZWdcblx0XHRcdFx0XHQmJiAoc2VnLl9pbnRlcnNlY3Rpb24gfHwgb3BlcmF0b3Ioc2VnLl93aW5kaW5nKSkpO1xuXHRcdFx0aWYgKHNlZyAmJiAoc2VnID09PSBzdGFydFNlZyB8fCBzZWcgPT09IHN0YXJ0SW50ZXJTZWcpKSB7XG5cdFx0XHRcdHBhdGguZmlyc3RTZWdtZW50LnNldEhhbmRsZUluKChzZWcgPT09IHN0YXJ0SW50ZXJTZWdcblx0XHRcdFx0XHRcdD8gc3RhcnRJbnRlclNlZyA6IHNlZykuX2hhbmRsZUluKTtcblx0XHRcdFx0cGF0aC5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLmxhc3RTZWdtZW50Ll9oYW5kbGVPdXQuc2V0KDAsIDApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBhdGguX3NlZ21lbnRzLmxlbmd0aCA+XG5cdFx0XHRcdFx0KHBhdGguX2Nsb3NlZCA/IHBhdGguaXNQb2x5Z29uKCkgPyAyIDogMCA6IDEpKVxuXHRcdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9nZXRXaW5kaW5nOiBmdW5jdGlvbihwb2ludCwgaG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKSB7XG5cdFx0XHRyZXR1cm4gZ2V0V2luZGluZyhwb2ludCwgdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRcdGhvcml6b250YWwsIHRlc3RDb250YWlucyk7XG5cdFx0fSxcblxuXHRcdHVuaXRlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgZnVuY3Rpb24odykge1xuXHRcdFx0XHRyZXR1cm4gdyA9PT0gMSB8fCB3ID09PSAwO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCBmdW5jdGlvbih3KSB7XG5cdFx0XHRcdHJldHVybiB3ID09PSAyO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsIGZ1bmN0aW9uKHcpIHtcblx0XHRcdFx0cmV0dXJuIHcgPT09IDE7XG5cdFx0XHR9LCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0ZXhjbHVkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBHcm91cChbdGhpcy5zdWJ0cmFjdChwYXRoKSwgcGF0aC5zdWJ0cmFjdCh0aGlzKV0pO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBuZXcgR3JvdXAoW3RoaXMuc3VidHJhY3QocGF0aCksIHRoaXMuaW50ZXJzZWN0KHBhdGgpXSk7XG5cdFx0fVxuXHR9O1xufSk7XG5cblBhdGguaW5qZWN0KHtcblx0X2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyxcblx0XHRcdHByZXZDdXJ2ZTtcblxuXHRcdGZ1bmN0aW9uIGluc2VydEN1cnZlKHYpIHtcblx0XHRcdHZhciB5MCA9IHZbMV0sXG5cdFx0XHRcdHkxID0gdls3XSxcblx0XHRcdFx0Y3VydmUgPSB7XG5cdFx0XHRcdFx0dmFsdWVzOiB2LFxuXHRcdFx0XHRcdHdpbmRpbmc6IHkwID09PSB5MVxuXHRcdFx0XHRcdFx0PyAwIFxuXHRcdFx0XHRcdFx0OiB5MCA+IHkxXG5cdFx0XHRcdFx0XHRcdD8gLTEgXG5cdFx0XHRcdFx0XHRcdDogMSwgXG5cdFx0XHRcdFx0cHJldmlvdXM6IHByZXZDdXJ2ZSxcblx0XHRcdFx0XHRuZXh0OiBudWxsIFxuXHRcdFx0XHR9O1xuXHRcdFx0aWYgKHByZXZDdXJ2ZSlcblx0XHRcdFx0cHJldkN1cnZlLm5leHQgPSBjdXJ2ZTtcblx0XHRcdG1vbm9DdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHRwcmV2Q3VydmUgPSBjdXJ2ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVDdXJ2ZSh2KSB7XG5cdFx0XHRpZiAoQ3VydmUuZ2V0TGVuZ3RoKHYpID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgeTAgPSB2WzFdLFxuXHRcdFx0XHR5MSA9IHZbM10sXG5cdFx0XHRcdHkyID0gdls1XSxcblx0XHRcdFx0eTMgPSB2WzddO1xuXHRcdFx0aWYgKEN1cnZlLmlzTGluZWFyKHYpKSB7XG5cdFx0XHRcdGluc2VydEN1cnZlKHYpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGEgPSAzICogKHkxIC0geTIpIC0geTAgKyB5Myxcblx0XHRcdFx0XHRiID0gMiAqICh5MCArIHkyKSAtIDQgKiB5MSxcblx0XHRcdFx0XHRjID0geTEgLSB5MCxcblx0XHRcdFx0XHRUT0xFUkFOQ0UgPSAwLjAwMDAxLFxuXHRcdFx0XHRcdHJvb3RzID0gW107XG5cdFx0XHRcdHZhciBjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cywgVE9MRVJBTkNFLFxuXHRcdFx0XHRcdFx0MSAtIFRPTEVSQU5DRSk7XG5cdFx0XHRcdGlmIChjb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdGluc2VydEN1cnZlKHYpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJvb3RzLnNvcnQoKTtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdLFxuXHRcdFx0XHRcdFx0cGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgdCk7XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMF0pO1xuXHRcdFx0XHRcdGlmIChjb3VudCA+IDEpIHtcblx0XHRcdFx0XHRcdHQgPSAocm9vdHNbMV0gLSB0KSAvICgxIC0gdCk7XG5cdFx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZShwYXJ0c1sxXSwgdCk7XG5cdFx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1swXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbW9ub0N1cnZlcykge1xuXHRcdFx0bW9ub0N1cnZlcyA9IHRoaXMuX21vbm9DdXJ2ZXMgPSBbXTtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRoYW5kbGVDdXJ2ZShjdXJ2ZXNbaV0uZ2V0VmFsdWVzKCkpO1xuXHRcdFx0aWYgKCF0aGlzLl9jbG9zZWQgJiYgc2VnbWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR2YXIgcDEgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5fcG9pbnQsXG5cdFx0XHRcdFx0cDIgPSBzZWdtZW50c1swXS5fcG9pbnQsXG5cdFx0XHRcdFx0cDF4ID0gcDEuX3gsIHAxeSA9IHAxLl95LFxuXHRcdFx0XHRcdHAyeCA9IHAyLl94LCBwMnkgPSBwMi5feTtcblx0XHRcdFx0aGFuZGxlQ3VydmUoW3AxeCwgcDF5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAyeCwgcDJ5XSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9ub0N1cnZlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciBmaXJzdCA9IG1vbm9DdXJ2ZXNbMF0sXG5cdFx0XHRcdFx0bGFzdCA9IG1vbm9DdXJ2ZXNbbW9ub0N1cnZlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0Zmlyc3QucHJldmlvdXMgPSBsYXN0O1xuXHRcdFx0XHRsYXN0Lm5leHQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1vbm9DdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0SW50ZXJpb3JQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRwb2ludCA9IGJvdW5kcy5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0aWYgKCF0aGlzLmNvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuX2dldE1vbm9DdXJ2ZXMoKSxcblx0XHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdFx0eSA9IHBvaW50LnksXG5cdFx0XHRcdHhJbnRlcmNlcHRzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGN1cnZlc1tpXS52YWx1ZXM7XG5cdFx0XHRcdGlmICgoY3VydmVzW2ldLndpbmRpbmcgPT09IDFcblx0XHRcdFx0XHRcdCYmIHkgPj0gdmFsdWVzWzFdICYmIHkgPD0gdmFsdWVzWzddXG5cdFx0XHRcdFx0XHR8fCB5ID49IHZhbHVlc1s3XSAmJiB5IDw9IHZhbHVlc1sxXSlcblx0XHRcdFx0XHRcdCYmIEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAxLCB5LCByb290cywgMCwgMSkgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuXHRcdFx0XHRcdFx0eEludGVyY2VwdHMucHVzaChDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHJvb3RzW2pdLCAwKS54KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeEludGVyY2VwdHMubGVuZ3RoID4gMSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHBvaW50LnggPSAoeEludGVyY2VwdHNbMF0gKyB4SW50ZXJjZXB0c1sxXSkgLyAyO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0cmVvcmllbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2V0Q2xvY2t3aXNlKHRydWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuQ29tcG91bmRQYXRoLmluamVjdCh7XG5cdF9nZXRNb25vQ3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSAgdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRtb25vQ3VydmVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRtb25vQ3VydmVzLnB1c2guYXBwbHkobW9ub0N1cnZlcywgY2hpbGRyZW5baV0uX2dldE1vbm9DdXJ2ZXMoKSk7XG5cdFx0cmV0dXJuIG1vbm9DdXJ2ZXM7XG5cdH0sXG5cblx0cmVvcmllbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMucmVtb3ZlQ2hpbGRyZW4oKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBiLmdldEJvdW5kcygpLmdldEFyZWEoKSAtIGEuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpO1xuXHRcdH0pO1xuXHRcdHRoaXMuYWRkQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXHRcdHZhciBjbG9ja3dpc2UgPSBjaGlsZHJlblswXS5pc0Nsb2Nrd2lzZSgpO1xuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IFxuXHRcdFx0dmFyIHBvaW50ID0gY2hpbGRyZW5baV0uZ2V0SW50ZXJpb3JQb2ludCgpLFxuXHRcdFx0XHRjb3VudGVycyA9IDA7XG5cdFx0XHRmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdGlmIChjaGlsZHJlbltqXS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0Y291bnRlcnMrKztcblx0XHRcdH1cblx0XHRcdGNoaWxkcmVuW2ldLnNldENsb2Nrd2lzZShjb3VudGVycyAlIDIgPT09IDAgJiYgY2xvY2t3aXNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG52YXIgUGF0aEZsYXR0ZW5lciA9IEJhc2UuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdHRoaXMuY3VydmVzID0gW107IFxuXHRcdHRoaXMucGFydHMgPSBbXTsgXG5cdFx0dGhpcy5sZW5ndGggPSAwOyBcblx0XHR0aGlzLmluZGV4ID0gMDtcblxuXHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0c2VnbWVudDEgPSBzZWdtZW50c1swXSxcblx0XHRcdHNlZ21lbnQyLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cblx0XHRmdW5jdGlvbiBhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFZhbHVlcyhzZWdtZW50MSwgc2VnbWVudDIpO1xuXHRcdFx0dGhhdC5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHR0aGF0Ll9jb21wdXRlUGFydHMoY3VydmUsIHNlZ21lbnQxLl9pbmRleCwgMCwgMSk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHNlZ21lbnQyID0gc2VnbWVudHNbaV07XG5cdFx0XHRhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpO1xuXHRcdFx0c2VnbWVudDEgPSBzZWdtZW50Mjtcblx0XHR9XG5cdFx0aWYgKHBhdGguX2Nsb3NlZClcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQyLCBzZWdtZW50c1swXSk7XG5cdH0sXG5cblx0X2NvbXB1dGVQYXJ0czogZnVuY3Rpb24oY3VydmUsIGluZGV4LCBtaW5ULCBtYXhUKSB7XG5cdFx0aWYgKChtYXhUIC0gbWluVCkgPiAxIC8gMzIgJiYgIUN1cnZlLmlzRmxhdEVub3VnaChjdXJ2ZSwgMC4yNSkpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSBDdXJ2ZS5zdWJkaXZpZGUoY3VydmUpO1xuXHRcdFx0dmFyIGhhbGZUID0gKG1pblQgKyBtYXhUKSAvIDI7XG5cdFx0XHR0aGlzLl9jb21wdXRlUGFydHMoY3VydmVzWzBdLCBpbmRleCwgbWluVCwgaGFsZlQpO1xuXHRcdFx0dGhpcy5fY29tcHV0ZVBhcnRzKGN1cnZlc1sxXSwgaW5kZXgsIGhhbGZULCBtYXhUKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHggPSBjdXJ2ZVs2XSAtIGN1cnZlWzBdLFxuXHRcdFx0XHR5ID0gY3VydmVbN10gLSBjdXJ2ZVsxXSxcblx0XHRcdFx0ZGlzdCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdGlmIChkaXN0ID4gMC4wMDAwMSkge1xuXHRcdFx0XHR0aGlzLmxlbmd0aCArPSBkaXN0O1xuXHRcdFx0XHR0aGlzLnBhcnRzLnB1c2goe1xuXHRcdFx0XHRcdG9mZnNldDogdGhpcy5sZW5ndGgsXG5cdFx0XHRcdFx0dmFsdWU6IG1heFQsXG5cdFx0XHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0dmFyIGksIGogPSB0aGlzLmluZGV4O1xuXHRcdGZvciAoOzspIHtcblx0XHRcdGkgPSBqO1xuXHRcdFx0aWYgKGogPT0gMCB8fCB0aGlzLnBhcnRzWy0tal0ub2Zmc2V0IDwgb2Zmc2V0KVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Zm9yICh2YXIgbCA9IHRoaXMucGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbaV07XG5cdFx0XHRpZiAocGFydC5vZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBpO1xuXHRcdFx0XHR2YXIgcHJldiA9IHRoaXMucGFydHNbaSAtIDFdO1xuXHRcdFx0XHR2YXIgcHJldlZhbCA9IHByZXYgJiYgcHJldi5pbmRleCA9PSBwYXJ0LmluZGV4ID8gcHJldi52YWx1ZSA6IDAsXG5cdFx0XHRcdFx0cHJldkxlbiA9IHByZXYgPyBwcmV2Lm9mZnNldCA6IDA7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByZXZWYWwgKyAocGFydC52YWx1ZSAtIHByZXZWYWwpXG5cdFx0XHRcdFx0XHQqIChvZmZzZXQgLSBwcmV2TGVuKSAvICAocGFydC5vZmZzZXQgLSBwcmV2TGVuKSxcblx0XHRcdFx0XHRpbmRleDogcGFydC5pbmRleFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbdGhpcy5wYXJ0cy5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsdWU6IDEsXG5cdFx0XHRpbmRleDogcGFydC5pbmRleFxuXHRcdH07XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKG9mZnNldCwgdHlwZSkge1xuXHRcdHZhciBwYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcblx0XHRyZXR1cm4gQ3VydmUuZXZhbHVhdGUodGhpcy5jdXJ2ZXNbcGFyYW0uaW5kZXhdLCBwYXJhbS52YWx1ZSwgdHlwZSk7XG5cdH0sXG5cblx0ZHJhd1BhcnQ6IGZ1bmN0aW9uKGN0eCwgZnJvbSwgdG8pIHtcblx0XHRmcm9tID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChmcm9tKTtcblx0XHR0byA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQodG8pO1xuXHRcdGZvciAodmFyIGkgPSBmcm9tLmluZGV4OyBpIDw9IHRvLmluZGV4OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFBhcnQodGhpcy5jdXJ2ZXNbaV0sXG5cdFx0XHRcdFx0aSA9PSBmcm9tLmluZGV4ID8gZnJvbS52YWx1ZSA6IDAsXG5cdFx0XHRcdFx0aSA9PSB0by5pbmRleCA/IHRvLnZhbHVlIDogMSk7XG5cdFx0XHRpZiAoaSA9PSBmcm9tLmluZGV4KVxuXHRcdFx0XHRjdHgubW92ZVRvKGN1cnZlWzBdLCBjdXJ2ZVsxXSk7XG5cdFx0XHRjdHguYmV6aWVyQ3VydmVUby5hcHBseShjdHgsIGN1cnZlLnNsaWNlKDIpKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgUGF0aEZpdHRlciA9IEJhc2UuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgZXJyb3IpIHtcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0cHJldjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBvaW50ID0gc2VnbWVudHNbaV0ucG9pbnQuY2xvbmUoKTtcblx0XHRcdGlmICghcHJldiB8fCAhcHJldi5lcXVhbHMocG9pbnQpKSB7XG5cdFx0XHRcdHRoaXMucG9pbnRzLnB1c2gocG9pbnQpO1xuXHRcdFx0XHRwcmV2ID0gcG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuZXJyb3IgPSBlcnJvcjtcblx0fSxcblxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyxcblx0XHRcdGxlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG5cdFx0dGhpcy5zZWdtZW50cyA9IGxlbmd0aCA+IDAgPyBbbmV3IFNlZ21lbnQocG9pbnRzWzBdKV0gOiBbXTtcblx0XHRpZiAobGVuZ3RoID4gMSlcblx0XHRcdHRoaXMuZml0Q3ViaWMoMCwgbGVuZ3RoIC0gMSxcblx0XHRcdFx0cG9pbnRzWzFdLnN1YnRyYWN0KHBvaW50c1swXSkubm9ybWFsaXplKCksXG5cdFx0XHRcdHBvaW50c1tsZW5ndGggLSAyXS5zdWJ0cmFjdChwb2ludHNbbGVuZ3RoIC0gMV0pLm5vcm1hbGl6ZSgpKTtcblx0XHRyZXR1cm4gdGhpcy5zZWdtZW50cztcblx0fSxcblxuXHRmaXRDdWJpYzogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHRhbjEsIHRhbjIpIHtcblx0XHRpZiAobGFzdCAtIGZpcnN0ID09IDEpIHtcblx0XHRcdHZhciBwdDEgPSB0aGlzLnBvaW50c1tmaXJzdF0sXG5cdFx0XHRcdHB0MiA9IHRoaXMucG9pbnRzW2xhc3RdLFxuXHRcdFx0XHRkaXN0ID0gcHQxLmdldERpc3RhbmNlKHB0MikgLyAzO1xuXHRcdFx0dGhpcy5hZGRDdXJ2ZShbcHQxLCBwdDEuYWRkKHRhbjEubm9ybWFsaXplKGRpc3QpKSxcblx0XHRcdFx0XHRwdDIuYWRkKHRhbjIubm9ybWFsaXplKGRpc3QpKSwgcHQyXSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciB1UHJpbWUgPSB0aGlzLmNob3JkTGVuZ3RoUGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0KSxcblx0XHRcdG1heEVycm9yID0gTWF0aC5tYXgodGhpcy5lcnJvciwgdGhpcy5lcnJvciAqIHRoaXMuZXJyb3IpLFxuXHRcdFx0c3BsaXQ7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gNDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdlbmVyYXRlQmV6aWVyKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpO1xuXHRcdFx0dmFyIG1heCA9IHRoaXMuZmluZE1heEVycm9yKGZpcnN0LCBsYXN0LCBjdXJ2ZSwgdVByaW1lKTtcblx0XHRcdGlmIChtYXguZXJyb3IgPCB0aGlzLmVycm9yKSB7XG5cdFx0XHRcdHRoaXMuYWRkQ3VydmUoY3VydmUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzcGxpdCA9IG1heC5pbmRleDtcblx0XHRcdGlmIChtYXguZXJyb3IgPj0gbWF4RXJyb3IpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0dGhpcy5yZXBhcmFtZXRlcml6ZShmaXJzdCwgbGFzdCwgdVByaW1lLCBjdXJ2ZSk7XG5cdFx0XHRtYXhFcnJvciA9IG1heC5lcnJvcjtcblx0XHR9XG5cdFx0dmFyIFYxID0gdGhpcy5wb2ludHNbc3BsaXQgLSAxXS5zdWJ0cmFjdCh0aGlzLnBvaW50c1tzcGxpdF0pLFxuXHRcdFx0VjIgPSB0aGlzLnBvaW50c1tzcGxpdF0uc3VidHJhY3QodGhpcy5wb2ludHNbc3BsaXQgKyAxXSksXG5cdFx0XHR0YW5DZW50ZXIgPSBWMS5hZGQoVjIpLmRpdmlkZSgyKS5ub3JtYWxpemUoKTtcblx0XHR0aGlzLmZpdEN1YmljKGZpcnN0LCBzcGxpdCwgdGFuMSwgdGFuQ2VudGVyKTtcblx0XHR0aGlzLmZpdEN1YmljKHNwbGl0LCBsYXN0LCB0YW5DZW50ZXIubmVnYXRlKCksIHRhbjIpO1xuXHR9LFxuXG5cdGFkZEN1cnZlOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHZhciBwcmV2ID0gdGhpcy5zZWdtZW50c1t0aGlzLnNlZ21lbnRzLmxlbmd0aCAtIDFdO1xuXHRcdHByZXYuc2V0SGFuZGxlT3V0KGN1cnZlWzFdLnN1YnRyYWN0KGN1cnZlWzBdKSk7XG5cdFx0dGhpcy5zZWdtZW50cy5wdXNoKFxuXHRcdFx0XHRuZXcgU2VnbWVudChjdXJ2ZVszXSwgY3VydmVbMl0uc3VidHJhY3QoY3VydmVbM10pKSk7XG5cdH0sXG5cblx0Z2VuZXJhdGVCZXppZXI6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTExLFxuXHRcdFx0cHQxID0gdGhpcy5wb2ludHNbZmlyc3RdLFxuXHRcdFx0cHQyID0gdGhpcy5wb2ludHNbbGFzdF0sXG5cdFx0XHRDID0gW1swLCAwXSwgWzAsIDBdXSxcblx0XHRcdFggPSBbMCwgMF07XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxhc3QgLSBmaXJzdCArIDE7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciB1ID0gdVByaW1lW2ldLFxuXHRcdFx0XHR0ID0gMSAtIHUsXG5cdFx0XHRcdGIgPSAzICogdSAqIHQsXG5cdFx0XHRcdGIwID0gdCAqIHQgKiB0LFxuXHRcdFx0XHRiMSA9IGIgKiB0LFxuXHRcdFx0XHRiMiA9IGIgKiB1LFxuXHRcdFx0XHRiMyA9IHUgKiB1ICogdSxcblx0XHRcdFx0YTEgPSB0YW4xLm5vcm1hbGl6ZShiMSksXG5cdFx0XHRcdGEyID0gdGFuMi5ub3JtYWxpemUoYjIpLFxuXHRcdFx0XHR0bXAgPSB0aGlzLnBvaW50c1tmaXJzdCArIGldXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHB0MS5tdWx0aXBseShiMCArIGIxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QocHQyLm11bHRpcGx5KGIyICsgYjMpKTtcblx0XHRcdENbMF1bMF0gKz0gYTEuZG90KGExKTtcblx0XHRcdENbMF1bMV0gKz0gYTEuZG90KGEyKTtcblx0XHRcdENbMV1bMF0gPSBDWzBdWzFdO1xuXHRcdFx0Q1sxXVsxXSArPSBhMi5kb3QoYTIpO1xuXHRcdFx0WFswXSArPSBhMS5kb3QodG1wKTtcblx0XHRcdFhbMV0gKz0gYTIuZG90KHRtcCk7XG5cdFx0fVxuXG5cdFx0dmFyIGRldEMwQzEgPSBDWzBdWzBdICogQ1sxXVsxXSAtIENbMV1bMF0gKiBDWzBdWzFdLFxuXHRcdFx0YWxwaGExLCBhbHBoYTI7XG5cdFx0aWYgKE1hdGguYWJzKGRldEMwQzEpID4gZXBzaWxvbikge1xuXHRcdFx0dmFyIGRldEMwWCAgPSBDWzBdWzBdICogWFsxXSAgICAtIENbMV1bMF0gKiBYWzBdLFxuXHRcdFx0XHRkZXRYQzEgID0gWFswXSAgICAqIENbMV1bMV0gLSBYWzFdICAgICogQ1swXVsxXTtcblx0XHRcdGFscGhhMSA9IGRldFhDMSAvIGRldEMwQzE7XG5cdFx0XHRhbHBoYTIgPSBkZXRDMFggLyBkZXRDMEMxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYzAgPSBDWzBdWzBdICsgQ1swXVsxXSxcblx0XHRcdFx0YzEgPSBDWzFdWzBdICsgQ1sxXVsxXTtcblx0XHRcdGlmIChNYXRoLmFicyhjMCkgPiBlcHNpbG9uKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IFhbMF0gLyBjMDtcblx0XHRcdH0gZWxzZSBpZiAoTWF0aC5hYnMoYzEpID4gZXBzaWxvbikge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBYWzFdIC8gYzE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBzZWdMZW5ndGggPSBwdDIuZ2V0RGlzdGFuY2UocHQxKTtcblx0XHRlcHNpbG9uICo9IHNlZ0xlbmd0aDtcblx0XHRpZiAoYWxwaGExIDwgZXBzaWxvbiB8fCBhbHBoYTIgPCBlcHNpbG9uKSB7XG5cdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuXHRcdH1cblxuXHRcdHJldHVybiBbcHQxLCBwdDEuYWRkKHRhbjEubm9ybWFsaXplKGFscGhhMSkpLFxuXHRcdFx0XHRwdDIuYWRkKHRhbjIubm9ybWFsaXplKGFscGhhMikpLCBwdDJdO1xuXHR9LFxuXG5cdHJlcGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdSwgY3VydmUpIHtcblx0XHRmb3IgKHZhciBpID0gZmlyc3Q7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB0aGlzLmZpbmRSb290KGN1cnZlLCB0aGlzLnBvaW50c1tpXSwgdVtpIC0gZmlyc3RdKTtcblx0XHR9XG5cdH0sXG5cblx0ZmluZFJvb3Q6IGZ1bmN0aW9uKGN1cnZlLCBwb2ludCwgdSkge1xuXHRcdHZhciBjdXJ2ZTEgPSBbXSxcblx0XHRcdGN1cnZlMiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDI7IGkrKykge1xuXHRcdFx0Y3VydmUxW2ldID0gY3VydmVbaSArIDFdLnN1YnRyYWN0KGN1cnZlW2ldKS5tdWx0aXBseSgzKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTJbaV0gPSBjdXJ2ZTFbaSArIDFdLnN1YnRyYWN0KGN1cnZlMVtpXSkubXVsdGlwbHkoMik7XG5cdFx0fVxuXHRcdHZhciBwdCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHUpLFxuXHRcdFx0cHQxID0gdGhpcy5ldmFsdWF0ZSgyLCBjdXJ2ZTEsIHUpLFxuXHRcdFx0cHQyID0gdGhpcy5ldmFsdWF0ZSgxLCBjdXJ2ZTIsIHUpLFxuXHRcdFx0ZGlmZiA9IHB0LnN1YnRyYWN0KHBvaW50KSxcblx0XHRcdGRmID0gcHQxLmRvdChwdDEpICsgZGlmZi5kb3QocHQyKTtcblx0XHRpZiAoTWF0aC5hYnMoZGYpIDwgMC4wMDAwMSlcblx0XHRcdHJldHVybiB1O1xuXHRcdHJldHVybiB1IC0gZGlmZi5kb3QocHQxKSAvIGRmO1xuXHR9LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbihkZWdyZWUsIGN1cnZlLCB0KSB7XG5cdFx0dmFyIHRtcCA9IGN1cnZlLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZSAtIGk7IGorKykge1xuXHRcdFx0XHR0bXBbal0gPSB0bXBbal0ubXVsdGlwbHkoMSAtIHQpLmFkZCh0bXBbaiArIDFdLm11bHRpcGx5KHQpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRtcFswXTtcblx0fSxcblxuXHRjaG9yZExlbmd0aFBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QpIHtcblx0XHR2YXIgdSA9IFswXTtcblx0XHRmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdVtpIC0gZmlyc3QgLSAxXVxuXHRcdFx0XHRcdCsgdGhpcy5wb2ludHNbaV0uZ2V0RGlzdGFuY2UodGhpcy5wb2ludHNbaSAtIDFdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDEsIG0gPSBsYXN0IC0gZmlyc3Q7IGkgPD0gbTsgaSsrKSB7XG5cdFx0XHR1W2ldIC89IHVbbV07XG5cdFx0fVxuXHRcdHJldHVybiB1O1xuXHR9LFxuXG5cdGZpbmRNYXhFcnJvcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIGN1cnZlLCB1KSB7XG5cdFx0dmFyIGluZGV4ID0gTWF0aC5mbG9vcigobGFzdCAtIGZpcnN0ICsgMSkgLyAyKSxcblx0XHRcdG1heERpc3QgPSAwO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcblx0XHRcdHZhciBQID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdVtpIC0gZmlyc3RdKTtcblx0XHRcdHZhciB2ID0gUC5zdWJ0cmFjdCh0aGlzLnBvaW50c1tpXSk7XG5cdFx0XHR2YXIgZGlzdCA9IHYueCAqIHYueCArIHYueSAqIHYueTsgXG5cdFx0XHRpZiAoZGlzdCA+PSBtYXhEaXN0KSB7XG5cdFx0XHRcdG1heERpc3QgPSBkaXN0O1xuXHRcdFx0XHRpbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRlcnJvcjogbWF4RGlzdCxcblx0XHRcdGluZGV4OiBpbmRleFxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgVGV4dEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1RleHRJdGVtJyxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y29udGVudDogbnVsbFxuXHR9LFxuXHRfYm91bmRzR2V0dGVyOiAnZ2V0Qm91bmRzJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUZXh0SXRlbShhcmcpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJyc7XG5cdFx0dGhpcy5fbGluZXMgPSBbXTtcblx0XHR2YXIgaGFzUHJvcHMgPSBhcmcgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZylcblx0XHRcdFx0JiYgYXJnLnggPT09IHVuZGVmaW5lZCAmJiBhcmcueSA9PT0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2luaXRpYWxpemUoaGFzUHJvcHMgJiYgYXJnLCAhaGFzUHJvcHMgJiYgUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQgPT09IGl0ZW0uX2NvbnRlbnQ7XG5cdH0sXG5cblx0X2Nsb25lOiBmdW5jdGlvbiBfY2xvbmUoY29weSkge1xuXHRcdGNvcHkuc2V0Q29udGVudCh0aGlzLl9jb250ZW50KTtcblx0XHRyZXR1cm4gX2Nsb25lLmJhc2UuY2FsbCh0aGlzLCBjb3B5KTtcblx0fSxcblxuXHRnZXRDb250ZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcblx0fSxcblxuXHRzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnICsgY29udGVudDtcblx0XHR0aGlzLl9saW5lcyA9IHRoaXMuX2NvbnRlbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL21nKTtcblx0XHR0aGlzLl9jaGFuZ2VkKDI2NSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdGdldENoYXJhY3RlclN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0Q2hhcmFjdGVyU3R5bGU6ICcjc2V0U3R5bGUnLFxuXG5cdGdldFBhcmFncmFwaFN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0UGFyYWdyYXBoU3R5bGU6ICcjc2V0U3R5bGUnXG59KTtcblxudmFyIFBvaW50VGV4dCA9IFRleHRJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BvaW50VGV4dCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnRUZXh0KCkge1xuXHRcdFRleHRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShuZXcgUG9pbnRUZXh0KEl0ZW0uTk9fSU5TRVJUKSwgaW5zZXJ0KTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChwb2ludC54LCBwb2ludC55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMudHJhbnNsYXRlKHBvaW50LnN1YnRyYWN0KHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpKSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5fY29udGVudClcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGxpbmVzID0gdGhpcy5fbGluZXMsXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBjdHguc2hhZG93Q29sb3I7XG5cdFx0Y3R4LmZvbnQgPSBzdHlsZS5nZXRGb250U3R5bGUoKTtcblx0XHRjdHgudGV4dEFsaWduID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcjtcblx0XHRcdHZhciBsaW5lID0gbGluZXNbaV07XG5cdFx0XHRpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0XHRjdHguc3Ryb2tlVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdGN0eC50cmFuc2xhdGUoMCwgbGVhZGluZyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0bnVtTGluZXMgPSBsaW5lcy5sZW5ndGgsXG5cdFx0XHRqdXN0aWZpY2F0aW9uID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpLFxuXHRcdFx0bGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcblx0XHRcdHdpZHRoID0gdGhpcy5nZXRWaWV3KCkuZ2V0VGV4dFdpZHRoKHN0eWxlLmdldEZvbnRTdHlsZSgpLCBsaW5lcyksXG5cdFx0XHR4ID0gMDtcblx0XHRpZiAoanVzdGlmaWNhdGlvbiAhPT0gJ2xlZnQnKVxuXHRcdFx0eCAtPSB3aWR0aCAvIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJyA/IDI6IDEpO1xuXHRcdHZhciBib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKHgsXG5cdFx0XHRcdFx0bnVtTGluZXMgPyAtIDAuNzUgKiBsZWFkaW5nIDogMCxcblx0XHRcdFx0XHR3aWR0aCwgbnVtTGluZXMgKiBsZWFkaW5nKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMoYm91bmRzLCBib3VuZHMpIDogYm91bmRzO1xuXHR9XG59KTtcblxudmFyIENvbG9yID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciB0eXBlcyA9IHtcblx0XHRncmF5OiBbJ2dyYXknXSxcblx0XHRyZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcblx0XHRoc2I6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnYnJpZ2h0bmVzcyddLFxuXHRcdGhzbDogWydodWUnLCAnc2F0dXJhdGlvbicsICdsaWdodG5lc3MnXSxcblx0XHRncmFkaWVudDogWydncmFkaWVudCcsICdvcmlnaW4nLCAnZGVzdGluYXRpb24nLCAnaGlnaGxpZ2h0J11cblx0fTtcblxuXHR2YXIgY29tcG9uZW50UGFyc2VycyA9IHt9LFxuXHRcdGNvbG9yQ2FjaGUgPSB7fSxcblx0XHRjb2xvckN0eDtcblxuXHRmdW5jdGlvbiBmcm9tQ1NTKHN0cmluZykge1xuXHRcdHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiMoXFx3ezEsMn0pKFxcd3sxLDJ9KShcXHd7MSwyfSkkLyksXG5cdFx0XHRjb21wb25lbnRzO1xuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0Y29tcG9uZW50cyA9IFswLCAwLCAwXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IG1hdGNoW2kgKyAxXTtcblx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHBhcnNlSW50KHZhbHVlLmxlbmd0aCA9PSAxXG5cdFx0XHRcdFx0XHQ/IHZhbHVlICsgdmFsdWUgOiB2YWx1ZSwgMTYpIC8gMjU1O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL15yZ2JhP1xcKCguKilcXCkkLykpIHtcblx0XHRcdGNvbXBvbmVudHMgPSBtYXRjaFsxXS5zcGxpdCgnLCcpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSArY29tcG9uZW50c1tpXTtcblx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IGkgPCAzID8gdmFsdWUgLyAyNTUgOiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGVbc3RyaW5nXTtcblx0XHRcdGlmICghY2FjaGVkKSB7XG5cdFx0XHRcdGlmICghY29sb3JDdHgpIHtcblx0XHRcdFx0XHRjb2xvckN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdFx0XHRcdFx0Y29sb3JDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gc3RyaW5nO1xuXHRcdFx0XHRjb2xvckN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdFx0dmFyIGRhdGEgPSBjb2xvckN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YTtcblx0XHRcdFx0Y2FjaGVkID0gY29sb3JDYWNoZVtzdHJpbmddID0gW1xuXHRcdFx0XHRcdGRhdGFbMF0gLyAyNTUsXG5cdFx0XHRcdFx0ZGF0YVsxXSAvIDI1NSxcblx0XHRcdFx0XHRkYXRhWzJdIC8gMjU1XG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRjb21wb25lbnRzID0gY2FjaGVkLnNsaWNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBjb21wb25lbnRzO1xuXHR9XG5cblx0dmFyIGhzYkluZGljZXMgPSBbXG5cdFx0WzAsIDMsIDFdLCBcblx0XHRbMiwgMCwgMV0sIFxuXHRcdFsxLCAwLCAzXSwgXG5cdFx0WzEsIDIsIDBdLCBcblx0XHRbMywgMSwgMF0sIFxuXHRcdFswLCAxLCAyXSAgXG5cdF07XG5cblx0dmFyIGNvbnZlcnRlcnMgPSB7XG5cdFx0J3JnYi1oc2InOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuXHRcdFx0XHRkZWx0YSA9IG1heCAtIG1pbixcblx0XHRcdFx0aCA9IGRlbHRhID09PSAwID8gMFxuXHRcdFx0XHRcdDogICAoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0OiAgICAgICAgICAgIChyIC0gZykgLyBkZWx0YSArIDQpICogNjA7IFxuXHRcdFx0cmV0dXJuIFtoLCBtYXggPT09IDAgPyAwIDogZGVsdGEgLyBtYXgsIG1heF07XG5cdFx0fSxcblxuXHRcdCdoc2ItcmdiJzogZnVuY3Rpb24oaCwgcywgYikge1xuXHRcdFx0aCA9ICgoKGggLyA2MCkgJSA2KSArIDYpICUgNjtcblx0XHRcdHZhciBpID0gTWF0aC5mbG9vcihoKSwgXG5cdFx0XHRcdGYgPSBoIC0gaSxcblx0XHRcdFx0aSA9IGhzYkluZGljZXNbaV0sXG5cdFx0XHRcdHYgPSBbXG5cdFx0XHRcdFx0YixcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRiICogKDEgLSBzKSxcdFx0XHRcblx0XHRcdFx0XHRiICogKDEgLSBzICogZiksXHRcdFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiAoMSAtIGYpKVx0XG5cdFx0XHRcdF07XG5cdFx0XHRyZXR1cm4gW3ZbaVswXV0sIHZbaVsxXV0sIHZbaVsyXV1dO1xuXHRcdH0sXG5cblx0XHQncmdiLWhzbCc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRhY2hyb21hdGljID0gZGVsdGEgPT09IDAsXG5cdFx0XHRcdGggPSBhY2hyb21hdGljID8gMFxuXHRcdFx0XHRcdDogICAoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0OiAgICAgICAgICAgIChyIC0gZykgLyBkZWx0YSArIDQpICogNjAsIFxuXHRcdFx0XHRsID0gKG1heCArIG1pbikgLyAyLFxuXHRcdFx0XHRzID0gYWNocm9tYXRpYyA/IDAgOiBsIDwgMC41XG5cdFx0XHRcdFx0XHQ/IGRlbHRhIC8gKG1heCArIG1pbilcblx0XHRcdFx0XHRcdDogZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdFx0XHRyZXR1cm4gW2gsIHMsIGxdO1xuXHRcdH0sXG5cblx0XHQnaHNsLXJnYic6IGZ1bmN0aW9uKGgsIHMsIGwpIHtcblx0XHRcdGggPSAoKChoIC8gMzYwKSAlIDEpICsgMSkgJSAxO1xuXHRcdFx0aWYgKHMgPT09IDApXG5cdFx0XHRcdHJldHVybiBbbCwgbCwgbF07XG5cdFx0XHR2YXIgdDNzID0gWyBoICsgMSAvIDMsIGgsIGggLSAxIC8gMyBdLFxuXHRcdFx0XHR0MiA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHMsXG5cdFx0XHRcdHQxID0gMiAqIGwgLSB0Mixcblx0XHRcdFx0YyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0dmFyIHQzID0gdDNzW2ldO1xuXHRcdFx0XHRpZiAodDMgPCAwKSB0MyArPSAxO1xuXHRcdFx0XHRpZiAodDMgPiAxKSB0MyAtPSAxO1xuXHRcdFx0XHRjW2ldID0gNiAqIHQzIDwgMVxuXHRcdFx0XHRcdD8gdDEgKyAodDIgLSB0MSkgKiA2ICogdDNcblx0XHRcdFx0XHQ6IDIgKiB0MyA8IDFcblx0XHRcdFx0XHRcdD8gdDJcblx0XHRcdFx0XHRcdDogMyAqIHQzIDwgMlxuXHRcdFx0XHRcdFx0XHQ/IHQxICsgKHQyIC0gdDEpICogKCgyIC8gMykgLSB0MykgKiA2XG5cdFx0XHRcdFx0XHRcdDogdDE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYztcblx0XHR9LFxuXG5cdFx0J3JnYi1ncmF5JzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0cmV0dXJuIFtyICogMC4yOTg5ICsgZyAqIDAuNTg3ICsgYiAqIDAuMTE0XTtcblx0XHR9LFxuXG5cdFx0J2dyYXktcmdiJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFtnLCBnLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYXktaHNiJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFswLCAwLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYXktaHNsJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFswLCAwLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYWRpZW50LXJnYic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH0sXG5cblx0XHQncmdiLWdyYWRpZW50JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdH07XG5cblx0cmV0dXJuIEJhc2UuZWFjaCh0eXBlcywgZnVuY3Rpb24ocHJvcGVydGllcywgdHlwZSkge1xuXHRcdGNvbXBvbmVudFBhcnNlcnNbdHlwZV0gPSBbXTtcblx0XHRCYXNlLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcblx0XHRcdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0XHRoYXNPdmVybGFwID0gL14oaHVlfHNhdHVyYXRpb24pJC8udGVzdChuYW1lKSxcblx0XHRcdFx0cGFyc2VyID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXVtpbmRleF0gPSBuYW1lID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0PyBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb21wb25lbnRzWzBdO1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBHcmFkaWVudC5yZWFkKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVcblx0XHRcdFx0XHRcdFx0XHQ6IGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50ICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudClcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50Ll9yZW1vdmVPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlLl9hZGRPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0OiB0eXBlID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHQ/IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWROdWxsOiBuYW1lID09PSAnaGlnaGxpZ2h0Jyxcblx0XHRcdFx0XHRcdFx0XHRcdGNsb25lOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAwIDogdmFsdWU7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHR8fCBoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzW2luZGV4XVxuXHRcdFx0XHRcdFx0OiB0aGlzLl9jb252ZXJ0KHR5cGUpW2luZGV4XTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh0aGlzLl90eXBlICE9PSB0eXBlXG5cdFx0XHRcdFx0XHQmJiAhKGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpKSkge1xuXHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LCB0aGlzKTtcblx0fSwge1xuXHRcdF9jbGFzczogJ0NvbG9yJyxcblx0XHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29sb3IoYXJnKSB7XG5cdFx0XHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHJlYWQgPSAwLFxuXHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRjb21wb25lbnRzLFxuXHRcdFx0XHRhbHBoYSxcblx0XHRcdFx0dmFsdWVzO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRhcmdzID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzBdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGFyZ1R5cGUgPSBhcmcgIT0gbnVsbCAmJiB0eXBlb2YgYXJnO1xuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnICYmIGFyZyBpbiB0eXBlcykge1xuXHRcdFx0XHR0eXBlID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzFdO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZztcblx0XHRcdFx0XHRhbHBoYSA9IGFyZ3NbMl07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdFx0cmVhZCA9IDE7IFxuXHRcdFx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3MsIDEpO1xuXHRcdFx0XHRcdGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbXBvbmVudHMpIHtcblx0XHRcdFx0dmFsdWVzID0gYXJnVHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHRcdD8gYXJnc1xuXHRcdFx0XHRcdFx0OiBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBhcmdcblx0XHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdFx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRcdFx0aWYgKCF0eXBlKVxuXHRcdFx0XHRcdFx0dHlwZSA9IHZhbHVlcy5sZW5ndGggPj0gM1xuXHRcdFx0XHRcdFx0XHRcdD8gJ3JnYidcblx0XHRcdFx0XHRcdFx0XHQ6ICdncmF5Jztcblx0XHRcdFx0XHR2YXIgbGVuZ3RoID0gdHlwZXNbdHlwZV0ubGVuZ3RoO1xuXHRcdFx0XHRcdGFscGhhID0gdmFsdWVzW2xlbmd0aF07XG5cdFx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdFx0cmVhZCArPSB2YWx1ZXMgPT09IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHQ/IGxlbmd0aCArIChhbHBoYSAhPSBudWxsID8gMSA6IDApXG5cdFx0XHRcdFx0XHRcdDogMTtcblx0XHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA+IGxlbmd0aClcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHNsaWNlLmNhbGwodmFsdWVzLCAwLCBsZW5ndGgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dHlwZSA9ICdyZ2InO1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBmcm9tQ1NTKGFyZyk7XG5cdFx0XHRcdFx0aWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSA0KSB7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGNvbXBvbmVudHNbM107XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzLmxlbmd0aC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGlmIChhcmcuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gYXJnLl90eXBlO1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBhcmcuX2FscGhhO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gR3JhZGllbnQpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSAnZ3JhZGllbnQnO1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gYXJncztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdodWUnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHQ/ICdsaWdodG5lc3MnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2hzbCdcblx0XHRcdFx0XHRcdFx0XHQ6ICdoc2InXG5cdFx0XHRcdFx0XHRcdDogJ2dyYWRpZW50JyBpbiBhcmcgfHwgJ3N0b3BzJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHRcdHx8ICdyYWRpYWwnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyAnZ3JheSdcblx0XHRcdFx0XHRcdFx0XHRcdDogJ3JnYic7XG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0XHRcdFx0XHRwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXTtcblx0XHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IGFyZ1twcm9wZXJ0aWVzW2ldXTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID09IG51bGwgJiYgaSA9PT0gMCAmJiB0eXBlID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0XHQmJiAnc3RvcHMnIGluIGFyZykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RvcHM6IGFyZy5zdG9wcyxcblx0XHRcdFx0XHRcdFx0XHRcdHJhZGlhbDogYXJnLnJhZGlhbFxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5hbHBoYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkICYmIHR5cGUpXG5cdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwZSB8fCAncmdiJztcblx0XHRcdGlmICh0eXBlID09PSAnZ3JhZGllbnQnKVxuXHRcdFx0XHR0aGlzLl9pZCA9IENvbG9yLl9pZCA9IChDb2xvci5faWQgfHwgMCkgKyAxO1xuXHRcdFx0aWYgKCFjb21wb25lbnRzKSB7XG5cdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdHZhciBwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0aGlzLl90eXBlXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZXMgJiYgdmFsdWVzW2ldKTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG5cdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdGhpcy5fdHlwZV07XG5cdFx0XHR0aGlzLl9hbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdFx0fSxcblxuXHRcdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzKCk7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoXG5cdFx0XHRcdFx0L14oZ3JheXxyZ2IpJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyBjb21wb25lbnRzXG5cdFx0XHRcdFx0XHQ6IFt0aGlzLl90eXBlXS5jb25jYXQoY29tcG9uZW50cyksXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSxcblxuXHRcdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2NhbnZhc1N0eWxlID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoNjUpO1xuXHRcdH0sXG5cblx0XHRfY29udmVydDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGNvbnZlcnRlcjtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG5cdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzLnNsaWNlKClcblx0XHRcdFx0XHQ6IChjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLScgKyB0eXBlXSlcblx0XHRcdFx0XHRcdD8gY29udmVydGVyLmFwcGx5KHRoaXMsIHRoaXMuX2NvbXBvbmVudHMpXG5cdFx0XHRcdFx0XHQ6IGNvbnZlcnRlcnNbJ3JnYi0nICsgdHlwZV0uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1t0aGlzLl90eXBlICsgJy1yZ2InXS5hcHBseSh0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMpKTtcblx0XHR9LFxuXG5cdFx0Y29udmVydDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0eXBlLCB0aGlzLl9jb252ZXJ0KHR5cGUpLCB0aGlzLl9hbHBoYSk7XG5cdFx0fSxcblxuXHRcdGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdFx0fSxcblxuXHRcdHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0fSxcblxuXHRcdGdldENvbXBvbmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cdFx0XHRpZiAodGhpcy5fYWxwaGEgIT0gbnVsbClcblx0XHRcdFx0Y29tcG9uZW50cy5wdXNoKHRoaXMuX2FscGhhKTtcblx0XHRcdHJldHVybiBjb21wb25lbnRzO1xuXHRcdH0sXG5cblx0XHRnZXRBbHBoYTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbCA/IHRoaXMuX2FscGhhIDogMTtcblx0XHR9LFxuXG5cdFx0c2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG5cdFx0XHR0aGlzLl9hbHBoYSA9IGFscGhhID09IG51bGwgPyBudWxsIDogTWF0aC5taW4oTWF0aC5tYXgoYWxwaGEsIDApLCAxKTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHR9LFxuXG5cdFx0aGFzQWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGw7XG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24oY29sb3IpIHtcblx0XHRcdHZhciBjb2wgPSBCYXNlLmlzUGxhaW5WYWx1ZShjb2xvcilcblx0XHRcdFx0XHQ/IENvbG9yLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHRcdDogY29sb3I7XG5cdFx0XHRyZXR1cm4gY29sID09PSB0aGlzIHx8IGNvbCAmJiB0aGlzLl9jbGFzcyA9PT0gY29sLl9jbGFzc1xuXHRcdFx0XHRcdCYmIHRoaXMuX3R5cGUgPT09IGNvbC5fdHlwZVxuXHRcdFx0XHRcdCYmIHRoaXMuX2FscGhhID09PSBjb2wuX2FscGhhXG5cdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fY29tcG9uZW50cywgY29sLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdHx8IGZhbHNlO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcGVydGllcyA9IHRoaXMuX3Byb3BlcnRpZXMsXG5cdFx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRcdGlzR3JhZGllbnQgPSB0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnLFxuXHRcdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl9jb21wb25lbnRzW2ldO1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKHByb3BlcnRpZXNbaV0gKyAnOiAnXG5cdFx0XHRcdFx0XHRcdCsgKGlzR3JhZGllbnQgPyB2YWx1ZSA6IGYubnVtYmVyKHZhbHVlKSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdHBhcnRzLnB1c2goJ2FscGhhOiAnICsgZi5udW1iZXIodGhpcy5fYWxwaGEpKTtcblx0XHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdFx0fSxcblxuXHRcdHRvQ1NTOiBmdW5jdGlvbihoZXgpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29udmVydCgncmdiJyksXG5cdFx0XHRcdGFscGhhID0gaGV4IHx8IHRoaXMuX2FscGhhID09IG51bGwgPyAxIDogdGhpcy5fYWxwaGE7XG5cdFx0XHRmdW5jdGlvbiBjb252ZXJ0KHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCgodmFsIDwgMCA/IDAgOiB2YWwgPiAxID8gMSA6IHZhbCkgKiAyNTUpO1xuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IFtcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzBdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzFdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzJdKVxuXHRcdFx0XTtcblx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaChhbHBoYSA8IDAgPyAwIDogYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGhleFxuXHRcdFx0XHRcdD8gJyMnICsgKCgxIDw8IDI0KSArIChjb21wb25lbnRzWzBdIDw8IDE2KVxuXHRcdFx0XHRcdFx0KyAoY29tcG9uZW50c1sxXSA8PCA4KVxuXHRcdFx0XHRcdFx0KyBjb21wb25lbnRzWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSlcblx0XHRcdFx0XHQ6IChjb21wb25lbnRzLmxlbmd0aCA9PSA0ID8gJ3JnYmEoJyA6ICdyZ2IoJylcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50cy5qb2luKCcsJykgKyAnKSc7XG5cdFx0fSxcblxuXHRcdHRvQ2FudmFzU3R5bGU6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0aWYgKHRoaXMuX2NhbnZhc1N0eWxlKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGU7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gJ2dyYWRpZW50Jylcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gdGhpcy50b0NTUygpO1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRncmFkaWVudCA9IGNvbXBvbmVudHNbMF0sXG5cdFx0XHRcdHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzLFxuXHRcdFx0XHRvcmlnaW4gPSBjb21wb25lbnRzWzFdLFxuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGNvbXBvbmVudHNbMl0sXG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50O1xuXHRcdFx0aWYgKGdyYWRpZW50Ll9yYWRpYWwpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IGRlc3RpbmF0aW9uLmdldERpc3RhbmNlKG9yaWdpbiksXG5cdFx0XHRcdFx0aGlnaGxpZ2h0ID0gY29tcG9uZW50c1szXTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdHZhciB2ZWN0b3IgPSBoaWdobGlnaHQuc3VidHJhY3Qob3JpZ2luKTtcblx0XHRcdFx0XHRpZiAodmVjdG9yLmdldExlbmd0aCgpID4gcmFkaXVzKVxuXHRcdFx0XHRcdFx0aGlnaGxpZ2h0ID0gb3JpZ2luLmFkZCh2ZWN0b3Iubm9ybWFsaXplKHJhZGl1cyAtIDAuMSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzdGFydCA9IGhpZ2hsaWdodCB8fCBvcmlnaW47XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksXG5cdFx0XHRcdFx0XHQwLCBvcmlnaW4ueCwgb3JpZ2luLnksIHJhZGl1cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChvcmlnaW4ueCwgb3JpZ2luLnksXG5cdFx0XHRcdFx0XHRkZXN0aW5hdGlvbi54LCBkZXN0aW5hdGlvbi55KTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzdG9wID0gc3RvcHNbaV07XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLl9yYW1wUG9pbnQsXG5cdFx0XHRcdFx0XHRzdG9wLl9jb2xvci50b0NhbnZhc1N0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gY2FudmFzR3JhZGllbnQ7XG5cdFx0fSxcblxuXHRcdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50LCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdF90eXBlczogdHlwZXMsXG5cblx0XHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblx0XHRcdFx0cmV0dXJuIG5ldyBDb2xvcihyYW5kb20oKSwgcmFuZG9tKCksIHJhbmRvbSgpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdGFkZDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKyBiO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdH0sXG5cblx0XHRtdWx0aXBseTogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKiBiO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC8gYjtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIEJhc2UuZWFjaChvcGVyYXRvcnMsIGZ1bmN0aW9uKG9wZXJhdG9yLCBuYW1lKSB7XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0Y29tcG9uZW50czEgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRjb21wb25lbnRzMiA9IGNvbG9yLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb21wb25lbnRzMS5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNvbXBvbmVudHMyW2ldID0gb3BlcmF0b3IoY29tcG9uZW50czFbaV0sIGNvbXBvbmVudHMyW2ldKTtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50czIsXG5cdFx0XHRcdFx0dGhpcy5fYWxwaGEgIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IG9wZXJhdG9yKHRoaXMuX2FscGhhLCBjb2xvci5nZXRBbHBoYSgpKVxuXHRcdFx0XHRcdFx0XHQ6IG51bGwpO1xuXHRcdH07XG5cdH0sIHtcblx0fSk7XG59KTtcblxuQmFzZS5lYWNoKENvbG9yLl90eXBlcywgZnVuY3Rpb24ocHJvcGVydGllcywgdHlwZSkge1xuXHR2YXIgY3RvciA9IHRoaXNbQmFzZS5jYXBpdGFsaXplKHR5cGUpICsgJ0NvbG9yJ10gPSBmdW5jdGlvbihhcmcpIHtcblx0XHRcdHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZyxcblx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuXHRcdFx0XHRcdD8gYXJnXG5cdFx0XHRcdFx0OiBhcmdUeXBlID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0XHQ6IGFyZ3VtZW50cztcblx0XHRcdHJldHVybiBjb21wb25lbnRzXG5cdFx0XHRcdFx0PyBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50cylcblx0XHRcdFx0XHQ6IG5ldyBDb2xvcihhcmcpO1xuXHRcdH07XG5cdGlmICh0eXBlLmxlbmd0aCA9PSAzKSB7XG5cdFx0dmFyIGFjcm9ueW0gPSB0eXBlLnRvVXBwZXJDYXNlKCk7XG5cdFx0Q29sb3JbYWNyb255bV0gPSB0aGlzW2Fjcm9ueW0gKyAnQ29sb3InXSA9IGN0b3I7XG5cdH1cbn0sIEJhc2UuZXhwb3J0cyk7XG5cbnZhciBHcmFkaWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JhZGllbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50KHN0b3BzLCByYWRpYWwpIHtcblx0XHR0aGlzLl9pZCA9IEdyYWRpZW50Ll9pZCA9IChHcmFkaWVudC5faWQgfHwgMCkgKyAxO1xuXHRcdGlmIChzdG9wcyAmJiB0aGlzLl9zZXQoc3RvcHMpKVxuXHRcdFx0c3RvcHMgPSByYWRpYWwgPSBudWxsO1xuXHRcdGlmICghdGhpcy5fc3RvcHMpXG5cdFx0XHR0aGlzLnNldFN0b3BzKHN0b3BzIHx8IFsnd2hpdGUnLCAnYmxhY2snXSk7XG5cdFx0aWYgKHRoaXMuX3JhZGlhbCA9PSBudWxsKVxuXHRcdFx0dGhpcy5zZXRSYWRpYWwodHlwZW9mIHJhZGlhbCA9PT0gJ3N0cmluZycgJiYgcmFkaWFsID09PSAncmFkaWFsJ1xuXHRcdFx0XHRcdHx8IHJhZGlhbCB8fCBmYWxzZSk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fc3RvcHMsIHRoaXMuX3JhZGlhbF0sXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fb3duZXJzICYmIHRoaXMuX293bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9vd25lcnNbaV0uX2NoYW5nZWQoKTtcblx0fSxcblxuXHRfYWRkT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0aWYgKCF0aGlzLl9vd25lcnMpXG5cdFx0XHR0aGlzLl9vd25lcnMgPSBbXTtcblx0XHR0aGlzLl9vd25lcnMucHVzaChjb2xvcik7XG5cdH0sXG5cblx0X3JlbW92ZU93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX293bmVycyA/IHRoaXMuX293bmVycy5pbmRleE9mKGNvbG9yKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdFx0dGhpcy5fb3duZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRpZiAodGhpcy5fb3duZXJzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0dGhpcy5fb3duZXJzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN0b3BzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzdG9wc1tpXSA9IHRoaXMuX3N0b3BzW2ldLmNsb25lKCk7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudChzdG9wcyk7XG5cdH0sXG5cblx0Z2V0U3RvcHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdG9wcztcblx0fSxcblxuXHRzZXRTdG9wczogZnVuY3Rpb24oc3RvcHMpIHtcblx0XHRpZiAodGhpcy5zdG9wcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX3N0b3BzW2ldLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKHN0b3BzLmxlbmd0aCA8IDIpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J0dyYWRpZW50IHN0b3AgbGlzdCBuZWVkcyB0byBjb250YWluIGF0IGxlYXN0IHR3byBzdG9wcy4nKTtcblx0XHR0aGlzLl9zdG9wcyA9IEdyYWRpZW50U3RvcC5yZWFkQWxsKHN0b3BzLCAwLCB7IGNsb25lOiB0cnVlIH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc3RvcCA9IHRoaXMuX3N0b3BzW2ldO1xuXHRcdFx0c3RvcC5fb3duZXIgPSB0aGlzO1xuXHRcdFx0aWYgKHN0b3AuX2RlZmF1bHRSYW1wKVxuXHRcdFx0XHRzdG9wLnNldFJhbXBQb2ludChpIC8gKGwgLSAxKSk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRSYWRpYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpYWw7XG5cdH0sXG5cblx0c2V0UmFkaWFsOiBmdW5jdGlvbihyYWRpYWwpIHtcblx0XHR0aGlzLl9yYWRpYWwgPSByYWRpYWw7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oZ3JhZGllbnQpIHtcblx0XHRpZiAoZ3JhZGllbnQgPT09IHRoaXMpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZiAoZ3JhZGllbnQgJiYgIHRoaXMuX2NsYXNzID09PSBncmFkaWVudC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fc3RvcHMubGVuZ3RoID09PSBncmFkaWVudC5fc3RvcHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3N0b3BzW2ldLmVxdWFscyhncmFkaWVudC5fc3RvcHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgR3JhZGllbnRTdG9wID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcmFkaWVudFN0b3AnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50U3RvcChhcmcwLCBhcmcxKSB7XG5cdFx0aWYgKGFyZzApIHtcblx0XHRcdHZhciBjb2xvciwgcmFtcFBvaW50O1xuXHRcdFx0aWYgKGFyZzEgPT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMFswXTtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMFsxXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5jb2xvcikge1xuXHRcdFx0XHRjb2xvciA9IGFyZzAuY29sb3I7XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzAucmFtcFBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRDb2xvcihjb2xvcik7XG5cdFx0XHR0aGlzLnNldFJhbXBQb2ludChyYW1wUG9pbnQpO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudFN0b3AodGhpcy5fY29sb3IuY2xvbmUoKSwgdGhpcy5fcmFtcFBvaW50KTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jb2xvciwgdGhpcy5fcmFtcFBvaW50XSwgb3B0aW9ucywgdHJ1ZSxcblx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0fSxcblxuXHRnZXRSYW1wUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYW1wUG9pbnQ7XG5cdH0sXG5cblx0c2V0UmFtcFBvaW50OiBmdW5jdGlvbihyYW1wUG9pbnQpIHtcblx0XHR0aGlzLl9kZWZhdWx0UmFtcCA9IHJhbXBQb2ludCA9PSBudWxsO1xuXHRcdHRoaXMuX3JhbXBQb2ludCA9IHJhbXBQb2ludCB8fCAwO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbG9yO1xuXHR9LFxuXG5cdHNldENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHRoaXMuX2NvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLl9jb2xvciA9PT0gY29sb3IpXG5cdFx0XHR0aGlzLl9jb2xvciA9IGNvbG9yLmNsb25lKCk7XG5cdFx0dGhpcy5fY29sb3IuX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdG9wKSB7XG5cdFx0cmV0dXJuIHN0b3AgPT09IHRoaXMgfHwgc3RvcCAmJiB0aGlzLl9jbGFzcyA9PT0gc3RvcC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fY29sb3IuZXF1YWxzKHN0b3AuX2NvbG9yKVxuXHRcdFx0XHQmJiB0aGlzLl9yYW1wUG9pbnQgPT0gc3RvcC5fcmFtcFBvaW50XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIFN0eWxlID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0ZmlsbENvbG9yOiB1bmRlZmluZWQsXG5cdFx0c3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRzdHJva2VXaWR0aDogMSxcblx0XHRzdHJva2VDYXA6ICdidXR0Jyxcblx0XHRzdHJva2VKb2luOiAnbWl0ZXInLFxuXHRcdG1pdGVyTGltaXQ6IDEwLFxuXHRcdGRhc2hPZmZzZXQ6IDAsXG5cdFx0ZGFzaEFycmF5OiBbXSxcblx0XHR3aW5kaW5nUnVsZTogJ25vbnplcm8nLFxuXHRcdHNoYWRvd0NvbG9yOiB1bmRlZmluZWQsXG5cdFx0c2hhZG93Qmx1cjogMCxcblx0XHRzaGFkb3dPZmZzZXQ6IG5ldyBQb2ludCgpLFxuXHRcdHNlbGVjdGVkQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG5cdFx0Zm9udFdlaWdodDogJ25vcm1hbCcsXG5cdFx0Zm9udFNpemU6IDEyLFxuXHRcdGZvbnQ6ICdzYW5zLXNlcmlmJywgXG5cdFx0bGVhZGluZzogbnVsbCxcblx0XHRqdXN0aWZpY2F0aW9uOiAnbGVmdCdcblx0fTtcblxuXHR2YXIgZmxhZ3MgPSB7XG5cdFx0c3Ryb2tlV2lkdGg6IDk3LFxuXHRcdHN0cm9rZUNhcDogOTcsXG5cdFx0c3Ryb2tlSm9pbjogOTcsXG5cdFx0bWl0ZXJMaW1pdDogOTcsXG5cdFx0Zm9udEZhbWlseTogOSxcblx0XHRmb250V2VpZ2h0OiA5LFxuXHRcdGZvbnRTaXplOiA5LFxuXHRcdGZvbnQ6IDksIFxuXHRcdGxlYWRpbmc6IDksXG5cdFx0anVzdGlmaWNhdGlvbjogOVxuXHR9O1xuXG5cdHZhciBpdGVtID0ge30sXG5cdFx0ZmllbGRzID0ge1xuXHRcdFx0X2RlZmF1bHRzOiBkZWZhdWx0cyxcblx0XHRcdF90ZXh0RGVmYXVsdHM6IG5ldyBCYXNlKGRlZmF1bHRzLCB7XG5cdFx0XHRcdGZpbGxDb2xvcjogbmV3IENvbG9yKCkgXG5cdFx0XHR9KSxcblx0XHRcdGJlYW5zOiB0cnVlXG5cdFx0fTtcblxuXHRCYXNlLmVhY2goZGVmYXVsdHMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgaXNDb2xvciA9IC9Db2xvciQvLnRlc3Qoa2V5KSxcblx0XHRcdHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRcdGZsYWcgPSBmbGFnc1trZXldLFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0O1xuXG5cdFx0ZmllbGRzW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuO1xuXHRcdFx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcblx0XHRcdFx0XHQmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRjaGlsZHJlbltpXS5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgb2xkID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmIChvbGQgIT0gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoaXNDb2xvcikge1xuXHRcdFx0XHRcdFx0aWYgKG9sZClcblx0XHRcdFx0XHRcdFx0b2xkLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlLl9vd25lcilcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlLl9vd25lciA9IG93bmVyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChvd25lcilcblx0XHRcdFx0XHRcdG93bmVyLl9jaGFuZ2VkKGZsYWcgfHwgNjUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZpZWxkc1tnZXRdID0gZnVuY3Rpb24oX2RvbnRNZXJnZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuLFxuXHRcdFx0XHR2YWx1ZTtcblx0XHRcdGlmICghY2hpbGRyZW4gfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IF9kb250TWVyZ2Vcblx0XHRcdFx0XHR8fCBvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXNba2V5XTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2RlZmF1bHRzW2tleV07XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmNsb25lKVxuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNDb2xvciAmJiAhKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBDb2xvcikpIHtcblx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlID0gQ29sb3IucmVhZChbdmFsdWVdLCAwLFxuXHRcdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlLCBjbG9uZTogdHJ1ZSB9KTtcblx0XHRcdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdFx0XHR2YWx1ZS5fb3duZXIgPSBvd25lcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGRWYWx1ZSA9IGNoaWxkcmVuW2ldLl9zdHlsZVtnZXRdKCk7XG5cdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjaGlsZFZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwgY2hpbGRWYWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblxuXHRcdGl0ZW1bZ2V0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0eWxlW2dldF0oKTtcblx0XHR9O1xuXG5cdFx0aXRlbVtzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdH07XG5cdH0pO1xuXG5cdEl0ZW0uaW5qZWN0KGl0ZW0pO1xuXHRyZXR1cm4gZmllbGRzO1xufSwge1xuXHRfY2xhc3M6ICdTdHlsZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3R5bGUoc3R5bGUsIF9vd25lciwgX3Byb2plY3QpIHtcblx0XHR0aGlzLl92YWx1ZXMgPSB7fTtcblx0XHR0aGlzLl9vd25lciA9IF9vd25lcjtcblx0XHR0aGlzLl9wcm9qZWN0ID0gX293bmVyICYmIF9vd25lci5fcHJvamVjdCB8fCBfcHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuXHRcdGlmIChfb3duZXIgaW5zdGFuY2VvZiBUZXh0SXRlbSlcblx0XHRcdHRoaXMuX2RlZmF1bHRzID0gdGhpcy5fdGV4dERlZmF1bHRzO1xuXHRcdGlmIChzdHlsZSlcblx0XHRcdHRoaXMuc2V0KHN0eWxlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dmFyIGlzU3R5bGUgPSBzdHlsZSBpbnN0YW5jZW9mIFN0eWxlLFxuXHRcdFx0dmFsdWVzID0gaXNTdHlsZSA/IHN0eWxlLl92YWx1ZXMgOiBzdHlsZTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHRyZXR1cm4gc3R5bGUgPT09IHRoaXMgfHwgc3R5bGUgJiYgdGhpcy5fY2xhc3MgPT09IHN0eWxlLl9jbGFzc1xuXHRcdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl92YWx1ZXMsIHN0eWxlLl92YWx1ZXMpXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0RmlsbENvbG9yKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldFN0cm9rZUNvbG9yKCkgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0U2hhZG93Q29sb3IoKSAmJiB0aGlzLmdldFNoYWRvd0JsdXIoKSA+IDA7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdGdldEZvbnRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdHJldHVybiB0aGlzLmdldEZvbnRXZWlnaHQoKVxuXHRcdFx0XHQrICcgJyArIGZvbnRTaXplICsgKC9bYS16XS9pLnRlc3QoZm9udFNpemUgKyAnJykgPyAnICcgOiAncHggJylcblx0XHRcdFx0KyB0aGlzLmdldEZvbnRGYW1pbHkoKTtcblx0fSxcblxuXHRnZXRGb250OiAnI2dldEZvbnRGYW1pbHknLFxuXHRzZXRGb250OiAnI3NldEZvbnRGYW1pbHknLFxuXG5cdGdldExlYWRpbmc6IGZ1bmN0aW9uIGdldExlYWRpbmcoKSB7XG5cdFx0dmFyIGxlYWRpbmcgPSBnZXRMZWFkaW5nLmJhc2UuY2FsbCh0aGlzKSxcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdGlmICgvcHR8ZW18JXxweC8udGVzdChmb250U2l6ZSkpXG5cdFx0XHRmb250U2l6ZSA9IHRoaXMuZ2V0VmlldygpLmdldFBpeGVsU2l6ZShmb250U2l6ZSk7XG5cdFx0cmV0dXJuIGxlYWRpbmcgIT0gbnVsbCA/IGxlYWRpbmcgOiBmb250U2l6ZSAqIDEuMjtcblx0fVxuXG59KTtcblxudmFyIERvbUVsZW1lbnQgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIHNwZWNpYWwgPSAvXihjaGVja2VkfHZhbHVlfHNlbGVjdGVkfGRpc2FibGVkKSQvaSxcblx0XHR0cmFuc2xhdGVkID0geyB0ZXh0OiAndGV4dENvbnRlbnQnLCBodG1sOiAnaW5uZXJIVE1MJyB9LFxuXHRcdHVuaXRsZXNzID0geyBsaW5lSGVpZ2h0OiAxLCB6b29tOiAxLCB6SW5kZXg6IDEsIG9wYWNpdHk6IDEgfTtcblxuXHRmdW5jdGlvbiBjcmVhdGUobm9kZXMsIHBhcmVudCkge1xuXHRcdHZhciByZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gIDAsIGwgPSBub2RlcyAmJiBub2Rlcy5sZW5ndGg7IGkgPCBsOykge1xuXHRcdFx0dmFyIGVsID0gbm9kZXNbaSsrXTtcblx0XHRcdGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFlbCB8fCAhZWwubm9kZVR5cGUpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KG5vZGVzW2ldKSlcblx0XHRcdFx0RG9tRWxlbWVudC5zZXQoZWwsIG5vZGVzW2krK10pO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobm9kZXNbaV0pKVxuXHRcdFx0XHRjcmVhdGUobm9kZXNbaSsrXSwgZWwpO1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcblx0XHRcdHJlcy5wdXNoKGVsKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVByZWZpeChlbCwgbmFtZSwgc2V0LCB2YWx1ZSkge1xuXHRcdHZhciBwcmVmaXhlcyA9IFsnd2Via2l0JywgJ21veicsICdNb3onLCAnbXMnLCAnbycsICcnXSxcblx0XHRcdHN1ZmZpeCA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHR2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV0sXG5cdFx0XHRcdGtleSA9IHByZWZpeCA/IHByZWZpeCArIHN1ZmZpeCA6IG5hbWU7XG5cdFx0XHRpZiAoa2V5IGluIGVsKSB7XG5cdFx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0XHRlbFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRjcmVhdGU6IGZ1bmN0aW9uKG5vZGVzLCBwYXJlbnQpIHtcblx0XHRcdHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShub2RlcyksXG5cdFx0XHRcdHJlcyA9IGNyZWF0ZShpc0FycmF5ID8gbm9kZXMgOiBhcmd1bWVudHMsIGlzQXJyYXkgPyBwYXJlbnQgOiBudWxsKTtcblx0XHRcdHJldHVybiByZXMubGVuZ3RoID09IDEgPyByZXNbMF0gOiByZXM7XG5cdFx0fSxcblxuXHRcdGZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCByb290KSB7XG5cdFx0XHRyZXR1cm4gKHJvb3QgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuXHRcdH0sXG5cblx0XHRmaW5kQWxsOiBmdW5jdGlvbihzZWxlY3Rvciwgcm9vdCkge1xuXHRcdFx0cmV0dXJuIChyb290IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHR9LFxuXG5cdFx0Z2V0OiBmdW5jdGlvbihlbCwga2V5KSB7XG5cdFx0XHRyZXR1cm4gZWxcblx0XHRcdFx0PyBzcGVjaWFsLnRlc3Qoa2V5KVxuXHRcdFx0XHRcdD8ga2V5ID09PSAndmFsdWUnIHx8IHR5cGVvZiBlbFtrZXldICE9PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBlbFtrZXldXG5cdFx0XHRcdFx0XHQ6IHRydWVcblx0XHRcdFx0XHQ6IGtleSBpbiB0cmFuc2xhdGVkXG5cdFx0XHRcdFx0XHQ/IGVsW3RyYW5zbGF0ZWRba2V5XV1cblx0XHRcdFx0XHRcdDogZWwuZ2V0QXR0cmlidXRlKGtleSlcblx0XHRcdFx0OiBudWxsO1xuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKGVsLCBrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBrZXkpXG5cdFx0XHRcdFx0aWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcblx0XHRcdFx0XHRcdHRoaXMuc2V0KGVsLCBuYW1lLCBrZXlbbmFtZV0pO1xuXHRcdFx0fSBlbHNlIGlmICghZWwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gZWw7XG5cdFx0XHR9IGVsc2UgaWYgKHNwZWNpYWwudGVzdChrZXkpKSB7XG5cdFx0XHRcdGVsW2tleV0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAoa2V5IGluIHRyYW5zbGF0ZWQpIHtcblx0XHRcdFx0ZWxbdHJhbnNsYXRlZFtrZXldXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcblx0XHRcdFx0dGhpcy5zZXRTdHlsZShlbCwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdldmVudHMnKSB7XG5cdFx0XHRcdERvbUV2ZW50LmFkZChlbCwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH0sXG5cblx0XHRnZXRTdHlsZXM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgZG9jID0gZWwgJiYgZWwubm9kZVR5cGUgIT09IDkgPyBlbC5vd25lckRvY3VtZW50IDogZWwsXG5cdFx0XHRcdHZpZXcgPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0cmV0dXJuIHZpZXcgJiYgdmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG5cdFx0fSxcblxuXHRcdGdldFN0eWxlOiBmdW5jdGlvbihlbCwga2V5KSB7XG5cdFx0XHRyZXR1cm4gZWwgJiYgZWwuc3R5bGVba2V5XSB8fCB0aGlzLmdldFN0eWxlcyhlbClba2V5XSB8fCBudWxsO1xuXHRcdH0sXG5cblx0XHRzZXRTdHlsZTogZnVuY3Rpb24oZWwsIGtleSwgdmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRmb3IgKHZhciBuYW1lIGluIGtleSlcblx0XHRcdFx0XHRpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKVxuXHRcdFx0XHRcdFx0dGhpcy5zZXRTdHlsZShlbCwgbmFtZSwga2V5W25hbWVdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgvXi0/W1xcZFxcLl0rJC8udGVzdCh2YWx1ZSkgJiYgIShrZXkgaW4gdW5pdGxlc3MpKVxuXHRcdFx0XHRcdHZhbHVlICs9ICdweCc7XG5cdFx0XHRcdGVsLnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBlbDtcblx0XHR9LFxuXG5cdFx0aGFzQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbHMpIHtcblx0XHRcdHJldHVybiBuZXcgUmVnRXhwKCdcXFxccyonICsgY2xzICsgJ1xcXFxzKicpLnRlc3QoZWwuY2xhc3NOYW1lKTtcblx0XHR9LFxuXG5cdFx0YWRkQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbHMpIHtcblx0XHRcdGVsLmNsYXNzTmFtZSA9IChlbC5jbGFzc05hbWUgKyAnICcgKyBjbHMpLnRyaW0oKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbHMpIHtcblx0XHRcdGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKFxuXHRcdFx0XHRuZXcgUmVnRXhwKCdcXFxccyonICsgY2xzICsgJ1xcXFxzKicpLCAnICcpLnRyaW0oKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0aWYgKGVsLnBhcmVudE5vZGUpXG5cdFx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHdoaWxlIChlbC5maXJzdENoaWxkKVxuXHRcdFx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcblx0XHR9LFxuXG5cdFx0Z2V0Qm91bmRzOiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHRib2R5ID0gZG9jLmJvZHksXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0XHRyZWN0O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWN0ID0geyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gcmVjdC5sZWZ0IC0gKGh0bWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCksXG5cdFx0XHRcdHkgPSByZWN0LnRvcCAtIChodG1sLmNsaWVudFRvcCAgfHwgYm9keS5jbGllbnRUb3AgIHx8IDApO1xuXHRcdFx0aWYgKCF2aWV3cG9ydCkge1xuXHRcdFx0XHR2YXIgdmlldyA9IGRvYy5kZWZhdWx0Vmlldztcblx0XHRcdFx0eCArPSB2aWV3LnBhZ2VYT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHRcdHkgKz0gdmlldy5wYWdlWU9mZnNldCB8fCBodG1sLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHR9LFxuXG5cdFx0Z2V0Vmlld3BvcnRCb3VuZHM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcblx0XHRcdFx0dmlldyA9IGRvYy5kZWZhdWx0Vmlldyxcblx0XHRcdFx0aHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLFxuXHRcdFx0XHR2aWV3LmlubmVyV2lkdGggfHwgaHRtbC5jbGllbnRXaWR0aCxcblx0XHRcdFx0dmlldy5pbm5lckhlaWdodCB8fCBodG1sLmNsaWVudEhlaWdodFxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Z2V0T2Zmc2V0OiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEJvdW5kcyhlbCwgdmlld3BvcnQpLmdldFBvaW50KCk7XG5cdFx0fSxcblxuXHRcdGdldFNpemU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoZWwsIHRydWUpLmdldFNpemUoKTtcblx0XHR9LFxuXG5cdFx0aXNJbnZpc2libGU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRTaXplKGVsKS5lcXVhbHMobmV3IFNpemUoMCwgMCkpO1xuXHRcdH0sXG5cblx0XHRpc0luVmlldzogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiAhdGhpcy5pc0ludmlzaWJsZShlbCkgJiYgdGhpcy5nZXRWaWV3cG9ydEJvdW5kcyhlbCkuaW50ZXJzZWN0cyhcblx0XHRcdFx0XHR0aGlzLmdldEJvdW5kcyhlbCwgdHJ1ZSkpO1xuXHRcdH0sXG5cblx0XHRnZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUpIHtcblx0XHRcdHJldHVybiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUpO1xuXHRcdH0sXG5cblx0XHRzZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKVxuXHRcdFx0XHRcdGhhbmRsZVByZWZpeChlbCwga2V5LCB0cnVlLCBuYW1lW2tleV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBuYW1lLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIERvbUV2ZW50ID0ge1xuXHRhZGQ6IGZ1bmN0aW9uKGVsLCBldmVudHMpIHtcblx0XHRmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuXHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdHBhcnRzID0gdHlwZS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKHBhcnRzW2ldLCBmdW5jLCBmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHBvcyA9IGV2ZW50LnRhcmdldFRvdWNoZXNcblx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aFxuXHRcdFx0XHRcdD8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXVxuXHRcdFx0XHRcdDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cblx0XHRcdFx0OiBldmVudDtcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0cG9zLnBhZ2VYIHx8IHBvcy5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG5cdFx0XHRwb3MucGFnZVkgfHwgcG9zLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG5cdFx0KTtcblx0fSxcblxuXHRnZXRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXHR9LFxuXG5cdGdldFJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudG9FbGVtZW50O1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCkge1xuXHRcdHJldHVybiBEb21FdmVudC5nZXRQb2ludChldmVudCkuc3VidHJhY3QoRG9tRWxlbWVudC5nZXRPZmZzZXQoXG5cdFx0XHRcdHRhcmdldCB8fCBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpKSk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG59O1xuXG5Eb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBuYXRpdmVSZXF1ZXN0ID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZCh3aW5kb3csICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSxcblx0XHRyZXF1ZXN0ZWQgPSBmYWxzZSxcblx0XHRjYWxsYmFja3MgPSBbXSxcblx0XHRmb2N1c2VkID0gdHJ1ZSxcblx0XHR0aW1lcjtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9jdXNlZCA9IHRydWU7XG5cdFx0fSxcblx0XHRibHVyOiBmdW5jdGlvbigpIHtcblx0XHRcdGZvY3VzZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrcygpIHtcblx0XHRmb3IgKHZhciBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgZW50cnkgPSBjYWxsYmFja3NbaV0sXG5cdFx0XHRcdGZ1bmMgPSBlbnRyeVswXSxcblx0XHRcdFx0ZWwgPSBlbnRyeVsxXTtcblx0XHRcdGlmICghZWwgfHwgKFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGVsLCAna2VlcGFsaXZlJykgPT0gJ3RydWUnXG5cdFx0XHRcdFx0fHwgZm9jdXNlZCkgJiYgRG9tRWxlbWVudC5pc0luVmlldyhlbCkpIHtcblx0XHRcdFx0Y2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0ZnVuYygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobmF0aXZlUmVxdWVzdCkge1xuXHRcdFx0aWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2goW2NhbGxiYWNrLCBlbGVtZW50XSk7XG5cdFx0aWYgKG5hdGl2ZVJlcXVlc3QpIHtcblx0XHRcdGlmICghcmVxdWVzdGVkKSB7XG5cdFx0XHRcdG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcblx0XHRcdFx0cmVxdWVzdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCF0aW1lcikge1xuXHRcdFx0dGltZXIgPSBzZXRJbnRlcnZhbChoYW5kbGVDYWxsYmFja3MsIDEwMDAgLyA2MCk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFZpZXcgPSBCYXNlLmV4dGVuZChDYWxsYmFjaywge1xuXHRfY2xhc3M6ICdWaWV3JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBWaWV3KHByb2plY3QsIGVsZW1lbnQpIHtcblx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHR0aGlzLl9zY29wZSA9IHByb2plY3QuX3Njb3BlO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXHRcdHZhciBzaXplO1xuXHRcdGlmICghdGhpcy5fcGl4ZWxSYXRpbylcblx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXHRcdHRoaXMuX2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0aWYgKHRoaXMuX2lkID09IG51bGwpXG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLl9pZCA9ICd2aWV3LScgKyBWaWV3Ll9pZCsrKTtcblx0XHREb21FdmVudC5hZGQoZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG5cdFx0dmFyIG5vbmUgPSAnbm9uZSc7XG5cdFx0RG9tRWxlbWVudC5zZXRQcmVmaXhlZChlbGVtZW50LnN0eWxlLCB7XG5cdFx0XHR1c2VyU2VsZWN0OiBub25lLFxuXHRcdFx0dG91Y2hBY3Rpb246IG5vbmUsXG5cdFx0XHR0b3VjaENhbGxvdXQ6IG5vbmUsXG5cdFx0XHRjb250ZW50Wm9vbWluZzogbm9uZSxcblx0XHRcdHVzZXJEcmFnOiBub25lLFxuXHRcdFx0dGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuXHRcdH0pO1xuXHRcdGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcblx0XHRcdHZhciBvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50LCB0cnVlKSxcblx0XHRcdFx0dGhhdCA9IHRoaXM7XG5cdFx0XHRzaXplID0gRG9tRWxlbWVudC5nZXRWaWV3cG9ydEJvdW5kcyhlbGVtZW50KVxuXHRcdFx0XHRcdC5nZXRTaXplKCkuc3VidHJhY3Qob2Zmc2V0KTtcblx0XHRcdHRoaXMuX3dpbmRvd0V2ZW50cyA9IHtcblx0XHRcdFx0cmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIURvbUVsZW1lbnQuaXNJbnZpc2libGUoZWxlbWVudCkpXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50LCB0cnVlKTtcblx0XHRcdFx0XHR0aGF0LnNldFZpZXdTaXplKERvbUVsZW1lbnQuZ2V0Vmlld3BvcnRCb3VuZHMoZWxlbWVudClcblx0XHRcdFx0XHRcdFx0LmdldFNpemUoKS5zdWJ0cmFjdChvZmZzZXQpKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdERvbUV2ZW50LmFkZCh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNpemUgPSBEb21FbGVtZW50LmdldFNpemUoZWxlbWVudCk7XG5cdFx0XHRpZiAoc2l6ZS5pc05hTigpIHx8IHNpemUuaXNaZXJvKCkpIHtcblx0XHRcdFx0dmFyIGdldFNpemUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnRbbmFtZV1cblx0XHRcdFx0XHRcdFx0fHwgcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSksIDEwKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldFNpemUoJ3dpZHRoJyksIGdldFNpemUoJ2hlaWdodCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fc2V0Vmlld1NpemUoc2l6ZSk7XG5cdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdzdGF0cycpXG5cdFx0XHRcdCYmIHR5cGVvZiBTdGF0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMuX3N0YXRzID0gbmV3IFN0YXRzKCk7XG5cdFx0XHR2YXIgc3RhdHMgPSB0aGlzLl9zdGF0cy5kb21FbGVtZW50LFxuXHRcdFx0XHRzdHlsZSA9IHN0YXRzLnN0eWxlLFxuXHRcdFx0XHRvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50KTtcblx0XHRcdHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdHN0eWxlLmxlZnQgPSBvZmZzZXQueCArICdweCc7XG5cdFx0XHRzdHlsZS50b3AgPSBvZmZzZXQueSArICdweCc7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzKTtcblx0XHR9XG5cdFx0Vmlldy5fdmlld3MucHVzaCh0aGlzKTtcblx0XHRWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdID0gdGhpcztcblx0XHR0aGlzLl92aWV3U2l6ZSA9IHNpemU7XG5cdFx0KHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSkuX293bmVyID0gdGhpcztcblx0XHR0aGlzLl96b29tID0gMTtcblx0XHRpZiAoIVZpZXcuX2ZvY3VzZWQpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gdGhpcztcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0dGhpcy5fZnJhbWVJdGVtQ291bnQgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmIChWaWV3Ll9mb2N1c2VkID09PSB0aGlzKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IG51bGw7XG5cdFx0Vmlldy5fdmlld3Muc3BsaWNlKFZpZXcuX3ZpZXdzLmluZGV4T2YodGhpcyksIDEpO1xuXHRcdGRlbGV0ZSBWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdO1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0Ll92aWV3ID09PSB0aGlzKVxuXHRcdFx0dGhpcy5fcHJvamVjdC5fdmlldyA9IG51bGw7XG5cdFx0RG9tRXZlbnQucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuXHRcdERvbUV2ZW50LnJlbW92ZSh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyk7XG5cdFx0dGhpcy5fZWxlbWVudCA9IHRoaXMuX3Byb2plY3QgPSBudWxsO1xuXHRcdHRoaXMuZGV0YWNoKCdmcmFtZScpO1xuXHRcdHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2V2ZW50czoge1xuXHRcdG9uRnJhbWU6IHtcblx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdH0sXG5cblx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25SZXNpemU6IHt9XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZhbHNlLFxuXHRfdGltZTogMCxcblx0X2NvdW50OiAwLFxuXG5cdF9yZXF1ZXN0RnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHREb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGF0Ll9yZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHRcdGlmICghdGhhdC5fYW5pbWF0ZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dGhhdC5fcmVxdWVzdEZyYW1lKCk7XG5cdFx0XHR0aGF0Ll9oYW5kbGVGcmFtZSgpO1xuXHRcdH0sIHRoaXMuX2VsZW1lbnQpO1xuXHRcdHRoaXMuX3JlcXVlc3RlZCA9IHRydWU7XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMCxcblx0XHRcdGRlbHRhID0gdGhpcy5fYmVmb3JlID8gbm93IC0gdGhpcy5fYmVmb3JlIDogMDtcblx0XHR0aGlzLl9iZWZvcmUgPSBub3c7XG5cdFx0dGhpcy5faGFuZGxpbmdGcmFtZSA9IHRydWU7XG5cdFx0dGhpcy5maXJlKCdmcmFtZScsIG5ldyBCYXNlKHtcblx0XHRcdGRlbHRhOiBkZWx0YSxcblx0XHRcdHRpbWU6IHRoaXMuX3RpbWUgKz0gZGVsdGEsXG5cdFx0XHRjb3VudDogdGhpcy5fY291bnQrK1xuXHRcdH0pKTtcblx0XHRpZiAodGhpcy5fc3RhdHMpXG5cdFx0XHR0aGlzLl9zdGF0cy51cGRhdGUoKTtcblx0XHR0aGlzLl9oYW5kbGluZ0ZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGFuaW1hdGUpIHtcblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9mcmFtZUl0ZW1zO1xuXHRcdGlmIChhbmltYXRlKSB7XG5cdFx0XHRpdGVtc1tpdGVtLl9pZF0gPSB7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHRpbWU6IDAsXG5cdFx0XHRcdGNvdW50OiAwXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCsrdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDEpXG5cdFx0XHRcdHRoaXMuYXR0YWNoKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgaXRlbXNbaXRlbS5faWRdO1xuXHRcdFx0aWYgKC0tdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDApIHtcblx0XHRcdFx0dGhpcy5kZXRhY2goJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVGcmFtZUl0ZW1zOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fZnJhbWVJdGVtcykge1xuXHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5fZnJhbWVJdGVtc1tpXTtcblx0XHRcdGVudHJ5Lml0ZW0uZmlyZSgnZnJhbWUnLCBuZXcgQmFzZShldmVudCwge1xuXHRcdFx0XHR0aW1lOiBlbnRyeS50aW1lICs9IGV2ZW50LmRlbHRhLFxuXHRcdFx0XHRjb3VudDogZW50cnkuY291bnQrK1xuXHRcdFx0fSkpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0aWYgKHRoaXMuX2hhbmRsaW5nRnJhbWUpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYgKHRoaXMuX2FuaW1hdGUpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUZyYW1lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAmIDEpXG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH0sXG5cblx0X3RyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dGhpcy5fbWF0cml4LmNvbmNhdGVuYXRlKG1hdHJpeCk7XG5cdFx0dGhpcy5fYm91bmRzID0gbnVsbDtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZWxlbWVudDtcblx0fSxcblxuXHRnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbztcblx0fSxcblxuXHRnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbyAqIDcyO1xuXHR9LFxuXG5cdGdldFZpZXdTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFZpZXdTaXplJyk7XG5cdH0sXG5cblx0c2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRkZWx0YSA9IHNpemUuc3VidHJhY3QodGhpcy5fdmlld1NpemUpO1xuXHRcdGlmIChkZWx0YS5pc1plcm8oKSlcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLl92aWV3U2l6ZS5zZXQoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdHRoaXMuX3NldFZpZXdTaXplKHNpemUpO1xuXHRcdHRoaXMuX2JvdW5kcyA9IG51bGw7IFxuXHRcdHRoaXMuZmlyZSgncmVzaXplJywge1xuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdGRlbHRhOiBkZWx0YVxuXHRcdH0pO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9zZXRWaWV3U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcblx0XHRlbGVtZW50LndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRlbGVtZW50LmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9tYXRyaXguaW52ZXJ0ZWQoKS5fdHJhbnNmb3JtQm91bmRzKFxuXHRcdFx0XHRcdG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksIHRoaXMuX3ZpZXdTaXplKSk7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRTaXplKCk7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcblx0fSxcblxuXHRzZXRDZW50ZXI6IGZ1bmN0aW9uKGNlbnRlcikge1xuXHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnNjcm9sbEJ5KGNlbnRlci5zdWJ0cmFjdCh0aGlzLmdldENlbnRlcigpKSk7XG5cdH0sXG5cblx0Z2V0Wm9vbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XG5cdH0sXG5cblx0c2V0Wm9vbTogZnVuY3Rpb24oem9vbSkge1xuXHRcdHRoaXMuX3RyYW5zZm9ybShuZXcgTWF0cml4KCkuc2NhbGUoem9vbSAvIHRoaXMuX3pvb20sXG5cdFx0XHR0aGlzLmdldENlbnRlcigpKSk7XG5cdFx0dGhpcy5fem9vbSA9IHpvb207XG5cdH0sXG5cblx0aXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gRG9tRWxlbWVudC5pc0luVmlldyh0aGlzLl9lbGVtZW50KTtcblx0fSxcblxuXHRzY3JvbGxCeTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLm5lZ2F0ZSgpKSk7XG5cdH0sXG5cblx0cGxheTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IHRydWU7XG5cdFx0aWYgKCF0aGlzLl9yZXF1ZXN0ZWQpXG5cdFx0XHR0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcblx0fSxcblxuXHRwYXVzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH0sXG5cblx0cHJvamVjdFRvVmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHR2aWV3VG9Qcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH1cblxufSwge1xuXHRzdGF0aWNzOiB7XG5cdFx0X3ZpZXdzOiBbXSxcblx0XHRfdmlld3NCeUlkOiB7fSxcblx0XHRfaWQ6IDAsXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKHByb2plY3QsIGVsZW1lbnQpIHtcblx0XHRcdGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcblx0XHRcdHJldHVybiBuZXcgQ2FudmFzVmlldyhwcm9qZWN0LCBlbGVtZW50KTtcblx0XHR9XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHRvb2wsXG5cdFx0cHJldkZvY3VzLFxuXHRcdHRlbXBGb2N1cyxcblx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIGdldFZpZXcoZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0ID0gRG9tRXZlbnQuZ2V0VGFyZ2V0KGV2ZW50KTtcblx0XHRyZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBWaWV3Ll92aWV3c0J5SWRbdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaWQnKV07XG5cdH1cblxuXHRmdW5jdGlvbiB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSB7XG5cdFx0cmV0dXJuIHZpZXcudmlld1RvUHJvamVjdChEb21FdmVudC5nZXRPZmZzZXQoZXZlbnQsIHZpZXcuX2VsZW1lbnQpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUZvY3VzKCkge1xuXHRcdGlmICghVmlldy5fZm9jdXNlZCB8fCAhVmlldy5fZm9jdXNlZC5pc1Zpc2libGUoKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBWaWV3Ll92aWV3cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBWaWV3Ll92aWV3c1tpXTtcblx0XHRcdFx0aWYgKHZpZXcgJiYgdmlldy5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB2aWV3O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIHBvaW50LCBldmVudCkge1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZW1vdmUnLCBwb2ludCwgZXZlbnQpO1xuXHRcdHZhciB0b29sID0gdmlldy5fc2NvcGUudG9vbDtcblx0XHRpZiAodG9vbCkge1xuXHRcdFx0dG9vbC5faGFuZGxlRXZlbnQoZHJhZ2dpbmcgJiYgdG9vbC5yZXNwb25kcygnbW91c2VkcmFnJylcblx0XHRcdFx0XHQ/ICdtb3VzZWRyYWcnIDogJ21vdXNlbW92ZScsIHBvaW50LCBldmVudCk7XG5cdFx0fVxuXHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0cmV0dXJuIHRvb2w7XG5cdH1cblxuXHR2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcixcblx0XHRtb3VzZWRvd24sIG1vdXNlbW92ZSwgbW91c2V1cDtcblx0aWYgKG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuXHRcdG1vdXNlZG93biA9ICdwb2ludGVyZG93biBNU1BvaW50ZXJEb3duJztcblx0XHRtb3VzZW1vdmUgPSAncG9pbnRlcm1vdmUgTVNQb2ludGVyTW92ZSc7XG5cdFx0bW91c2V1cCA9ICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xuXHR9IGVsc2Uge1xuXHRcdG1vdXNlZG93biA9ICd0b3VjaHN0YXJ0Jztcblx0XHRtb3VzZW1vdmUgPSAndG91Y2htb3ZlJztcblx0XHRtb3VzZXVwID0gJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJztcblx0XHRpZiAoISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChcblx0XHRcdFx0L21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kpKSkge1xuXHRcdFx0bW91c2Vkb3duICs9ICcgbW91c2Vkb3duJztcblx0XHRcdG1vdXNlbW92ZSArPSAnIG1vdXNlbW92ZSc7XG5cdFx0XHRtb3VzZXVwICs9ICcgbW91c2V1cCc7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHZpZXdFdmVudHMgPSB7XG5cdFx0J3NlbGVjdHN0YXJ0IGRyYWdzdGFydCc6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZiAoZHJhZ2dpbmcpXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBkb2NFdmVudHMgPSB7XG5cdFx0bW91c2VvdXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQsXG5cdFx0XHRcdHRhcmdldCA9IERvbUV2ZW50LmdldFJlbGF0ZWRUYXJnZXQoZXZlbnQpO1xuXHRcdFx0aWYgKHZpZXcgJiYgKCF0YXJnZXQgfHwgdGFyZ2V0Lm5vZGVOYW1lID09PSAnSFRNTCcpKVxuXHRcdFx0XHRoYW5kbGVNb3VzZU1vdmUodmlldywgdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCksIGV2ZW50KTtcblx0XHR9LFxuXG5cdFx0c2Nyb2xsOiB1cGRhdGVGb2N1c1xuXHR9O1xuXG5cdHZpZXdFdmVudHNbbW91c2Vkb3duXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gZ2V0VmlldyhldmVudCksXG5cdFx0XHRwb2ludCA9IHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpO1xuXHRcdGRyYWdnaW5nID0gdHJ1ZTtcblx0XHR2aWV3Ll9oYW5kbGVFdmVudCgnbW91c2Vkb3duJywgcG9pbnQsIGV2ZW50KTtcblx0XHRpZiAodG9vbCA9IHZpZXcuX3Njb3BlLnRvb2wpXG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudCgnbW91c2Vkb3duJywgcG9pbnQsIGV2ZW50KTtcblx0XHR2aWV3LnVwZGF0ZSgpO1xuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZW1vdmVdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCFkcmFnZ2luZykge1xuXHRcdFx0dmFyIHRhcmdldCA9IGdldFZpZXcoZXZlbnQpO1xuXHRcdFx0aWYgKHRhcmdldCkge1xuXHRcdFx0XHRpZiAodmlldyAhPT0gdGFyZ2V0KVxuXHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSwgZXZlbnQpO1xuXHRcdFx0XHRwcmV2Rm9jdXMgPSB2aWV3O1xuXHRcdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHRhcmdldDtcblx0XHRcdH0gZWxzZSBpZiAodGVtcEZvY3VzICYmIHRlbXBGb2N1cyA9PT0gdmlldykge1xuXHRcdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHByZXZGb2N1cztcblx0XHRcdFx0dXBkYXRlRm9jdXMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdHZhciBwb2ludCA9IHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpO1xuXHRcdFx0aWYgKGRyYWdnaW5nIHx8IHZpZXcuZ2V0Qm91bmRzKCkuY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHR0b29sID0gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIHBvaW50LCBldmVudCk7XG5cdFx0fVxuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZXVwXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXHRcdGlmICghdmlldyB8fCAhZHJhZ2dpbmcpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0ZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHR2aWV3Ll9oYW5kbGVFdmVudCgnbW91c2V1cCcsIHBvaW50LCBldmVudCk7XG5cdFx0aWYgKHRvb2wpXG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudCgnbW91c2V1cCcsIHBvaW50LCBldmVudCk7XG5cdFx0dmlldy51cGRhdGUoKTtcblx0fTtcblxuXHREb21FdmVudC5hZGQoZG9jdW1lbnQsIGRvY0V2ZW50cyk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGxvYWQ6IHVwZGF0ZUZvY3VzXG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0X3ZpZXdFdmVudHM6IHZpZXdFdmVudHMsXG5cblx0XHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKCkge30sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHR1cGRhdGVGb2N1czogdXBkYXRlRm9jdXNcblx0XHR9XG5cdH07XG59KTtcblxudmFyIENhbnZhc1ZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cdF9jbGFzczogJ0NhbnZhc1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIENhbnZhc1ZpZXcocHJvamVjdCwgY2FudmFzKSB7XG5cdFx0aWYgKCEoY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0aWYgKHNpemUuaXNaZXJvKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIENhbnZhc1ZpZXcgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQ6ICdcblx0XHRcdFx0XHRcdCsgY2FudmFzKTtcblx0XHRcdGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKTtcblx0XHR9XG5cdFx0dGhpcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdHRoaXMuX2V2ZW50Q291bnRlcnMgPSB7fTtcblx0XHR0aGlzLl9waXhlbFJhdGlvID0gMTtcblx0XHRpZiAoUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoY2FudmFzLCAnaGlkcGknKSAhPT0gJ29mZicpIHtcblx0XHRcdHZhciBkZXZpY2VSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG5cdFx0XHRcdGJhY2tpbmdTdG9yZVJhdGlvID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZCh0aGlzLl9jb250ZXh0LFxuXHRcdFx0XHRcdFx0J2JhY2tpbmdTdG9yZVBpeGVsUmF0aW8nKSB8fCAxO1xuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IGRldmljZVJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cdFx0fVxuXHRcdFZpZXcuY2FsbCh0aGlzLCBwcm9qZWN0LCBjYW52YXMpO1xuXHR9LFxuXG5cdF9zZXRWaWV3U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciB3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodCxcblx0XHRcdHBpeGVsUmF0aW8gPSB0aGlzLl9waXhlbFJhdGlvLFxuXHRcdFx0ZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG5cdFx0XHRzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cdFx0ZWxlbWVudC53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcblx0XHRlbGVtZW50LmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpIHtcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdHRoaXMuX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBpeGVsU2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0cHJldkZvbnQgPSBjdHguZm9udDtcblx0XHRjdHguZm9udCA9IHNpemUgKyAnIHNlcmlmJztcblx0XHRzaXplID0gcGFyc2VGbG9hdChjdHguZm9udCk7XG5cdFx0Y3R4LmZvbnQgPSBwcmV2Rm9udDtcblx0XHRyZXR1cm4gc2l6ZTtcblx0fSxcblxuXHRnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKGZvbnQsIGxpbmVzKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250LFxuXHRcdFx0d2lkdGggPSAwO1xuXHRcdGN0eC5mb250ID0gZm9udDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGgpO1xuXHRcdGN0eC5mb250ID0gcHJldkZvbnQ7XG5cdFx0cmV0dXJuIHdpZHRoO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdGlmICghcHJvamVjdCB8fCAhcHJvamVjdC5fbmVlZHNVcGRhdGUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoICsgMSwgc2l6ZS5oZWlnaHQgKyAxKTtcblx0XHRwcm9qZWN0LmRyYXcoY3R4LCB0aGlzLl9tYXRyaXgsIHRoaXMuX3BpeGVsUmF0aW8pO1xuXHRcdHByb2plY3QuX25lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHsgXG5cblx0dmFyIGRvd25Qb2ludCxcblx0XHRsYXN0UG9pbnQsXG5cdFx0b3ZlclBvaW50LFxuXHRcdGRvd25JdGVtLFxuXHRcdGxhc3RJdGVtLFxuXHRcdG92ZXJJdGVtLFxuXHRcdGRyYWdJdGVtLFxuXHRcdGRibENsaWNrLFxuXHRcdGNsaWNrVGltZTtcblxuXHRmdW5jdGlvbiBjYWxsRXZlbnQodmlldywgdHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsIGxhc3RQb2ludCkge1xuXHRcdHZhciBpdGVtID0gdGFyZ2V0LFxuXHRcdFx0bW91c2VFdmVudDtcblxuXHRcdGZ1bmN0aW9uIGNhbGwob2JqKSB7XG5cdFx0XHRpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRcdGlmICghbW91c2VFdmVudCkge1xuXHRcdFx0XHRcdG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCxcblx0XHRcdFx0XHRcdFx0bGFzdFBvaW50ID8gcG9pbnQuc3VidHJhY3QobGFzdFBvaW50KSA6IG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvYmouZmlyZSh0eXBlLCBtb3VzZUV2ZW50KSAmJiBtb3VzZUV2ZW50LmlzU3RvcHBlZCkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKGNhbGwoaXRlbSkpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdGlmIChjYWxsKHZpZXcpKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBldmVudCkge1xuXHRcdFx0aWYgKCF0aGlzLl9ldmVudENvdW50ZXJzW3R5cGVdKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdGhpdCA9IHByb2plY3QuaGl0VGVzdChwb2ludCwge1xuXHRcdFx0XHRcdHRvbGVyYW5jZTogdGhpcy5fc2NvcGUuc2V0dGluZ3MuaGl0VG9sZXJhbmNlLFxuXHRcdFx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRcdFx0c3Ryb2tlOiB0cnVlXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRpdGVtID0gaGl0ICYmIGhpdC5pdGVtLFxuXHRcdFx0XHRzdG9wcGVkID0gZmFsc2U7XG5cdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtKTtcblx0XHRcdFx0ZGJsQ2xpY2sgPSBsYXN0SXRlbSA9PSBpdGVtICYmIChEYXRlLm5vdygpIC0gY2xpY2tUaW1lIDwgMzAwKTtcblx0XHRcdFx0ZG93bkl0ZW0gPSBsYXN0SXRlbSA9IGl0ZW07XG5cdFx0XHRcdGRvd25Qb2ludCA9IGxhc3RQb2ludCA9IG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRkcmFnSXRlbSA9ICFzdG9wcGVkICYmIGl0ZW07XG5cdFx0XHRcdHdoaWxlIChkcmFnSXRlbSAmJiAhZHJhZ0l0ZW0ucmVzcG9uZHMoJ21vdXNlZHJhZycpKVxuXHRcdFx0XHRcdGRyYWdJdGVtID0gZHJhZ0l0ZW0uX3BhcmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0sIGRvd25Qb2ludCk7XG5cdFx0XHRcdGlmIChkcmFnSXRlbSkge1xuXHRcdFx0XHRcdGlmIChsYXN0UG9pbnQgJiYgIWxhc3RQb2ludC5lcXVhbHMocG9pbnQpKVxuXHRcdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWRyYWcnLCBldmVudCwgcG9pbnQsIGRyYWdJdGVtLFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RQb2ludCk7XG5cdFx0XHRcdFx0aWYgKGl0ZW0gIT09IGRyYWdJdGVtKSB7XG5cdFx0XHRcdFx0XHRvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2Vtb3ZlJywgZXZlbnQsIHBvaW50LCBpdGVtLFxuXHRcdFx0XHRcdFx0XHRcdG92ZXJQb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3RvcHBlZCAmJiBpdGVtICYmIGl0ZW0gPT09IGRvd25JdGVtKSB7XG5cdFx0XHRcdFx0Y2xpY2tUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgZGJsQ2xpY2sgJiYgZG93bkl0ZW0ucmVzcG9uZHMoJ2RvdWJsZWNsaWNrJylcblx0XHRcdFx0XHRcdFx0PyAnZG91YmxlY2xpY2snIDogJ2NsaWNrJywgZXZlbnQsIGRvd25Qb2ludCwgaXRlbSk7XG5cdFx0XHRcdFx0ZGJsQ2xpY2sgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb3duSXRlbSA9IGRyYWdJdGVtID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHRpZiAoZHJhZ0l0ZW0pXG5cdFx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCAnbW91c2VkcmFnJywgZXZlbnQsIHBvaW50LFxuXHRcdFx0XHRcdFx0XHRkcmFnSXRlbSwgbGFzdFBvaW50KTtcblx0XHRcdFx0aWYgKCFzdG9wcGVkKSB7XG5cdFx0XHRcdFx0aWYgKGl0ZW0gIT09IG92ZXJJdGVtKVxuXHRcdFx0XHRcdFx0b3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0sXG5cdFx0XHRcdFx0XHRcdG92ZXJQb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdFBvaW50ID0gb3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdGlmIChpdGVtICE9PSBvdmVySXRlbSkge1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VsZWF2ZScsIGV2ZW50LCBwb2ludCwgb3Zlckl0ZW0pO1xuXHRcdFx0XHRcdG92ZXJJdGVtID0gaXRlbTtcblx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlZW50ZXInLCBldmVudCwgcG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0b3BwZWQ7XG5cdFx0fVxuXHR9O1xufSk7XG5cbnZhciBFdmVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnRXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEV2ZW50KGV2ZW50KSB7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHR9LFxuXG5cdGlzUHJldmVudGVkOiBmYWxzZSxcblx0aXNTdG9wcGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc1ByZXZlbnRlZCA9IHRydWU7XG5cdFx0dGhpcy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9LFxuXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR0aGlzLnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0Z2V0TW9kaWZpZXJzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gS2V5Lm1vZGlmaWVycztcblx0fVxufSk7XG5cbnZhciBLZXlFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ0tleUV2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBLZXlFdmVudChkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpIHtcblx0XHRFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHR0aGlzLnR5cGUgPSBkb3duID8gJ2tleWRvd24nIDogJ2tleXVwJztcblx0XHR0aGlzLmtleSA9IGtleTtcblx0XHR0aGlzLmNoYXJhY3RlciA9IGNoYXJhY3Rlcjtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyBcIicsIGtleTogJ1wiICsgdGhpcy5rZXlcblx0XHRcdFx0KyBcIicsIGNoYXJhY3RlcjogJ1wiICsgdGhpcy5jaGFyYWN0ZXJcblx0XHRcdFx0KyBcIicsIG1vZGlmaWVyczogXCIgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgXCIgfVwiO1xuXHR9XG59KTtcblxudmFyIEtleSA9IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIgc3BlY2lhbEtleXMgPSB7XG5cdFx0ODogJ2JhY2tzcGFjZScsXG5cdFx0OTogJ3RhYicsXG5cdFx0MTM6ICdlbnRlcicsXG5cdFx0MTY6ICdzaGlmdCcsXG5cdFx0MTc6ICdjb250cm9sJyxcblx0XHQxODogJ29wdGlvbicsXG5cdFx0MTk6ICdwYXVzZScsXG5cdFx0MjA6ICdjYXBzLWxvY2snLFxuXHRcdDI3OiAnZXNjYXBlJyxcblx0XHQzMjogJ3NwYWNlJyxcblx0XHQzNTogJ2VuZCcsXG5cdFx0MzY6ICdob21lJyxcblx0XHQzNzogJ2xlZnQnLFxuXHRcdDM4OiAndXAnLFxuXHRcdDM5OiAncmlnaHQnLFxuXHRcdDQwOiAnZG93bicsXG5cdFx0NDY6ICdkZWxldGUnLFxuXHRcdDkxOiAnY29tbWFuZCcsXG5cdFx0OTM6ICdjb21tYW5kJywgXG5cdFx0MjI0OiAnY29tbWFuZCcgIFxuXHR9LFxuXG5cdHNwZWNpYWxDaGFycyA9IHtcblx0XHQ5OiB0cnVlLCBcblx0XHQxMzogdHJ1ZSwgXG5cdFx0MzI6IHRydWUgXG5cdH0sXG5cblx0bW9kaWZpZXJzID0gbmV3IEJhc2Uoe1xuXHRcdHNoaWZ0OiBmYWxzZSxcblx0XHRjb250cm9sOiBmYWxzZSxcblx0XHRvcHRpb246IGZhbHNlLFxuXHRcdGNvbW1hbmQ6IGZhbHNlLFxuXHRcdGNhcHNMb2NrOiBmYWxzZSxcblx0XHRzcGFjZTogZmFsc2Vcblx0fSksXG5cblx0Y2hhckNvZGVNYXAgPSB7fSwgXG5cdGtleU1hcCA9IHt9LCBcblx0ZG93bkNvZGU7IFxuXG5cdGZ1bmN0aW9uIGhhbmRsZUtleShkb3duLCBrZXlDb2RlLCBjaGFyQ29kZSwgZXZlbnQpIHtcblx0XHR2YXIgY2hhcmFjdGVyID0gY2hhckNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSA6ICcnLFxuXHRcdFx0c3BlY2lhbEtleSA9IHNwZWNpYWxLZXlzW2tleUNvZGVdLFxuXHRcdFx0a2V5ID0gc3BlY2lhbEtleSB8fCBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSxcblx0XHRcdHR5cGUgPSBkb3duID8gJ2tleWRvd24nIDogJ2tleXVwJyxcblx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkLFxuXHRcdFx0c2NvcGUgPSB2aWV3ICYmIHZpZXcuaXNWaXNpYmxlKCkgJiYgdmlldy5fc2NvcGUsXG5cdFx0XHR0b29sID0gc2NvcGUgJiYgc2NvcGUudG9vbCxcblx0XHRcdG5hbWU7XG5cdFx0a2V5TWFwW2tleV0gPSBkb3duO1xuXHRcdGlmIChzcGVjaWFsS2V5ICYmIChuYW1lID0gQmFzZS5jYW1lbGl6ZShzcGVjaWFsS2V5KSkgaW4gbW9kaWZpZXJzKVxuXHRcdFx0bW9kaWZpZXJzW25hbWVdID0gZG93bjtcblx0XHRpZiAoZG93bikge1xuXHRcdFx0Y2hhckNvZGVNYXBba2V5Q29kZV0gPSBjaGFyQ29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIGNoYXJDb2RlTWFwW2tleUNvZGVdO1xuXHRcdH1cblx0XHRpZiAodG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0dG9vbC5maXJlKHR5cGUsIG5ldyBLZXlFdmVudChkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpKTtcblx0XHRcdGlmICh2aWV3KVxuXHRcdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwge1xuXHRcdGtleWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgY29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG5cdFx0XHRpZiAoY29kZSBpbiBzcGVjaWFsS2V5cyB8fCBtb2RpZmllcnMuY29tbWFuZCkge1xuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwgY29kZSxcblx0XHRcdFx0XHRcdGNvZGUgaW4gc3BlY2lhbENoYXJzIHx8IG1vZGlmaWVycy5jb21tYW5kID8gY29kZSA6IDAsXG5cdFx0XHRcdFx0XHRldmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb3duQ29kZSA9IGNvZGU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKGRvd25Db2RlICE9IG51bGwpIHtcblx0XHRcdFx0aGFuZGxlS2V5KHRydWUsIGRvd25Db2RlLCBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlLCBldmVudCk7XG5cdFx0XHRcdGRvd25Db2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0a2V5dXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgY29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG5cdFx0XHRpZiAoY29kZSBpbiBjaGFyQ29kZU1hcClcblx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBjb2RlLCBjaGFyQ29kZU1hcFtjb2RlXSwgZXZlbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGJsdXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRmb3IgKHZhciBjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNoYXJDb2RlTWFwW2NvZGVdLCBldmVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4ge1xuXHRcdG1vZGlmaWVyczogbW9kaWZpZXJzLFxuXG5cdFx0aXNEb3duOiBmdW5jdGlvbihrZXkpIHtcblx0XHRcdHJldHVybiAhIWtleU1hcFtrZXldO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBNb3VzZUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTW91c2VFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCwgZGVsdGEpIHtcblx0XHRFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMucG9pbnQgPSBwb2ludDtcblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XHR0aGlzLmRlbHRhID0gZGVsdGE7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBwb2ludDogXCIgKyB0aGlzLnBvaW50XG5cdFx0XHRcdCsgJywgdGFyZ2V0OiAnICsgdGhpcy50YXJnZXRcblx0XHRcdFx0KyAodGhpcy5kZWx0YSA/ICcsIGRlbHRhOiAnICsgdGhpcy5kZWx0YSA6ICcnKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxuIEJhc2UuZXh0ZW5kKENhbGxiYWNrLCB7XG5cdF9jbGFzczogJ1BhbGV0dGUnLFxuXHRfZXZlbnRzOiBbICdvbkNoYW5nZScgXSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYWxldHRlKHRpdGxlLCBjb21wb25lbnRzLCB2YWx1ZXMpIHtcblx0XHR2YXIgcGFyZW50ID0gRG9tRWxlbWVudC5maW5kKCcucGFsZXR0ZWpzLXBhbmVsJylcblx0XHRcdHx8IERvbUVsZW1lbnQuZmluZCgnYm9keScpLmFwcGVuZENoaWxkKFxuXHRcdFx0XHREb21FbGVtZW50LmNyZWF0ZSgnZGl2JywgeyAnY2xhc3MnOiAncGFsZXR0ZWpzLXBhbmVsJyB9KSk7XG5cdFx0dGhpcy5fZWxlbWVudCA9IHBhcmVudC5hcHBlbmRDaGlsZChcblx0XHRcdERvbUVsZW1lbnQuY3JlYXRlKCd0YWJsZScsIHsgJ2NsYXNzJzogJ3BhbGV0dGVqcy1wYW5lJyB9KSk7XG5cdFx0dGhpcy5fdGl0bGUgPSB0aXRsZTtcblx0XHRpZiAoIXZhbHVlcylcblx0XHRcdHZhbHVlcyA9IHt9O1xuXHRcdGZvciAodmFyIG5hbWUgaW4gKHRoaXMuY29tcG9uZW50cyA9IGNvbXBvbmVudHMpKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tuYW1lXTtcblx0XHRcdGlmICghKGNvbXBvbmVudCBpbnN0YW5jZW9mIENvbXBvbmVudCkpIHtcblx0XHRcdFx0aWYgKGNvbXBvbmVudC52YWx1ZSA9PSBudWxsKVxuXHRcdFx0XHRcdGNvbXBvbmVudC52YWx1ZSA9IHZhbHVlc1tuYW1lXTtcblx0XHRcdFx0Y29tcG9uZW50Lm5hbWUgPSBuYW1lO1xuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wb25lbnRzW25hbWVdID0gbmV3IENvbXBvbmVudChjb21wb25lbnQpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZChjb21wb25lbnQuX2VsZW1lbnQpO1xuXHRcdFx0Y29tcG9uZW50Ll9wYWxldHRlID0gdGhpcztcblx0XHRcdGlmICh2YWx1ZXNbbmFtZV0gPT09IHVuZGVmaW5lZClcblx0XHRcdFx0dmFsdWVzW25hbWVdID0gY29tcG9uZW50LnZhbHVlO1xuXHRcdH1cblx0XHR0aGlzLnZhbHVlcyA9IEJhc2UuZWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tuYW1lXTtcblx0XHRcdGlmIChjb21wb25lbnQpIHtcblx0XHRcdFx0QmFzZS5kZWZpbmUodmFsdWVzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjb21wb25lbnQuX3ZhbHVlO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0XHRcdGNvbXBvbmVudC5zZXRWYWx1ZSh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aWYgKHdpbmRvdy5wYXBlcilcblx0XHRcdHBhcGVyLnBhbGV0dGVzLnB1c2godGhpcyk7XG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5jb21wb25lbnRzKVxuXHRcdFx0dGhpcy5jb21wb25lbnRzW2ldLnJlc2V0KCk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHREb21FbGVtZW50LnJlbW92ZSh0aGlzLl9lbGVtZW50KTtcblx0fVxufSk7XG5cbnZhciBDb21wb25lbnQgPSBCYXNlLmV4dGVuZChDYWxsYmFjaywge1xuXHRfY2xhc3M6ICdDb21wb25lbnQnLFxuXHRfZXZlbnRzOiBbICdvbkNoYW5nZScsICdvbkNsaWNrJyBdLFxuXG5cdF90eXBlczoge1xuXHRcdCdib29sZWFuJzoge1xuXHRcdFx0dHlwZTogJ2NoZWNrYm94Jyxcblx0XHRcdHZhbHVlOiAnY2hlY2tlZCdcblx0XHR9LFxuXG5cdFx0c3RyaW5nOiB7XG5cdFx0XHR0eXBlOiAndGV4dCdcblx0XHR9LFxuXG5cdFx0bnVtYmVyOiB7XG5cdFx0XHR0eXBlOiAnbnVtYmVyJyxcblx0XHRcdG51bWJlcjogdHJ1ZVxuXHRcdH0sXG5cblx0XHRidXR0b246IHtcblx0XHRcdHR5cGU6ICdidXR0b24nXG5cdFx0fSxcblxuXHRcdHRleHQ6IHtcblx0XHRcdHRhZzogJ2RpdicsXG5cdFx0XHR2YWx1ZTogJ3RleHQnXG5cdFx0fSxcblxuXHRcdHNsaWRlcjoge1xuXHRcdFx0dHlwZTogJ3JhbmdlJyxcblx0XHRcdG51bWJlcjogdHJ1ZVxuXHRcdH0sXG5cblx0XHRsaXN0OiB7XG5cdFx0XHR0YWc6ICdzZWxlY3QnLFxuXG5cdFx0XHRzZXRPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0RG9tRWxlbWVudC5yZW1vdmVDaGlsZHJlbih0aGlzLl9pbnB1dCk7XG5cdFx0XHRcdERvbUVsZW1lbnQuY3JlYXRlKEJhc2UuZWFjaCh0aGlzLl9vcHRpb25zLCBmdW5jdGlvbihvcHRpb24pIHtcblx0XHRcdFx0XHR0aGlzLnB1c2goJ29wdGlvbicsIHsgdmFsdWU6IG9wdGlvbiwgdGV4dDogb3B0aW9uIH0pO1xuXHRcdFx0XHR9LCBbXSksIHRoaXMuX2lucHV0KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y29sb3I6IHtcblx0XHRcdHR5cGU6ICdjb2xvcicsXG5cblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbG9yKHZhbHVlKTtcblx0XHRcdH0sXG5cblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbG9yKHZhbHVlKS50b0NTUyhcblx0XHRcdFx0XHRcdERvbUVsZW1lbnQuZ2V0KHRoaXMuX2lucHV0LCAndHlwZScpID09PSAnY29sb3InKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29tcG9uZW50KG9iaikge1xuXHRcdHRoaXMuX2lkID0gQ29tcG9uZW50Ll9pZCA9IChDb21wb25lbnQuX2lkIHx8IDApICsgMTtcblx0XHR0aGlzLl90eXBlID0gb2JqLnR5cGUgaW4gdGhpcy5fdHlwZXNcblx0XHRcdD8gb2JqLnR5cGVcblx0XHRcdDogJ29wdGlvbnMnIGluIG9ialxuXHRcdFx0XHQ/ICdsaXN0J1xuXHRcdFx0XHQ6ICdvbkNsaWNrJyBpbiBvYmpcblx0XHRcdFx0XHQ/ICdidXR0b24nXG5cdFx0XHRcdFx0OiB0eXBlb2Ygb2JqLnZhbHVlO1xuXHRcdHRoaXMuX21ldGEgPSB0aGlzLl90eXBlc1t0aGlzLl90eXBlXSB8fCB7IHR5cGU6IHRoaXMuX3R5cGUgfTtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRpZCA9ICdjb21wb25lbnQtJyArIHRoaXMuX2lkO1xuXHRcdHRoaXMuX2RvbnRGaXJlID0gdHJ1ZTtcblx0XHR0aGlzLl9pbnB1dCA9IERvbUVsZW1lbnQuY3JlYXRlKHRoaXMuX21ldGEudGFnIHx8ICdpbnB1dCcsIHtcblx0XHRcdGlkOiBpZCxcblx0XHRcdHR5cGU6IHRoaXMuX21ldGEudHlwZSxcblx0XHRcdGV2ZW50czoge1xuXHRcdFx0XHRjaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoYXQuc2V0VmFsdWUoXG5cdFx0XHRcdFx0XHREb21FbGVtZW50LmdldCh0aGlzLCB0aGF0Ll9tZXRhLnZhbHVlIHx8ICd2YWx1ZScpKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2xpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoYXQuZmlyZSgnY2xpY2snKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuYXR0YWNoKCdjaGFuZ2UnLCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCF0aGlzLl9kb250RmlyZSlcblx0XHRcdFx0dGhpcy5fcGFsZXR0ZS5maXJlKCdjaGFuZ2UnLCB0aGlzLCB0aGlzLm5hbWUsIHZhbHVlKTtcblx0XHR9KTtcblx0XHR0aGlzLl9lbGVtZW50ID0gRG9tRWxlbWVudC5jcmVhdGUoJ3RyJywgW1xuXHRcdFx0J3RkJywgW3RoaXMuX2xhYmVsID0gRG9tRWxlbWVudC5jcmVhdGUoJ2xhYmVsJywgeyAnZm9yJzogaWQgfSldLFxuXHRcdFx0J3RkJywgW3RoaXMuX2lucHV0XVxuXHRcdF0pO1xuXHRcdEJhc2UuZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdH0sIHRoaXMpO1xuXHRcdHRoaXMuX2RlZmF1bHRWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuXHRcdHRoaXMuX2RvbnRGaXJlID0gZmFsc2U7XG5cdH0sXG5cblx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH0sXG5cblx0Z2V0TGFiZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9fbGFiZWw7XG5cdH0sXG5cblx0c2V0TGFiZWw6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0dGhpcy5fX2xhYmVsID0gbGFiZWw7XG5cdFx0RG9tRWxlbWVudC5zZXQodGhpcy5fbGFiZWwsICd0ZXh0JywgbGFiZWwgKyAnOicpO1xuXHR9LFxuXG5cdGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vcHRpb25zO1xuXHR9LFxuXG5cdHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblx0XHR2YXIgc2V0T3B0aW9ucyA9IHRoaXMuX21ldGEuc2V0T3B0aW9ucztcblx0XHRpZiAoc2V0T3B0aW9ucylcblx0XHRcdHNldE9wdGlvbnMuY2FsbCh0aGlzKTtcblx0fSxcblxuXHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy5fdmFsdWUsXG5cdFx0XHRnZXRWYWx1ZSA9IHRoaXMuX21ldGEuZ2V0VmFsdWU7XG5cdFx0cmV0dXJuIGdldFZhbHVlID8gZ2V0VmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSkgOiB2YWx1ZTtcblx0fSxcblxuXHRzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIga2V5ID0gdGhpcy5fbWV0YS52YWx1ZSB8fCAndmFsdWUnLFxuXHRcdFx0c2V0VmFsdWUgPSB0aGlzLl9tZXRhLnNldFZhbHVlO1xuXHRcdGlmIChzZXRWYWx1ZSlcblx0XHRcdHZhbHVlID0gc2V0VmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0RG9tRWxlbWVudC5zZXQodGhpcy5faW5wdXQsIGtleSwgdmFsdWUpO1xuXHRcdHZhbHVlID0gRG9tRWxlbWVudC5nZXQodGhpcy5faW5wdXQsIGtleSk7XG5cdFx0aWYgKHRoaXMuX21ldGEubnVtYmVyKVxuXHRcdFx0dmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XG5cdFx0aWYgKHRoaXMuX3ZhbHVlICE9PSB2YWx1ZSkge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0XHRcdGlmICghdGhpcy5fZG9udEZpcmUpXG5cdFx0XHRcdHRoaXMuZmlyZSgnY2hhbmdlJywgdGhpcy5nZXRWYWx1ZSgpKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UmFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbcGFyc2VGbG9hdChEb21FbGVtZW50LmdldCh0aGlzLl9pbnB1dCwgJ21pbicpKSxcblx0XHRcdFx0cGFyc2VGbG9hdChEb21FbGVtZW50LmdldCh0aGlzLl9pbnB1dCwgJ21heCcpKV07XG5cdH0sXG5cblx0c2V0UmFuZ2U6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG5cdFx0dmFyIHJhbmdlID0gQXJyYXkuaXNBcnJheShtaW4pID8gbWluIDogW21pbiwgbWF4XTtcblx0XHREb21FbGVtZW50LnNldCh0aGlzLl9pbnB1dCwgeyBtaW46IHJhbmdlWzBdLCBtYXg6IHJhbmdlWzFdIH0pO1xuXHR9LFxuXG5cdGdldE1pbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmFuZ2UoKVswXTtcblx0fSxcblxuXHRzZXRNaW46IGZ1bmN0aW9uKG1pbikge1xuXHRcdHRoaXMuc2V0UmFuZ2UobWluLCB0aGlzLmdldE1heCgpKTtcblx0fSxcblxuXHRnZXRNYXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFJhbmdlKClbMV07XG5cdH0sXG5cblx0c2V0TWF4OiBmdW5jdGlvbihtYXgpIHtcblx0XHR0aGlzLnNldFJhbmdlKHRoaXMuZ2V0TWluKCksIG1heCk7XG5cdH0sXG5cblx0Z2V0U3RlcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHBhcnNlRmxvYXQoRG9tRWxlbWVudC5nZXQodGhpcy5faW5wdXQsICdzdGVwJykpO1xuXHR9LFxuXG5cdHNldFN0ZXA6IGZ1bmN0aW9uKHN0ZXApIHtcblx0XHREb21FbGVtZW50LnNldCh0aGlzLl9pbnB1dCwgJ3N0ZXAnLCBzdGVwKTtcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZXRWYWx1ZSh0aGlzLl9kZWZhdWx0VmFsdWUpO1xuXHR9XG59KTtcblxudmFyIFRvb2xFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2xFdmVudCcsXG5cdF9pdGVtOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkge1xuXHRcdHRoaXMudG9vbCA9IHRvb2w7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH0sXG5cblx0X2Nob29zZVBvaW50OiBmdW5jdGlvbihwb2ludCwgdG9vbFBvaW50KSB7XG5cdFx0cmV0dXJuIHBvaW50ID8gcG9pbnQgOiB0b29sUG9pbnQgPyB0b29sUG9pbnQuY2xvbmUoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9wb2ludCwgdGhpcy50b29sLl9wb2ludCk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0fSxcblxuXHRnZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9sYXN0UG9pbnQsIHRoaXMudG9vbC5fbGFzdFBvaW50KTtcblx0fSxcblxuXHRzZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKGxhc3RQb2ludCkge1xuXHRcdHRoaXMuX2xhc3RQb2ludCA9IGxhc3RQb2ludDtcblx0fSxcblxuXHRnZXREb3duUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9kb3duUG9pbnQsIHRoaXMudG9vbC5fZG93blBvaW50KTtcblx0fSxcblxuXHRzZXREb3duUG9pbnQ6IGZ1bmN0aW9uKGRvd25Qb2ludCkge1xuXHRcdHRoaXMuX2Rvd25Qb2ludCA9IGRvd25Qb2ludDtcblx0fSxcblxuXHRnZXRNaWRkbGVQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9taWRkbGVQb2ludCAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9vbC5fcG9pbnQuYWRkKHRoaXMudG9vbC5fbGFzdFBvaW50KS5kaXZpZGUoMik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9taWRkbGVQb2ludDtcblx0fSxcblxuXHRzZXRNaWRkbGVQb2ludDogZnVuY3Rpb24obWlkZGxlUG9pbnQpIHtcblx0XHR0aGlzLl9taWRkbGVQb2ludCA9IG1pZGRsZVBvaW50O1xuXHR9LFxuXG5cdGdldERlbHRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2RlbHRhICYmIHRoaXMudG9vbC5fbGFzdFBvaW50XG5cdFx0IFx0XHQ/IHRoaXMudG9vbC5fcG9pbnQuc3VidHJhY3QodGhpcy50b29sLl9sYXN0UG9pbnQpXG5cdFx0XHRcdDogdGhpcy5fZGVsdGE7XG5cdH0sXG5cblx0c2V0RGVsdGE6IGZ1bmN0aW9uKGRlbHRhKSB7XG5cdFx0dGhpcy5fZGVsdGEgPSBkZWx0YTtcblx0fSxcblxuXHRnZXRDb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIC9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSlcblx0XHRcdFx0PyB0aGlzLnRvb2wuX2Rvd25Db3VudFxuXHRcdFx0XHQ6IHRoaXMudG9vbC5fY291bnQ7XG5cdH0sXG5cblx0c2V0Q291bnQ6IGZ1bmN0aW9uKGNvdW50KSB7XG5cdFx0dGhpcy50b29sWy9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSkgPyAnZG93bkNvdW50JyA6ICdjb3VudCddXG5cdFx0XHQ9IGNvdW50O1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5faXRlbSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMudG9vbC5fc2NvcGUucHJvamVjdC5oaXRUZXN0KHRoaXMuZ2V0UG9pbnQoKSk7XG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdHZhciBpdGVtID0gcmVzdWx0Lml0ZW0sXG5cdFx0XHRcdFx0cGFyZW50ID0gaXRlbS5fcGFyZW50O1xuXHRcdFx0XHR3aGlsZSAoL14oR3JvdXB8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcykpIHtcblx0XHRcdFx0XHRpdGVtID0gcGFyZW50O1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faXRlbTtcblx0fSxcblxuXHRzZXRJdGVtOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAneyB0eXBlOiAnICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgJywgcG9pbnQ6ICcgKyB0aGlzLmdldFBvaW50KClcblx0XHRcdFx0KyAnLCBjb3VudDogJyArIHRoaXMuZ2V0Q291bnQoKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFRvb2wgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdUb29sJyxcblx0X2xpc3Q6ICd0b29scycsXG5cdF9yZWZlcmVuY2U6ICd0b29sJyxcblx0X2V2ZW50czogWyAnb25BY3RpdmF0ZScsICdvbkRlYWN0aXZhdGUnLCAnb25FZGl0T3B0aW9ucycsXG5cdFx0XHQnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uTW91c2VNb3ZlJyxcblx0XHRcdCdvbktleURvd24nLCAnb25LZXlVcCcgXSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUb29sKHByb3BzKSB7XG5cdFx0UGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9maXJzdE1vdmUgPSB0cnVlO1xuXHRcdHRoaXMuX2NvdW50ID0gMDtcblx0XHR0aGlzLl9kb3duQ291bnQgPSAwO1xuXHRcdHRoaXMuX3NldChwcm9wcyk7XG5cdH0sXG5cblx0Z2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW5EaXN0YW5jZTtcblx0fSxcblxuXHRzZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24obWluRGlzdGFuY2UpIHtcblx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXHRcdGlmICh0aGlzLl9taW5EaXN0YW5jZSAhPSBudWxsICYmIHRoaXMuX21heERpc3RhbmNlICE9IG51bGxcblx0XHRcdFx0JiYgdGhpcy5fbWluRGlzdGFuY2UgPiB0aGlzLl9tYXhEaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5fbWF4RGlzdGFuY2UgPSB0aGlzLl9taW5EaXN0YW5jZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXhEaXN0YW5jZTtcblx0fSxcblxuXHRzZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24obWF4RGlzdGFuY2UpIHtcblx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdGlmICh0aGlzLl9taW5EaXN0YW5jZSAhPSBudWxsICYmIHRoaXMuX21heERpc3RhbmNlICE9IG51bGxcblx0XHRcdFx0JiYgdGhpcy5fbWF4RGlzdGFuY2UgPCB0aGlzLl9taW5EaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlID09IHRoaXMuX21heERpc3RhbmNlXG5cdFx0XHQ/IHRoaXMuX21pbkRpc3RhbmNlIDogbnVsbDtcblx0fSxcblxuXHRzZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbihkaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0dGhpcy5fbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0fSxcblxuXHRfdXBkYXRlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UsIHN0YXJ0LFxuXHRcdFx0bmVlZHNDaGFuZ2UsIG1hdGNoTWF4RGlzdGFuY2UpIHtcblx0XHRpZiAoIXN0YXJ0KSB7XG5cdFx0XHRpZiAobWluRGlzdGFuY2UgIT0gbnVsbCB8fCBtYXhEaXN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBtaW5EaXN0ID0gbWluRGlzdGFuY2UgIT0gbnVsbCA/IG1pbkRpc3RhbmNlIDogMCxcblx0XHRcdFx0XHR2ZWN0b3IgPSBwb2ludC5zdWJ0cmFjdCh0aGlzLl9wb2ludCksXG5cdFx0XHRcdFx0ZGlzdGFuY2UgPSB2ZWN0b3IuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3QpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR2YXIgbWF4RGlzdCA9IG1heERpc3RhbmNlICE9IG51bGwgPyBtYXhEaXN0YW5jZSA6IDA7XG5cdFx0XHRcdGlmIChtYXhEaXN0ICE9IDApIHtcblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPiBtYXhEaXN0KSB7XG5cdFx0XHRcdFx0XHRwb2ludCA9IHRoaXMuX3BvaW50LmFkZCh2ZWN0b3Iubm9ybWFsaXplKG1heERpc3QpKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG1hdGNoTWF4RGlzdGFuY2UpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChuZWVkc0NoYW5nZSAmJiBwb2ludC5lcXVhbHModGhpcy5fcG9pbnQpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHRoaXMuX2xhc3RQb2ludCA9IHN0YXJ0ICYmIHR5cGUgPT0gJ21vdXNlbW92ZScgPyBwb2ludCA6IHRoaXMuX3BvaW50O1xuXHRcdHRoaXMuX3BvaW50ID0gcG9pbnQ7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdHRoaXMuX2xhc3RQb2ludCA9IHRoaXMuX2Rvd25Qb2ludDtcblx0XHRcdHRoaXMuX2Rvd25Qb2ludCA9IHRoaXMuX3BvaW50O1xuXHRcdFx0dGhpcy5fZG93bkNvdW50Kys7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdHRoaXMuX2xhc3RQb2ludCA9IHRoaXMuX2Rvd25Qb2ludDtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR0aGlzLl9jb3VudCA9IHN0YXJ0ID8gMCA6IHRoaXMuX2NvdW50ICsgMTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfZmlyZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuXHRcdHZhciBzZXRzID0gcGFwZXIucHJvamVjdC5fcmVtb3ZlU2V0cztcblx0XHRpZiAoc2V0cykge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXVwJylcblx0XHRcdFx0c2V0cy5tb3VzZWRyYWcgPSBudWxsO1xuXHRcdFx0dmFyIHNldCA9IHNldHNbdHlwZV07XG5cdFx0XHRpZiAoc2V0KSB7XG5cdFx0XHRcdGZvciAodmFyIGlkIGluIHNldCkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gc2V0W2lkXTtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gc2V0cykge1xuXHRcdFx0XHRcdFx0dmFyIG90aGVyID0gc2V0c1trZXldO1xuXHRcdFx0XHRcdFx0aWYgKG90aGVyICYmIG90aGVyICE9IHNldClcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIG90aGVyW2l0ZW0uX2lkXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRzW3R5cGVdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucmVzcG9uZHModHlwZSlcblx0XHRcdFx0JiYgdGhpcy5maXJlKHR5cGUsIG5ldyBUb29sRXZlbnQodGhpcywgdHlwZSwgZXZlbnQpKTtcblx0fSxcblxuXHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBldmVudCkge1xuXHRcdHBhcGVyID0gdGhpcy5fc2NvcGU7XG5cdFx0dmFyIGNhbGxlZCA9IGZhbHNlO1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHR0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgbnVsbCwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZWRyYWcnOlxuXHRcdFx0dmFyIG5lZWRzQ2hhbmdlID0gZmFsc2UsXG5cdFx0XHRcdG1hdGNoTWF4RGlzdGFuY2UgPSBmYWxzZTtcblx0XHRcdHdoaWxlICh0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHR0aGlzLm1heERpc3RhbmNlLCBmYWxzZSwgbmVlZHNDaGFuZ2UsIG1hdGNoTWF4RGlzdGFuY2UpKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCkgfHwgY2FsbGVkO1xuXHRcdFx0XHRuZWVkc0NoYW5nZSA9IHRydWU7XG5cdFx0XHRcdG1hdGNoTWF4RGlzdGFuY2UgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRpZiAoIXBvaW50LmVxdWFscyh0aGlzLl9wb2ludClcblx0XHRcdFx0XHQmJiB0aGlzLl91cGRhdGVFdmVudCgnbW91c2VkcmFnJywgcG9pbnQsIHRoaXMubWluRGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCgnbW91c2VkcmFnJywgZXZlbnQpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLFxuXHRcdFx0XHRcdGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcblx0XHRcdHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCBudWxsLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fZmlyc3RNb3ZlID0gdHJ1ZTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHR3aGlsZSAodGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIHRoaXMubWluRGlzdGFuY2UsXG5cdFx0XHRcdFx0dGhpcy5tYXhEaXN0YW5jZSwgdGhpcy5fZmlyc3RNb3ZlLCB0cnVlLCBmYWxzZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0TW92ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGlmIChjYWxsZWQpXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHJldHVybiBjYWxsZWQ7XG5cdH1cblxufSk7XG5cbnZhciBIdHRwID0ge1xuXHRyZXF1ZXN0OiBmdW5jdGlvbihtZXRob2QsIHVybCwgY2FsbGJhY2spIHtcblx0XHR2YXIgeGhyID0gbmV3ICh3aW5kb3cuQWN0aXZlWE9iamVjdCB8fCBYTUxIdHRwUmVxdWVzdCkoXG5cdFx0XHRcdFx0J01pY3Jvc29mdC5YTUxIVFRQJyk7XG5cdFx0eGhyLm9wZW4obWV0aG9kLnRvVXBwZXJDYXNlKCksIHVybCwgdHJ1ZSk7XG5cdFx0aWYgKCdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1cztcblx0XHRcdFx0aWYgKHN0YXR1cyA9PT0gMCB8fCBzdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoeGhyLCB4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkICcgKyB1cmwgKyAnIChFcnJvciAnXG5cdFx0XHRcdFx0XHRcdCsgc3RhdHVzICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIHhoci5zZW5kKG51bGwpO1xuXHR9XG59O1xuXG52YXIgQ2FudmFzUHJvdmlkZXIgPSB7XG5cdGNhbnZhc2VzOiBbXSxcblxuXHRnZXRDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8pIHtcblx0XHR2YXIgY2FudmFzLFxuXHRcdFx0aW5pdCA9IHRydWU7XG5cdFx0aWYgKHR5cGVvZiB3aWR0aCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHBpeGVsUmF0aW8gPSBoZWlnaHQ7XG5cdFx0XHRoZWlnaHQgPSB3aWR0aC5oZWlnaHQ7XG5cdFx0XHR3aWR0aCA9IHdpZHRoLndpZHRoO1xuXHRcdH1cblx0XHRpZiAoIXBpeGVsUmF0aW8pIHtcblx0XHRcdHBpeGVsUmF0aW8gPSAxO1xuXHRcdH0gZWxzZSBpZiAocGl4ZWxSYXRpbyAhPT0gMSkge1xuXHRcdFx0d2lkdGggKj0gcGl4ZWxSYXRpbztcblx0XHRcdGhlaWdodCAqPSBwaXhlbFJhdGlvO1xuXHRcdH1cblx0XHRpZiAodGhpcy5jYW52YXNlcy5sZW5ndGgpIHtcblx0XHRcdGNhbnZhcyA9IHRoaXMuY2FudmFzZXMucG9wKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdH1cblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0aWYgKGNhbnZhcy53aWR0aCA9PT0gd2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG5cdFx0XHRpZiAoaW5pdClcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCArIDEsIGhlaWdodCArIDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpXG5cdFx0XHRjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fSxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2FudmFzKHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8pLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0cmVsZWFzZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGNhbnZhcyA9IG9iai5jYW52YXMgPyBvYmouY2FudmFzIDogb2JqO1xuXHRcdGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnJlc3RvcmUoKTtcblx0XHR0aGlzLmNhbnZhc2VzLnB1c2goY2FudmFzKTtcblx0fVxufTtcblxudmFyIEJsZW5kTW9kZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1pbiA9IE1hdGgubWluLFxuXHRcdG1heCA9IE1hdGgubWF4LFxuXHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdHNyLCBzZywgc2IsIHNhLCBcblx0XHRiciwgYmcsIGJiLCBiYSwgXG5cdFx0ZHIsIGRnLCBkYjsgICAgIFxuXG5cdGZ1bmN0aW9uIGdldEx1bShyLCBnLCBiKSB7XG5cdFx0cmV0dXJuIDAuMjk4OSAqIHIgKyAwLjU4NyAqIGcgKyAwLjExNCAqIGI7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRMdW0ociwgZywgYiwgbCkge1xuXHRcdHZhciBkID0gbCAtIGdldEx1bShyLCBnLCBiKTtcblx0XHRkciA9IHIgKyBkO1xuXHRcdGRnID0gZyArIGQ7XG5cdFx0ZGIgPSBiICsgZDtcblx0XHR2YXIgbCA9IGdldEx1bShkciwgZGcsIGRiKSxcblx0XHRcdG1uID0gbWluKGRyLCBkZywgZGIpLFxuXHRcdFx0bXggPSBtYXgoZHIsIGRnLCBkYik7XG5cdFx0aWYgKG1uIDwgMCkge1xuXHRcdFx0dmFyIGxtbiA9IGwgLSBtbjtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbCAvIGxtbjtcblx0XHRcdGRnID0gbCArIChkZyAtIGwpICogbCAvIGxtbjtcblx0XHRcdGRiID0gbCArIChkYiAtIGwpICogbCAvIGxtbjtcblx0XHR9XG5cdFx0aWYgKG14ID4gMjU1KSB7XG5cdFx0XHR2YXIgbG4gPSAyNTUgLSBsLFxuXHRcdFx0XHRteGwgPSBteCAtIGw7XG5cdFx0XHRkciA9IGwgKyAoZHIgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsbiAvIG14bDtcblx0XHRcdGRiID0gbCArIChkYiAtIGwpICogbG4gLyBteGw7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2F0KHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gbWF4KHIsIGcsIGIpIC0gbWluKHIsIGcsIGIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2F0KHIsIGcsIGIsIHMpIHtcblx0XHR2YXIgY29sID0gW3IsIGcsIGJdLFxuXHRcdFx0bXggPSBtYXgociwgZywgYiksIFxuXHRcdFx0bW4gPSBtaW4ociwgZywgYiksIFxuXHRcdFx0bWQ7IFxuXHRcdG1uID0gbW4gPT09IHIgPyAwIDogbW4gPT09IGcgPyAxIDogMjtcblx0XHRteCA9IG14ID09PSByID8gMCA6IG14ID09PSBnID8gMSA6IDI7XG5cdFx0bWQgPSBtaW4obW4sIG14KSA9PT0gMCA/IG1heChtbiwgbXgpID09PSAxID8gMiA6IDEgOiAwO1xuXHRcdGlmIChjb2xbbXhdID4gY29sW21uXSkge1xuXHRcdFx0Y29sW21kXSA9IChjb2xbbWRdIC0gY29sW21uXSkgKiBzIC8gKGNvbFtteF0gLSBjb2xbbW5dKTtcblx0XHRcdGNvbFtteF0gPSBzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb2xbbWRdID0gY29sW214XSA9IDA7XG5cdFx0fVxuXHRcdGNvbFttbl0gPSAwO1xuXHRcdGRyID0gY29sWzBdO1xuXHRcdGRnID0gY29sWzFdO1xuXHRcdGRiID0gY29sWzJdO1xuXHR9XG5cblx0dmFyIG1vZGVzID0ge1xuXHRcdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKiBzciAvIDI1NTtcblx0XHRcdGRnID0gYmcgKiBzZyAvIDI1NTtcblx0XHRcdGRiID0gYmIgKiBzYiAvIDI1NTtcblx0XHR9LFxuXG5cdFx0c2NyZWVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKyBzciAtIChiciAqIHNyIC8gMjU1KTtcblx0XHRcdGRnID0gYmcgKyBzZyAtIChiZyAqIHNnIC8gMjU1KTtcblx0XHRcdGRiID0gYmIgKyBzYiAtIChiYiAqIHNiIC8gMjU1KTtcblx0XHR9LFxuXG5cdFx0b3ZlcmxheTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIDwgMTI4ID8gMiAqIGJyICogc3IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnIDwgMTI4ID8gMiAqIGJnICogc2cgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiIDwgMTI4ID8gMiAqIGJiICogc2IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdzb2Z0LWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdCA9IHNyICogYnIgLyAyNTU7XG5cdFx0XHRkciA9IHQgKyBiciAqICgyNTUgLSAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdFx0dCA9IHNnICogYmcgLyAyNTU7XG5cdFx0XHRkZyA9IHQgKyBiZyAqICgyNTUgLSAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdFx0dCA9IHNiICogYmIgLyAyNTU7XG5cdFx0XHRkYiA9IHQgKyBiYiAqICgyNTUgLSAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnaGFyZC1saWdodCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBzciA8IDEyOCA/IDIgKiBzciAqIGJyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzcikgKiAoMjU1IC0gYnIpIC8gMjU1O1xuXHRcdFx0ZGcgPSBzZyA8IDEyOCA/IDIgKiBzZyAqIGJnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzZykgKiAoMjU1IC0gYmcpIC8gMjU1O1xuXHRcdFx0ZGIgPSBzYiA8IDEyOCA/IDIgKiBzYiAqIGJiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzYikgKiAoMjU1IC0gYmIpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnY29sb3ItZG9kZ2UnOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPT09IDAgPyAwIDogc3IgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJyIC8gKDI1NSAtIHNyKSk7XG5cdFx0XHRkZyA9IGJnID09PSAwID8gMCA6IHNnID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiZyAvICgyNTUgLSBzZykpO1xuXHRcdFx0ZGIgPSBiYiA9PT0gMCA/IDAgOiBzYiA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYmIgLyAoMjU1IC0gc2IpKTtcblx0XHR9LFxuXG5cdFx0J2NvbG9yLWJ1cm4nOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPT09IDI1NSA/IDI1NSA6IHNyID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYnIpICogMjU1IC8gc3IpO1xuXHRcdFx0ZGcgPSBiZyA9PT0gMjU1ID8gMjU1IDogc2cgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiZykgKiAyNTUgLyBzZyk7XG5cdFx0XHRkYiA9IGJiID09PSAyNTUgPyAyNTUgOiBzYiA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJiKSAqIDI1NSAvIHNiKTtcblx0XHR9LFxuXG5cdFx0ZGFya2VuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnIDwgc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA8IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0bGlnaHRlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID4gc3IgPyBiciA6IHNyO1xuXHRcdFx0ZGcgPSBiZyA+IHNnID8gYmcgOiBzZztcblx0XHRcdGRiID0gYmIgPiBzYiA/IGJiIDogc2I7XG5cdFx0fSxcblxuXHRcdGRpZmZlcmVuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAtIHNyO1xuXHRcdFx0aWYgKGRyIDwgMClcblx0XHRcdFx0ZHIgPSAtZHI7XG5cdFx0XHRkZyA9IGJnIC0gc2c7XG5cdFx0XHRpZiAoZGcgPCAwKVxuXHRcdFx0XHRkZyA9IC1kZztcblx0XHRcdGRiID0gYmIgLSBzYjtcblx0XHRcdGlmIChkYiA8IDApXG5cdFx0XHRcdGRiID0gLWRiO1xuXHRcdH0sXG5cblx0XHRleGNsdXNpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyICogKDI1NSAtIGJyIC0gYnIpIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyArIHNnICogKDI1NSAtIGJnIC0gYmcpIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiArIHNiICogKDI1NSAtIGJiIC0gYmIpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRodWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0U2F0KHNyLCBzZywgc2IsIGdldFNhdChiciwgYmcsIGJiKSk7XG5cdFx0XHRzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0c2F0dXJhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoYnIsIGJnLCBiYiwgZ2V0U2F0KHNyLCBzZywgc2IpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRsdW1pbm9zaXR5OiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShiciwgYmcsIGJiLCBnZXRMdW0oc3IsIHNnLCBzYikpO1xuXHRcdH0sXG5cblx0XHRjb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRMdW0oc3IsIHNnLCBzYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gbWluKGJyICsgc3IsIDI1NSk7XG5cdFx0XHRkZyA9IG1pbihiZyArIHNnLCAyNTUpO1xuXHRcdFx0ZGIgPSBtaW4oYmIgKyBzYiwgMjU1KTtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtYXgoYnIgLSBzciwgMCk7XG5cdFx0XHRkZyA9IG1heChiZyAtIHNnLCAwKTtcblx0XHRcdGRiID0gbWF4KGJiIC0gc2IsIDApO1xuXHRcdH0sXG5cblx0XHRhdmVyYWdlOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gKGJyICsgc3IpIC8gMjtcblx0XHRcdGRnID0gKGJnICsgc2cpIC8gMjtcblx0XHRcdGRiID0gKGJiICsgc2IpIC8gMjtcblx0XHR9LFxuXG5cdFx0bmVnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAyNTUgLSBhYnMoMjU1IC0gc3IgLSBicik7XG5cdFx0XHRkZyA9IDI1NSAtIGFicygyNTUgLSBzZyAtIGJnKTtcblx0XHRcdGRiID0gMjU1IC0gYWJzKDI1NSAtIHNiIC0gYmIpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgbmF0aXZlTW9kZXMgPSB0aGlzLm5hdGl2ZU1vZGVzID0gQmFzZS5lYWNoKFtcblx0XHQnc291cmNlLW92ZXInLCAnc291cmNlLWluJywgJ3NvdXJjZS1vdXQnLCAnc291cmNlLWF0b3AnLFxuXHRcdCdkZXN0aW5hdGlvbi1vdmVyJywgJ2Rlc3RpbmF0aW9uLWluJywgJ2Rlc3RpbmF0aW9uLW91dCcsXG5cdFx0J2Rlc3RpbmF0aW9uLWF0b3AnLCAnbGlnaHRlcicsICdkYXJrZXInLCAnY29weScsICd4b3InXG5cdF0sIGZ1bmN0aW9uKG1vZGUpIHtcblx0XHR0aGlzW21vZGVdID0gdHJ1ZTtcblx0fSwge30pO1xuXG5cdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRCYXNlLmVhY2gobW9kZXMsIGZ1bmN0aW9uKGZ1bmMsIG1vZGUpIHtcblx0XHR2YXIgZGFya2VuID0gbW9kZSA9PT0gJ2RhcmtlbicsXG5cdFx0XHRvayA9IGZhbHNlO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dHJ5IHtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnIzMwMCcgOiAnI2EwMCc7XG5cdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdGlmIChjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID09PSBtb2RlKSB7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnI2EwMCcgOiAnIzMwMCc7XG5cdFx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdFx0b2sgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbMF0gIT09IGRhcmtlbiA/IDE3MCA6IDUxO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRuYXRpdmVNb2Rlc1ttb2RlXSA9IG9rO1xuXHR9KTtcblx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXG5cdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKG1vZGUsIHNyY0NvbnRleHQsIGRzdENvbnRleHQsIGFscGhhLCBvZmZzZXQpIHtcblx0XHR2YXIgc3JjQ2FudmFzID0gc3JjQ29udGV4dC5jYW52YXMsXG5cdFx0XHRub3JtYWwgPSBtb2RlID09PSAnbm9ybWFsJztcblx0XHRpZiAobm9ybWFsIHx8IG5hdGl2ZU1vZGVzW21vZGVdKSB7XG5cdFx0XHRkc3RDb250ZXh0LnNhdmUoKTtcblx0XHRcdGRzdENvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0ZHN0Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKCFub3JtYWwpXG5cdFx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdGRzdENvbnRleHQuZHJhd0ltYWdlKHNyY0NhbnZhcywgb2Zmc2V0LngsIG9mZnNldC55KTtcblx0XHRcdGRzdENvbnRleHQucmVzdG9yZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHJvY2VzcyA9IG1vZGVzW21vZGVdO1xuXHRcdFx0aWYgKCFwcm9jZXNzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgZHN0RGF0YSA9IGRzdENvbnRleHQuZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSxcblx0XHRcdFx0XHRzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLFxuXHRcdFx0XHRkc3QgID0gZHN0RGF0YS5kYXRhLFxuXHRcdFx0XHRzcmMgID0gc3JjQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCxcblx0XHRcdFx0XHRzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLmRhdGE7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGRzdC5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcblx0XHRcdFx0c3IgPSBzcmNbaV07XG5cdFx0XHRcdGJyID0gZHN0W2ldO1xuXHRcdFx0XHRzZyA9IHNyY1tpICsgMV07XG5cdFx0XHRcdGJnID0gZHN0W2kgKyAxXTtcblx0XHRcdFx0c2IgPSBzcmNbaSArIDJdO1xuXHRcdFx0XHRiYiA9IGRzdFtpICsgMl07XG5cdFx0XHRcdHNhID0gc3JjW2kgKyAzXTtcblx0XHRcdFx0YmEgPSBkc3RbaSArIDNdO1xuXHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdHZhciBhMSA9IHNhICogYWxwaGEgLyAyNTUsXG5cdFx0XHRcdFx0YTIgPSAxIC0gYTE7XG5cdFx0XHRcdGRzdFtpXSA9IGExICogZHIgKyBhMiAqIGJyO1xuXHRcdFx0XHRkc3RbaSArIDFdID0gYTEgKiBkZyArIGEyICogYmc7XG5cdFx0XHRcdGRzdFtpICsgMl0gPSBhMSAqIGRiICsgYTIgKiBiYjtcblx0XHRcdFx0ZHN0W2kgKyAzXSA9IHNhICogYWxwaGEgKyBhMiAqIGJhO1xuXHRcdFx0fVxuXHRcdFx0ZHN0Q29udGV4dC5wdXRJbWFnZURhdGEoZHN0RGF0YSwgb2Zmc2V0LngsIG9mZnNldC55KTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgU1ZHU3R5bGVzID0gQmFzZS5lYWNoKHtcblx0ZmlsbENvbG9yOiBbJ2ZpbGwnLCAnY29sb3InXSxcblx0c3Ryb2tlQ29sb3I6IFsnc3Ryb2tlJywgJ2NvbG9yJ10sXG5cdHN0cm9rZVdpZHRoOiBbJ3N0cm9rZS13aWR0aCcsICdudW1iZXInXSxcblx0c3Ryb2tlQ2FwOiBbJ3N0cm9rZS1saW5lY2FwJywgJ3N0cmluZyddLFxuXHRzdHJva2VKb2luOiBbJ3N0cm9rZS1saW5lam9pbicsICdzdHJpbmcnXSxcblx0bWl0ZXJMaW1pdDogWydzdHJva2UtbWl0ZXJsaW1pdCcsICdudW1iZXInXSxcblx0ZGFzaEFycmF5OiBbJ3N0cm9rZS1kYXNoYXJyYXknLCAnYXJyYXknXSxcblx0ZGFzaE9mZnNldDogWydzdHJva2UtZGFzaG9mZnNldCcsICdudW1iZXInXSxcblx0Zm9udEZhbWlseTogWydmb250LWZhbWlseScsICdzdHJpbmcnXSxcblx0Zm9udFdlaWdodDogWydmb250LXdlaWdodCcsICdzdHJpbmcnXSxcblx0Zm9udFNpemU6IFsnZm9udC1zaXplJywgJ251bWJlciddLFxuXHRqdXN0aWZpY2F0aW9uOiBbJ3RleHQtYW5jaG9yJywgJ2xvb2t1cCcsIHtcblx0XHRsZWZ0OiAnc3RhcnQnLFxuXHRcdGNlbnRlcjogJ21pZGRsZScsXG5cdFx0cmlnaHQ6ICdlbmQnXG5cdH1dLFxuXHRvcGFjaXR5OiBbJ29wYWNpdHknLCAnbnVtYmVyJ10sXG5cdGJsZW5kTW9kZTogWydtaXgtYmxlbmQtbW9kZScsICdzdHJpbmcnXVxufSwgZnVuY3Rpb24oZW50cnksIGtleSkge1xuXHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdGxvb2t1cCA9IGVudHJ5WzJdO1xuXHR0aGlzW2tleV0gPSB7XG5cdFx0dHlwZTogZW50cnlbMV0sXG5cdFx0cHJvcGVydHk6IGtleSxcblx0XHRhdHRyaWJ1dGU6IGVudHJ5WzBdLFxuXHRcdHRvU1ZHOiBsb29rdXAsXG5cdFx0ZnJvbVNWRzogbG9va3VwICYmIEJhc2UuZWFjaChsb29rdXAsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHR0aGlzW3ZhbHVlXSA9IG5hbWU7XG5cdFx0fSwge30pLFxuXHRcdGdldDogJ2dldCcgKyBwYXJ0LFxuXHRcdHNldDogJ3NldCcgKyBwYXJ0XG5cdH07XG59LCB7fSk7XG5cbnZhciBTVkdOYW1lc3BhY2VzID0ge1xuXHRocmVmOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG5cdHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucydcbn07XG5cbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGZvcm1hdHRlcjtcblxuXHRmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHR2YXIgdmFsID0gYXR0cnNba2V5XSxcblx0XHRcdFx0bmFtZXNwYWNlID0gU1ZHTmFtZXNwYWNlc1trZXldO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuXHRcdFx0XHR2YWwgPSBmb3JtYXR0ZXIubnVtYmVyKHZhbCk7XG5cdFx0XHRpZiAobmFtZXNwYWNlKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBrZXksIHZhbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJzKSB7XG5cdFx0cmV0dXJuIHNldEF0dHJpYnV0ZXMoXG5cdFx0XHRkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdGFnKSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKGl0ZW0sIGNvb3JkaW5hdGVzLCBjZW50ZXIpIHtcblx0XHR2YXIgbWF0cml4ID0gaXRlbS5fbWF0cml4LFxuXHRcdFx0dHJhbnMgPSBtYXRyaXguZ2V0VHJhbnNsYXRpb24oKSxcblx0XHRcdGF0dHJzID0ge307XG5cdFx0aWYgKGNvb3JkaW5hdGVzKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2hpZnRsZXNzKCk7XG5cdFx0XHR2YXIgcG9pbnQgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0odHJhbnMpO1xuXHRcdFx0YXR0cnNbY2VudGVyID8gJ2N4JyA6ICd4J10gPSBwb2ludC54O1xuXHRcdFx0YXR0cnNbY2VudGVyID8gJ2N5JyA6ICd5J10gPSBwb2ludC55O1xuXHRcdFx0dHJhbnMgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoIW1hdHJpeC5pc0lkZW50aXR5KCkpIHtcblx0XHRcdHZhciBkZWNvbXBvc2VkID0gbWF0cml4LmRlY29tcG9zZSgpO1xuXHRcdFx0aWYgKGRlY29tcG9zZWQgJiYgIWRlY29tcG9zZWQuc2hlYXJpbmcpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gW10sXG5cdFx0XHRcdFx0YW5nbGUgPSBkZWNvbXBvc2VkLnJvdGF0aW9uLFxuXHRcdFx0XHRcdHNjYWxlID0gZGVjb21wb3NlZC5zY2FsaW5nO1xuXHRcdFx0XHRpZiAodHJhbnMgJiYgIXRyYW5zLmlzWmVybygpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3RyYW5zbGF0ZSgnICsgZm9ybWF0dGVyLnBvaW50KHRyYW5zKSArICcpJyk7XG5cdFx0XHRcdGlmIChhbmdsZSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdyb3RhdGUoJyArIGZvcm1hdHRlci5udW1iZXIoYW5nbGUpICsgJyknKTtcblx0XHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnggLSAxKVxuXHRcdFx0XHRcdFx0fHwgIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueSAtIDEpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NjYWxlKCcgKyBmb3JtYXR0ZXIucG9pbnQoc2NhbGUpICsnKScpO1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyBtYXRyaXguZ2V0VmFsdWVzKCkuam9pbignLCcpICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXR0cnM7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcm91cChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0pLFxuXHRcdFx0Y2hpbGRyZW4gPSBpdGVtLl9jaGlsZHJlbjtcblx0XHR2YXIgbm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ2cnLCBhdHRycyk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0dmFyIGNoaWxkTm9kZSA9IGV4cG9ydFNWRyhjaGlsZCwgb3B0aW9ucyk7XG5cdFx0XHRpZiAoY2hpbGROb2RlKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5pc0NsaXBNYXNrKCkpIHtcblx0XHRcdFx0XHR2YXIgY2xpcCA9IGNyZWF0ZUVsZW1lbnQoJ2NsaXBQYXRoJyk7XG5cdFx0XHRcdFx0Y2xpcC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHRcdHNldERlZmluaXRpb24oY2hpbGQsIGNsaXAsICdjbGlwJyk7XG5cdFx0XHRcdFx0c2V0QXR0cmlidXRlcyhub2RlLCB7XG5cdFx0XHRcdFx0XHQnY2xpcC1wYXRoJzogJ3VybCgjJyArIGNsaXAuaWQgKyAnKSdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRSYXN0ZXIoaXRlbSkge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLCB0cnVlKSxcblx0XHRcdHNpemUgPSBpdGVtLmdldFNpemUoKTtcblx0XHRhdHRycy54IC09IHNpemUud2lkdGggLyAyO1xuXHRcdGF0dHJzLnkgLT0gc2l6ZS5oZWlnaHQgLyAyO1xuXHRcdGF0dHJzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRhdHRycy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRhdHRycy5ocmVmID0gaXRlbS50b0RhdGFVUkwoKTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgnaW1hZ2UnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucy5tYXRjaFNoYXBlcykge1xuXHRcdFx0dmFyIHNoYXBlID0gaXRlbS50b1NoYXBlKGZhbHNlKTtcblx0XHRcdGlmIChzaGFwZSlcblx0XHRcdFx0cmV0dXJuIGV4cG9ydFNoYXBlKHNoYXBlLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0dmFyIHNlZ21lbnRzID0gaXRlbS5fc2VnbWVudHMsXG5cdFx0XHR0eXBlLFxuXHRcdFx0YXR0cnM7XG5cdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGlmIChpdGVtLmlzUG9seWdvbigpKSB7XG5cdFx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID49IDMpIHtcblx0XHRcdFx0dHlwZSA9IGl0ZW0uX2Nsb3NlZCA/ICdwb2x5Z29uJyA6ICdwb2x5bGluZSc7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cGFydHMucHVzaChmb3JtYXR0ZXIucG9pbnQoc2VnbWVudHNbaV0uX3BvaW50KSk7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdHBvaW50czogcGFydHMuam9pbignICcpXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gJ2xpbmUnO1xuXHRcdFx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXS5fcG9pbnQsXG5cdFx0XHRcdFx0bGFzdCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLl9wb2ludDtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0eDE6IGZpcnN0LngsXG5cdFx0XHRcdFx0eTE6IGZpcnN0LnksXG5cdFx0XHRcdFx0eDI6IGxhc3QueCxcblx0XHRcdFx0XHR5MjogbGFzdC55XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHR5cGUgPSAncGF0aCc7XG5cdFx0XHR2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEoKTtcblx0XHRcdGF0dHJzID0gZGF0YSAmJiB7IGQ6IGRhdGEgfTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U2hhcGUoaXRlbSkge1xuXHRcdHZhciB0eXBlID0gaXRlbS5fdHlwZSxcblx0XHRcdHJhZGl1cyA9IGl0ZW0uX3JhZGl1cyxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0sIHRydWUsIHR5cGUgIT09ICdyZWN0YW5nbGUnKTtcblx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdHR5cGUgPSAncmVjdCc7IFxuXHRcdFx0dmFyIHNpemUgPSBpdGVtLl9zaXplLFxuXHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0YXR0cnMueCAtPSB3aWR0aCAvIDI7XG5cdFx0XHRhdHRycy55IC09IGhlaWdodCAvIDI7XG5cdFx0XHRhdHRycy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0YXR0cnMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0aWYgKHJhZGl1cy5pc1plcm8oKSlcblx0XHRcdFx0cmFkaXVzID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHJhZGl1cykge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdGF0dHJzLnIgPSByYWRpdXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy5yeCA9IHJhZGl1cy53aWR0aDtcblx0XHRcdFx0YXR0cnMucnkgPSByYWRpdXMuaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRDb21wb3VuZFBhdGgoaXRlbSkge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLCB0cnVlKTtcblx0XHR2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEoKTtcblx0XHRpZiAoZGF0YSlcblx0XHRcdGF0dHJzLmQgPSBkYXRhO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KCdwYXRoJywgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UGxhY2VkU3ltYm9sKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbSwgdHJ1ZSksXG5cdFx0XHRzeW1ib2wgPSBpdGVtLmdldFN5bWJvbCgpLFxuXHRcdFx0c3ltYm9sTm9kZSA9IGdldERlZmluaXRpb24oc3ltYm9sLCAnc3ltYm9sJyksXG5cdFx0XHRkZWZpbml0aW9uID0gc3ltYm9sLmdldERlZmluaXRpb24oKSxcblx0XHRcdGJvdW5kcyA9IGRlZmluaXRpb24uZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKCFzeW1ib2xOb2RlKSB7XG5cdFx0XHRzeW1ib2xOb2RlID0gY3JlYXRlRWxlbWVudCgnc3ltYm9sJywge1xuXHRcdFx0XHR2aWV3Qm94OiBmb3JtYXR0ZXIucmVjdGFuZ2xlKGJvdW5kcylcblx0XHRcdH0pO1xuXHRcdFx0c3ltYm9sTm9kZS5hcHBlbmRDaGlsZChleHBvcnRTVkcoZGVmaW5pdGlvbiwgb3B0aW9ucykpO1xuXHRcdFx0c2V0RGVmaW5pdGlvbihzeW1ib2wsIHN5bWJvbE5vZGUsICdzeW1ib2wnKTtcblx0XHR9XG5cdFx0YXR0cnMuaHJlZiA9ICcjJyArIHN5bWJvbE5vZGUuaWQ7XG5cdFx0YXR0cnMueCArPSBib3VuZHMueDtcblx0XHRhdHRycy55ICs9IGJvdW5kcy55O1xuXHRcdGF0dHJzLndpZHRoID0gZm9ybWF0dGVyLm51bWJlcihib3VuZHMud2lkdGgpO1xuXHRcdGF0dHJzLmhlaWdodCA9IGZvcm1hdHRlci5udW1iZXIoYm91bmRzLmhlaWdodCk7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3VzZScsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyYWRpZW50KGNvbG9yKSB7XG5cdFx0dmFyIGdyYWRpZW50Tm9kZSA9IGdldERlZmluaXRpb24oY29sb3IsICdjb2xvcicpO1xuXHRcdGlmICghZ3JhZGllbnROb2RlKSB7XG5cdFx0XHR2YXIgZ3JhZGllbnQgPSBjb2xvci5nZXRHcmFkaWVudCgpLFxuXHRcdFx0XHRyYWRpYWwgPSBncmFkaWVudC5fcmFkaWFsLFxuXHRcdFx0XHRvcmlnaW4gPSBjb2xvci5nZXRPcmlnaW4oKS50cmFuc2Zvcm0oKSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb2xvci5nZXREZXN0aW5hdGlvbigpLnRyYW5zZm9ybSgpLFxuXHRcdFx0XHRhdHRycztcblx0XHRcdGlmIChyYWRpYWwpIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0Y3g6IG9yaWdpbi54LFxuXHRcdFx0XHRcdGN5OiBvcmlnaW4ueSxcblx0XHRcdFx0XHRyOiBvcmlnaW4uZ2V0RGlzdGFuY2UoZGVzdGluYXRpb24pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBoaWdobGlnaHQgPSBjb2xvci5nZXRIaWdobGlnaHQoKTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdGhpZ2hsaWdodCA9IGhpZ2hsaWdodC50cmFuc2Zvcm0oKTtcblx0XHRcdFx0XHRhdHRycy5meCA9IGhpZ2hsaWdodC54O1xuXHRcdFx0XHRcdGF0dHJzLmZ5ID0gaGlnaGxpZ2h0Lnk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdHgxOiBvcmlnaW4ueCxcblx0XHRcdFx0XHR5MTogb3JpZ2luLnksXG5cdFx0XHRcdFx0eDI6IGRlc3RpbmF0aW9uLngsXG5cdFx0XHRcdFx0eTI6IGRlc3RpbmF0aW9uLnlcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGF0dHJzLmdyYWRpZW50VW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xuXHRcdFx0Z3JhZGllbnROb2RlID0gY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHQocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJykgKyAnR3JhZGllbnQnLCBhdHRycyk7XG5cdFx0XHR2YXIgc3RvcHMgPSBncmFkaWVudC5fc3RvcHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldLFxuXHRcdFx0XHRcdHN0b3BDb2xvciA9IHN0b3AuX2NvbG9yLFxuXHRcdFx0XHRcdGFscGhhID0gc3RvcENvbG9yLmdldEFscGhhKCk7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdG9mZnNldDogc3RvcC5fcmFtcFBvaW50LFxuXHRcdFx0XHRcdCdzdG9wLWNvbG9yJzogc3RvcENvbG9yLnRvQ1NTKHRydWUpXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdFx0YXR0cnNbJ3N0b3Atb3BhY2l0eSddID0gYWxwaGE7XG5cdFx0XHRcdGdyYWRpZW50Tm9kZS5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzdG9wJywgYXR0cnMpKTtcblx0XHRcdH1cblx0XHRcdHNldERlZmluaXRpb24oY29sb3IsIGdyYWRpZW50Tm9kZSwgJ2NvbG9yJyk7XG5cdFx0fVxuXHRcdHJldHVybiAndXJsKCMnICsgZ3JhZGllbnROb2RlLmlkICsgJyknO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0VGV4dChpdGVtKSB7XG5cdFx0dmFyIG5vZGUgPSBjcmVhdGVFbGVtZW50KCd0ZXh0JywgZ2V0VHJhbnNmb3JtKGl0ZW0sIHRydWUpKTtcblx0XHRub2RlLnRleHRDb250ZW50ID0gaXRlbS5fY29udGVudDtcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdHZhciBleHBvcnRlcnMgPSB7XG5cdFx0R3JvdXA6IGV4cG9ydEdyb3VwLFxuXHRcdExheWVyOiBleHBvcnRHcm91cCxcblx0XHRSYXN0ZXI6IGV4cG9ydFJhc3Rlcixcblx0XHRQYXRoOiBleHBvcnRQYXRoLFxuXHRcdFNoYXBlOiBleHBvcnRTaGFwZSxcblx0XHRDb21wb3VuZFBhdGg6IGV4cG9ydENvbXBvdW5kUGF0aCxcblx0XHRQbGFjZWRTeW1ib2w6IGV4cG9ydFBsYWNlZFN5bWJvbCxcblx0XHRQb2ludFRleHQ6IGV4cG9ydFRleHRcblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUpIHtcblx0XHR2YXIgYXR0cnMgPSB7fSxcblx0XHRcdHBhcmVudCA9IGl0ZW0uZ2V0UGFyZW50KCk7XG5cblx0XHRpZiAoaXRlbS5fbmFtZSAhPSBudWxsKVxuXHRcdFx0YXR0cnMuaWQgPSBpdGVtLl9uYW1lO1xuXG5cdFx0QmFzZS5lYWNoKFNWR1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHRcdHZhciBnZXQgPSBlbnRyeS5nZXQsXG5cdFx0XHRcdHR5cGUgPSBlbnRyeS50eXBlLFxuXHRcdFx0XHR2YWx1ZSA9IGl0ZW1bZ2V0XSgpO1xuXHRcdFx0aWYgKCFwYXJlbnQgfHwgIUJhc2UuZXF1YWxzKHBhcmVudFtnZXRdKCksIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NvbG9yJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIGFscGhhID0gdmFsdWUuZ2V0QWxwaGEoKTtcblx0XHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlICsgJy1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGVdID0gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHRcdD8gJ25vbmUnXG5cdFx0XHRcdFx0OiB0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBmb3JtYXR0ZXIubnVtYmVyKHZhbHVlKVxuXHRcdFx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuZ3JhZGllbnRcblx0XHRcdFx0XHRcdFx0XHQ/IGV4cG9ydEdyYWRpZW50KHZhbHVlLCBpdGVtKVxuXHRcdFx0XHRcdFx0XHRcdDogdmFsdWUudG9DU1ModHJ1ZSlcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnYXJyYXknXG5cdFx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5qb2luKCcsJylcblx0XHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdsb29rdXAnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGVudHJ5LnRvU1ZHW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChhdHRycy5vcGFjaXR5ID09PSAxKVxuXHRcdFx0ZGVsZXRlIGF0dHJzLm9wYWNpdHk7XG5cblx0XHRpZiAoaXRlbS5fdmlzaWJpbGl0eSAhPSBudWxsICYmICFpdGVtLl92aXNpYmlsaXR5KVxuXHRcdFx0YXR0cnMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG5cdFx0cmV0dXJuIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpO1xuXHR9XG5cblx0dmFyIGRlZmluaXRpb25zO1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKGl0ZW0sIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSB7IGlkczoge30sIHN2Z3M6IHt9IH07XG5cdFx0cmV0dXJuIGl0ZW0gJiYgZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgaXRlbS5faWRdO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0RGVmaW5pdGlvbihpdGVtLCBub2RlLCB0eXBlKSB7XG5cdFx0aWYgKCFkZWZpbml0aW9ucylcblx0XHRcdGdldERlZmluaXRpb24oKTtcblx0XHR2YXIgaWQgPSBkZWZpbml0aW9ucy5pZHNbdHlwZV0gPSAoZGVmaW5pdGlvbnMuaWRzW3R5cGVdIHx8IDApICsgMTtcblx0XHRub2RlLmlkID0gdHlwZSArICctJyArIGlkO1xuXHRcdGRlZmluaXRpb25zLnN2Z3NbdHlwZSArICctJyArIGl0ZW0uX2lkXSA9IG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHN2ZyA9IG5vZGUsXG5cdFx0XHRkZWZzID0gbnVsbDtcblx0XHRpZiAoZGVmaW5pdGlvbnMpIHtcblx0XHRcdHN2ZyA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycgJiYgbm9kZTtcblx0XHRcdGZvciAodmFyIGkgaW4gZGVmaW5pdGlvbnMuc3Zncykge1xuXHRcdFx0XHRpZiAoIWRlZnMpIHtcblx0XHRcdFx0XHRpZiAoIXN2Zykge1xuXHRcdFx0XHRcdFx0c3ZnID0gY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG5cdFx0XHRcdFx0XHRzdmcuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlZnMgPSBzdmcuaW5zZXJ0QmVmb3JlKGNyZWF0ZUVsZW1lbnQoJ2RlZnMnKSxcblx0XHRcdFx0XHRcdFx0c3ZnLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZnMuYXBwZW5kQ2hpbGQoZGVmaW5pdGlvbnMuc3Znc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbml0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpb25zLmFzU3RyaW5nXG5cdFx0XHRcdD8gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpXG5cdFx0XHRcdDogc3ZnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U1ZHKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgZXhwb3J0ZXIgPSBleHBvcnRlcnNbaXRlbS5fY2xhc3NdLFxuXHRcdFx0bm9kZSA9IGV4cG9ydGVyICYmIGV4cG9ydGVyKGl0ZW0sIG9wdGlvbnMpO1xuXHRcdGlmIChub2RlICYmIGl0ZW0uX2RhdGEpIHtcblx0XHRcdHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5fZGF0YSk7XG5cdFx0XHRpZiAoZGF0YSAhPT0gJ3t9Jylcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScsIGRhdGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZSAmJiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMoZXhwb3J0U1ZHKHRoaXMsIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0dmFyIGxheWVycyA9IHRoaXMubGF5ZXJzLFxuXHRcdFx0XHRzaXplID0gdGhpcy5nZXRWaWV3KCkuZ2V0U2l6ZSgpLFxuXHRcdFx0XHRub2RlID0gY3JlYXRlRWxlbWVudCgnc3ZnJywge1xuXHRcdFx0XHRcdHg6IDAsXG5cdFx0XHRcdFx0eTogMCxcblx0XHRcdFx0XHR3aWR0aDogc2l6ZS53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuXHRcdFx0XHRcdHZlcnNpb246ICcxLjEnLFxuXHRcdFx0XHRcdHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdFx0XHRcdCd4bWxuczp4bGluayc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xuXHRcdFx0XHR9KTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChleHBvcnRTVkcobGF5ZXJzW2ldLCBvcHRpb25zKSk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBnZXRWYWx1ZShub2RlLCBuYW1lLCBpc1N0cmluZywgYWxsb3dOdWxsKSB7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IFNWR05hbWVzcGFjZXNbbmFtZV0sXG5cdFx0XHR2YWx1ZSA9IG5hbWVzcGFjZVxuXHRcdFx0XHQ/IG5vZGUuZ2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lKVxuXHRcdFx0XHQ6IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXHRcdGlmICh2YWx1ZSA9PT0gJ251bGwnKVxuXHRcdFx0dmFsdWUgPSBudWxsO1xuXHRcdHJldHVybiB2YWx1ZSA9PSBudWxsXG5cdFx0XHRcdD8gYWxsb3dOdWxsXG5cdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdFx0PyAnJ1xuXHRcdFx0XHRcdFx0OiAwXG5cdFx0XHRcdDogaXNTdHJpbmdcblx0XHRcdFx0XHQ/IHZhbHVlXG5cdFx0XHRcdFx0OiBwYXJzZUZsb2F0KHZhbHVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBvaW50KG5vZGUsIHgsIHksIGFsbG93TnVsbCkge1xuXHRcdHggPSBnZXRWYWx1ZShub2RlLCB4LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHR5ID0gZ2V0VmFsdWUobm9kZSwgeSwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0cmV0dXJuIGFsbG93TnVsbCAmJiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkgPyBudWxsXG5cdFx0XHRcdDogbmV3IFBvaW50KHgsIHkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2l6ZShub2RlLCB3LCBoLCBhbGxvd051bGwpIHtcblx0XHR3ID0gZ2V0VmFsdWUobm9kZSwgdywgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0aCA9IGdldFZhbHVlKG5vZGUsIGgsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHJldHVybiBhbGxvd051bGwgJiYgKHcgPT0gbnVsbCB8fCBoID09IG51bGwpID8gbnVsbFxuXHRcdFx0XHQ6IG5ldyBTaXplKHcsIGgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlLCB0eXBlLCBsb29rdXApIHtcblx0XHRyZXR1cm4gdmFsdWUgPT09ICdub25lJ1xuXHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0OiB0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdD8gcGFyc2VGbG9hdCh2YWx1ZSlcblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheSdcblx0XHRcdFx0XHRcdD8gdmFsdWUgPyB2YWx1ZS5zcGxpdCgvW1xccyxdKy9nKS5tYXAocGFyc2VGbG9hdCkgOiBbXVxuXHRcdFx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InXG5cdFx0XHRcdFx0XHRcdD8gZ2V0RGVmaW5pdGlvbih2YWx1ZSkgfHwgdmFsdWVcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJ1xuXHRcdFx0XHRcdFx0XHRcdD8gbG9va3VwW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHRcdDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcm91cChub2RlLCB0eXBlLCBpc1Jvb3QsIG9wdGlvbnMpIHtcblx0XHR2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG5cdFx0XHRpc0NsaXAgPSB0eXBlID09PSAnY2xpcHBhdGgnLFxuXHRcdFx0aXRlbSA9IG5ldyBHcm91cCgpLFxuXHRcdFx0cHJvamVjdCA9IGl0ZW0uX3Byb2plY3QsXG5cdFx0XHRjdXJyZW50U3R5bGUgPSBwcm9qZWN0Ll9jdXJyZW50U3R5bGUsXG5cdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdGlmICghaXNDbGlwKSB7XG5cdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdFx0XHRwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBpdGVtLl9zdHlsZS5jbG9uZSgpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkTm9kZSA9IG5vZGVzW2ldLFxuXHRcdFx0XHRjaGlsZDtcblx0XHRcdGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDFcblx0XHRcdFx0XHQmJiAoY2hpbGQgPSBpbXBvcnRTVkcoY2hpbGROb2RlLCBmYWxzZSwgb3B0aW9ucykpXG5cdFx0XHRcdFx0JiYgIShjaGlsZCBpbnN0YW5jZW9mIFN5bWJvbCkpXG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdH1cblx0XHRpdGVtLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHRpZiAoaXNDbGlwKVxuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLnJlZHVjZSgpLCBub2RlLCBpc1Jvb3QpO1xuXHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGN1cnJlbnRTdHlsZTtcblx0XHRpZiAoaXNDbGlwIHx8IHR5cGUgPT09ICdkZWZzJykge1xuXHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdGl0ZW0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBvbHkobm9kZSwgdHlwZSkge1xuXHRcdHZhciBjb29yZHMgPSBub2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJykubWF0Y2goXG5cdFx0XHRcdFx0L1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb29yZHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2ldKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pKSk7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aChwb2ludHMpO1xuXHRcdGlmICh0eXBlID09PSAncG9seWdvbicpXG5cdFx0XHRwYXRoLmNsb3NlUGF0aCgpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UGF0aChub2RlKSB7XG5cdFx0dmFyIGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSgnZCcpLFxuXHRcdFx0cGFyYW0gPSB7IHBhdGhEYXRhOiBkYXRhIH07XG5cdFx0cmV0dXJuIGRhdGEubWF0Y2goL20vZ2kpLmxlbmd0aCA+IDEgfHwgL3pcXFMrL2kudGVzdChkYXRhKVxuXHRcdFx0XHQ/IG5ldyBDb21wb3VuZFBhdGgocGFyYW0pXG5cdFx0XHRcdDogbmV3IFBhdGgocGFyYW0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0R3JhZGllbnQobm9kZSwgdHlwZSkge1xuXHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRpc1JhZGlhbCA9IHR5cGUgPT09ICdyYWRpYWxncmFkaWVudCcsXG5cdFx0XHRncmFkaWVudDtcblx0XHRpZiAoaWQpIHtcblx0XHRcdGdyYWRpZW50ID0gZGVmaW5pdGlvbnNbaWRdLmdldEdyYWRpZW50KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdFx0c3RvcHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpXG5cdFx0XHRcdFx0c3RvcHMucHVzaChhcHBseUF0dHJpYnV0ZXMobmV3IEdyYWRpZW50U3RvcCgpLCBjaGlsZCkpO1xuXHRcdFx0fVxuXHRcdFx0Z3JhZGllbnQgPSBuZXcgR3JhZGllbnQoc3RvcHMsIGlzUmFkaWFsKTtcblx0XHR9XG5cdFx0dmFyIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodDtcblx0XHRpZiAoaXNSYWRpYWwpIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBvcmlnaW4uYWRkKGdldFZhbHVlKG5vZGUsICdyJyksIDApO1xuXHRcdFx0aGlnaGxpZ2h0ID0gZ2V0UG9pbnQobm9kZSwgJ2Z4JywgJ2Z5JywgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICd4MScsICd5MScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBnZXRQb2ludChub2RlLCAneDInLCAneTInKTtcblx0XHR9XG5cdFx0YXBwbHlBdHRyaWJ1dGVzKFxuXHRcdFx0bmV3IENvbG9yKGdyYWRpZW50LCBvcmlnaW4sIGRlc3RpbmF0aW9uLCBoaWdobGlnaHQpLCBub2RlKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBpbXBvcnRlcnMgPSB7XG5cdFx0JyNkb2N1bWVudCc6IGZ1bmN0aW9uIChub2RlLCB0eXBlLCBpc1Jvb3QsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHR2YXIgbmV4dCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHRcdHZhciBpdGVtID0gaW1wb3J0U1ZHKGNoaWxkLCBpc1Jvb3QsIG9wdGlvbnMpO1xuXHRcdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0XHRub2RlLmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZzogaW1wb3J0R3JvdXAsXG5cdFx0c3ZnOiBpbXBvcnRHcm91cCxcblx0XHRjbGlwcGF0aDogaW1wb3J0R3JvdXAsXG5cdFx0cG9seWdvbjogaW1wb3J0UG9seSxcblx0XHRwb2x5bGluZTogaW1wb3J0UG9seSxcblx0XHRwYXRoOiBpbXBvcnRQYXRoLFxuXHRcdGxpbmVhcmdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblx0XHRyYWRpYWxncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG5cblx0XHRpbWFnZTogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdHZhciByYXN0ZXIgPSBuZXcgUmFzdGVyKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkpO1xuXHRcdFx0cmFzdGVyLmF0dGFjaCgnbG9hZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcpO1xuXHRcdFx0XHR0aGlzLnNldFNpemUoc2l6ZSk7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFxuXHRcdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ3gnLCAneScpLmFkZChzaXplLmRpdmlkZSgyKSkpO1xuXHRcdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcmFzdGVyO1xuXHRcdH0sXG5cblx0XHRzeW1ib2w6IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIGlzUm9vdCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBTeW1ib2woaW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgaXNSb290LCBvcHRpb25zKSwgdHJ1ZSk7XG5cdFx0fSxcblxuXHRcdGRlZnM6IGltcG9ydEdyb3VwLFxuXG5cdFx0dXNlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgaWQgPSAoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSB8fCAnJykuc3Vic3RyaW5nKDEpLFxuXHRcdFx0XHRkZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbaWRdLFxuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KG5vZGUsICd4JywgJ3knKTtcblx0XHRcdHJldHVybiBkZWZpbml0aW9uXG5cdFx0XHRcdFx0PyBkZWZpbml0aW9uIGluc3RhbmNlb2YgU3ltYm9sXG5cdFx0XHRcdFx0XHQ/IGRlZmluaXRpb24ucGxhY2UocG9pbnQpXG5cdFx0XHRcdFx0XHQ6IGRlZmluaXRpb24uY2xvbmUoKS50cmFuc2xhdGUocG9pbnQpXG5cdFx0XHRcdFx0OiBudWxsO1xuXHRcdH0sXG5cblx0XHRjaXJjbGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuQ2lyY2xlKGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpLFxuXHRcdFx0XHRcdGdldFZhbHVlKG5vZGUsICdyJykpO1xuXHRcdH0sXG5cblx0XHRlbGxpcHNlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLkVsbGlwc2Uoe1xuXHRcdFx0XHRjZW50ZXI6IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpLFxuXHRcdFx0XHRyYWRpdXM6IGdldFNpemUobm9kZSwgJ3J4JywgJ3J5Jylcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRyZWN0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBnZXRQb2ludChub2RlLCAneCcsICd5JyksXG5cdFx0XHRcdHNpemUgPSBnZXRTaXplKG5vZGUsICd3aWR0aCcsICdoZWlnaHQnKSxcblx0XHRcdFx0cmFkaXVzID0gZ2V0U2l6ZShub2RlLCAncngnLCAncnknKTtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuUmVjdGFuZ2xlKG5ldyBSZWN0YW5nbGUocG9pbnQsIHNpemUpLCByYWRpdXMpO1xuXHRcdH0sXG5cblx0XHRsaW5lOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBhdGguTGluZShnZXRQb2ludChub2RlLCAneDEnLCAneTEnKSxcblx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneDInLCAneTInKSk7XG5cdFx0fSxcblxuXHRcdHRleHQ6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciB0ZXh0ID0gbmV3IFBvaW50VGV4dChnZXRQb2ludChub2RlLCAneCcsICd5Jylcblx0XHRcdFx0XHQuYWRkKGdldFBvaW50KG5vZGUsICdkeCcsICdkeScpKSk7XG5cdFx0XHR0ZXh0LnNldENvbnRlbnQobm9kZS50ZXh0Q29udGVudC50cmltKCkgfHwgJycpO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlKSB7XG5cdFx0dmFyIHRyYW5zZm9ybXMgPSAobm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgJycpLnNwbGl0KC9cXClcXHMqL2cpLFxuXHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW2ldO1xuXHRcdFx0aWYgKCF0cmFuc2Zvcm0pXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0dmFyIHBhcnRzID0gdHJhbnNmb3JtLnNwbGl0KCcoJyksXG5cdFx0XHRcdGNvbW1hbmQgPSBwYXJ0c1swXSxcblx0XHRcdFx0diA9IHBhcnRzWzFdLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDAsIG0gPSB2Lmxlbmd0aDsgaiA8IG07IGorKylcblx0XHRcdFx0dltqXSA9IHBhcnNlRmxvYXQodltqXSk7XG5cdFx0XHRzd2l0Y2ggKGNvbW1hbmQpIHtcblx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdG1hdHJpeC5jb25jYXRlbmF0ZShcblx0XHRcdFx0XHRcdG5ldyBNYXRyaXgodlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdG1hdHJpeC5yb3RhdGUodlswXSwgdlsxXSwgdlsyXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0bWF0cml4LnRyYW5zbGF0ZSh2WzBdLCB2WzFdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdG1hdHJpeC5zY2FsZSh2KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdza2V3WCc6XG5cdFx0XHRcdG1hdHJpeC5za2V3KHZbMF0sIDApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NrZXdZJzpcblx0XHRcdFx0bWF0cml4LnNrZXcoMCwgdlswXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpdGVtLnRyYW5zZm9ybShtYXRyaXgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlPcGFjaXR5KGl0ZW0sIHZhbHVlLCBuYW1lKSB7XG5cdFx0dmFyIGNvbG9yID0gaXRlbVtuYW1lID09PSAnZmlsbC1vcGFjaXR5JyA/ICdnZXRGaWxsQ29sb3InXG5cdFx0XHRcdDogJ2dldFN0cm9rZUNvbG9yJ10oKTtcblx0XHRpZiAoY29sb3IpXG5cdFx0XHRjb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdH1cblxuXHR2YXIgYXR0cmlidXRlcyA9IEJhc2UuZWFjaChTVkdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0dGhpc1tlbnRyeS5hdHRyaWJ1dGVdID0gZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGl0ZW1bZW50cnkuc2V0XShjb252ZXJ0VmFsdWUodmFsdWUsIGVudHJ5LnR5cGUsIGVudHJ5LmZyb21TVkcpKTtcblx0XHRcdGlmIChlbnRyeS50eXBlID09PSAnY29sb3InICYmIGl0ZW0gaW5zdGFuY2VvZiBTaGFwZSkge1xuXHRcdFx0XHR2YXIgY29sb3IgPSBpdGVtW2VudHJ5LmdldF0oKTtcblx0XHRcdFx0aWYgKGNvbG9yKVxuXHRcdFx0XHRcdGNvbG9yLnRyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRpdGVtLmdldFBvc2l0aW9uKHRydWUpLm5lZ2F0ZSgpKSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSwge1xuXHRcdGlkOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0ZGVmaW5pdGlvbnNbdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmIChpdGVtLnNldE5hbWUpXG5cdFx0XHRcdGl0ZW0uc2V0TmFtZSh2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdjbGlwLXBhdGgnOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIGNsaXAgPSBnZXREZWZpbml0aW9uKHZhbHVlKTtcblx0XHRcdGlmIChjbGlwKSB7XG5cdFx0XHRcdGNsaXAgPSBjbGlwLmNsb25lKCk7XG5cdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0XHRpdGVtLmluc2VydENoaWxkKDAsIGNsaXApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgR3JvdXAoY2xpcCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z3JhZGllbnRUcmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuXHRcdHRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cblx0XHQnZmlsbC1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXHRcdCdzdHJva2Utb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcblxuXHRcdHZpc2liaWxpdHk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgPT09ICd2aXNpYmxlJyk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLWNvbG9yJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldENvbG9yKVxuXHRcdFx0XHRpdGVtLnNldENvbG9yKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J3N0b3Atb3BhY2l0eSc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5fY29sb3IpXG5cdFx0XHRcdGl0ZW0uX2NvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0b2Zmc2V0OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIHBlcmNlbnRhZ2UgPSB2YWx1ZS5tYXRjaCgvKC4qKSUkLyk7XG5cdFx0XHRpdGVtLnNldFJhbXBQb2ludChwZXJjZW50YWdlXG5cdFx0XHRcdFx0PyBwZXJjZW50YWdlWzFdIC8gMTAwXG5cdFx0XHRcdFx0OiBwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdHZpZXdCb3g6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpIHtcblx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZShjb252ZXJ0VmFsdWUodmFsdWUsICdhcnJheScpKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcsIHRydWUpO1xuXHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHR2YXIgc2NhbGUgPSBzaXplID8gcmVjdC5nZXRTaXplKCkuZGl2aWRlKHNpemUpIDogMSxcblx0XHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkudHJhbnNsYXRlKHJlY3QuZ2V0UG9pbnQoKSkuc2NhbGUoc2NhbGUpO1xuXHRcdFx0XHRpdGVtLnRyYW5zZm9ybShtYXRyaXguaW52ZXJ0ZWQoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcblx0XHRcdFx0aWYgKHNpemUpXG5cdFx0XHRcdFx0cmVjdC5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHR2YXIgY2xpcCA9IGdldEF0dHJpYnV0ZShub2RlLCAnb3ZlcmZsb3cnLCBzdHlsZXMpICE9ICd2aXNpYmxlJyxcblx0XHRcdFx0XHRncm91cCA9IGl0ZW0uX2RlZmluaXRpb247XG5cdFx0XHRcdGlmIChjbGlwICYmICFyZWN0LmNvbnRhaW5zKGdyb3VwLmdldEJvdW5kcygpKSkge1xuXHRcdFx0XHRcdGNsaXAgPSBuZXcgU2hhcGUuUmVjdGFuZ2xlKHJlY3QpLnRyYW5zZm9ybShncm91cC5fbWF0cml4KTtcblx0XHRcdFx0XHRjbGlwLnNldENsaXBNYXNrKHRydWUpO1xuXHRcdFx0XHRcdGdyb3VwLmFkZENoaWxkKGNsaXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKSB7XG5cdFx0dmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbbmFtZV0sXG5cdFx0XHR2YWx1ZSA9IGF0dHIgJiYgYXR0ci52YWx1ZTtcblx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBCYXNlLmNhbWVsaXplKG5hbWUpO1xuXHRcdFx0dmFsdWUgPSBub2RlLnN0eWxlW3N0eWxlXTtcblx0XHRcdGlmICghdmFsdWUgJiYgc3R5bGVzLm5vZGVbc3R5bGVdICE9PSBzdHlsZXMucGFyZW50W3N0eWxlXSlcblx0XHRcdFx0dmFsdWUgPSBzdHlsZXMubm9kZVtzdHlsZV07XG5cdFx0fVxuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0PyB1bmRlZmluZWRcblx0XHRcdFx0OiB2YWx1ZSA9PT0gJ25vbmUnXG5cdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpIHtcblx0XHR2YXIgc3R5bGVzID0ge1xuXHRcdFx0bm9kZTogRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZSkgfHwge30sXG5cdFx0XHRwYXJlbnQ6ICFpc1Jvb3QgJiYgRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZS5wYXJlbnROb2RlKSB8fCB7fVxuXHRcdH07XG5cdFx0QmFzZS5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGFwcGx5LCBuYW1lKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKTtcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRpdGVtID0gQmFzZS5waWNrKGFwcGx5KGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpLCBpdGVtKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdHZhciBkZWZpbml0aW9ucyA9IHt9O1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIG1hdGNoID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL1xcKCg/OiN8KShbXiknXSspLyk7XG5cdFx0cmV0dXJuIG1hdGNoICYmIGRlZmluaXRpb25zW21hdGNoWzFdXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFNWRyhzb3VyY2UsIGlzUm9vdCwgb3B0aW9ucykge1xuXHRcdGlmICghc291cmNlKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0aWYgKCFvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3B0aW9ucyA9IHsgb25Mb2FkOiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0dmFyIG5vZGUgPSBzb3VyY2UsXG5cdFx0XHRzY29wZSA9IHBhcGVyO1xuXG5cdFx0ZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2soc3ZnKSB7XG5cdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0dmFyIGl0ZW0gPSBpbXBvcnRTVkcoc3ZnLCBpc1Jvb3QsIG9wdGlvbnMpLFxuXHRcdFx0XHRvbkxvYWQgPSBvcHRpb25zLm9uTG9hZCxcblx0XHRcdFx0dmlldyA9IHNjb3BlLnByb2plY3QgJiYgc2NvcGUuZ2V0VmlldygpO1xuXHRcdFx0aWYgKG9uTG9hZClcblx0XHRcdFx0b25Mb2FkLmNhbGwodGhpcywgaXRlbSk7XG5cdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAhL14uKjwvLnRlc3Qoc291cmNlKSkge1xuXHRcdFx0XHRub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc291cmNlKTtcblx0XHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0XHRzb3VyY2UgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBIdHRwLnJlcXVlc3QoJ2dldCcsIHNvdXJjZSwgb25Mb2FkQ2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG5cdFx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0b25Mb2FkQ2FsbGJhY2socmVhZGVyLnJlc3VsdCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiByZWFkZXIucmVhZEFzVGV4dChzb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJylcblx0XHRcdG5vZGUgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHNvdXJjZSwgJ2ltYWdlL3N2Zyt4bWwnKTtcblx0XHRpZiAoIW5vZGUubm9kZU5hbWUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFNWRyBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuXHRcdHZhciB0eXBlID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0aW1wb3J0ZXIgPSBpbXBvcnRlcnNbdHlwZV0sXG5cdFx0XHRpdGVtLFxuXHRcdFx0ZGF0YSA9IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnKSxcblx0XHRcdHNldHRpbmdzID0gc2NvcGUuc2V0dGluZ3MsXG5cdFx0XHRwcmV2QXBwbHlNYXRyaXggPSBzZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRzZXR0aW5ncy5hcHBseU1hdHJpeCA9IGZhbHNlO1xuXHRcdGl0ZW0gPSBpbXBvcnRlciAmJiBpbXBvcnRlcihub2RlLCB0eXBlLCBpc1Jvb3QsIG9wdGlvbnMpIHx8IG51bGw7XG5cdFx0c2V0dGluZ3MuYXBwbHlNYXRyaXggPSBwcmV2QXBwbHlNYXRyaXg7XG5cdFx0aWYgKGl0ZW0pIHtcblx0XHRcdGlmICghKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdGlmIChvcHRpb25zLmV4cGFuZFNoYXBlcyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0aXRlbSA9IGl0ZW0udG9QYXRoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YSlcblx0XHRcdFx0aXRlbS5fZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0fVxuXHRcdGlmIChpc1Jvb3QpXG5cdFx0XHRkZWZpbml0aW9ucyA9IHt9O1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2hpbGQoaW1wb3J0U1ZHKG5vZGUsIHRydWUsIG9wdGlvbnMpKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiBpbXBvcnRTVkcobm9kZSwgdHJ1ZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbkJhc2UuZXhwb3J0cy5QYXBlclNjcmlwdCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGV4cG9ydHMsIGRlZmluZSxcblx0XHRzY29wZSA9IHRoaXM7XG4hZnVuY3Rpb24oZSxyKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9yKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxyKToocihlLmFjb3JufHwoZS5hY29ybj17fSkpLHZvaWQgMCl9KHRoaXMsZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtmcj1lfHx7fTtmb3IodmFyIHIgaW4gaHIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZyLHIpfHwoZnJbcl09aHJbcl0pO21yPWZyLnNvdXJjZUZpbGV8fG51bGx9ZnVuY3Rpb24gdChlLHIpe3ZhciB0PXZyKHByLGUpO3IrPVwiIChcIit0LmxpbmUrXCI6XCIrdC5jb2x1bW4rXCIpXCI7dmFyIG49bmV3IFN5bnRheEVycm9yKHIpO3Rocm93IG4ucG9zPWUsbi5sb2M9dCxuLnJhaXNlZEF0PWJyLG59ZnVuY3Rpb24gbihlKXtmdW5jdGlvbiByKGUpe2lmKDE9PWUubGVuZ3RoKXJldHVybiB0Kz1cInJldHVybiBzdHIgPT09IFwiK0pTT04uc3RyaW5naWZ5KGVbMF0pK1wiO1wiO3QrPVwic3dpdGNoKHN0cil7XCI7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDsrK3IpdCs9XCJjYXNlIFwiK0pTT04uc3RyaW5naWZ5KGVbcl0pK1wiOlwiO3QrPVwicmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO1wifWU9ZS5zcGxpdChcIiBcIik7dmFyIHQ9XCJcIixuPVtdO2U6Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDsrK2Epe2Zvcih2YXIgbz0wO288bi5sZW5ndGg7KytvKWlmKG5bb11bMF0ubGVuZ3RoPT1lW2FdLmxlbmd0aCl7bltvXS5wdXNoKGVbYV0pO2NvbnRpbnVlIGV9bi5wdXNoKFtlW2FdXSl9aWYobi5sZW5ndGg+Myl7bi5zb3J0KGZ1bmN0aW9uKGUscil7cmV0dXJuIHIubGVuZ3RoLWUubGVuZ3RofSksdCs9XCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7Zm9yKHZhciBhPTA7YTxuLmxlbmd0aDsrK2Epe3ZhciBpPW5bYV07dCs9XCJjYXNlIFwiK2lbMF0ubGVuZ3RoK1wiOlwiLHIoaSl9dCs9XCJ9XCJ9ZWxzZSByKGUpO3JldHVybiBuZXcgRnVuY3Rpb24oXCJzdHJcIix0KX1mdW5jdGlvbiBhKCl7dGhpcy5saW5lPUFyLHRoaXMuY29sdW1uPWJyLVNyfWZ1bmN0aW9uIG8oKXtBcj0xLGJyPVNyPTAsRXI9ITAsdSgpfWZ1bmN0aW9uIGkoZSxyKXtncj1icixmci5sb2NhdGlvbnMmJihrcj1uZXcgYSksd3I9ZSx1KCksQ3I9cixFcj1lLmJlZm9yZUV4cHJ9ZnVuY3Rpb24gcygpe3ZhciBlPWZyLm9uQ29tbWVudCYmZnIubG9jYXRpb25zJiZuZXcgYSxyPWJyLG49cHIuaW5kZXhPZihcIiovXCIsYnIrPTIpO2lmKC0xPT09biYmdChici0yLFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIiksYnI9bisyLGZyLmxvY2F0aW9ucyl7S3QubGFzdEluZGV4PXI7Zm9yKHZhciBvOyhvPUt0LmV4ZWMocHIpKSYmby5pbmRleDxicjspKytBcixTcj1vLmluZGV4K29bMF0ubGVuZ3RofWZyLm9uQ29tbWVudCYmZnIub25Db21tZW50KCEwLHByLnNsaWNlKHIrMixuKSxyLGJyLGUsZnIubG9jYXRpb25zJiZuZXcgYSl9ZnVuY3Rpb24gYygpe2Zvcih2YXIgZT1icixyPWZyLm9uQ29tbWVudCYmZnIubG9jYXRpb25zJiZuZXcgYSx0PXByLmNoYXJDb2RlQXQoYnIrPTIpO2RyPmJyJiYxMCE9PXQmJjEzIT09dCYmODIzMiE9PXQmJjgzMjkhPT10OykrK2JyLHQ9cHIuY2hhckNvZGVBdChicik7ZnIub25Db21tZW50JiZmci5vbkNvbW1lbnQoITEscHIuc2xpY2UoZSsyLGJyKSxlLGJyLHIsZnIubG9jYXRpb25zJiZuZXcgYSl9ZnVuY3Rpb24gdSgpe2Zvcig7ZHI+YnI7KXt2YXIgZT1wci5jaGFyQ29kZUF0KGJyKTtpZigzMj09PWUpKyticjtlbHNlIGlmKDEzPT09ZSl7Kyticjt2YXIgcj1wci5jaGFyQ29kZUF0KGJyKTsxMD09PXImJisrYnIsZnIubG9jYXRpb25zJiYoKytBcixTcj1icil9ZWxzZSBpZigxMD09PWUpKyticiwrK0FyLFNyPWJyO2Vsc2UgaWYoMTQ+ZSYmZT44KSsrYnI7ZWxzZSBpZig0Nz09PWUpe3ZhciByPXByLmNoYXJDb2RlQXQoYnIrMSk7aWYoNDI9PT1yKXMoKTtlbHNle2lmKDQ3IT09cilicmVhaztjKCl9fWVsc2UgaWYoMTYwPT09ZSkrK2JyO2Vsc2V7aWYoIShlPj01NzYwJiZKdC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpKSlicmVhazsrK2JyfX19ZnVuY3Rpb24gbCgpe3ZhciBlPXByLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIGU+PTQ4JiY1Nz49ZT9FKCEwKTooKyticixpKHh0KSl9ZnVuY3Rpb24gZigpe3ZhciBlPXByLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIEVyPygrK2JyLGsoKSk6NjE9PT1lP3goRXQsMik6eCh3dCwxKX1mdW5jdGlvbiBwKCl7dmFyIGU9cHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gNjE9PT1lP3goRXQsMik6eChGdCwxKX1mdW5jdGlvbiBkKGUpe3ZhciByPXByLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIHI9PT1lP3goMTI0PT09ZT9MdDpVdCwyKTo2MT09PXI/eChFdCwyKTp4KDEyND09PWU/UnQ6VnQsMSl9ZnVuY3Rpb24gbSgpe3ZhciBlPXByLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIDYxPT09ZT94KEV0LDIpOngoVHQsMSl9ZnVuY3Rpb24gaChlKXt2YXIgcj1wci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiByPT09ZT94KFN0LDIpOjYxPT09cj94KEV0LDIpOngoQXQsMSl9ZnVuY3Rpb24gdihlKXt2YXIgcj1wci5jaGFyQ29kZUF0KGJyKzEpLHQ9MTtyZXR1cm4gcj09PWU/KHQ9NjI9PT1lJiY2Mj09PXByLmNoYXJDb2RlQXQoYnIrMik/MzoyLDYxPT09cHIuY2hhckNvZGVBdChicit0KT94KEV0LHQrMSk6eChqdCx0KSk6KDYxPT09ciYmKHQ9NjE9PT1wci5jaGFyQ29kZUF0KGJyKzIpPzM6MikseChPdCx0KSl9ZnVuY3Rpb24gYihlKXt2YXIgcj1wci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiA2MT09PXI/eChxdCw2MT09PXByLmNoYXJDb2RlQXQoYnIrMik/MzoyKTp4KDYxPT09ZT9DdDpJdCwxKX1mdW5jdGlvbiB5KGUpe3N3aXRjaChlKXtjYXNlIDQ2OnJldHVybiBsKCk7Y2FzZSA0MDpyZXR1cm4rK2JyLGkoaHQpO2Nhc2UgNDE6cmV0dXJuKyticixpKHZ0KTtjYXNlIDU5OnJldHVybisrYnIsaSh5dCk7Y2FzZSA0NDpyZXR1cm4rK2JyLGkoYnQpO2Nhc2UgOTE6cmV0dXJuKyticixpKGZ0KTtjYXNlIDkzOnJldHVybisrYnIsaShwdCk7Y2FzZSAxMjM6cmV0dXJuKyticixpKGR0KTtjYXNlIDEyNTpyZXR1cm4rK2JyLGkobXQpO2Nhc2UgNTg6cmV0dXJuKyticixpKGd0KTtjYXNlIDYzOnJldHVybisrYnIsaShrdCk7Y2FzZSA0ODp2YXIgcj1wci5jaGFyQ29kZUF0KGJyKzEpO2lmKDEyMD09PXJ8fDg4PT09cilyZXR1cm4gQygpO2Nhc2UgNDk6Y2FzZSA1MDpjYXNlIDUxOmNhc2UgNTI6Y2FzZSA1MzpjYXNlIDU0OmNhc2UgNTU6Y2FzZSA1NjpjYXNlIDU3OnJldHVybiBFKCExKTtjYXNlIDM0OmNhc2UgMzk6cmV0dXJuIEEoZSk7Y2FzZSA0NzpyZXR1cm4gZihlKTtjYXNlIDM3OmNhc2UgNDI6cmV0dXJuIHAoKTtjYXNlIDEyNDpjYXNlIDM4OnJldHVybiBkKGUpO2Nhc2UgOTQ6cmV0dXJuIG0oKTtjYXNlIDQzOmNhc2UgNDU6cmV0dXJuIGgoZSk7Y2FzZSA2MDpjYXNlIDYyOnJldHVybiB2KGUpO2Nhc2UgNjE6Y2FzZSAzMzpyZXR1cm4gYihlKTtjYXNlIDEyNjpyZXR1cm4geChJdCwxKX1yZXR1cm4hMX1mdW5jdGlvbiBnKGUpe2lmKGU/YnI9eXIrMTp5cj1icixmci5sb2NhdGlvbnMmJih4cj1uZXcgYSksZSlyZXR1cm4gaygpO2lmKGJyPj1kcilyZXR1cm4gaShCcik7dmFyIHI9cHIuY2hhckNvZGVBdChicik7aWYoUXQocil8fDkyPT09cilyZXR1cm4gTCgpO3ZhciBuPXkocik7aWYobj09PSExKXt2YXIgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHIpO2lmKFwiXFxcXFwiPT09b3x8JHQudGVzdChvKSlyZXR1cm4gTCgpO3QoYnIsXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIrbytcIidcIil9cmV0dXJuIG59ZnVuY3Rpb24geChlLHIpe3ZhciB0PXByLnNsaWNlKGJyLGJyK3IpO2JyKz1yLGkoZSx0KX1mdW5jdGlvbiBrKCl7Zm9yKHZhciBlLHIsbj1cIlwiLGE9YnI7Oyl7YnI+PWRyJiZ0KGEsXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO3ZhciBvPXByLmNoYXJBdChicik7aWYoR3QudGVzdChvKSYmdChhLFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKSxlKWU9ITE7ZWxzZXtpZihcIltcIj09PW8pcj0hMDtlbHNlIGlmKFwiXVwiPT09byYmcilyPSExO2Vsc2UgaWYoXCIvXCI9PT1vJiYhcilicmVhaztlPVwiXFxcXFwiPT09b30rK2JyfXZhciBuPXByLnNsaWNlKGEsYnIpOysrYnI7dmFyIHM9SSgpO3JldHVybiBzJiYhL15bZ21zaXldKiQvLnRlc3QocykmJnQoYSxcIkludmFsaWQgcmVnZXhwIGZsYWdcIiksaShqcixuZXcgUmVnRXhwKG4scykpfWZ1bmN0aW9uIHcoZSxyKXtmb3IodmFyIHQ9YnIsbj0wLGE9MCxvPW51bGw9PXI/MS8wOnI7bz5hOysrYSl7dmFyIGkscz1wci5jaGFyQ29kZUF0KGJyKTtpZihpPXM+PTk3P3MtOTcrMTA6cz49NjU/cy02NSsxMDpzPj00OCYmNTc+PXM/cy00ODoxLzAsaT49ZSlicmVhazsrK2JyLG49biplK2l9cmV0dXJuIGJyPT09dHx8bnVsbCE9ciYmYnItdCE9PXI/bnVsbDpufWZ1bmN0aW9uIEMoKXticis9Mjt2YXIgZT13KDE2KTtyZXR1cm4gbnVsbD09ZSYmdCh5cisyLFwiRXhwZWN0ZWQgaGV4YWRlY2ltYWwgbnVtYmVyXCIpLFF0KHByLmNoYXJDb2RlQXQoYnIpKSYmdChicixcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpLGkoT3IsZSl9ZnVuY3Rpb24gRShlKXt2YXIgcj1icixuPSExLGE9NDg9PT1wci5jaGFyQ29kZUF0KGJyKTtlfHxudWxsIT09dygxMCl8fHQocixcIkludmFsaWQgbnVtYmVyXCIpLDQ2PT09cHIuY2hhckNvZGVBdChicikmJigrK2JyLHcoMTApLG49ITApO3ZhciBvPXByLmNoYXJDb2RlQXQoYnIpOyg2OT09PW98fDEwMT09PW8pJiYobz1wci5jaGFyQ29kZUF0KCsrYnIpLCg0Mz09PW98fDQ1PT09bykmJisrYnIsbnVsbD09PXcoMTApJiZ0KHIsXCJJbnZhbGlkIG51bWJlclwiKSxuPSEwKSxRdChwci5jaGFyQ29kZUF0KGJyKSkmJnQoYnIsXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTt2YXIgcyxjPXByLnNsaWNlKHIsYnIpO3JldHVybiBuP3M9cGFyc2VGbG9hdChjKTphJiYxIT09Yy5sZW5ndGg/L1s4OV0vLnRlc3QoYyl8fFZyP3QocixcIkludmFsaWQgbnVtYmVyXCIpOnM9cGFyc2VJbnQoYyw4KTpzPXBhcnNlSW50KGMsMTApLGkoT3Iscyl9ZnVuY3Rpb24gQShlKXticisrO2Zvcih2YXIgcj1cIlwiOzspe2JyPj1kciYmdCh5cixcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7dmFyIG49cHIuY2hhckNvZGVBdChicik7aWYobj09PWUpcmV0dXJuKyticixpKEZyLHIpO2lmKDkyPT09bil7bj1wci5jaGFyQ29kZUF0KCsrYnIpO3ZhciBhPS9eWzAtN10rLy5leGVjKHByLnNsaWNlKGJyLGJyKzMpKTtmb3IoYSYmKGE9YVswXSk7YSYmcGFyc2VJbnQoYSw4KT4yNTU7KWE9YS5zbGljZSgwLGEubGVuZ3RoLTEpO2lmKFwiMFwiPT09YSYmKGE9bnVsbCksKyticixhKVZyJiZ0KGJyLTIsXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpLHIrPVN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYSw4KSksYnIrPWEubGVuZ3RoLTE7ZWxzZSBzd2l0Y2gobil7Y2FzZSAxMTA6cis9XCJcXG5cIjticmVhaztjYXNlIDExNDpyKz1cIlxcclwiO2JyZWFrO2Nhc2UgMTIwOnIrPVN0cmluZy5mcm9tQ2hhckNvZGUoUygyKSk7YnJlYWs7Y2FzZSAxMTc6cis9U3RyaW5nLmZyb21DaGFyQ29kZShTKDQpKTticmVhaztjYXNlIDg1OnIrPVN0cmluZy5mcm9tQ2hhckNvZGUoUyg4KSk7YnJlYWs7Y2FzZSAxMTY6cis9XCJcdFwiO2JyZWFrO2Nhc2UgOTg6cis9XCJcXGJcIjticmVhaztjYXNlIDExODpyKz1cIlx1MDAwYlwiO2JyZWFrO2Nhc2UgMTAyOnIrPVwiXFxmXCI7YnJlYWs7Y2FzZSA0ODpyKz1cIlxcMFwiO2JyZWFrO2Nhc2UgMTM6MTA9PT1wci5jaGFyQ29kZUF0KGJyKSYmKyticjtjYXNlIDEwOmZyLmxvY2F0aW9ucyYmKFNyPWJyLCsrQXIpO2JyZWFrO2RlZmF1bHQ6cis9U3RyaW5nLmZyb21DaGFyQ29kZShuKX19ZWxzZSgxMz09PW58fDEwPT09bnx8ODIzMj09PW58fDgzMjk9PT1uKSYmdCh5cixcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIikscis9U3RyaW5nLmZyb21DaGFyQ29kZShuKSwrK2JyfX1mdW5jdGlvbiBTKGUpe3ZhciByPXcoMTYsZSk7cmV0dXJuIG51bGw9PT1yJiZ0KHlyLFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIikscn1mdW5jdGlvbiBJKCl7QnQ9ITE7Zm9yKHZhciBlLHI9ITAsbj1icjs7KXt2YXIgYT1wci5jaGFyQ29kZUF0KGJyKTtpZihZdChhKSlCdCYmKGUrPXByLmNoYXJBdChicikpLCsrYnI7ZWxzZXtpZig5MiE9PWEpYnJlYWs7QnR8fChlPXByLnNsaWNlKG4sYnIpKSxCdD0hMCwxMTchPXByLmNoYXJDb2RlQXQoKyticikmJnQoYnIsXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpLCsrYnI7dmFyIG89Uyg0KSxpPVN0cmluZy5mcm9tQ2hhckNvZGUobyk7aXx8dChici0xLFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKSwocj9RdChvKTpZdChvKSl8fHQoYnItNCxcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIiksZSs9aX1yPSExfXJldHVybiBCdD9lOnByLnNsaWNlKG4sYnIpfWZ1bmN0aW9uIEwoKXt2YXIgZT1JKCkscj1EcjtyZXR1cm4gQnR8fChXdChlKT9yPWx0W2VdOihmci5mb3JiaWRSZXNlcnZlZCYmKDM9PT1mci5lY21hVmVyc2lvbj9NdDp6dCkoZSl8fFZyJiZYdChlKSkmJnQoeXIsXCJUaGUga2V5d29yZCAnXCIrZStcIicgaXMgcmVzZXJ2ZWRcIikpLGkocixlKX1mdW5jdGlvbiBVKCl7SXI9eXIsTHI9Z3IsVXI9a3IsZygpfWZ1bmN0aW9uIFIoZSl7Zm9yKFZyPWUsYnI9THI7U3I+YnI7KVNyPXByLmxhc3RJbmRleE9mKFwiXFxuXCIsU3ItMikrMSwtLUFyO3UoKSxnKCl9ZnVuY3Rpb24gVCgpe3RoaXMudHlwZT1udWxsLHRoaXMuc3RhcnQ9eXIsdGhpcy5lbmQ9bnVsbH1mdW5jdGlvbiBWKCl7dGhpcy5zdGFydD14cix0aGlzLmVuZD1udWxsLG51bGwhPT1tciYmKHRoaXMuc291cmNlPW1yKX1mdW5jdGlvbiBxKCl7dmFyIGU9bmV3IFQ7cmV0dXJuIGZyLmxvY2F0aW9ucyYmKGUubG9jPW5ldyBWKSxmci5yYW5nZXMmJihlLnJhbmdlPVt5ciwwXSksZX1mdW5jdGlvbiBPKGUpe3ZhciByPW5ldyBUO3JldHVybiByLnN0YXJ0PWUuc3RhcnQsZnIubG9jYXRpb25zJiYoci5sb2M9bmV3IFYsci5sb2Muc3RhcnQ9ZS5sb2Muc3RhcnQpLGZyLnJhbmdlcyYmKHIucmFuZ2U9W2UucmFuZ2VbMF0sMF0pLHJ9ZnVuY3Rpb24gaihlLHIpe3JldHVybiBlLnR5cGU9cixlLmVuZD1Mcixmci5sb2NhdGlvbnMmJihlLmxvYy5lbmQ9VXIpLGZyLnJhbmdlcyYmKGUucmFuZ2VbMV09THIpLGV9ZnVuY3Rpb24gRihlKXtyZXR1cm4gZnIuZWNtYVZlcnNpb24+PTUmJlwiRXhwcmVzc2lvblN0YXRlbWVudFwiPT09ZS50eXBlJiZcIkxpdGVyYWxcIj09PWUuZXhwcmVzc2lvbi50eXBlJiZcInVzZSBzdHJpY3RcIj09PWUuZXhwcmVzc2lvbi52YWx1ZX1mdW5jdGlvbiBEKGUpe3JldHVybiB3cj09PWU/KFUoKSwhMCk6dm9pZCAwfWZ1bmN0aW9uIEIoKXtyZXR1cm4hZnIuc3RyaWN0U2VtaWNvbG9ucyYmKHdyPT09QnJ8fHdyPT09bXR8fEd0LnRlc3QocHIuc2xpY2UoTHIseXIpKSl9ZnVuY3Rpb24gTSgpe0QoeXQpfHxCKCl8fFgoKX1mdW5jdGlvbiB6KGUpe3dyPT09ZT9VKCk6WCgpfWZ1bmN0aW9uIFgoKXt0KHlyLFwiVW5leHBlY3RlZCB0b2tlblwiKX1mdW5jdGlvbiBOKGUpe1wiSWRlbnRpZmllclwiIT09ZS50eXBlJiZcIk1lbWJlckV4cHJlc3Npb25cIiE9PWUudHlwZSYmdChlLnN0YXJ0LFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKSxWciYmXCJJZGVudGlmaWVyXCI9PT1lLnR5cGUmJk50KGUubmFtZSkmJnQoZS5zdGFydCxcIkFzc2lnbmluZyB0byBcIitlLm5hbWUrXCIgaW4gc3RyaWN0IG1vZGVcIil9ZnVuY3Rpb24gVyhlKXtJcj1Mcj1icixmci5sb2NhdGlvbnMmJihVcj1uZXcgYSksUnI9VnI9bnVsbCxUcj1bXSxnKCk7dmFyIHI9ZXx8cSgpLHQ9ITA7Zm9yKGV8fChyLmJvZHk9W10pO3dyIT09QnI7KXt2YXIgbj1KKCk7ci5ib2R5LnB1c2gobiksdCYmRihuKSYmUighMCksdD0hMX1yZXR1cm4gaihyLFwiUHJvZ3JhbVwiKX1mdW5jdGlvbiBKKCl7d3I9PT13dCYmZyghMCk7dmFyIGU9d3Iscj1xKCk7c3dpdGNoKGUpe2Nhc2UgTXI6Y2FzZSBOcjpVKCk7dmFyIG49ZT09PU1yO0QoeXQpfHxCKCk/ci5sYWJlbD1udWxsOndyIT09RHI/WCgpOihyLmxhYmVsPWxyKCksTSgpKTtmb3IodmFyIGE9MDthPFRyLmxlbmd0aDsrK2Epe3ZhciBvPVRyW2FdO2lmKG51bGw9PXIubGFiZWx8fG8ubmFtZT09PXIubGFiZWwubmFtZSl7aWYobnVsbCE9by5raW5kJiYobnx8XCJsb29wXCI9PT1vLmtpbmQpKWJyZWFrO2lmKHIubGFiZWwmJm4pYnJlYWt9fXJldHVybiBhPT09VHIubGVuZ3RoJiZ0KHIuc3RhcnQsXCJVbnN5bnRhY3RpYyBcIitlLmtleXdvcmQpLGoocixuP1wiQnJlYWtTdGF0ZW1lbnRcIjpcIkNvbnRpbnVlU3RhdGVtZW50XCIpO2Nhc2UgV3I6cmV0dXJuIFUoKSxNKCksaihyLFwiRGVidWdnZXJTdGF0ZW1lbnRcIik7Y2FzZSBQcjpyZXR1cm4gVSgpLFRyLnB1c2goWnQpLHIuYm9keT1KKCksVHIucG9wKCkseih0dCksci50ZXN0PVAoKSxNKCksaihyLFwiRG9XaGlsZVN0YXRlbWVudFwiKTtjYXNlIF9yOmlmKFUoKSxUci5wdXNoKFp0KSx6KGh0KSx3cj09PXl0KXJldHVybiAkKHIsbnVsbCk7aWYod3I9PT1ydCl7dmFyIGk9cSgpO3JldHVybiBVKCksRyhpLCEwKSwxPT09aS5kZWNsYXJhdGlvbnMubGVuZ3RoJiZEKHV0KT9fKHIsaSk6JChyLGkpfXZhciBpPUsoITEsITApO3JldHVybiBEKHV0KT8oTihpKSxfKHIsaSkpOiQocixpKTtjYXNlIEdyOnJldHVybiBVKCksY3IociwhMCk7Y2FzZSBLcjpyZXR1cm4gVSgpLHIudGVzdD1QKCksci5jb25zZXF1ZW50PUooKSxyLmFsdGVybmF0ZT1EKEhyKT9KKCk6bnVsbCxqKHIsXCJJZlN0YXRlbWVudFwiKTtjYXNlIFFyOnJldHVybiBScnx8dCh5cixcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIiksVSgpLEQoeXQpfHxCKCk/ci5hcmd1bWVudD1udWxsOihyLmFyZ3VtZW50PUsoKSxNKCkpLGoocixcIlJldHVyblN0YXRlbWVudFwiKTtjYXNlIFlyOlUoKSxyLmRpc2NyaW1pbmFudD1QKCksci5jYXNlcz1bXSx6KGR0KSxUci5wdXNoKGVuKTtmb3IodmFyIHMsYzt3ciE9bXQ7KWlmKHdyPT09enJ8fHdyPT09SnIpe3ZhciB1PXdyPT09enI7cyYmaihzLFwiU3dpdGNoQ2FzZVwiKSxyLmNhc2VzLnB1c2gocz1xKCkpLHMuY29uc2VxdWVudD1bXSxVKCksdT9zLnRlc3Q9SygpOihjJiZ0KElyLFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpLGM9ITAscy50ZXN0PW51bGwpLHooZ3QpfWVsc2Ugc3x8WCgpLHMuY29uc2VxdWVudC5wdXNoKEooKSk7cmV0dXJuIHMmJmoocyxcIlN3aXRjaENhc2VcIiksVSgpLFRyLnBvcCgpLGoocixcIlN3aXRjaFN0YXRlbWVudFwiKTtjYXNlIFpyOnJldHVybiBVKCksR3QudGVzdChwci5zbGljZShMcix5cikpJiZ0KExyLFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpLHIuYXJndW1lbnQ9SygpLE0oKSxqKHIsXCJUaHJvd1N0YXRlbWVudFwiKTtjYXNlIGV0OmlmKFUoKSxyLmJsb2NrPUgoKSxyLmhhbmRsZXI9bnVsbCx3cj09PVhyKXt2YXIgbD1xKCk7VSgpLHooaHQpLGwucGFyYW09bHIoKSxWciYmTnQobC5wYXJhbS5uYW1lKSYmdChsLnBhcmFtLnN0YXJ0LFwiQmluZGluZyBcIitsLnBhcmFtLm5hbWUrXCIgaW4gc3RyaWN0IG1vZGVcIikseih2dCksbC5ndWFyZD1udWxsLGwuYm9keT1IKCksci5oYW5kbGVyPWoobCxcIkNhdGNoQ2xhdXNlXCIpfXJldHVybiByLmd1YXJkZWRIYW5kbGVycz1xcixyLmZpbmFsaXplcj1EKCRyKT9IKCk6bnVsbCxyLmhhbmRsZXJ8fHIuZmluYWxpemVyfHx0KHIuc3RhcnQsXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpLGoocixcIlRyeVN0YXRlbWVudFwiKTtjYXNlIHJ0OnJldHVybiBVKCkscj1HKHIpLE0oKSxyO2Nhc2UgdHQ6cmV0dXJuIFUoKSxyLnRlc3Q9UCgpLFRyLnB1c2goWnQpLHIuYm9keT1KKCksVHIucG9wKCksaihyLFwiV2hpbGVTdGF0ZW1lbnRcIik7Y2FzZSBudDpyZXR1cm4gVnImJnQoeXIsXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIiksVSgpLHIub2JqZWN0PVAoKSxyLmJvZHk9SigpLGoocixcIldpdGhTdGF0ZW1lbnRcIik7Y2FzZSBkdDpyZXR1cm4gSCgpO2Nhc2UgeXQ6cmV0dXJuIFUoKSxqKHIsXCJFbXB0eVN0YXRlbWVudFwiKTtkZWZhdWx0OnZhciBmPUNyLHA9SygpO2lmKGU9PT1EciYmXCJJZGVudGlmaWVyXCI9PT1wLnR5cGUmJkQoZ3QpKXtmb3IodmFyIGE9MDthPFRyLmxlbmd0aDsrK2EpVHJbYV0ubmFtZT09PWYmJnQocC5zdGFydCxcIkxhYmVsICdcIitmK1wiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO3ZhciBkPXdyLmlzTG9vcD9cImxvb3BcIjp3cj09PVlyP1wic3dpdGNoXCI6bnVsbDtyZXR1cm4gVHIucHVzaCh7bmFtZTpmLGtpbmQ6ZH0pLHIuYm9keT1KKCksVHIucG9wKCksci5sYWJlbD1wLGoocixcIkxhYmVsZWRTdGF0ZW1lbnRcIil9cmV0dXJuIHIuZXhwcmVzc2lvbj1wLE0oKSxqKHIsXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpfX1mdW5jdGlvbiBQKCl7eihodCk7dmFyIGU9SygpO3JldHVybiB6KHZ0KSxlfWZ1bmN0aW9uIEgoZSl7dmFyIHIsdD1xKCksbj0hMCxhPSExO2Zvcih0LmJvZHk9W10seihkdCk7IUQobXQpOyl7dmFyIG89SigpO3QuYm9keS5wdXNoKG8pLG4mJmUmJkYobykmJihyPWEsUihhPSEwKSksbj0hMX1yZXR1cm4gYSYmIXImJlIoITEpLGoodCxcIkJsb2NrU3RhdGVtZW50XCIpfWZ1bmN0aW9uICQoZSxyKXtyZXR1cm4gZS5pbml0PXIseih5dCksZS50ZXN0PXdyPT09eXQ/bnVsbDpLKCkseih5dCksZS51cGRhdGU9d3I9PT12dD9udWxsOksoKSx6KHZ0KSxlLmJvZHk9SigpLFRyLnBvcCgpLGooZSxcIkZvclN0YXRlbWVudFwiKX1mdW5jdGlvbiBfKGUscil7cmV0dXJuIGUubGVmdD1yLGUucmlnaHQ9SygpLHoodnQpLGUuYm9keT1KKCksVHIucG9wKCksaihlLFwiRm9ySW5TdGF0ZW1lbnRcIil9ZnVuY3Rpb24gRyhlLHIpe2ZvcihlLmRlY2xhcmF0aW9ucz1bXSxlLmtpbmQ9XCJ2YXJcIjs7KXt2YXIgbj1xKCk7aWYobi5pZD1scigpLFZyJiZOdChuLmlkLm5hbWUpJiZ0KG4uaWQuc3RhcnQsXCJCaW5kaW5nIFwiK24uaWQubmFtZStcIiBpbiBzdHJpY3QgbW9kZVwiKSxuLmluaXQ9RChDdCk/SyghMCxyKTpudWxsLGUuZGVjbGFyYXRpb25zLnB1c2goaihuLFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKSwhRChidCkpYnJlYWt9cmV0dXJuIGooZSxcIlZhcmlhYmxlRGVjbGFyYXRpb25cIil9ZnVuY3Rpb24gSyhlLHIpe3ZhciB0PVEocik7aWYoIWUmJndyPT09YnQpe3ZhciBuPU8odCk7Zm9yKG4uZXhwcmVzc2lvbnM9W3RdO0QoYnQpOyluLmV4cHJlc3Npb25zLnB1c2goUShyKSk7cmV0dXJuIGoobixcIlNlcXVlbmNlRXhwcmVzc2lvblwiKX1yZXR1cm4gdH1mdW5jdGlvbiBRKGUpe3ZhciByPVkoZSk7aWYod3IuaXNBc3NpZ24pe3ZhciB0PU8ocik7cmV0dXJuIHQub3BlcmF0b3I9Q3IsdC5sZWZ0PXIsVSgpLHQucmlnaHQ9UShlKSxOKHIpLGoodCxcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpfXJldHVybiByfWZ1bmN0aW9uIFkoZSl7dmFyIHI9WihlKTtpZihEKGt0KSl7dmFyIHQ9TyhyKTtyZXR1cm4gdC50ZXN0PXIsdC5jb25zZXF1ZW50PUsoITApLHooZ3QpLHQuYWx0ZXJuYXRlPUsoITAsZSksaih0LFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpfXJldHVybiByfWZ1bmN0aW9uIFooZSl7cmV0dXJuIGVyKHJyKCksLTEsZSl9ZnVuY3Rpb24gZXIoZSxyLHQpe3ZhciBuPXdyLmJpbm9wO2lmKG51bGwhPW4mJighdHx8d3IhPT11dCkmJm4+cil7dmFyIGE9TyhlKTthLmxlZnQ9ZSxhLm9wZXJhdG9yPUNyLFUoKSxhLnJpZ2h0PWVyKHJyKCksbix0KTt2YXIgYT1qKGEsLyYmfFxcfFxcfC8udGVzdChhLm9wZXJhdG9yKT9cIkxvZ2ljYWxFeHByZXNzaW9uXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIpO3JldHVybiBlcihhLHIsdCl9cmV0dXJuIGV9ZnVuY3Rpb24gcnIoKXtpZih3ci5wcmVmaXgpe3ZhciBlPXEoKSxyPXdyLmlzVXBkYXRlO3JldHVybiBlLm9wZXJhdG9yPUNyLGUucHJlZml4PSEwLFUoKSxlLmFyZ3VtZW50PXJyKCkscj9OKGUuYXJndW1lbnQpOlZyJiZcImRlbGV0ZVwiPT09ZS5vcGVyYXRvciYmXCJJZGVudGlmaWVyXCI9PT1lLmFyZ3VtZW50LnR5cGUmJnQoZS5zdGFydCxcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpLGooZSxyP1wiVXBkYXRlRXhwcmVzc2lvblwiOlwiVW5hcnlFeHByZXNzaW9uXCIpfWZvcih2YXIgbj10cigpO3dyLnBvc3RmaXgmJiFCKCk7KXt2YXIgZT1PKG4pO2Uub3BlcmF0b3I9Q3IsZS5wcmVmaXg9ITEsZS5hcmd1bWVudD1uLE4obiksVSgpLG49aihlLFwiVXBkYXRlRXhwcmVzc2lvblwiKX1yZXR1cm4gbn1mdW5jdGlvbiB0cigpe3JldHVybiBucihhcigpKX1mdW5jdGlvbiBucihlLHIpe2lmKEQoeHQpKXt2YXIgdD1PKGUpO3JldHVybiB0Lm9iamVjdD1lLHQucHJvcGVydHk9bHIoITApLHQuY29tcHV0ZWQ9ITEsbnIoaih0LFwiTWVtYmVyRXhwcmVzc2lvblwiKSxyKX1pZihEKGZ0KSl7dmFyIHQ9TyhlKTtyZXR1cm4gdC5vYmplY3Q9ZSx0LnByb3BlcnR5PUsoKSx0LmNvbXB1dGVkPSEwLHoocHQpLG5yKGoodCxcIk1lbWJlckV4cHJlc3Npb25cIikscil9aWYoIXImJkQoaHQpKXt2YXIgdD1PKGUpO3JldHVybiB0LmNhbGxlZT1lLHQuYXJndW1lbnRzPXVyKHZ0LCExKSxucihqKHQsXCJDYWxsRXhwcmVzc2lvblwiKSxyKX1yZXR1cm4gZX1mdW5jdGlvbiBhcigpe3N3aXRjaCh3cil7Y2FzZSBvdDp2YXIgZT1xKCk7cmV0dXJuIFUoKSxqKGUsXCJUaGlzRXhwcmVzc2lvblwiKTtjYXNlIERyOnJldHVybiBscigpO2Nhc2UgT3I6Y2FzZSBGcjpjYXNlIGpyOnZhciBlPXEoKTtyZXR1cm4gZS52YWx1ZT1DcixlLnJhdz1wci5zbGljZSh5cixnciksVSgpLGooZSxcIkxpdGVyYWxcIik7Y2FzZSBpdDpjYXNlIHN0OmNhc2UgY3Q6dmFyIGU9cSgpO3JldHVybiBlLnZhbHVlPXdyLmF0b21WYWx1ZSxlLnJhdz13ci5rZXl3b3JkLFUoKSxqKGUsXCJMaXRlcmFsXCIpO2Nhc2UgaHQ6dmFyIHI9eHIsdD15cjtVKCk7dmFyIG49SygpO3JldHVybiBuLnN0YXJ0PXQsbi5lbmQ9Z3IsZnIubG9jYXRpb25zJiYobi5sb2Muc3RhcnQ9cixuLmxvYy5lbmQ9a3IpLGZyLnJhbmdlcyYmKG4ucmFuZ2U9W3QsZ3JdKSx6KHZ0KSxuO2Nhc2UgZnQ6dmFyIGU9cSgpO3JldHVybiBVKCksZS5lbGVtZW50cz11cihwdCwhMCwhMCksaihlLFwiQXJyYXlFeHByZXNzaW9uXCIpO2Nhc2UgZHQ6cmV0dXJuIGlyKCk7Y2FzZSBHcjp2YXIgZT1xKCk7cmV0dXJuIFUoKSxjcihlLCExKTtjYXNlIGF0OnJldHVybiBvcigpO2RlZmF1bHQ6WCgpfX1mdW5jdGlvbiBvcigpe3ZhciBlPXEoKTtyZXR1cm4gVSgpLGUuY2FsbGVlPW5yKGFyKCksITApLGUuYXJndW1lbnRzPUQoaHQpP3VyKHZ0LCExKTpxcixqKGUsXCJOZXdFeHByZXNzaW9uXCIpfWZ1bmN0aW9uIGlyKCl7dmFyIGU9cSgpLHI9ITAsbj0hMTtmb3IoZS5wcm9wZXJ0aWVzPVtdLFUoKTshRChtdCk7KXtpZihyKXI9ITE7ZWxzZSBpZih6KGJ0KSxmci5hbGxvd1RyYWlsaW5nQ29tbWFzJiZEKG10KSlicmVhazt2YXIgYSxvPXtrZXk6c3IoKX0saT0hMTtpZihEKGd0KT8oby52YWx1ZT1LKCEwKSxhPW8ua2luZD1cImluaXRcIik6ZnIuZWNtYVZlcnNpb24+PTUmJlwiSWRlbnRpZmllclwiPT09by5rZXkudHlwZSYmKFwiZ2V0XCI9PT1vLmtleS5uYW1lfHxcInNldFwiPT09by5rZXkubmFtZSk/KGk9bj0hMCxhPW8ua2luZD1vLmtleS5uYW1lLG8ua2V5PXNyKCksd3IhPT1odCYmWCgpLG8udmFsdWU9Y3IocSgpLCExKSk6WCgpLFwiSWRlbnRpZmllclwiPT09by5rZXkudHlwZSYmKFZyfHxuKSlmb3IodmFyIHM9MDtzPGUucHJvcGVydGllcy5sZW5ndGg7KytzKXt2YXIgYz1lLnByb3BlcnRpZXNbc107aWYoYy5rZXkubmFtZT09PW8ua2V5Lm5hbWUpe3ZhciB1PWE9PWMua2luZHx8aSYmXCJpbml0XCI9PT1jLmtpbmR8fFwiaW5pdFwiPT09YSYmKFwiZ2V0XCI9PT1jLmtpbmR8fFwic2V0XCI9PT1jLmtpbmQpO3UmJiFWciYmXCJpbml0XCI9PT1hJiZcImluaXRcIj09PWMua2luZCYmKHU9ITEpLHUmJnQoby5rZXkuc3RhcnQsXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIil9fWUucHJvcGVydGllcy5wdXNoKG8pfXJldHVybiBqKGUsXCJPYmplY3RFeHByZXNzaW9uXCIpfWZ1bmN0aW9uIHNyKCl7cmV0dXJuIHdyPT09T3J8fHdyPT09RnI/YXIoKTpscighMCl9ZnVuY3Rpb24gY3IoZSxyKXt3cj09PURyP2UuaWQ9bHIoKTpyP1goKTplLmlkPW51bGwsZS5wYXJhbXM9W107dmFyIG49ITA7Zm9yKHooaHQpOyFEKHZ0KTspbj9uPSExOnooYnQpLGUucGFyYW1zLnB1c2gobHIoKSk7dmFyIGE9UnIsbz1UcjtpZihScj0hMCxUcj1bXSxlLmJvZHk9SCghMCksUnI9YSxUcj1vLFZyfHxlLmJvZHkuYm9keS5sZW5ndGgmJkYoZS5ib2R5LmJvZHlbMF0pKWZvcih2YXIgaT1lLmlkPy0xOjA7aTxlLnBhcmFtcy5sZW5ndGg7KytpKXt2YXIgcz0wPmk/ZS5pZDplLnBhcmFtc1tpXTtpZigoWHQocy5uYW1lKXx8TnQocy5uYW1lKSkmJnQocy5zdGFydCxcIkRlZmluaW5nICdcIitzLm5hbWUrXCInIGluIHN0cmljdCBtb2RlXCIpLGk+PTApZm9yKHZhciBjPTA7aT5jOysrYylzLm5hbWU9PT1lLnBhcmFtc1tjXS5uYW1lJiZ0KHMuc3RhcnQsXCJBcmd1bWVudCBuYW1lIGNsYXNoIGluIHN0cmljdCBtb2RlXCIpfXJldHVybiBqKGUscj9cIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKX1mdW5jdGlvbiB1cihlLHIsdCl7Zm9yKHZhciBuPVtdLGE9ITA7IUQoZSk7KXtpZihhKWE9ITE7ZWxzZSBpZih6KGJ0KSxyJiZmci5hbGxvd1RyYWlsaW5nQ29tbWFzJiZEKGUpKWJyZWFrO3QmJndyPT09YnQ/bi5wdXNoKG51bGwpOm4ucHVzaChLKCEwKSl9cmV0dXJuIG59ZnVuY3Rpb24gbHIoZSl7dmFyIHI9cSgpO3JldHVybiByLm5hbWU9d3I9PT1Ecj9DcjplJiYhZnIuZm9yYmlkUmVzZXJ2ZWQmJndyLmtleXdvcmR8fFgoKSxVKCksaihyLFwiSWRlbnRpZmllclwiKX1lLnZlcnNpb249XCIwLjMuMlwiO3ZhciBmcixwcixkcixtcjtlLnBhcnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHByPVN0cmluZyhlKSxkcj1wci5sZW5ndGgscih0KSxvKCksVyhmci5wcm9ncmFtKX07dmFyIGhyPWUuZGVmYXVsdE9wdGlvbnM9e2VjbWFWZXJzaW9uOjUsc3RyaWN0U2VtaWNvbG9uczohMSxhbGxvd1RyYWlsaW5nQ29tbWFzOiEwLGZvcmJpZFJlc2VydmVkOiExLGxvY2F0aW9uczohMSxvbkNvbW1lbnQ6bnVsbCxyYW5nZXM6ITEscHJvZ3JhbTpudWxsLHNvdXJjZUZpbGU6bnVsbH0sdnI9ZS5nZXRMaW5lSW5mbz1mdW5jdGlvbihlLHIpe2Zvcih2YXIgdD0xLG49MDs7KXtLdC5sYXN0SW5kZXg9bjt2YXIgYT1LdC5leGVjKGUpO2lmKCEoYSYmYS5pbmRleDxyKSlicmVhazsrK3Qsbj1hLmluZGV4K2FbMF0ubGVuZ3RofXJldHVybntsaW5lOnQsY29sdW1uOnItbn19O2UudG9rZW5pemU9ZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBuKGUpe3JldHVybiBnKGUpLGEuc3RhcnQ9eXIsYS5lbmQ9Z3IsYS5zdGFydExvYz14cixhLmVuZExvYz1rcixhLnR5cGU9d3IsYS52YWx1ZT1DcixhfXByPVN0cmluZyhlKSxkcj1wci5sZW5ndGgscih0KSxvKCk7dmFyIGE9e307cmV0dXJuIG4uanVtcFRvPWZ1bmN0aW9uKGUscil7aWYoYnI9ZSxmci5sb2NhdGlvbnMpe0FyPTEsU3I9S3QubGFzdEluZGV4PTA7Zm9yKHZhciB0Oyh0PUt0LmV4ZWMocHIpKSYmdC5pbmRleDxlOykrK0FyLFNyPXQuaW5kZXgrdFswXS5sZW5ndGh9RXI9cix1KCl9LG59O3ZhciBicix5cixncix4cixrcix3cixDcixFcixBcixTcixJcixMcixVcixScixUcixWcixxcj1bXSxPcj17dHlwZTpcIm51bVwifSxqcj17dHlwZTpcInJlZ2V4cFwifSxGcj17dHlwZTpcInN0cmluZ1wifSxEcj17dHlwZTpcIm5hbWVcIn0sQnI9e3R5cGU6XCJlb2ZcIn0sTXI9e2tleXdvcmQ6XCJicmVha1wifSx6cj17a2V5d29yZDpcImNhc2VcIixiZWZvcmVFeHByOiEwfSxYcj17a2V5d29yZDpcImNhdGNoXCJ9LE5yPXtrZXl3b3JkOlwiY29udGludWVcIn0sV3I9e2tleXdvcmQ6XCJkZWJ1Z2dlclwifSxKcj17a2V5d29yZDpcImRlZmF1bHRcIn0sUHI9e2tleXdvcmQ6XCJkb1wiLGlzTG9vcDohMH0sSHI9e2tleXdvcmQ6XCJlbHNlXCIsYmVmb3JlRXhwcjohMH0sJHI9e2tleXdvcmQ6XCJmaW5hbGx5XCJ9LF9yPXtrZXl3b3JkOlwiZm9yXCIsaXNMb29wOiEwfSxHcj17a2V5d29yZDpcImZ1bmN0aW9uXCJ9LEtyPXtrZXl3b3JkOlwiaWZcIn0sUXI9e2tleXdvcmQ6XCJyZXR1cm5cIixiZWZvcmVFeHByOiEwfSxZcj17a2V5d29yZDpcInN3aXRjaFwifSxacj17a2V5d29yZDpcInRocm93XCIsYmVmb3JlRXhwcjohMH0sZXQ9e2tleXdvcmQ6XCJ0cnlcIn0scnQ9e2tleXdvcmQ6XCJ2YXJcIn0sdHQ9e2tleXdvcmQ6XCJ3aGlsZVwiLGlzTG9vcDohMH0sbnQ9e2tleXdvcmQ6XCJ3aXRoXCJ9LGF0PXtrZXl3b3JkOlwibmV3XCIsYmVmb3JlRXhwcjohMH0sb3Q9e2tleXdvcmQ6XCJ0aGlzXCJ9LGl0PXtrZXl3b3JkOlwibnVsbFwiLGF0b21WYWx1ZTpudWxsfSxzdD17a2V5d29yZDpcInRydWVcIixhdG9tVmFsdWU6ITB9LGN0PXtrZXl3b3JkOlwiZmFsc2VcIixhdG9tVmFsdWU6ITF9LHV0PXtrZXl3b3JkOlwiaW5cIixiaW5vcDo3LGJlZm9yZUV4cHI6ITB9LGx0PXtcImJyZWFrXCI6TXIsXCJjYXNlXCI6enIsXCJjYXRjaFwiOlhyLFwiY29udGludWVcIjpOcixcImRlYnVnZ2VyXCI6V3IsXCJkZWZhdWx0XCI6SnIsXCJkb1wiOlByLFwiZWxzZVwiOkhyLFwiZmluYWxseVwiOiRyLFwiZm9yXCI6X3IsXCJmdW5jdGlvblwiOkdyLFwiaWZcIjpLcixcInJldHVyblwiOlFyLFwic3dpdGNoXCI6WXIsXCJ0aHJvd1wiOlpyLFwidHJ5XCI6ZXQsXCJ2YXJcIjpydCxcIndoaWxlXCI6dHQsXCJ3aXRoXCI6bnQsXCJudWxsXCI6aXQsXCJ0cnVlXCI6c3QsXCJmYWxzZVwiOmN0LFwibmV3XCI6YXQsXCJpblwiOnV0LFwiaW5zdGFuY2VvZlwiOntrZXl3b3JkOlwiaW5zdGFuY2VvZlwiLGJpbm9wOjcsYmVmb3JlRXhwcjohMH0sXCJ0aGlzXCI6b3QsXCJ0eXBlb2ZcIjp7a2V5d29yZDpcInR5cGVvZlwiLHByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxcInZvaWRcIjp7a2V5d29yZDpcInZvaWRcIixwcmVmaXg6ITAsYmVmb3JlRXhwcjohMH0sXCJkZWxldGVcIjp7a2V5d29yZDpcImRlbGV0ZVwiLHByZWZpeDohMCxiZWZvcmVFeHByOiEwfX0sZnQ9e3R5cGU6XCJbXCIsYmVmb3JlRXhwcjohMH0scHQ9e3R5cGU6XCJdXCJ9LGR0PXt0eXBlOlwie1wiLGJlZm9yZUV4cHI6ITB9LG10PXt0eXBlOlwifVwifSxodD17dHlwZTpcIihcIixiZWZvcmVFeHByOiEwfSx2dD17dHlwZTpcIilcIn0sYnQ9e3R5cGU6XCIsXCIsYmVmb3JlRXhwcjohMH0seXQ9e3R5cGU6XCI7XCIsYmVmb3JlRXhwcjohMH0sZ3Q9e3R5cGU6XCI6XCIsYmVmb3JlRXhwcjohMH0seHQ9e3R5cGU6XCIuXCJ9LGt0PXt0eXBlOlwiP1wiLGJlZm9yZUV4cHI6ITB9LHd0PXtiaW5vcDoxMCxiZWZvcmVFeHByOiEwfSxDdD17aXNBc3NpZ246ITAsYmVmb3JlRXhwcjohMH0sRXQ9e2lzQXNzaWduOiEwLGJlZm9yZUV4cHI6ITB9LEF0PXtiaW5vcDo5LHByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxTdD17cG9zdGZpeDohMCxwcmVmaXg6ITAsaXNVcGRhdGU6ITB9LEl0PXtwcmVmaXg6ITAsYmVmb3JlRXhwcjohMH0sTHQ9e2Jpbm9wOjEsYmVmb3JlRXhwcjohMH0sVXQ9e2Jpbm9wOjIsYmVmb3JlRXhwcjohMH0sUnQ9e2Jpbm9wOjMsYmVmb3JlRXhwcjohMH0sVHQ9e2Jpbm9wOjQsYmVmb3JlRXhwcjohMH0sVnQ9e2Jpbm9wOjUsYmVmb3JlRXhwcjohMH0scXQ9e2Jpbm9wOjYsYmVmb3JlRXhwcjohMH0sT3Q9e2Jpbm9wOjcsYmVmb3JlRXhwcjohMH0sanQ9e2Jpbm9wOjgsYmVmb3JlRXhwcjohMH0sRnQ9e2Jpbm9wOjEwLGJlZm9yZUV4cHI6ITB9O2UudG9rVHlwZXM9e2JyYWNrZXRMOmZ0LGJyYWNrZXRSOnB0LGJyYWNlTDpkdCxicmFjZVI6bXQscGFyZW5MOmh0LHBhcmVuUjp2dCxjb21tYTpidCxzZW1pOnl0LGNvbG9uOmd0LGRvdDp4dCxxdWVzdGlvbjprdCxzbGFzaDp3dCxlcTpDdCxuYW1lOkRyLGVvZjpCcixudW06T3IscmVnZXhwOmpyLHN0cmluZzpGcn07Zm9yKHZhciBEdCBpbiBsdCllLnRva1R5cGVzW1wiX1wiK0R0XT1sdFtEdF07dmFyIEJ0LE10PW4oXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIpLHp0PW4oXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiKSxYdD1uKFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiKSxOdD1uKFwiZXZhbCBhcmd1bWVudHNcIiksV3Q9bihcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiKSxKdD0vW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyOFxcdTIwMjlcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS8sUHQ9XCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiLEh0PVwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIiwkdD1uZXcgUmVnRXhwKFwiW1wiK1B0K1wiXVwiKSxfdD1uZXcgUmVnRXhwKFwiW1wiK1B0K0h0K1wiXVwiKSxHdD0vW1xcblxcclxcdTIwMjhcXHUyMDI5XS8sS3Q9L1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2csUXQ9ZS5pc0lkZW50aWZpZXJTdGFydD1mdW5jdGlvbihlKXtyZXR1cm4gNjU+ZT8zNj09PWU6OTE+ZT8hMDo5Nz5lPzk1PT09ZToxMjM+ZT8hMDplPj0xNzAmJiR0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSl9LFl0PWUuaXNJZGVudGlmaWVyQ2hhcj1mdW5jdGlvbihlKXtyZXR1cm4gNDg+ZT8zNj09PWU6NTg+ZT8hMDo2NT5lPyExOjkxPmU/ITA6OTc+ZT85NT09PWU6MTIzPmU/ITA6ZT49MTcwJiZfdC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpfSxadD17a2luZDpcImxvb3BcIn0sZW49e2tpbmQ6XCJzd2l0Y2hcIn19KTtcblxuXHR2YXIgYmluYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCcrJzogJ19fYWRkJyxcblx0XHQnLSc6ICdfX3N1YnRyYWN0Jyxcblx0XHQnKic6ICdfX211bHRpcGx5Jyxcblx0XHQnLyc6ICdfX2RpdmlkZScsXG5cdFx0JyUnOiAnX19tb2R1bG8nLFxuXHRcdCc9PSc6ICdlcXVhbHMnLFxuXHRcdCchPSc6ICdlcXVhbHMnXG5cdH07XG5cblx0dmFyIHVuYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCctJzogJ19fbmVnYXRlJyxcblx0XHQnKyc6IG51bGxcblx0fTtcblxuXHR2YXIgZmllbGRzID0gQmFzZS5lYWNoKFxuXHRcdFsnYWRkJywgJ3N1YnRyYWN0JywgJ211bHRpcGx5JywgJ2RpdmlkZScsICdtb2R1bG8nLCAnbmVnYXRlJ10sXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1snX18nICsgbmFtZV0gPSAnIycgKyBuYW1lO1xuXHRcdH0sXG5cdFx0e31cblx0KTtcblx0UG9pbnQuaW5qZWN0KGZpZWxkcyk7XG5cdFNpemUuaW5qZWN0KGZpZWxkcyk7XG5cdENvbG9yLmluamVjdChmaWVsZHMpO1xuXG5cdGZ1bmN0aW9uIF8kXyhsZWZ0LCBvcGVyYXRvciwgcmlnaHQpIHtcblx0XHR2YXIgaGFuZGxlciA9IGJpbmFyeU9wZXJhdG9yc1tvcGVyYXRvcl07XG5cdFx0aWYgKGxlZnQgJiYgbGVmdFtoYW5kbGVyXSkge1xuXHRcdFx0dmFyIHJlcyA9IGxlZnRbaGFuZGxlcl0ocmlnaHQpO1xuXHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSAnIT0nID8gIXJlcyA6IHJlcztcblx0XHR9XG5cdFx0c3dpdGNoIChvcGVyYXRvcikge1xuXHRcdGNhc2UgJysnOiByZXR1cm4gbGVmdCArIHJpZ2h0O1xuXHRcdGNhc2UgJy0nOiByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuXHRcdGNhc2UgJyonOiByZXR1cm4gbGVmdCAqIHJpZ2h0O1xuXHRcdGNhc2UgJy8nOiByZXR1cm4gbGVmdCAvIHJpZ2h0O1xuXHRcdGNhc2UgJyUnOiByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuXHRcdGNhc2UgJz09JzogcmV0dXJuIGxlZnQgPT0gcmlnaHQ7XG5cdFx0Y2FzZSAnIT0nOiByZXR1cm4gbGVmdCAhPSByaWdodDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiAkXyhvcGVyYXRvciwgdmFsdWUpIHtcblx0XHR2YXIgaGFuZGxlciA9IHVuYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAoaGFuZGxlciAmJiB2YWx1ZSAmJiB2YWx1ZVtoYW5kbGVyXSlcblx0XHRcdHJldHVybiB2YWx1ZVtoYW5kbGVyXSgpO1xuXHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRjYXNlICcrJzogcmV0dXJuICt2YWx1ZTtcblx0XHRjYXNlICctJzogcmV0dXJuIC12YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21waWxlKGNvZGUpIHtcblxuXHRcdHZhciBpbnNlcnRpb25zID0gW107XG5cblx0XHRmdW5jdGlvbiBnZXRPZmZzZXQob2Zmc2V0KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGluc2VydGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpbnNlcnRpb24gPSBpbnNlcnRpb25zW2ldO1xuXHRcdFx0XHRpZiAoaW5zZXJ0aW9uWzBdID49IG9mZnNldClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0b2Zmc2V0ICs9IGluc2VydGlvblsxXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvZmZzZXQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29kZShub2RlKSB7XG5cdFx0XHRyZXR1cm4gY29kZS5zdWJzdHJpbmcoZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMF0pLFxuXHRcdFx0XHRcdGdldE9mZnNldChub2RlLnJhbmdlWzFdKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVwbGFjZUNvZGUobm9kZSwgc3RyKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG5cdFx0XHRcdGVuZCA9IGdldE9mZnNldChub2RlLnJhbmdlWzFdKSxcblx0XHRcdFx0aW5zZXJ0ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSBpbnNlcnRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmIChzdGFydCA+IGluc2VydGlvbnNbaV1bMF0pIHtcblx0XHRcdFx0XHRpbnNlcnQgPSBpICsgMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aW5zZXJ0aW9ucy5zcGxpY2UoaW5zZXJ0LCAwLCBbc3RhcnQsIHN0ci5sZW5ndGggLSBlbmQgKyBzdGFydF0pO1xuXHRcdFx0Y29kZSA9IGNvZGUuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHN0ciArIGNvZGUuc3Vic3RyaW5nKGVuZCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd2Fsa0FTVChub2RlLCBwYXJlbnQpIHtcblx0XHRcdGlmICghbm9kZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG5vZGUpIHtcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3JhbmdlJylcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIHZhbHVlID0gbm9kZVtrZXldO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRcdHdhbGtBU1QodmFsdWVbaV0sIG5vZGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR3YWxrQVNUKHZhbHVlLCBub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChub2RlICYmIG5vZGUudHlwZSkge1xuXHRcdFx0Y2FzZSAnVW5hcnlFeHByZXNzaW9uJzogXG5cdFx0XHRcdGlmIChub2RlLm9wZXJhdG9yIGluIHVuYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmFyZ3VtZW50LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpO1xuXHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsICckXyhcIicgKyBub2RlLm9wZXJhdG9yICsgJ1wiLCAnXG5cdFx0XHRcdFx0XHRcdCsgYXJnICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOiBcblx0XHRcdFx0aWYgKG5vZGUub3BlcmF0b3IgaW4gYmluYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0dmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG5cdFx0XHRcdFx0XHRyaWdodCA9IGdldENvZGUobm9kZS5yaWdodCk7XG5cdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgJ18kXygnICsgbGVmdCArICcsIFwiJyArIG5vZGUub3BlcmF0b3Jcblx0XHRcdFx0XHRcdFx0KyAnXCIsICcgKyByaWdodCArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdVcGRhdGVFeHByZXNzaW9uJzogXG5cdFx0XHRjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6IFxuXHRcdFx0XHRpZiAoIShwYXJlbnQgJiYgKFxuXHRcdFx0XHRcdFx0cGFyZW50LnR5cGUgPT09ICdGb3JTdGF0ZW1lbnQnXG5cdFx0XHRcdFx0XHR8fCBwYXJlbnQudHlwZSA9PT0gJ0JpbmFyeUV4cHJlc3Npb24nXG5cdFx0XHRcdFx0XHRcdCYmIC9eWz0hPD5dLy50ZXN0KHBhcmVudC5vcGVyYXRvcilcblx0XHRcdFx0XHRcdHx8IHBhcmVudC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbidcblx0XHRcdFx0XHRcdFx0JiYgcGFyZW50LmNvbXB1dGVkKSkpIHtcblx0XHRcdFx0XHRpZiAobm9kZS50eXBlID09PSAnVXBkYXRlRXhwcmVzc2lvbicpIHtcblx0XHRcdFx0XHRcdGlmICghbm9kZS5wcmVmaXgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCk7XG5cdFx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsIGFyZyArICcgPSBfJF8oJyArIGFyZyArICcsIFwiJ1xuXHRcdFx0XHRcdFx0XHRcdFx0KyBub2RlLm9wZXJhdG9yWzBdICsgJ1wiLCAxKScpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7IFxuXHRcdFx0XHRcdFx0aWYgKC9eLj0kLy50ZXN0KG5vZGUub3BlcmF0b3IpXG5cdFx0XHRcdFx0XHRcdFx0JiYgbm9kZS5sZWZ0LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcblx0XHRcdFx0XHRcdFx0XHRyaWdodCA9IGdldENvZGUobm9kZS5yaWdodCk7XG5cdFx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsIGxlZnQgKyAnID0gXyRfKCcgKyBsZWZ0ICsgJywgXCInXG5cdFx0XHRcdFx0XHRcdFx0XHQrIG5vZGUub3BlcmF0b3JbMF0gKyAnXCIsICcgKyByaWdodCArICcpJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3YWxrQVNUKHNjb3BlLmFjb3JuLnBhcnNlKGNvZGUsIHsgcmFuZ2VzOiB0cnVlIH0pKTtcblx0XHRyZXR1cm4gY29kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4ZWN1dGUoY29kZSwgc2NvcGUpIHtcblx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdHZhciB2aWV3ID0gc2NvcGUuZ2V0VmlldygpLFxuXHRcdFx0dG9vbCA9IC9cXHMrb24oPzpLZXl8TW91c2UpKD86VXB8RG93bnxNb3ZlfERyYWcpXFxiLy50ZXN0KGNvZGUpXG5cdFx0XHRcdFx0PyBuZXcgVG9vbCgpXG5cdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0dG9vbEhhbmRsZXJzID0gdG9vbCA/IHRvb2wuX2V2ZW50cyA6IFtdLFxuXHRcdFx0aGFuZGxlcnMgPSBbJ29uRnJhbWUnLCAnb25SZXNpemUnXS5jb25jYXQodG9vbEhhbmRsZXJzKSxcblx0XHRcdHBhcmFtcyA9IFtdLFxuXHRcdFx0YXJncyA9IFtdLFxuXHRcdFx0ZnVuYztcblx0XHRjb2RlID0gY29tcGlsZShjb2RlKTtcblx0XHRmdW5jdGlvbiBleHBvc2Uoc2NvcGUsIGhpZGRlbikge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHNjb3BlKSB7XG5cdFx0XHRcdGlmICgoaGlkZGVuIHx8ICEvXl8vLnRlc3Qoa2V5KSkgJiYgbmV3IFJlZ0V4cChcblx0XHRcdFx0XHRcdCdcXFxcYicgKyBrZXkucmVwbGFjZSgvXFwkL2csICdcXFxcJCcpICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuXHRcdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0YXJncy5wdXNoKHNjb3BlW2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV4cG9zZSh7IF8kXzogXyRfLCAkXzogJF8sIHZpZXc6IHZpZXcsIHRvb2w6IHRvb2wgfSwgdHJ1ZSk7XG5cdFx0ZXhwb3NlKHNjb3BlKTtcblx0XHRoYW5kbGVycyA9IEJhc2UuZWFjaChoYW5kbGVycywgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRpZiAobmV3IFJlZ0V4cCgnXFxcXHMrJyArIGtleSArICdcXFxcYicpLnRlc3QoY29kZSkpIHtcblx0XHRcdFx0cGFyYW1zLnB1c2goa2V5KTtcblx0XHRcdFx0dGhpcy5wdXNoKGtleSArICc6ICcgKyBrZXkpO1xuXHRcdFx0fVxuXHRcdH0sIFtdKS5qb2luKCcsICcpO1xuXHRcdGlmIChoYW5kbGVycylcblx0XHRcdGNvZGUgKz0gJ1xcbnJldHVybiB7ICcgKyBoYW5kbGVycyArICcgfTsnO1xuXHRcdHZhciBmaXJlZm94ID0gd2luZG93Lkluc3RhbGxUcmlnZ2VyO1xuXHRcdGlmIChmaXJlZm94IHx8IHdpbmRvdy5jaHJvbWUpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcblx0XHRcdFx0aGVhZCA9IGRvY3VtZW50LmhlYWQ7XG5cdFx0XHRpZiAoZmlyZWZveClcblx0XHRcdFx0Y29kZSA9ICdcXG4nICsgY29kZTtcblx0XHRcdHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcblx0XHRcdFx0J3BhcGVyLl9leGVjdXRlID0gZnVuY3Rpb24oJyArIHBhcmFtcyArICcpIHsnICsgY29kZSArICdcXG59J1xuXHRcdFx0KSk7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0XHRmdW5jID0gcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRkZWxldGUgcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZ1bmMgPSBGdW5jdGlvbihwYXJhbXMsIGNvZGUpO1xuXHRcdH1cblx0XHR2YXIgcmVzID0gZnVuYy5hcHBseShzY29wZSwgYXJncykgfHwge307XG5cdFx0QmFzZS5lYWNoKHRvb2xIYW5kbGVycywgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgdmFsdWUgPSByZXNba2V5XTtcblx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0dG9vbFtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdGlmIChyZXMub25SZXNpemUpXG5cdFx0XHRcdHZpZXcuc2V0T25SZXNpemUocmVzLm9uUmVzaXplKTtcblx0XHRcdHZpZXcuZmlyZSgncmVzaXplJywge1xuXHRcdFx0XHRzaXplOiB2aWV3LnNpemUsXG5cdFx0XHRcdGRlbHRhOiBuZXcgUG9pbnQoKVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAocmVzLm9uRnJhbWUpXG5cdFx0XHRcdHZpZXcuc2V0T25GcmFtZShyZXMub25GcmFtZSk7XG5cdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWQoKSB7XG5cdFx0QmFzZS5lYWNoKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSwgZnVuY3Rpb24oc2NyaXB0KSB7XG5cdFx0XHRpZiAoL150ZXh0XFwvKD86eC18KXBhcGVyc2NyaXB0JC8udGVzdChzY3JpcHQudHlwZSlcblx0XHRcdFx0XHQmJiAhc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1pZ25vcmUnKSkge1xuXHRcdFx0XHR2YXIgY2FudmFzID0gUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnY2FudmFzJyksXG5cdFx0XHRcdFx0c2NvcGUgPSBQYXBlclNjb3BlLmdldChjYW52YXMpXG5cdFx0XHRcdFx0XHRcdHx8IG5ldyBQYXBlclNjb3BlKHNjcmlwdCkuc2V0dXAoY2FudmFzKSxcblx0XHRcdFx0XHRzcmMgPSBzY3JpcHQuc3JjO1xuXHRcdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdFx0SHR0cC5yZXF1ZXN0KCdnZXQnLCBzcmMsIGZ1bmN0aW9uKGNvZGUpIHtcblx0XHRcdFx0XHRcdGV4ZWN1dGUoY29kZSwgc2NvcGUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGV4ZWN1dGUoc2NyaXB0LmlubmVySFRNTCwgc2NvcGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItaWdub3JlJywgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyk7XG5cdH1cblxuXHRpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHRcdHNldFRpbWVvdXQobG9hZCk7XG5cdH0gZWxzZSB7XG5cdFx0RG9tRXZlbnQuYWRkKHdpbmRvdywgeyBsb2FkOiBsb2FkIH0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRjb21waWxlOiBjb21waWxlLFxuXHRcdGV4ZWN1dGU6IGV4ZWN1dGUsXG5cdFx0bG9hZDogbG9hZCxcblx0XHRsaW5lTnVtYmVyQmFzZTogMFxuXHR9O1xuXG59KS5jYWxsKHRoaXMpO1xuXG5wYXBlciA9IG5ldyAoUGFwZXJTY29wZS5pbmplY3QoQmFzZS5leHBvcnRzLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdEJhc2U6IEJhc2UsXG5cdE51bWVyaWNhbDogTnVtZXJpY2FsLFxuXHREb21FbGVtZW50OiBEb21FbGVtZW50LFxuXHREb21FdmVudDogRG9tRXZlbnQsXG5cdEh0dHA6IEh0dHAsXG5cdEtleTogS2V5XG59KSkoKTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0ZGVmaW5lKCdwYXBlcicsIHBhcGVyKTtcbmVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0bW9kdWxlLmV4cG9ydHMgPSBwYXBlcjtcblxucmV0dXJuIHBhcGVyO1xufTtcbiIsIkJhY2tib25lIFx0XHQ9IHJlcXVpcmUoJ2JhY2tib25lJylcbl9cdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuR3JvdXBNb2RlbCBcdD0gcmVxdWlyZSgnLi4vbW9kZWxzL2dyb3VwJylcbmFzeW5jIFx0XHRcdD0gcmVxdWlyZSgnYXN5bmMnKVxuXG5jbGFzcyBHcm91cENvbGxlY3Rpb24gZXh0ZW5kcyBCYWNrYm9uZS5Db2xsZWN0aW9uXG5cblx0bW9kZWw6IEdyb3VwTW9kZWxcblxuXHRjb21wYXJhdG9yOiAncG9zaXRpb24nXG5cblx0dXJsOiAnL2dyb3VwcydcblxuXHRiZWxvbmdzVG86ICdyZWNpcGVzJ1xuXG5cdGluaXRpYWxpemU6IChhdHRycyA9IHt9LCBvcHRpb25zID0ge30pIC0+XG5cdFx0eyBAYXBwIH0gPSBvcHRpb25zXG5cblx0ZmV0Y2hSZWN1cnNpdmU6IChAYXBwLCBAcGFyZW50LCBwYXJlbnRDYWxsYmFjaykgLT5cblx0XHRAZmV0Y2hcblx0XHRcdHVybDogXCIvI3tAYmVsb25nc1RvfS8je0BwYXJlbnQuZ2V0KCdpZCcpfSN7QHVybH1cIixcblx0XHRcdHN1Y2Nlc3M6IChjb2xsZWN0aW9uLCBtb2RlbHMsIG9wdGlvbnMpID0+XG5cdFx0XHRcdGZldGNoVGFza3MgPSBbXVxuXHRcdFx0XHRAZWFjaCAobW9kZWwpID0+XG5cdFx0XHRcdFx0ZmV0Y2hUYXNrcy5wdXNoIChjYWxsYmFjaykgPT5cblx0XHRcdFx0XHRcdG1vZGVsLnNvdW5kcy5mZXRjaFJlY3Vyc2l2ZSBAYXBwLCBtb2RlbCwgY2FsbGJhY2tcblx0XHRcdFx0XHRmZXRjaFRhc2tzLnB1c2ggKGNhbGxiYWNrMikgPT5cblx0XHRcdFx0XHRcdG1vZGVsLnBhdHRlcm5zLmZldGNoUmVjdXJzaXZlIEBhcHAsIG1vZGVsLCBjYWxsYmFjazJcblx0XHRcdFx0YXN5bmMucGFyYWxsZWwgZmV0Y2hUYXNrcywgcGFyZW50Q2FsbGJhY2tcblx0XHQsIHJlc2V0OiB0cnVlXG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBDb2xsZWN0aW9uIiwiQmFja2JvbmUgXHRcdFx0PSByZXF1aXJlKCdiYWNrYm9uZScpXG5fXHRcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuUGF0dGVybk1vZGVsIFx0PSByZXF1aXJlKCcuLi9tb2RlbHMvcGF0dGVybicpXG5cbmNsYXNzIFBhdHRlcm5Db2xsZWN0aW9uIGV4dGVuZHMgQmFja2JvbmUuQ29sbGVjdGlvblxuXG5cdGluaXRpYWxpemU6IChtb2RlbHMgPSB7fSwgb3B0aW9ucyA9IHt9KSAtPlxuXHRcdHsgQGdyb3VwIH0gPSBvcHRpb25zXG5cblx0Y29tcGFyYXRvcjogJ3Bvc2l0aW9uJ1xuXG5cdG1vZGVsOiBQYXR0ZXJuTW9kZWxcblxuXHRiZWxvbmdzVG86ICdncm91cHMnXG5cblx0dXJsOiAnL3BhdHRlcm5zJ1xuXG5cdGZldGNoUmVjdXJzaXZlOiAoQGFwcCwgQHBhcmVudCwgcGFyZW50Q2FsbGJhY2spIC0+XG5cdFx0QGZldGNoXG5cdFx0XHR1cmw6IFwiLyN7QGJlbG9uZ3NUb30vI3tAcGFyZW50LmdldCgnaWQnKX0je0B1cmx9XCIsXG5cdFx0XHRzdWNjZXNzOiAoY29sbGVjdGlvbiwgbW9kZWxzLCBvcHRpb25zKSA9PlxuXHRcdFx0XHRwYXJlbnRDYWxsYmFjay5jYWxsKEAsIG51bGwsIG1vZGVscylcblx0XHRcdFx0IyBmZXRjaFRhc2tzID0gW11cblx0XHRcdFx0IyBAZWFjaCAobW9kZWwpID0+XG5cdFx0XHRcdCMgXHRmZXRjaFRhc2tzLnB1c2ggKGNhbGxiYWNrKSA9PlxuXHRcdFx0XHQjIFx0XHRtb2RlbC5zb3VuZHMuZmV0Y2hSZWN1cnNpdmUgQGFwcCwgbW9kZWwuaWQsIGNhbGxiYWNrXG5cdFx0XHRcdCMgYXN5bmMucGFyYWxsZWwgZmV0Y2hUYXNrcywgcGFyZW50Q2FsbGJhY2tcblx0XHRcdCwgZ3JvdXA6IEBwYXJlbnQsIGFwcCwgQGFwcCwgcmVzZXQ6IHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSBQYXR0ZXJuQ29sbGVjdGlvbiIsIkJhY2tib25lIFx0XHQ9IHJlcXVpcmUoJ2JhY2tib25lJylcbl9cdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuU291bmRNb2RlbCBcdD0gcmVxdWlyZSgnLi4vbW9kZWxzL3NvdW5kJylcblxuY2xhc3MgU291bmRDb2xsZWN0aW9uIGV4dGVuZHMgQmFja2JvbmUuQ29sbGVjdGlvblxuXG5cdGluaXRpYWxpemU6IChtb2RlbHMsIG9wdGlvbnMgPSB7fSkgLT5cblx0XHR7IEBncm91cCB9ID0gb3B0aW9uc1xuXG5cdG1vZGVsOiBTb3VuZE1vZGVsXG5cblx0YmVsb25nc1RvOiAncmVjaXBlcydcblxuXHR1cmw6ICcvc291bmRzJ1xuXG5cdGZldGNoUmVjdXJzaXZlOiAoQGFwcCwgQHBhcmVudCwgcGFyZW50Q2FsbGJhY2spIC0+XG5cdFx0QGZldGNoXG5cdFx0XHR1cmw6IFwiLyN7QGJlbG9uZ3NUb30vI3tAcGFyZW50LmdldCgnaWQnKX0je0B1cmx9XCIsXG5cdFx0XHRzdWNjZXNzOiAoY29sbGVjdGlvbiwgbW9kZWxzLCBvcHRpb25zKSA9PlxuXHRcdFx0XHRwYXJlbnRDYWxsYmFjay5jYWxsKEAsIG51bGwsIG1vZGVscylcblx0XHRcdFx0IyBmZXRjaFRhc2tzID0gW11cblx0XHRcdFx0IyBAZWFjaCAobW9kZWwpID0+XG5cdFx0XHRcdCMgXHRmZXRjaFRhc2tzLnB1c2ggKGNhbGxiYWNrKSA9PlxuXHRcdFx0XHQjIFx0XHRtb2RlbC5zb3VuZHMuZmV0Y2hSZWN1cnNpdmUgbW9kZWwuaWQsIGNhbGxiYWNrXG5cdFx0XHRcdCMgYXN5bmMucGFyYWxsZWwgZmV0Y2hUYXNrcywgcGFyZW50Q2FsbGJhY2tcblx0XHQsIGdyb3VwOiBAcGFyZW50LCBhcHAsIEBhcHAsIHJlc2V0OiB0cnVlXG5cbm1vZHVsZS5leHBvcnRzID0gU291bmRDb2xsZWN0aW9uIiwiIy8qZ2xvYmFsIHJlcXVpcmUqL1xuJ3VzZSBzdHJpY3QnXG5cbiMgXHRcdGZvdW5kYXRpb25cdFx0XHQ6ICd2ZW5kb3IvZm91bmRhdGlvbi5taW4nXG4jIFx0XHRzb3VuZGNsb3VkXHRcdFx0OiAnaHR0cDovL2Nvbm5lY3Quc291bmRjbG91ZC5jb20vc2RrJ1xuIyBcdFx0Ym9vdHN0cmFwXHRcdFx0XHQ6ICd2ZW5kb3IvYm9vdHN0cmFwLm1pbidcbiMgXHRcdHNvY2tldGlvXHRcdFx0XHQ6ICd2ZW5kb3Ivc29ja2V0LmlvJ1xuIyBcdFx0cGFwZXJcdFx0XHRcdFx0XHQ6ICcvYm93ZXJfY29tcG9uZW50cy9wYXBlci9kaXN0L3BhcGVyLWZ1bGwubWluJ1xuXG5cbiMgYm9vdHN0cmFwIFx0PSByZXF1aXJlKCcuL2Jvd2VyX2NvbXBvbmVudHMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwJylcbiMgVCBcdFx0XHRcdFx0PSByZXF1aXJlKCcuL3ZlbmRvci90aW1icmUnKVxuXG5cdCMgU0MuaW5pdGlhbGl6ZShcblx0IyBcdGNsaWVudF9pZDogJzBkZWU2ZTdiNDI4NTQwZTEwMzczMjYzZGUxY2JmNzExJ1xuXHQjIClcblxud2luZG93LkJlZXRcdD0gd2luZG93LkJlZXQgfHwgcmVxdWlyZSgnLi92aWV3cy9hcHAnKSIsIkJhY2tib25lICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lLiQgICAgICAgICAgICA9ICQgPSByZXF1aXJlKCcuLi92ZW5kb3IvanF1ZXJ5LWJvb3RzdHJhcCcpXG5CYWNrYm9uZS5OZXN0ZWRNb2RlbCAgPSByZXF1aXJlKCdiYWNrYm9uZS1uZXN0ZWQnKS5OZXN0ZWRNb2RlbFxuXyAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpXG5cbmNsYXNzIEJhc2VNb2RlbCBleHRlbmRzIEJhY2tib25lLk5lc3RlZE1vZGVsXG5cbiAgaWRBdHRyaWJ1dGU6ICdfaWQnXG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZU1vZGVsIiwiQmFja2JvbmUgXHRcdFx0PSByZXF1aXJlKCdiYWNrYm9uZScpXG5fXHRcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuXG5jbGFzcyBEaXNwbGF5TW9kZWwgZXh0ZW5kcyBCYWNrYm9uZS5Nb2RlbFxuXHRkZWZhdWx0czpcblx0XHRvbmU6ICdXZWxjb21lJ1xuXHRcdHRpbWU6IDBcblx0aW5pdGlhbGl6ZTogKG9wdGlvbnMpIC0+XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGxheU1vZGVsIiwiQmFja2JvbmUgXHRcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lLiQgXHRcdFx0XHRcdFx0PSByZXF1aXJlKCdqcXVlcnknKVxuQmFja2JvbmUuTmVzdGVkTW9kZWwgXHQ9IHJlcXVpcmUoJ2JhY2tib25lLW5lc3RlZCcpLk5lc3RlZE1vZGVsXG5fXHRcdFx0XHRcdFx0XHRcdFx0XHRcdD0gcmVxdWlyZSgndW5kZXJzY29yZScpXG5Tb3VuZENvbGxlY3Rpb24gXHRcdFx0PSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9zb3VuZCcpXG5QYXR0ZXJuQ29sbGVjdGlvbiBcdFx0PSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9wYXR0ZXJuJylcblxuY2xhc3MgR3JvdXBNb2RlbCBleHRlbmRzIEJhY2tib25lLk5lc3RlZE1vZGVsXG5cblx0aW5pdGlhbGl6ZTogKGF0dHJzID0ge30sIG9wdGlvbnMgPSB7fSkgLT5cblx0XHR7IEBhcHAsIEBwYWRzIH0gPSBvcHRpb25zLmNvbGxlY3Rpb25cblx0XHRAc291bmRzID0gbmV3IFNvdW5kQ29sbGVjdGlvbiBhdHRycy5zb3VuZHMgfHwgW3twYWQ6IDF9XSwgZ3JvdXA6IEBcblx0XHRAcGF0dGVybnMgPSBuZXcgUGF0dGVybkNvbGxlY3Rpb24gYXR0cnMucGF0dGVybnMgfHwgW3twb3NpdGlvbjogMX1dLCBncm91cDogQFxuXG5cdHVybDogKCkgLT5cblx0XHRpZiBAaXNOZXcoKSAmJiBAZ2V0KCdyZWNpcGVfaWQnKVxuXHRcdFx0cmV0dXJuIFwiL3JlY2lwZXMvI3tAZ2V0KCdyZWNpcGVfaWQnKX0vZ3JvdXBzXCJcblx0XHRlbHNlXG5cdFx0XHRpZiBAaXNOZXcoKVxuXHRcdFx0XHRyZXR1cm4gXCIvZ3JvdXBzXCJcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuIFwiL2dyb3Vwcy8je0BnZXQoJ2lkJyl9XCJcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cE1vZGVsIiwiQmFja2JvbmUgXHRcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lLk5lc3RlZE1vZGVsIFx0PSByZXF1aXJlKCdiYWNrYm9uZS1uZXN0ZWQnKS5OZXN0ZWRNb2RlbFxuX1x0XHRcdFx0XHRcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuJCBcdFx0XHRcdFx0XHRcdFx0XHRcdD0gcmVxdWlyZSgnanF1ZXJ5JylcblBhdHRlcm5HcmlkVmlld1x0IFx0XHRcdD0gcmVxdWlyZSgnLi4vdmlld3MvcGF0dGVybi5ncmlkJylcblxuY2xhc3MgUGF0dGVybk1vZGVsIGV4dGVuZHMgQmFja2JvbmUuTmVzdGVkTW9kZWxcblxuXHRkZWZhdWx0czogKCkgLT5cblx0XHRhdHRycyA9IFxuXHRcdFx0dHJpZ2dlcnM6IHt9XG5cdFx0XHRsZW46IDRcblx0XHRcdHBvc2l0aW9uOiAxXG5cdFx0XHR6b29tOiAyXG5cdFx0XHRzdGVwOiA2NFxuXG5cdHVybDogKCkgLT5cblx0XHRpZiBAaXNOZXcoKSAmJiBAZ2V0KCdncm91cElkJylcblx0XHRcdHJldHVybiBcIi9ncm91cHMvI3tAZ2V0KCdncm91cElkJyl9L3BhdHRlcm5zXCJcblx0XHRlbHNlXG5cdFx0XHRpZiBAaXNOZXcoKVxuXHRcdFx0XHRyZXR1cm4gXCIvcGF0dGVybnNcIlxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm4gXCIvcGF0dGVybnMvI3tAZ2V0KCdpZCcpfVwiXG5cblx0aW5pdGlhbGl6ZTogKGF0dHJzID0ge30sIG9wdGlvbnMgPSB7fSkgLT5cblx0XHRAdmlldyA9IG5ldyBQYXR0ZXJuR3JpZFZpZXcgbW9kZWw6IEBcblxuXHR0b0pTT046IC0+XG5cdFx0YXR0cnMgPSAkLmV4dGVuZCB7fSwgQGF0dHJpYnV0ZXNcblx0XHRhdHRycy56b29tID0gcGFyc2VJbnQoYXR0cnMuem9vbSwgMTApIHx8IDJcblx0XHRhdHRycy5zdGVwID0gcGFyc2VJbnQoYXR0cnMuc3RlcCwgMTApIHx8IDY0XG5cdFx0YXR0cnNcblxubW9kdWxlLmV4cG9ydHMgPSBQYXR0ZXJuTW9kZWwiLCJCYWNrYm9uZSBcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lTmVzdGVkIFx0XHRcdD0gcmVxdWlyZSgnYmFja2JvbmUtbmVzdGVkJylcbl9cdFx0XHRcdFx0XHRcdFx0XHRcdD0gcmVxdWlyZSgndW5kZXJzY29yZScpXG5cbmNsYXNzIFJlY2lwZU1vZGVsIGV4dGVuZHMgQmFja2JvbmUuTmVzdGVkTW9kZWxcblx0ZGVmYXVsdHM6IFxuXHRcdG5hbWU6ICdOZXcgUmVjaXBlJ1xuXG5cdHVybFJvb3Q6ICcvcmVjaXBlcydcblxubW9kdWxlLmV4cG9ydHMgPSBSZWNpcGVNb2RlbCIsIiQgICAgICAgICAgPSByZXF1aXJlKCcuLi92ZW5kb3IvanF1ZXJ5LWJvb3RzdHJhcCcpXG5fICAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpXG5UICAgICAgICAgID0gcmVxdWlyZSgnLi4vdmVuZG9yL3RpbWJyZS5kZXYnKVxuQmFzZU1vZGVsICA9IHJlcXVpcmUoJy4vYmFzZScpXG5cbmNsYXNzIFNvdW5kTW9kZWwgZXh0ZW5kcyBCYXNlTW9kZWxcblxuICB1cmw6ICgpIC0+XG4gICAgaWYgQGlzTmV3KCkgJiYgQGdldCgnZ3JvdXBJZCcpXG4gICAgICByZXR1cm4gXCIvZ3JvdXBzLyN7QGdldCgnZ3JvdXBJZCcpfS9zb3VuZHNcIlxuICAgIGVsc2VcbiAgICAgIGlmIEBpc05ldygpIHRoZW4gXCIvc291bmRzXCIgZWxzZSBcIi9zb3VuZHMvI3tAZ2V0KCdfaWQnKX1cIlxuXG4gIGluaXRpYWxpemU6IChhdHRycyA9IHt9LCBvcHRpb25zID0ge30pIC0+XG4gICAgXy5iaW5kQWxsIHRoaXMsICdsb2FkU3JjJ1xuICAgIGlmIEBjb2xsZWN0aW9uPy5ncm91cC5hcHAucGFkcz9cbiAgICAgIEBjb2xsZWN0aW9uLmdyb3VwLmFwcC5wYWRzLnBhZHNbQGdldCgncGFkJykgLSAxICUgMTZdPy5ib290c3RyYXBXaXRoTW9kZWwoQClcbiAgICBAb24gJ2NoYW5nZTpzcmMnLCBAbG9hZFNyY1xuICAgIEBvbiAnY2hhbmdlOmZ4JywgKCkgPT5cbiAgICAgIEB0aW1icmVDb250ZXh0QXR0YWNoZWQgPSBmYWxzZVxuICAgICAgQHJlbmRlcmVkID0gZmFsc2VcblxuICBwbGF5OiAoKSAtPlxuICAgIGlmIG5vdCBAcmVuZGVyZWRcbiAgICAgIHNvdW5kID0gQHJlbmRlckVmZmVjdHMoKVxuICAgICAgaWYgbm90IEB0aW1icmVDb250ZXh0QXR0YWNoZWRcbiAgICAgICAgQHRpbWJyZUNvbnRleHRBdHRhY2hlZCA9IHRydWVcbiAgICAgICAgJChzb3VuZC5wbGF5KCkpLm9uZSgnZW5kZWQnLCBAb25FbmRlZClcbiAgICAgIGVsc2VcbiAgICAgICAgc291bmQuYmFuZygpXG4gICAgZWxzZVxuICAgICAgaWYgQFQucmVuZGVyZWQ/LnBsYXliYWNrU3RhdGVcbiAgICAgICAgQFQucmVuZGVyZWQuY3VycmVudFRpbWUgPSAwXG4gICAgICBlbHNlXG4gICAgICAgICQoQFQucmVuZGVyZWQuYmFuZygpKS5vbmUoJ2VuZGVkJywgQG9uRW5kZWQpXG4gICAgcmV0dXJuIEBcblxuICBvbkVuZGVkOiAtPlxuICAgICMgdGltYnJlIGFwaSBodHRwOi8vbW9oYXlvbmFvLmdpdGh1Yi5pby90aW1icmUuanMvYXVkaW8uaHRtbFxuICAgIEBwYXVzZSgpXG5cbiAgcmVuZGVyRWZmZWN0czogKGNiKSAtPlxuXG4gICAgc291bmQgPSBudWxsXG5cbiAgICBkZWxldGUgQFQucmVuZGVyZWQgaWYgQFRcblxuICAgIEBULnJlbmRlcmVkID0gQFQucmF3LmNsb25lKClcblxuICAgIF8uZWFjaCBAZ2V0KCdmeCcpLCAocGFyYW1zLCBmeCkgPT5cbiAgICAgIHNvdW5kID0gVChmeCwgcGFyYW1zLCBzb3VuZCB8fCBAVC5yZW5kZXJlZClcblxuICAgIEByZW5kZXJlZCA9IHRydWVcblxuICAgIHJldHVybiBzb3VuZCB8fCBAVC5yZW5kZXJlZFxuXG4gIGxvYWRTcmM6IChtb2RlbCwgc3JjLCBvcHRpb25zLCBjYikgLT5cbiAgICBfdGhpcyA9IEBcbiAgICBpZiBzcmMgfHwgQGdldCgnc3JjJylcbiAgICAgIEBsb2FkZWQgPSBmYWxzZVxuICAgICAgVCgnYXVkaW8nKS5sb2FkIChzcmMgfHwgQGdldCgnc3JjJykpLCAtPlxuICAgICAgICBfdGhpcy5UID0gcmF3OiB0aGlzXG4gICAgICAgIF90aGlzLmxvYWRlZCA9IHRydWVcbiAgICAgICAgX3RoaXMudHJpZ2dlcignbG9hZGVkJylcbiAgICAgICAgY2IuY2FsbCBfdGhpcywgdGhpcyBpZiBjYlxuICAjIGRlZmF1bHRzOlxuICAjICAgZng6IHt9XG4gICAgICAjIGVxOlxuICAgICAgIyAgIHBhcmFtczpcbiAgICAgICMgICAgIGxwZjogIFsyMCwgICAgMSwgMjBdXG4gICAgICAjICAgICBsZjogICBbMTAwLCAgIDEsIDIwXVxuICAgICAgIyAgICAgbG1mOiAgWzMwMCwgICAxLCAyMF1cbiAgICAgICMgICAgIG1mOiAgIFs3NTAsICAgMSwgMjBdXG4gICAgICAjICAgICBobWY6ICBbMjAwMCwgIDEsIDIwXVxuICAgICAgIyAgICAgaGY6ICAgWzcwMDAsICAxLCAyMF1cbiAgICAgICMgICAgIGhwZjogIFsyMDAwMCwgMSwgMjBdXG4gICAgIyBrZXk6ICcnXG4gICAgIyBuYW1lOiAnJ1xuICAgICMga2V5Q29kZTogJydcbiAgICAjIHNyYzogJydcblxubW9kdWxlLmV4cG9ydHMgPSBTb3VuZE1vZGVsIiwiQmFja2JvbmUgXHRcdFx0PSByZXF1aXJlKCdiYWNrYm9uZScpXG5fXHRcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuXG5jbGFzcyBUcmFuc3BvcnRNb2RlbCBleHRlbmRzIEJhY2tib25lLk1vZGVsXG5cblx0aW5pdGlhbGl6ZTogKGF0dHJzID0ge30pIC0+XG5cdFx0aWYgYXR0cnMuYnBtPyBhbmQgYXR0cnMuc3RlcFxuXHRcdFx0QHNldEludGVydmFsKGF0dHJzLmJwbSwgYXR0cnMuc3RlcClcblx0XHRAb24gJ2NoYW5nZTppbnRlcnZhbCcsIEBzZXRJbnRlcnZhbFxuXHRcdEBvbiAnY2hhbmdlOmJwbScsIEBzZXRJbnRlcnZhbFxuXHRcdEBvbiAnY2hhbmdlOnN0ZXAnLCBAc2V0SW50ZXJ2YWxcblxuXHQjIGNhbGN1bGF0ZXMgdGhlIG5lZWRlZCBtaWxsaXNlY29uZCBpbnRlcnZhbFxuXHQjIGJhc2VkIG9uIHRoZSBCUE0gYW5kIHNlcXVlbmNlIHN0ZXBcblx0c2V0SW50ZXJ2YWw6IChicG0sIHN0ZXApIC0+XG5cdFx0aW50ZXJ2YWwgPSAoKDYwICogMTAwMCkgLyBwYXJzZUludChicG0gb3IgQGdldCgnYnBtJyksIDEwKSAvIHBhcnNlSW50KHN0ZXAgb3IgQGdldCgnc3RlcCcpLCAxMCkpXG5cdFx0QHNldCgnaW50ZXJ2YWwnLCBpbnRlcnZhbClcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNb2RlbCIsIkJhY2tib25lIFx0XHRcdD0gcmVxdWlyZSgnYmFja2JvbmUnKVxuX1x0XHRcdFx0XHRcdFx0PSByZXF1aXJlKCd1bmRlcnNjb3JlJylcblxuY2xhc3MgQXBwUm91dGVyIGV4dGVuZHMgQmFja2JvbmUuUm91dGVyXG5cdHJvdXRlczoge1xuXHRcdCcnXHRcdFx0XHRcdFx0OiAnbWFpbidcblx0XHQncGFkLzpudW0nXHRcdDogJ3NvdW5kRWRpdG9yJ1xuXHRcdCdiZWV0LzppZCdcdFx0OiAnb3Blbidcblx0fVxuXG5cdGluaXRpYWxpemU6IChvcHRpb25zKSAtPlxuXHRcdHsgQGFwcCB9ID0gb3B0aW9uc1xuXG5cdG1haW46IC0+XG5cblx0c291bmRFZGl0b3I6IChwYWROdW1iZXIpIC0+XG5cdFx0XG5cdG9wZW46IChpZCkgLT5cblx0XHRjb25zb2xlLmxvZygnb3BlbiAnK2lkKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcFJvdXRlciIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cInJvd1wiPlxcblxcdDxkaXYgY2xhc3M9XCJjb2wteHMtMTJcIj5cXG5cXHRcXHQ8cHJlIGNsYXNzPVwidGlueVwiPlxcbiBfICAgICAgICAgICAgICAgXyAgICAgICAgICAgICAgICAgICAgICAgIF8gICAgIF8gICAgICAgICAgICBcXG58IHxfXyAgIF9fXyAgX19ffCB8XyBfIF9fIF9fXyAgIF9fIF8gIF9fX3wgfF9fIChfKV8gX18gICBfX18gXFxufCBcXCdfIFxcXFwgLyBfIFxcXFwvIF8gXFxcXCBfX3wgXFwnXyBgIF8gXFxcXCAvIF9gIHwvIF9ffCBcXCdfIFxcXFx8IHwgXFwnXyBcXFxcIC8gXyBcXFxcXFxufCB8XykgfCAgX18vICBfXy8gfF98IHwgfCB8IHwgfCAoX3wgfCAoX198IHwgfCB8IHwgfCB8IHwgIF9fL1xcbnxfLl9fLyBcXFxcX19ffFxcXFxfX198XFxcXF9ffF98IHxffCB8X3xcXFxcX18sX3xcXFxcX19ffF98IHxffF98X3wgfF98XFxcXF9fX3xcXG5cXHRcXHQ8L3ByZT5cXG5cXHRcXHQ8c3BhbiBsZy1iaW5kPVwib25lXCI+JytcbigoX190PSggb25lICkpPT1udWxsPycnOl9fdCkrXG4nPC9zcGFuPlxcblxcdDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XCJyb3dcIj5cXG5cXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTZcIj5cXG5cXHRcXHQ8c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwiZm9udC1mYW1pbHk6Q291cmllclwiIGxnLWJpbmQ9XCJsZWZ0XCI+MDA6MDA6MDA6MDA8L3NwYW4+XFxuXFx0PC9kaXY+XFxuXFx0PGRpdiBjbGFzcz1cImNvbC14cy02XCIgbGctYmluZD1cInJpZ2h0XCI+XFxuXFx0PC9kaXY+XFxuPC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59OyIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZ1wiPlxcblxcdDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+XFxuXFx0XFx0PGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxcblxcdFxcdFxcdDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cImNsb3NlIHJpZ2h0XCIgZGF0YS1kaXNtaXNzPVwibW9kYWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9hPlxcblxcdFxcdFxcdDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+U291bmQgRWRpdG9yOiA8c3BhbiBsZy1iaW5kPVwibmFtZVwiPjwvc3Bhbj48L2g0PlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XFxuXFx0XFx0XFx0PGZvcm0gY2xhc3M9XCJmb3JtLWhvcml6b250YWxcIiBvbnN1Ym1pdD1cInJldHVybiBmYWxzZVwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy0xMlwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxsYWJlbD5OYW1lPC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiXCIgbGctYmluZD1cIm5hbWVcIiAvPlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy0xMlwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxsYWJlbD5Tb3VyY2U8L2xhYmVsPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxpbnB1dCBjbGFzcz1cImZvcm0tY29udHJvbCByZWFkb25seVwiIHJlYWRvbmx5IHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJcIiBsZy1iaW5kPVwic3JjXCIgLz5cXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwicm93XCI+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy0xMlwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxjYW52YXMgd2lkdGg9XCI1NThcIiBoZWlnaHQ9XCIxMDBcIiBjbGFzcz1cIndhdmVmb3JtXCIgYWx0PVwiQ2xpY2sgdG8gcHJldmlld1wiPk5vIFBhZCBvciBOb3QgUmVuZGVyZWQgWWV0PC9jYW52YXM+XFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTZcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+S2V5IFRyaWdnZXI6PC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiXCIgbGctYmluZD1cImtleUNvZGVcIiAvPlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJjb2wteHMtNlwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJyb3cgY29sbGFwc2VcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+RWZmZWN0czwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy05XCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIlwiIC8+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTEyXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tZ3JvdXAtanVzdGlmaWVkXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGEgY2xhc3M9XCJidG4gYnRuLXNxdWlzaHkgYnRuLXNtIGFjdGl2ZVwiIGhyZWY9XCIjZWRpdG9yLycrXG4oKF9fdD0oIGRhdGEucGFkICkpPT1udWxsPycnOl9fdCkrXG4nLWVxXCIgZGF0YS1iZWhhdmlvcj1cInRhYlwiIGRhdGEtdGFiPVwiLmVxXCI+RVE8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGEgY2xhc3M9XCJidG4gYnRuLXNxdWlzaHkgYnRuLXNtXCIgaHJlZj1cIiNlZGl0b3IvJytcbigoX190PSggZGF0YS5wYWQgKSk9PW51bGw/Jyc6X190KStcbictcmV2ZXJiXCIgZGF0YS1iZWhhdmlvcj1cInRhYlwiIGRhdGEtdGFiPVwiLnJldmVyYlwiPlJldmVyYjwvYT5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8YSBjbGFzcz1cImJ0biBidG4tc3F1aXNoeSBidG4tc21cIiBocmVmPVwiI2VkaXRvci8nK1xuKChfX3Q9KCBkYXRhLnBhZCApKT09bnVsbD8nJzpfX3QpK1xuJy1kZWxheVwiIGRhdGEtYmVoYXZpb3I9XCJ0YWJcIiBkYXRhLXRhYj1cIi5kZWxheVwiPkRlbGF5PC9hPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxhIGNsYXNzPVwiYnRuIGJ0bi1zcXVpc2h5IGJ0bi1zbVwiIGhyZWY9XCIjZWRpdG9yLycrXG4oKF9fdD0oIGRhdGEucGFkICkpPT1udWxsPycnOl9fdCkrXG4nLWNob3J1c1wiIGRhdGEtYmVoYXZpb3I9XCJ0YWJcIiBkYXRhLXRhYj1cIi5jaG9ydXNcIj5DaG9ydXM8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cInRhYi1jb250ZW50XCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cInRhYi1wYW5lIGVxXCIgJytcbigoX190PSggIXZpZXcuc2hvdyA/ICdsZycgOiAnJyApKT09bnVsbD8nJzpfX3QpK1xuJz5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8Y2FudmFzIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6MTAwcHg7XCIgY2xhc3M9XCJlcWZvcm1cIj48L2NhbnZhcz5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJjb2wteHMtMTJcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+aHBmPC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJlcVwiIGRhdGEtcGFyYW09XCJocGZcIiBtaW49XCItMjBcIiBtYXg9XCIyMFwiIHN0ZXA9XCIwLjVcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+bGY8L2xhYmVsPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBjbGFzcz1cImVxXCIgZGF0YS1wYXJhbT1cImxmXCIgbWluPVwiLTIwXCIgbWF4PVwiMjBcIiBzdGVwPVwiMC41XCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGxhYmVsPmxtZjwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XCJyYW5nZVwiIGNsYXNzPVwiZXFcIiBkYXRhLXBhcmFtPVwibG1mXCIgbWluPVwiLTIwXCIgbWF4PVwiMjBcIiBzdGVwPVwiMC41XCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGxhYmVsPm1mPC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJlcVwiIGRhdGEtcGFyYW09XCJtZlwiIG1pbj1cIi0yMFwiIG1heD1cIjIwXCIgc3RlcD1cIjAuNVwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxsYWJlbD5obWY8L2xhYmVsPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBjbGFzcz1cImVxXCIgZGF0YS1wYXJhbT1cImhtZlwiIG1pbj1cIi0yMFwiIG1heD1cIjIwXCIgc3RlcD1cIjAuNVwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxsYWJlbD5oZjwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XCJyYW5nZVwiIGNsYXNzPVwiZXFcIiBkYXRhLXBhcmFtPVwiaGZcIiBtaW49XCItMjBcIiBtYXg9XCIyMFwiIHN0ZXA9XCIwLjVcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+bHBmPC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJlcVwiIGRhdGEtcGFyYW09XCJscGZcIiBtaW49XCItMjBcIiBtYXg9XCIyMFwiIHN0ZXA9XCIwLjVcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwidGFiLXBhbmUgcmV2ZXJiXCIgJytcbigoX190PSggdmlldy5zaG93ID09PSAncmV2ZXJiJyA/ICcnIDogJ2hpZGRlbicgKSk9PW51bGw/Jyc6X190KStcbic+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0JztcbiBpZiAoZGF0YS5meCAmJiBkYXRhLmZ4LnJldmVyYikgeyBcbl9fcCs9J1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy0xMiB0ZXh0LXJpZ2h0XCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGEgY2xhc3M9XCJidG4gYnRuLXNxdWlzaHkgYnRuLXNtXCIgZGF0YS1iZWhhdmlvcj1cInRvZ2dsZUVmZmVjdFwiIGRhdGEtZWZmZWN0PVwicmV2ZXJiXCI+RGlzYWJsZSBSZXZlcmI8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTRcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+Um9vbSA8c3BhbiBjbGFzcz1cImxhYmVsIGxhYmVsLWRlZmF1bHRcIiBsZy1iaW5kPVwiZngucmV2ZXJiLnJvb21cIj4nK1xuKChfX3Q9KCBkYXRhLmZ4LnJldmVyYi5yb29tICkpPT1udWxsPycnOl9fdCkrXG4nPC9zcGFuPjwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XCJyYW5nZVwiIGxnLWJpbmQ9XCJmeC5yZXZlcmIucm9vbVwiIG1pbj1cIjBcIiBtYXg9XCIyXCIgc3RlcD1cIjAuMVwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJjb2wteHMtNFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxsYWJlbD5XZXQvRHJ5IDxzcGFuIGNsYXNzPVwibGFiZWwgbGFiZWwtZGVmYXVsdFwiIGxnLWJpbmQ9XCJmeC5yZXZlcmIuZGFtcFwiPicrXG4oKF9fdD0oIGRhdGEuZngucmV2ZXJiLmRhbXAgKSk9PW51bGw/Jyc6X190KStcbic8L3NwYW4+PC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cInJhbmdlXCIgbGctYmluZD1cImZ4LnJldmVyYi5kYW1wXCIgbWluPVwiMFwiIG1heD1cIjFcIiBzdGVwPVwiMC4xXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy00XCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGxhYmVsPk1peCA8c3BhbiBjbGFzcz1cImxhYmVsIGxhYmVsLWRlZmF1bHRcIiBsZy1iaW5kPVwiZngucmV2ZXJiLm1peFwiPicrXG4oKF9fdD0oIGRhdGEuZngucmV2ZXJiLm1peCApKT09bnVsbD8nJzpfX3QpK1xuJzwvc3Bhbj48L2xhYmVsPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBsZy1iaW5kPVwiZngucmV2ZXJiLm1peFwiIG1pbj1cIjBcIiBtYXg9XCIxXCIgc3RlcD1cIjAuMDFcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQnO1xuIH0gZWxzZSB7IFxuX19wKz0nXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTEyXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGEgY2xhc3M9XCJidG4gYnRuLXNxdWlzaHkgYnRuLXNtXCIgZGF0YS1iZWhhdmlvcj1cInRvZ2dsZUVmZmVjdFwiIGRhdGEtZWZmZWN0PVwicmV2ZXJiXCI+RW5hYmxlIFJldmVyYjwvYT5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQnO1xuIH0gXG5fX3ArPSdcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwidGFiLXBhbmUgZGVsYXlcIiAnK1xuKChfX3Q9KCB2aWV3LnNob3cgPT09ICdkZWxheScgPyAnJyA6ICdoaWRkZW4nICkpPT1udWxsPycnOl9fdCkrXG4nPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCc7XG4gaWYgKGRhdGEuZnggJiYgZGF0YS5meC5kZWxheSkgeyBcbl9fcCs9J1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy0xMiB0ZXh0LXJpZ2h0XCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGEgY2xhc3M9XCJidG4gYnRuLXNxdWlzaHkgYnRuLXNtXCIgZGF0YS1iZWhhdmlvcj1cInRvZ2dsZUVmZmVjdFwiIGRhdGEtZWZmZWN0PVwiZGVsYXlcIj5EaXNhYmxlIERlbGF5PC9hPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy00XCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGxhYmVsPlRpbWUgPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1kZWZhdWx0XCIgbGctYmluZD1cImZ4LmRlbGF5LnRpbWVcIj4nK1xuKChfX3Q9KCBkYXRhLmZ4LmRlbGF5LnRpbWUgKSk9PW51bGw/Jyc6X190KStcbic8L3NwYW4+PC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cInJhbmdlXCIgbGctYmluZD1cImZ4LmRlbGF5LnRpbWVcIiBtaW49XCIxMFwiIG1heD1cIjEyNTBcIiBzdGVwPVwiMTBcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTRcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+RmVlZGJhY2sgPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1kZWZhdWx0XCIgbGctYmluZD1cImZ4LmRlbGF5LmZiXCI+JytcbigoX190PSggZGF0YS5meC5kZWxheS5mYiApKT09bnVsbD8nJzpfX3QpK1xuJzwvc3Bhbj48L2xhYmVsPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBsZy1iaW5kPVwiZnguZGVsYXkuZmJcIiBtaW49XCItMVwiIG1heD1cIjFcIiBzdGVwPVwiMC4xXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy0xXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGxhYmVsPkNyb3NzIERlbGF5IDxzcGFuIGNsYXNzPVwibGFiZWwgbGFiZWwtZGVmYXVsdFwiIGxnLWJpbmQ9XCJmeC5kZWxheS5jcm9zc1wiPicrXG4oKF9fdD0oIGRhdGEuZnguZGVsYXkuY3Jvc3MgKSk9PW51bGw/Jyc6X190KStcbic8L3NwYW4+PC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cInJhbmdlXCIgbGctYmluZD1cImZ4LmRlbGF5LmNyb3NzXCIgbWluPVwiMFwiIG1heD1cIjFcIiBzdGVwPVwiMC4wMVwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJjb2wteHMtM1wiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxsYWJlbD5NaXggPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1kZWZhdWx0XCIgbGctYmluZD1cImZ4LmRlbGF5Lm1peFwiPicrXG4oKF9fdD0oIGRhdGEuZnguZGVsYXkubWl4ICkpPT1udWxsPycnOl9fdCkrXG4nPC9zcGFuPjwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XCJyYW5nZVwiIGxnLWJpbmQ9XCJmeC5kZWxheS5taXhcIiBtaW49XCIwXCIgbWF4PVwiMVwiIHN0ZXA9XCIwLjAxXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0JztcbiB9IGVsc2UgeyBcbl9fcCs9J1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy0xMlwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxhIGNsYXNzPVwiYnRuIGJ0bi1zcXVpc2h5IGJ0bi1zbVwiIGRhdGEtYmVoYXZpb3I9XCJ0b2dnbGVFZmZlY3RcIiBkYXRhLWVmZmVjdD1cImRlbGF5XCI+RW5hYmxlIERlbGF5PC9hPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCc7XG4gfSBcbl9fcCs9J1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJ0YWItcGFuZSBjaG9ydXNcIiAnK1xuKChfX3Q9KCB2aWV3LnNob3cgPT09ICdjaG9ydXMnID8gJycgOiAnaGlkZGVuJyApKT09bnVsbD8nJzpfX3QpK1xuJz5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQnO1xuIGlmIChkYXRhLmZ4ICYmIGRhdGEuZnguY2hvcnVzKSB7IFxuX19wKz0nXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTEyIHRleHQtcmlnaHRcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8YSBjbGFzcz1cImJ0biBidG4tc3F1aXNoeSBidG4tc21cIiBkYXRhLWJlaGF2aW9yPVwidG9nZ2xlRWZmZWN0XCIgZGF0YS1lZmZlY3Q9XCJjaG9ydXNcIj5EaXNhYmxlIENob3J1czwvYT5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+VHlwZSA8c3BhbiBjbGFzcz1cImxhYmVsIGxhYmVsLWRlZmF1bHRcIiBsZy1iaW5kPVwiZnguY2hvcnVzLnR5cGVcIj4nK1xuKChfX3Q9KCBkYXRhLmZ4LmNob3J1cy50eXBlICkpPT1udWxsPycnOl9fdCkrXG4nPC9zcGFuPjwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PHNlbGVjdCBsZy1iaW5kPVwiZnguY2hvcnVzLnR5cGVcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxvcHRpb24gdmFsdWU9XCJzaW5cIj5TaW48L29wdGlvbj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8b3B0aW9uIHZhbHVlPVwidHJpXCI+VHJpPC9vcHRpb24+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9zZWxlY3Q+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTRcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+RGVsYXkgPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1kZWZhdWx0XCIgbGctYmluZD1cImZ4LmNob3J1cy5kZWxheVwiPicrXG4oKF9fdD0oIGRhdGEuZnguY2hvcnVzLmRlbGF5ICkpPT1udWxsPycnOl9fdCkrXG4nPC9zcGFuPjwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XCJyYW5nZVwiIGxnLWJpbmQ9XCJmeC5jaG9ydXMuZGVsYXlcIiBtaW49XCIwLjVcIiBtYXg9XCI4MFwiIHN0ZXA9XCIwLjVcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTRcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+UmF0ZSA8c3BhbiBjbGFzcz1cImxhYmVsIGxhYmVsLWRlZmF1bHRcIiBsZy1iaW5kPVwiZnguY2hvcnVzLnJhdGVcIj4nK1xuKChfX3Q9KCBkYXRhLmZ4LmNob3J1cy5yYXRlICkpPT1udWxsPycnOl9fdCkrXG4nPC9zcGFuPjwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XCJyYW5nZVwiIGxnLWJpbmQ9XCJmeC5jaG9ydXMucmF0ZVwiIG1pbj1cIjBcIiBtYXg9XCIxMFwiIHN0ZXA9XCIwLjVcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTRcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+RGVwdGggPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1kZWZhdWx0XCIgbGctYmluZD1cImZ4LmNob3J1cy5kZXB0aFwiPicrXG4oKF9fdD0oIGRhdGEuZnguY2hvcnVzLmRlcHRoICkpPT1udWxsPycnOl9fdCkrXG4nPC9zcGFuPjwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XCJyYW5nZVwiIGxnLWJpbmQ9XCJmeC5jaG9ydXMuZGVwdGhcIiBtaW49XCIwXCIgbWF4PVwiMTAwXCIgc3RlcD1cIjFcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJjb2wteHMtNFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxsYWJlbD5GZWVkYmFjayA8c3BhbiBjbGFzcz1cImxhYmVsIGxhYmVsLWRlZmF1bHRcIiBsZy1iaW5kPVwiZnguY2hvcnVzLmZiXCI+JytcbigoX190PSggZGF0YS5meC5jaG9ydXMuZmIgKSk9PW51bGw/Jyc6X190KStcbic8L3NwYW4+PC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cInJhbmdlXCIgbGctYmluZD1cImZ4LmNob3J1cy5mYlwiIG1pbj1cIi0xXCIgbWF4PVwiMVwiIHN0ZXA9XCIwLjFcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTRcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8bGFiZWw+V2V0IDxzcGFuIGNsYXNzPVwibGFiZWwgbGFiZWwtZGVmYXVsdFwiIGxnLWJpbmQ9XCJmeC5jaG9ydXMud2V0XCI+JytcbigoX190PSggZGF0YS5meC5jaG9ydXMud2V0ICkpPT1udWxsPycnOl9fdCkrXG4nPC9zcGFuPjwvbGFiZWw+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XCJyYW5nZVwiIGxnLWJpbmQ9XCJmeC5jaG9ydXMud2V0XCIgbWluPVwiMFwiIG1heD1cIjFcIiBzdGVwPVwiMC4wMVwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJjb2wteHMtNFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxsYWJlbD5NaXggPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1kZWZhdWx0XCIgbGctYmluZD1cImZ4LmNob3J1cy5taXhcIj4nK1xuKChfX3Q9KCBkYXRhLmZ4LmNob3J1cy5taXggKSk9PW51bGw/Jyc6X190KStcbic8L3NwYW4+PC9sYWJlbD5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cInJhbmdlXCIgbGctYmluZD1cImZ4LmNob3J1cy5taXhcIiBtaW49XCIwXCIgbWF4PVwiMVwiIHN0ZXA9XCIwLjAxXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0JztcbiB9IGVsc2UgeyBcbl9fcCs9J1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImNvbC14cy0xMlwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxhIGNsYXNzPVwiYnRuIGJ0bi1zcXVpc2h5IGJ0bi1zbVwiIGRhdGEtYmVoYXZpb3I9XCJ0b2dnbGVFZmZlY3RcIiBkYXRhLWVmZmVjdD1cImNob3J1c1wiPkVuYWJsZSBDaG9ydXM8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0JztcbiB9IFxuX19wKz0nXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVwiY29sLXhzLTEyXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PHRleHRhcmVhIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgcGxhY2Vob2xkZXI9XCJcIj48L3RleHRhcmVhPlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZm9ybT5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+XFxuXFx0XFx0XFx0PGEgZGF0YS1kaXNtaXNzPVwibW9kYWxcIiBkYXRhLWJlaGF2aW9yPVwiY2xvc2VcIiBjbGFzcz1cImJ0biBidG4tc20gYnRuLXNxdWlzaHlcIj5DYW5jZWw8L2E+XFxuXFx0XFx0XFx0PGEgZGF0YS1kaXNtaXNzPVwibW9kYWxcIiBkYXRhLWJlaGF2aW9yPVwic2F2ZVwiIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tc3F1aXNoeVwiPlNhdmU8L2E+XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9kaXY+XFxuPC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59OyIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cInBhZC1sYWJlbFwiPlxcblxcdDxzbWFsbCBsZy1iaW5kPVwibmFtZVwiPicrXG4oKF9fdD0oIG5hbWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9zbWFsbD5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVwicGFkIGJ0biBidG4tc3F1aXNoeVwiPiZuYnNwOzwvZGl2PlxcbjxkaXYgY2xhc3M9XCJwcm9ncmVzc1wiPlxcbiAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhclwiPjwvZGl2PlxcbjwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTsiLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9J1xcblxcbic7XG59XG5yZXR1cm4gX19wO1xufTsiLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYnRuLWdyb3VwLWp1c3RpZmllZFwiPlxcblxcdDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJlaGF2aW9yPVwicGxheVwiIGNsYXNzPVwiYnRuIGJ0bi1zcXVpc2h5IGJ0bi1zbVwiPlxcblxcdFxcdDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbGF5XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1wYXVzZVwiPjwvc3Bhbj4gUGxheVxcblxcdDwvYT5cXG5cXHQ8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgZGF0YS1iZWhhdmlvcj1cInJlY29yZFwiIGNsYXNzPVwiYnRuIGJ0bi1zcXVpc2h5IGJ0bi1zbVwiPlxcblxcdFxcdDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZWNvcmRcIj48L3NwYW4+IFJlY29yZFxcblxcdDwvYT5cXG5cXHQ8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgZGF0YS1iZWhhdmlvcj1cInN0b3BcIiBjbGFzcz1cImJ0biBidG4tc3F1aXNoeSBidG4tc21cIj5cXG5cXHRcXHQ8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tc3RvcFwiPjwvc3Bhbj4gU3RvcFxcblxcdDwvYT5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIGJ0bi1ncm91cC1qdXN0aWZpZWRcIj5cXG5cXHQ8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgZGF0YS1iZWhhdmlvcj1cInJlc3RhcnRcIiBjbGFzcz1cImJ0biBidG4tc3F1aXNoeSBidG4tc21cIj5cXG5cXHRcXHQ8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tc3RlcC1iYWNrd2FyZFwiPjwvc3Bhbj5cXG5cXHQ8L2E+XFxuXFx0PGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGRhdGEtYmVoYXZpb3I9XCJlbmRcIiBjbGFzcz1cImJ0biBidG4tc3F1aXNoeSBidG4tc21cIj5cXG5cXHRcXHQ8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tc3RlcC1mb3J3YXJkXCI+PC9zcGFuPlxcblxcdDwvYT5cXG48L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07IiwiJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG53aW5kb3cuJCA9IHdpbmRvdy5qUXVlcnkgPSAkXG5cbnJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy90d2l0dGVyLWJvb3RzdHJhcC9qcy9ib290c3RyYXAtYWxlcnQuanMnKTtcbnJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy90d2l0dGVyLWJvb3RzdHJhcC9qcy9ib290c3RyYXAtYnV0dG9uLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvdHdpdHRlci1ib290c3RyYXAvanMvYm9vdHN0cmFwLWRyb3Bkb3duLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvdHdpdHRlci1ib290c3RyYXAvanMvYm9vdHN0cmFwLW1vZGFsLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvdHdpdHRlci1ib290c3RyYXAvanMvYm9vdHN0cmFwLXRvb2x0aXAuanMnKTtcbnJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy90d2l0dGVyLWJvb3RzdHJhcC9qcy9ib290c3RyYXAtcG9wb3Zlci5qcycpO1xucmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL3R3aXR0ZXItYm9vdHN0cmFwL2pzL2Jvb3RzdHJhcC10cmFuc2l0aW9uLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvdHdpdHRlci1ib290c3RyYXAvanMvYm9vdHN0cmFwLXR5cGVhaGVhZC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICQ7IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBUKFwidGltYnJlLmpzXCIpIC0gQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIG9iamVjdGl2ZSBzb3VuZCBwcm9ncmFtbWluZ1xuICovXG4oZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgdGltYnJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBULmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIHZhciBGSU5JU0hFRF9TVEFURSAgICA9IDA7XG4gICAgdmFyIFBMQVlJTkdfU1RBVEUgICAgID0gMTtcbiAgICB2YXIgVU5TQ0hFRFVMRURfU1RBVEUgPSAyOyAvLyAobm90IHVzZSlcbiAgICB2YXIgU0NIRURVTEVEX1NUQVRFICAgPSAzOyAvLyAobm90IHVzZSlcblxuICAgIHZhciBBQ0NFUFRfU0FNUExFUkFURVMgPSBbODAwMCwxMTAyNSwxMjAwMCwxNjAwMCwyMjA1MCwyNDAwMCwzMjAwMCw0NDEwMCw0ODAwMF07XG4gICAgdmFyIEFDQ0VQVF9DRUxMU0laRVMgPSBbMzIsNjQsMTI4LDI1Nl07XG5cbiAgICB2YXIgX3ZlciA9IFwiMTQuMDUuMjhcIjtcbiAgICB2YXIgX3N5cyA9IG51bGw7XG4gICAgdmFyIF9jb25zdHJ1Y3RvcnMgPSB7fTtcbiAgICB2YXIgX2ZhY3RvcmllcyAgICA9IHt9O1xuICAgIHZhciBfZW52dHlwZSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSA/IFwiYnJvd3NlclwiIDpcbiAgICAgICAgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpID8gXCJub2RlXCIgOiBcInVua25vd25cIjtcbiAgICB2YXIgX2Vudm1vYmlsZSA9IF9lbnZ0eXBlID09PSBcImJyb3dzZXJcIiAmJiAvKGlQaG9uZXxpUGFkfGlQb2R8QW5kcm9pZCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHZhciBfZjY0bW9kZSA9IGZhbHNlO1xuICAgIHZhciBfYnBtID0gMTIwO1xuXG4gICAgdmFyIFQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksIGtleSA9IGFyZ3NbMF0sIHQsIG07XG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2Yga2V5KSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGlmIChfY29uc3RydWN0b3JzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0ID0gbmV3IF9jb25zdHJ1Y3RvcnNba2V5XShhcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2ZhY3Rvcmllc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdCA9IF9mYWN0b3JpZXNba2V5XShhcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbSA9IC9eKC4rPykoPzpcXC4oYXJ8a3IpKT8kLy5leGVjKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jb25zdHJ1Y3RvcnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG5ldyBfY29uc3RydWN0b3JzW2tleV0oYXJncy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2ZhY3Rvcmllc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gX2ZhY3Rvcmllc1trZXldKGFyZ3Muc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIG1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRbbVsyXV0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICB0ID0gbmV3IE51bWJlcldyYXBwZXIoYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHQgPSBuZXcgQm9vbGVhbldyYXBwZXIoYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICB0ID0gbmV3IEZ1bmN0aW9uV3JhcHBlcihhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIFRpbWJyZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmNvbnRleHQgaW5zdGFuY2VvZiBUaW1icmVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5jb250ZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEaWN0aW9uYXJ5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG5ldyBPYmplY3RXcmFwcGVyKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuZXcgQXJyYXlXcmFwcGVyKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdCA9IG5ldyBBZGROb2RlKGFyZ3Muc2xpY2UoMSkpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVChcXFwiXCIgKyBrZXkgKyBcIlxcXCIpIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfID0gdC5fO1xuICAgICAgICBfLm9yaWdpbmtleSA9IGtleTtcbiAgICAgICAgXy5tZXRhID0gX19idWlsZE1ldGFEYXRhKHQpO1xuICAgICAgICBfLmVtaXQoXCJpbml0XCIpO1xuXG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICB2YXIgX19idWlsZE1ldGFEYXRhID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIG1ldGEgPSBpbnN0YW5jZS5fLm1ldGE7XG4gICAgICAgIHZhciBuYW1lcywgZGVzYztcbiAgICAgICAgdmFyIHAgPSBpbnN0YW5jZTtcbiAgICAgICAgd2hpbGUgKHAgIT09IG51bGwgJiYgcC5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHApO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBuYW1lcy5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YVtuYW1lc1tpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvXihjb25zdHJ1Y3RvciR8cHJvY2VzcyR8XykvLnRlc3QobmFtZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbbmFtZXNbaV1dID0gXCJpZ25vcmVcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCBuYW1lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhW25hbWVzW2ldXSA9IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVtuYW1lc1tpXV0gPSBcInByb3BlcnR5XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhO1xuICAgIH07XG5cbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGltYnJlLCB7XG4gICAgICAgIHZlcnNpb24gIDogeyB2YWx1ZTogX3ZlciB9LFxuICAgICAgICBlbnZ0eXBlICA6IHsgdmFsdWU6IF9lbnZ0eXBlIH0sXG4gICAgICAgIGVudm1vYmlsZTogeyB2YWx1ZTogX2Vudm1vYmlsZSB9LFxuICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zeXMuaW1wbC5lbnY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNhbXBsZXJhdGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zeXMuc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zeXMuY2hhbm5lbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNlbGxzaXplOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3lzLmNlbGxzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50VGltZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N5cy5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNQbGF5aW5nOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3lzLnN0YXR1cyA9PT0gUExBWUlOR19TVEFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNSZWNvcmRpbmc6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zeXMuc3RhdHVzID09PSBTQ0hFRFVMRURfU1RBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFtcDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3N5cy5hbXAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N5cy5hbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJwbToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDUgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYnBtID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2JwbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGltYnJlLmJpbmQgPSBmdW5jdGlvbihLbGFzcywgb3B0cykge1xuICAgICAgICBfc3lzLmJpbmQoS2xhc3MsIG9wdHMpO1xuICAgICAgICByZXR1cm4gdGltYnJlO1xuICAgIH07XG4gICAgdGltYnJlLnNldHVwID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgICBfc3lzLnNldHVwKG9wdHMpO1xuICAgICAgICByZXR1cm4gdGltYnJlO1xuICAgIH07XG4gICAgdGltYnJlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3N5cy5wbGF5KCk7XG4gICAgICAgIHJldHVybiB0aW1icmU7XG4gICAgfTtcbiAgICB0aW1icmUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3N5cy5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdGltYnJlO1xuICAgIH07XG4gICAgdGltYnJlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9zeXMucmVzZXQoKTtcbiAgICAgICAgX3N5cy5ldmVudHMuZW1pdChcInJlc2V0XCIpO1xuICAgICAgICByZXR1cm4gdGltYnJlO1xuICAgIH07XG4gICAgdGltYnJlLm9uID0gdGltYnJlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgX3N5cy5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aW1icmU7XG4gICAgfTtcbiAgICB0aW1icmUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIF9zeXMub25jZSh0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aW1icmU7XG4gICAgfTtcbiAgICB0aW1icmUub2ZmID0gdGltYnJlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgX3N5cy5vZmYodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGltYnJlO1xuICAgIH07XG4gICAgdGltYnJlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgX3N5cy5yZW1vdmVBbGxMaXN0ZW5lcnModHlwZSk7XG4gICAgICAgIHJldHVybiB0aW1icmU7XG4gICAgfTtcbiAgICB0aW1icmUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gX3N5cy5saXN0ZW5lcnModHlwZSk7XG4gICAgfTtcbiAgICB0aW1icmUucmVjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc3lzLnJlYy5hcHBseShfc3lzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdGltYnJlLnRpbWV2YWx1ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdldGJwbSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIG0sIGJwbSA9IF9icG07XG4gICAgICAgICAgICBpZiAoKG0gPSAvXmJwbShcXGQrKD86XFwuXFxkKyk/KS9pLmV4ZWMoc3RyKSkpIHtcbiAgICAgICAgICAgICAgICBicG0gPSBNYXRoLm1heCg1LCBNYXRoLm1pbigzMDAsICsobVsxXXx8MCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBicG07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciBtLCBtcywgeDtcbiAgICAgICAgICAgIGlmICgobSA9IC9eKFxcZCsoPzpcXC5cXGQrKT8pSHokL2kuZXhlYyhzdHIpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiArbVsxXSA9PT0gMCA/IDAgOiAxMDAwIC8gK21bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG0gPSAvTChcXGQrKT8oXFwuKikkL2kuZXhlYyhzdHIpKSkge1xuICAgICAgICAgICAgICAgIG1zID0gNjAgLyBnZXRicG0oc3RyKSAqICg0IC8gKG1bMV18fDQpKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgbXMgKj0gWzEsIDEuNSwgMS43NSwgMS44NzVdWyhtWzJdfHxcIlwiKS5sZW5ndGhdIHx8IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtID0gL14oXFxkKyg/OlxcLlxcZCspP3xcXC4oPzpcXGQrKSkobWlufHNlY3xtKXM/JC9pLmV4ZWMoc3RyKSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1bMl0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWluXCI6IHJldHVybiArKG1bMV18fDApICogNjAgKiAxMDAwO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWNcIjogcmV0dXJuICsobVsxXXx8MCkgKiAxMDAwO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtXCIgIDogcmV0dXJuICsobVsxXXx8MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtID0gL14oPzooWzAtNV0/WzAtOV0pOik/KD86KFswLTVdP1swLTldKTopKD86KFswLTVdP1swLTldKSkoPzpcXC4oWzAtOV17MSwzfSkpPyQvLmV4ZWMoc3RyKSkpIHtcbiAgICAgICAgICAgICAgICB4ID0gKG1bMV18fDApICogMzYwMCArIChtWzJdfHwwKSAqIDYwICsgKG1bM118fDApO1xuICAgICAgICAgICAgICAgIHggPSB4ICogMTAwMCArICgoKChtWzRdfHxcIlwiKStcIjAwXCIpLnN1YnN0cigwLCAzKSl8MCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG0gPSAvKFxcZCspXFwuKFxcZCspXFwuKFxcZCspJC9pLmV4ZWMoc3RyKSkpIHtcbiAgICAgICAgICAgICAgICB4ID0gKG1bMV0gKiA0ICsgKCttWzJdKSkgKiA0ODAgKyAoK21bM10pO1xuICAgICAgICAgICAgICAgIHJldHVybiA2MCAvIGdldGJwbShzdHIpICogKHggLyA0ODApICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobSA9IC8oXFxkKyl0aWNrcyQvaS5leGVjKHN0cikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDYwIC8gZ2V0YnBtKHN0cikgKiAobVsxXSAvIDQ4MCkgKiAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtID0gL14oXFxkKylzYW1wbGVzKD86XFwvKFxcZCspSHopPyQvaS5leGVjKHN0cikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1bMV0gKiAxMDAwIC8gKG1bMl0gfHwgdGltYnJlLnNhbXBsZXJhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIHZhciBmbiA9IHRpbWJyZS5mbiA9IHtcbiAgICAgICAgU2lnbmFsQXJyYXk6IEZsb2F0MzJBcnJheSxcbiAgICAgICAgY3VycmVudFRpbWVJbmNyOiAwLFxuICAgICAgICBlbXB0eWNlbGw6IG51bGwsXG4gICAgICAgIEZJTklTSEVEX1NUQVRFOiBGSU5JU0hFRF9TVEFURSxcbiAgICAgICAgUExBWUlOR19TVEFURTogUExBWUlOR19TVEFURSxcbiAgICAgICAgVU5TQ0hFRFVMRURfU1RBVEU6IFVOU0NIRURVTEVEX1NUQVRFLFxuICAgICAgICBTQ0hFRFVMRURfU1RBVEU6IFNDSEVEVUxFRF9TVEFURVxuICAgIH07XG5cbiAgICB2YXIgaXNBcnJheSA9IGZuLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIHZhciBpc0RpY3Rpb25hcnkgPSBmbi5pc0RpY3Rpb25hcnkgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgfTtcblxuICAgIGZuLm5vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4uaXNTaWduYWxBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgZm4uU2lnbmFsQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgJiYgb2JqLl9fa2xhc3MgJiYgb2JqLl9fa2xhc3MudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBib3Jyb3dlZCBmcm9tIGNvZmZlZS1zY3JpcHRcbiAgICBmbi5leHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudCB8fCBUaW1icmVPYmplY3Q7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZ1bmN0aW9uIGN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOmZhbHNlICovXG4gICAgICAgIGN0b3IucHJvdG90eXBlICA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG4gICAgICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgZm4uY29uc3RydWN0b3JvZiA9IGZ1bmN0aW9uKGN0b3IsIEtsYXNzKSB7XG4gICAgICAgIHZhciBmID0gY3RvciAmJiBjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgd2hpbGUgKGYpIHtcbiAgICAgICAgICAgIGlmIChmID09PSBLbGFzcy5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlciA9IGZ1bmN0aW9uKGtleSwgY3Rvcikge1xuICAgICAgICBpZiAoZm4uY29uc3RydWN0b3JvZihjdG9yLCBUaW1icmVPYmplY3QpKSB7XG4gICAgICAgICAgICBfY29uc3RydWN0b3JzW2tleV0gPSBjdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2ZhY3Rvcmllc1trZXldID0gY3RvcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbi5hbGlhcyA9IGZ1bmN0aW9uKGtleSwgYWxpYXMpIHtcbiAgICAgICAgaWYgKF9jb25zdHJ1Y3RvcnNbYWxpYXNdKSB7XG4gICAgICAgICAgICBfY29uc3RydWN0b3JzW2tleV0gPSBfY29uc3RydWN0b3JzW2FsaWFzXTtcbiAgICAgICAgfSBlbHNlIGlmIChfZmFjdG9yaWVzW2FsaWFzXSkge1xuICAgICAgICAgICAgX2ZhY3Rvcmllc1trZXldID0gX2ZhY3Rvcmllc1thbGlhc107XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBmbi5nZXRDbGFzcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gX2NvbnN0cnVjdG9yc1trZXldO1xuICAgIH07XG5cbiAgICBmbi5wb2ludGVyID0gZnVuY3Rpb24oc3JjLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBvZmZzZXQgPSBzcmMuYnl0ZU9mZnNldCArIG9mZnNldCAqIHNyYy5jb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3JjLmNvbnN0cnVjdG9yKHNyYy5idWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3JjLmNvbnN0cnVjdG9yKHNyYy5idWZmZXIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZm4ubmV4dFRpY2sgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIF9zeXMubmV4dFRpY2soZnVuYyk7XG4gICAgICAgIHJldHVybiB0aW1icmU7XG4gICAgfTtcblxuICAgIGZuLmZpeEFSID0gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICBzZWxmLl8uYXIgPSB0cnVlO1xuICAgICAgICBzZWxmLl8uYXJvbmx5ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZm4uZml4S1IgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgIHNlbGYuXy5hciA9IGZhbHNlO1xuICAgICAgICBzZWxmLl8ua3Jvbmx5ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZm4uY2hhbmdlV2l0aFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICB2YXIgeCA9IF8udmFsdWUgKiBfLm11bCArIF8uYWRkO1xuICAgICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1swXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBjZWxsLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgY2VsbFtpXSA9IHg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZuLmNoYW5nZVdpdGhWYWx1ZS51bnJlbW92YWJsZSA9IHRydWU7XG5cbiAgICBmbi5jbG9uZSA9IGZ1bmN0aW9uKHNyYykge1xuICAgICAgICB2YXIgbmV3X2luc3RhbmNlID0gbmV3IHNyYy5jb25zdHJ1Y3RvcihbXSk7XG4gICAgICAgIG5ld19pbnN0YW5jZS5fLmFyICA9IHNyYy5fLmFyO1xuICAgICAgICBuZXdfaW5zdGFuY2UuXy5tdWwgPSBzcmMuXy5tdWw7XG4gICAgICAgIG5ld19pbnN0YW5jZS5fLmFkZCA9IHNyYy5fLmFkZDtcbiAgICAgICAgbmV3X2luc3RhbmNlLl8uYnlwYXNzZWQgPSBzcmMuXy5ieXBhc3NlZDtcbiAgICAgICAgcmV0dXJuIG5ld19pbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgZm4udGltZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYWtlX29uc3RhcnQgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9zeXMudGltZXJzLmluZGV4T2Yoc2VsZikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zeXMudGltZXJzLnB1c2goc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIF9zeXMuZXZlbnRzLmVtaXQoXCJhZGRPYmplY3RcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuXy5lbWl0KFwic3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGZuLmJ1ZGRpZXNfc3RhcnQoc2VsZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1ha2Vfb25zdG9wID0gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gX3N5cy50aW1lcnMuaW5kZXhPZihzZWxmKTtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3N5cy50aW1lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl8uZW1pdChcInN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgIF9zeXMuZXZlbnRzLmVtaXQoXCJyZW1vdmVPYmplY3RcIik7XG4gICAgICAgICAgICAgICAgICAgIGZuLmJ1ZGRpZXNfc3RvcChzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgdmFyIG9uc3RhcnQgPSBtYWtlX29uc3RhcnQoc2VsZik7XG4gICAgICAgICAgICB2YXIgb25zdG9wICA9IG1ha2Vfb25zdG9wKHNlbGYpO1xuICAgICAgICAgICAgc2VsZi5ub2RlVHlwZSA9IFRpbWJyZU9iamVjdC5USU1FUjtcbiAgICAgICAgICAgIHNlbGYuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfc3lzLm5leHRUaWNrKG9uc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9zeXMubmV4dFRpY2sob25zdG9wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgZm4ubGlzdGVuZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYWtlX29ubGlzdGVuID0gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChfc3lzLmxpc3RlbmVycy5pbmRleE9mKHNlbGYpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBfc3lzLmxpc3RlbmVycy5wdXNoKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICBfc3lzLmV2ZW50cy5lbWl0KFwiYWRkT2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl8uZW1pdChcImxpc3RlblwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uYnVkZGllc19zdGFydChzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWFrZV9vbnVubGlzdGVuID0gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gX3N5cy5saXN0ZW5lcnMuaW5kZXhPZihzZWxmKTtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3N5cy5saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl8uZW1pdChcInVubGlzdGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICBfc3lzLmV2ZW50cy5lbWl0KFwicmVtb3ZlT2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICBmbi5idWRkaWVzX3N0b3Aoc2VsZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIHZhciBvbmxpc3RlbiA9IG1ha2Vfb25saXN0ZW4oc2VsZik7XG4gICAgICAgICAgICB2YXIgb251bmxpc3RlbiA9IG1ha2Vfb251bmxpc3RlbihzZWxmKTtcbiAgICAgICAgICAgIHNlbGYubm9kZVR5cGUgPSBUaW1icmVPYmplY3QuTElTVEVORVI7XG4gICAgICAgICAgICBzZWxmLmxpc3RlbiA9IGZ1bmN0aW9uKGJ1ZGRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGVuZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3N5cy5uZXh0VGljayhvbmxpc3Rlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYudW5saXN0ZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zeXMubmV4dFRpY2sob251bmxpc3Rlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICBmbi5tYWtlX29uZW5kZWQgPSBmdW5jdGlvbihzZWxmLCBsYXN0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5wbGF5YmFja1N0YXRlID0gRklOSVNIRURfU1RBVEU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RWYWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsICA9IHNlbGYuY2VsbHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxMID0gc2VsZi5jZWxsc1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbFIgPSBzZWxmLmNlbGxzWzJdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbWF4ID0gY2VsbEwubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbMF0gPSBjZWxsTFtpXSA9IGNlbGxSW2ldID0gbGFzdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuXy5lbWl0KFwiZW5kZWRcIik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZuLmlucHV0U2lnbmFsQVIgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgIHZhciBjZWxsICA9IHNlbGYuY2VsbHNbMF07XG4gICAgICAgIHZhciBjZWxsTCA9IHNlbGYuY2VsbHNbMV07XG4gICAgICAgIHZhciBjZWxsUiA9IHNlbGYuY2VsbHNbMl07XG4gICAgICAgIHZhciBub2RlcyA9IHNlbGYubm9kZXM7XG4gICAgICAgIHZhciBpLCBpbWF4ID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB2YXIgaiwgam1heCA9IGNlbGwubGVuZ3RoO1xuICAgICAgICB2YXIgdGlja0lEICA9IHNlbGYudGlja0lEO1xuICAgICAgICB2YXIgbm90X2NsZWFyLCB0bXAsIHRtcEwsIHRtcFI7XG5cbiAgICAgICAgaWYgKHNlbGYubnVtQ2hhbm5lbHMgPT09IDIpIHtcbiAgICAgICAgICAgIG5vdF9jbGVhciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaW1heCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzW2ldLnBsYXliYWNrU3RhdGUgPT09IFBMQVlJTkdfU1RBVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLnByb2Nlc3ModGlja0lEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxMLnNldChub2Rlc1tpXS5jZWxsc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsUi5zZXQobm9kZXNbaV0uY2VsbHNbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90X2NsZWFyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXNbaV0ucGxheWJhY2tTdGF0ZSA9PT0gUExBWUlOR19TVEFURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0ucHJvY2Vzcyh0aWNrSUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wTCA9IG5vZGVzW2ldLmNlbGxzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wUiA9IG5vZGVzW2ldLmNlbGxzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gam1heDsgajsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiAtPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxMW2ogIF0gKz0gdG1wTFtqICBdOyBjZWxsUltqICBdICs9IHRtcFJbaiAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTFtqKzFdICs9IHRtcExbaisxXTsgY2VsbFJbaisxXSArPSB0bXBSW2orMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbExbaisyXSArPSB0bXBMW2orMl07IGNlbGxSW2orMl0gKz0gdG1wUltqKzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxMW2orM10gKz0gdG1wTFtqKzNdOyBjZWxsUltqKzNdICs9IHRtcFJbaiszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTFtqKzRdICs9IHRtcExbais0XTsgY2VsbFJbais0XSArPSB0bXBSW2orNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbExbais1XSArPSB0bXBMW2orNV07IGNlbGxSW2orNV0gKz0gdG1wUltqKzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxMW2orNl0gKz0gdG1wTFtqKzZdOyBjZWxsUltqKzZdICs9IHRtcFJbais2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTFtqKzddICs9IHRtcExbais3XTsgY2VsbFJbais3XSArPSB0bXBSW2orN107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90X2NsZWFyKSB7XG4gICAgICAgICAgICAgICAgY2VsbEwuc2V0KGZuLmVtcHR5Y2VsbCk7XG4gICAgICAgICAgICAgICAgY2VsbFIuc2V0KGZuLmVtcHR5Y2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3RfY2xlYXIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGltYXggIT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlc1tpXS5wbGF5YmFja1N0YXRlID09PSBQTEFZSU5HX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXS5wcm9jZXNzKHRpY2tJRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnNldChub2Rlc1tpXS5jZWxsc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RfY2xlYXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlc1tpXS5wbGF5YmFja1N0YXRlID09PSBQTEFZSU5HX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBub2Rlc1tpXS5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBqbWF4OyBqOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqIC09IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFtqICBdICs9IHRtcFtqICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxbaisxXSArPSB0bXBbaisxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsW2orMl0gKz0gdG1wW2orMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFtqKzNdICs9IHRtcFtqKzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxbais0XSArPSB0bXBbais0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsW2orNV0gKz0gdG1wW2orNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFtqKzZdICs9IHRtcFtqKzZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxbais3XSArPSB0bXBbais3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RfY2xlYXIpIHtcbiAgICAgICAgICAgICAgICBjZWxsLnNldChmbi5lbXB0eWNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZuLmlucHV0U2lnbmFsS1IgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgIHZhciBub2RlcyA9IHNlbGYubm9kZXM7XG4gICAgICAgIHZhciBpLCBpbWF4ID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB2YXIgdGlja0lEID0gc2VsZi50aWNrSUQ7XG4gICAgICAgIHZhciB0bXAgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbaV0ucGxheWJhY2tTdGF0ZSA9PT0gUExBWUlOR19TVEFURSkge1xuICAgICAgICAgICAgICAgIHRtcCArPSBub2Rlc1tpXS5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRtcDtcbiAgICB9O1xuXG4gICAgZm4ub3V0cHV0U2lnbmFsQVIgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgIHZhciBjZWxsICA9IHNlbGYuY2VsbHNbMF07XG4gICAgICAgIHZhciBjZWxsTCA9IHNlbGYuY2VsbHNbMV07XG4gICAgICAgIHZhciBjZWxsUiA9IHNlbGYuY2VsbHNbMl07XG4gICAgICAgIHZhciBtdWwgPSBzZWxmLl8ubXVsLCBhZGQgPSBzZWxmLl8uYWRkO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBpZiAoc2VsZi5udW1DaGFubmVscyA9PT0gMikge1xuICAgICAgICAgICAgZm9yIChpID0gY2VsbC5sZW5ndGg7IGk7ICkge1xuICAgICAgICAgICAgICAgIGkgLT0gODtcbiAgICAgICAgICAgICAgICBjZWxsTFtpICBdID0gY2VsbExbaSAgXSAqIG11bCArIGFkZDsgY2VsbFJbaSAgXSA9IGNlbGxSW2kgIF0gKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgY2VsbExbaSsxXSA9IGNlbGxMW2krMV0gKiBtdWwgKyBhZGQ7IGNlbGxSW2krMV0gPSBjZWxsUltpKzFdICogbXVsICsgYWRkO1xuICAgICAgICAgICAgICAgIGNlbGxMW2krMl0gPSBjZWxsTFtpKzJdICogbXVsICsgYWRkOyBjZWxsUltpKzJdID0gY2VsbFJbaSsyXSAqIG11bCArIGFkZDtcbiAgICAgICAgICAgICAgICBjZWxsTFtpKzNdID0gY2VsbExbaSszXSAqIG11bCArIGFkZDsgY2VsbFJbaSszXSA9IGNlbGxSW2krM10gKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgY2VsbExbaSs0XSA9IGNlbGxMW2krNF0gKiBtdWwgKyBhZGQ7IGNlbGxSW2krNF0gPSBjZWxsUltpKzRdICogbXVsICsgYWRkO1xuICAgICAgICAgICAgICAgIGNlbGxMW2krNV0gPSBjZWxsTFtpKzVdICogbXVsICsgYWRkOyBjZWxsUltpKzVdID0gY2VsbFJbaSs1XSAqIG11bCArIGFkZDtcbiAgICAgICAgICAgICAgICBjZWxsTFtpKzZdID0gY2VsbExbaSs2XSAqIG11bCArIGFkZDsgY2VsbFJbaSs2XSA9IGNlbGxSW2krNl0gKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgY2VsbExbaSs3XSA9IGNlbGxMW2krN10gKiBtdWwgKyBhZGQ7IGNlbGxSW2krN10gPSBjZWxsUltpKzddICogbXVsICsgYWRkO1xuICAgICAgICAgICAgICAgIGNlbGxbaSAgXSA9IChjZWxsTFtpICBdICsgY2VsbFJbaSAgXSkgKiAwLjU7XG4gICAgICAgICAgICAgICAgY2VsbFtpKzFdID0gKGNlbGxMW2krMV0gKyBjZWxsUltpKzFdKSAqIDAuNTtcbiAgICAgICAgICAgICAgICBjZWxsW2krMl0gPSAoY2VsbExbaSsyXSArIGNlbGxSW2krMl0pICogMC41O1xuICAgICAgICAgICAgICAgIGNlbGxbaSszXSA9IChjZWxsTFtpKzNdICsgY2VsbFJbaSszXSkgKiAwLjU7XG4gICAgICAgICAgICAgICAgY2VsbFtpKzRdID0gKGNlbGxMW2krNF0gKyBjZWxsUltpKzRdKSAqIDAuNTtcbiAgICAgICAgICAgICAgICBjZWxsW2krNV0gPSAoY2VsbExbaSs1XSArIGNlbGxSW2krNV0pICogMC41O1xuICAgICAgICAgICAgICAgIGNlbGxbaSs2XSA9IChjZWxsTFtpKzZdICsgY2VsbFJbaSs2XSkgKiAwLjU7XG4gICAgICAgICAgICAgICAgY2VsbFtpKzddID0gKGNlbGxMW2krN10gKyBjZWxsUltpKzddKSAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtdWwgIT09IDEgfHwgYWRkICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gY2VsbC5sZW5ndGg7IGk7ICkge1xuICAgICAgICAgICAgICAgICAgICBpIC09IDg7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbaSAgXSA9IGNlbGxbaSAgXSAqIG11bCArIGFkZDtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFtpKzFdID0gY2VsbFtpKzFdICogbXVsICsgYWRkO1xuICAgICAgICAgICAgICAgICAgICBjZWxsW2krMl0gPSBjZWxsW2krMl0gKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbaSszXSA9IGNlbGxbaSszXSAqIG11bCArIGFkZDtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFtpKzRdID0gY2VsbFtpKzRdICogbXVsICsgYWRkO1xuICAgICAgICAgICAgICAgICAgICBjZWxsW2krNV0gPSBjZWxsW2krNV0gKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbaSs2XSA9IGNlbGxbaSs2XSAqIG11bCArIGFkZDtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFtpKzddID0gY2VsbFtpKzddICogbXVsICsgYWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbi5vdXRwdXRTaWduYWxLUiA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgdmFyIGNlbGwgID0gc2VsZi5jZWxsc1swXTtcbiAgICAgICAgdmFyIGNlbGxMID0gc2VsZi5jZWxsc1sxXTtcbiAgICAgICAgdmFyIGNlbGxSID0gc2VsZi5jZWxsc1syXTtcbiAgICAgICAgdmFyIG11bCA9IHNlbGYuXy5tdWwsIGFkZCA9IHNlbGYuXy5hZGQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNlbGxbMF0gKiBtdWwgKyBhZGQ7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGlmIChzZWxmLm51bUNoYW5uZWxzID09PSAyKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBjZWxsLmxlbmd0aDsgaTsgKSB7XG4gICAgICAgICAgICAgICAgaSAtPSA4O1xuICAgICAgICAgICAgICAgIGNlbGxbaV0gPSBjZWxsW2krMV0gPSBjZWxsW2krMl0gPSBjZWxsW2krM10gPSBjZWxsW2krNF0gPSBjZWxsW2krNV0gPSBjZWxsW2krNl0gPSBjZWxsW2krN10gPSBjZWxsTFtpXSA9IGNlbGxMW2krMV0gPSBjZWxsTFtpKzJdID0gY2VsbExbaSszXSA9IGNlbGxMW2krNF0gPSBjZWxsTFtpKzVdID0gY2VsbExbaSs2XSA9IGNlbGxMW2krN10gPSBjZWxsUltpXSA9IGNlbGxSW2krMV0gPSBjZWxsUltpKzJdID0gY2VsbFJbaSszXSA9IGNlbGxSW2krNF0gPSBjZWxsUltpKzVdID0gY2VsbFJbaSs2XSA9IGNlbGxSW2krN10gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGNlbGwubGVuZ3RoOyBpOyApIHtcbiAgICAgICAgICAgICAgICBpIC09IDg7XG4gICAgICAgICAgICAgICAgY2VsbFtpXSA9IGNlbGxbaSsxXSA9IGNlbGxbaSsyXSA9IGNlbGxbaSszXSA9IGNlbGxbaSs0XSA9IGNlbGxbaSs1XSA9IGNlbGxbaSs2XSA9IGNlbGxbaSs3XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZuLmJ1ZGRpZXNfc3RhcnQgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgIHZhciBidWRkaWVzID0gc2VsZi5fLmJ1ZGRpZXM7XG4gICAgICAgIHZhciBub2RlLCBpLCBpbWF4O1xuICAgICAgICBmb3IgKGkgPSAwLCBpbWF4ID0gYnVkZGllcy5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgIG5vZGUgPSBidWRkaWVzW2ldO1xuICAgICAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFRpbWJyZU9iamVjdC5EU1A6XG4gICAgICAgICAgICAgICAgbm9kZS5wbGF5KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRpbWJyZU9iamVjdC5USU1FUjpcbiAgICAgICAgICAgICAgICBub2RlLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRpbWJyZU9iamVjdC5MSVNURU5FUjpcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZuLmJ1ZGRpZXNfc3RvcCA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgdmFyIGJ1ZGRpZXMgPSBzZWxmLl8uYnVkZGllcztcbiAgICAgICAgdmFyIG5vZGUsIGksIGltYXg7XG4gICAgICAgIGZvciAoaSA9IDAsIGltYXggPSBidWRkaWVzLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgbm9kZSA9IGJ1ZGRpZXNbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVGltYnJlT2JqZWN0LkRTUDpcbiAgICAgICAgICAgICAgICBub2RlLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRpbWJyZU9iamVjdC5USU1FUjpcbiAgICAgICAgICAgICAgICBub2RlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVGltYnJlT2JqZWN0LkxJU1RFTkVSOlxuICAgICAgICAgICAgICAgIG5vZGUudW5saXN0ZW4oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbi5maXhfaU9TNl8xX3Byb2JsZW0gPSBmdW5jdGlvbihmbGFnKSB7XG4gICAgICAgIF9zeXMuZml4X2lPUzZfMV9wcm9ibGVtKGZsYWcpO1xuICAgIH07XG5cbiAgICB2YXIgbW9kdWxlcyA9IHRpbWJyZS5tb2R1bGVzID0ge307XG5cbiAgICAvLyBFdmVudEVtaXR0ZXJcbiAgICB2YXIgRXZlbnRFbWl0dGVyID0gbW9kdWxlcy5FdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcihjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcblxuICAgICAgICAkLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXJncztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcy5jb250ZXh0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLmNvbnRleHQsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSBpbnN0YW5jZW9mIFRpbWJyZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmJhbmcuYXBwbHkobGlzdGVuZXJzW2ldLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgVGltYnJlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmJhbmcuYXBwbHkoaGFuZGxlciwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAkLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhKGxpc3RlbmVyIGluc3RhbmNlb2YgVGltYnJlT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZExpc3RlbmVyIHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbiBvciB0aW1icmUuT2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmV2ZW50cztcblxuICAgICAgICAgICAgaWYgKCFlW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgZVt0eXBlXSA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGVbdHlwZV0pKSB7XG4gICAgICAgICAgICAgICAgZVt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZVt0eXBlXSA9IFtlW3R5cGVdLCBsaXN0ZW5lcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAkLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9mZih0eXBlLCBnKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkoc2VsZi5jb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyIGluc3RhbmNlb2YgVGltYnJlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vZmYodHlwZSwgZyk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmJhbmcuYXBwbHkobGlzdGVuZXIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25jZSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24gb3IgdGltYnJlLk9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcblxuICAgICAgICAgICAgc2VsZi5vbih0eXBlLCBnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5vZmYgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICEobGlzdGVuZXIgaW5zdGFuY2VvZiBUaW1icmVPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVtb3ZlTGlzdGVuZXIgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uIG9yIHRpbWJyZS5PYmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuZXZlbnRzO1xuXG4gICAgICAgICAgICBpZiAoIWVbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpc3QgPSBlW3R5cGVdO1xuXG4gICAgICAgICAgICBpZiAoaXNBcnJheShsaXN0KSkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbWF4ID0gbGlzdC5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmNlIGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlW3R5cGVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIG9uY2UgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgKGxpc3QubGlzdGVuZXIgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgZVt0eXBlXSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmV2ZW50cztcblxuICAgICAgICAgICAgdmFyIHJlbWFpbiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGVbdHlwZV07XG4gICAgICAgICAgICBpZiAoaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnVucmVtb3ZhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnMudW5yZW1vdmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1haW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgZVt0eXBlXSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgdmFyIGEsIGUgPSB0aGlzLmV2ZW50cztcbiAgICAgICAgICAgIGlmICghZVt0eXBlXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUgPSBlW3R5cGVdO1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudW5yZW1vdmFibGUgPyBbXSA6IFtlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUgPSBlLnNsaWNlKCk7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IGUubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlW2ldLnVucmVtb3ZhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgIH0pKCk7XG5cbiAgICB2YXIgRGVmZXJyZWQgPSBtb2R1bGVzLkRlZmVycmVkID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWZlcnJlZChjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgdGhpcy5fZG9uZUxpc3QgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2ZhaWxMaXN0ID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkID0gRGVmZXJyZWQucHJvdG90eXBlO1xuXG4gICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24oc3RhdHVlLCBsaXN0LCBjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0dWU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBsaXN0Lmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0W2ldLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kb25lTGlzdCA9IHRoaXMuX2ZhaWxMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaXNEZWZlcnJlZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ICYmIHR5cGVvZiB4LnByb21pc2UgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfTtcblxuICAgICAgICAkLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgZXhlYy5jYWxsKHRoaXMsIFwicmVzb2x2ZWRcIiwgdGhpcy5fZG9uZUxpc3QsIHRoaXMuY29udGV4dCB8fCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAkLnJlc29sdmVXaXRoID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBleGVjLmNhbGwodGhpcywgXCJyZXNvbHZlZFwiLCB0aGlzLl9kb25lTGlzdCwgY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgJC5yZWplY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgZXhlYy5jYWxsKHRoaXMsIFwicmVqZWN0ZWRcIiwgdGhpcy5fZmFpbExpc3QsIHRoaXMuY29udGV4dCB8fCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAkLnJlamVjdFdpdGggPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGV4ZWMuY2FsbCh0aGlzLCBcInJlamVjdGVkXCIsIHRoaXMuX2ZhaWxMaXN0LCBjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQucHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgICQuZG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgaXNSZXNvbHZlZCA9ICh0aGlzLl9zdGF0ZSA9PT0gXCJyZXNvbHZlZFwiKTtcbiAgICAgICAgICAgIHZhciBpc1BlbmRpbmcgID0gKHRoaXMuX3N0YXRlID09PSBcInBlbmRpbmdcIik7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBhcmdzLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgJC5mYWlsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBpc1JlamVjdGVkID0gKHRoaXMuX3N0YXRlID09PSBcInJlamVjdGVkXCIpO1xuICAgICAgICAgICAgdmFyIGlzUGVuZGluZyAgPSAodGhpcy5fc3RhdGUgPT09IFwicGVuZGluZ1wiKTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5fZmFpbExpc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IGFyZ3MubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0oKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAkLmFsd2F5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5kb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmZhaWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAkLnRoZW4gPSBmdW5jdGlvbiB0aGVuKGRvbmUsIGZhaWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbmUoZG9uZSkuZmFpbChmYWlsKTtcbiAgICAgICAgfTtcbiAgICAgICAgJC5waXBlID0gZnVuY3Rpb24oZG9uZSwgZmFpbCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRmZCA9IG5ldyBEZWZlcnJlZCh0aGlzLmNvbnRleHQpO1xuXG4gICAgICAgICAgICB0aGlzLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGRvbmUuYXBwbHkoc2VsZi5jb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmVycmVkKHJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlV2l0aC5hcHBseShkZmQsIFtyZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlV2l0aChzZWxmLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmFpbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBmYWlsLmFwcGx5KHNlbGYuY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmZXJyZWQocmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlamVjdFdpdGguYXBwbHkoZGZkLCBbcmVzXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZmQucmVqZWN0LmFwcGx5KGRmZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRmZC5wcm9taXNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vICQudGhlbiA9ICQucGlwZTtcblxuICAgICAgICAkLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gXCJyZXNvbHZlZFwiO1xuICAgICAgICB9O1xuICAgICAgICAkLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xuICAgICAgICB9O1xuICAgICAgICAkLnN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVE9ETzogdGVzdFxuICAgICAgICBEZWZlcnJlZC53aGVuID0gZnVuY3Rpb24oc3Vib3JkaW5hdGUpIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciByZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCAgICA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IGxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSAmJiAhaXNEZWZlcnJlZChzdWJvcmRpbmF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gKHJlbWFpbmluZyA9PT0gMSkgPyBzdWJvcmRpbmF0ZSA6IG5ldyBEZWZlcnJlZCgpO1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlRnVuYyA9IGZ1bmN0aW9uKGksIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbChhcmd1bWVudHMpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKC0tcmVtYWluaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZS5hcHBseShkZWZlcnJlZCwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZVJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgb25mYWlsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlVmFsdWVzW2ldICYmIGlzRGVmZXJyZWQocmVzb2x2ZVZhbHVlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZXNbaV0ucHJvbWlzZSgpLmRvbmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhpLCByZXNvbHZlUmVzdWx0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICkuZmFpbChvbmZhaWxlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlUmVzdWx0c1tpXSA9IHJlc29sdmVWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAtLXJlbWFpbmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlLmFwcGx5KGRlZmVycmVkLCByZXNvbHZlVmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBQcm9taXNlKG9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gb2JqZWN0LmNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLnRoZW4gPSBvYmplY3QudGhlbjtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb25lLmFwcGx5KG9iamVjdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmZhaWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZmFpbC5hcHBseShvYmplY3QsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5waXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5waXBlLmFwcGx5KG9iamVjdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFsd2F5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5hbHdheXMuYXBwbHkob2JqZWN0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QuaXNSZXNvbHZlZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QuaXNSZWplY3RlZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEZWZlcnJlZDtcbiAgICB9KSgpO1xuXG4gICAgLy8gcm9vdCBvYmplY3RcbiAgICB2YXIgVGltYnJlT2JqZWN0ID0gdGltYnJlLk9iamVjdCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gVGltYnJlT2JqZWN0KG51bUNoYW5uZWxzLCBfYXJncykge1xuICAgICAgICAgICAgdGhpcy5fID0ge307IC8vIHByaXZhdGUgbWVtYmVyc1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLl8uZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuXy5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZW1pdC5hcHBseShlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpc0RpY3Rpb25hcnkoX2FyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IF9hcmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIF9pbiA9IHBhcmFtc1tcImluXCJdO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImluaXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KF9pbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCBfaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfaW4gaW5zdGFuY2VvZiBUaW1icmVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChfaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gLTE7XG4gICAgICAgICAgICB0aGlzLm5vZGVzICA9IF9hcmdzLm1hcCh0aW1icmUpO1xuICAgICAgICAgICAgdGhpcy5jZWxscyAgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubnVtQ2hhbm5lbHMgPSBudW1DaGFubmVscztcbiAgICAgICAgICAgIHN3aXRjaCAobnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLkwgPSB0aGlzLlIgPSBuZXcgQ2hhbm5lbE9iamVjdChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzWzBdID0gdGhpcy5jZWxsc1sxXSA9IHRoaXMuY2VsbHNbMl0gPSB0aGlzLkwuY2VsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aGlzLkwgPSB0aGlzLlIgPSBuZXcgQ2hhbm5lbE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzWzBdID0gdGhpcy5jZWxsc1sxXSA9IHRoaXMuY2VsbHNbMl0gPSB0aGlzLkwuY2VsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLkwgPSBuZXcgQ2hhbm5lbE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLlIgPSBuZXcgQ2hhbm5lbE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzWzBdID0gbmV3IGZuLlNpZ25hbEFycmF5KF9zeXMuY2VsbHNpemUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHNbMV0gPSB0aGlzLkwuY2VsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzWzJdID0gdGhpcy5SLmNlbGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBsYXliYWNrU3RhdGUgPSBQTEFZSU5HX1NUQVRFO1xuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9IFRpbWJyZU9iamVjdC5EU1A7XG5cbiAgICAgICAgICAgIHRoaXMuXy5hciAgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fLm11bCA9IDE7XG4gICAgICAgICAgICB0aGlzLl8uYWRkID0gMDtcbiAgICAgICAgICAgIHRoaXMuXy5kYWMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fLmJ5cGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl8ubWV0YSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fLnNhbXBsZXJhdGUgPSBfc3lzLnNhbXBsZXJhdGU7XG4gICAgICAgICAgICB0aGlzLl8uY2VsbHNpemUgICA9IF9zeXMuY2VsbHNpemU7XG4gICAgICAgICAgICB0aGlzLl8uYnVkZGllcyAgICA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFRpbWJyZU9iamVjdC5EU1AgICAgICA9IDE7XG4gICAgICAgIFRpbWJyZU9iamVjdC5USU1FUiAgICA9IDI7XG4gICAgICAgIFRpbWJyZU9iamVjdC5MSVNURU5FUiA9IDM7XG5cbiAgICAgICAgdmFyICQgPSBUaW1icmVPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgICAgIGlzQXI6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0tyOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLl8uYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQnlwYXNzZWQ6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmJ5cGFzc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0VuZGVkOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEodGhpcy5wbGF5YmFja1N0YXRlICYgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bDoge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fLm11bCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmVtaXQoXCJzZXRNdWxcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLm11bDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkOiB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8uYWRkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8uZW1pdChcInNldEFkZFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uYWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidWRkaWVzOiB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmJ1ZGRpZXMgPSB2YWx1ZS5maWx0ZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUaW1icmVPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5idWRkaWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgfTtcblxuICAgICAgICAkLnZhbHVlT2YgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChfc3lzLnRpY2tJRCAhPT0gdGhpcy50aWNrSUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoX3N5cy50aWNrSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbHNbMF1bMF07XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5hcHBlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcCh0aW1icmUpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSB0aGlzLm5vZGVzLmNvbmNhdChsaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl8uZW1pdChcImFwcGVuZFwiLCBsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQuYXBwZW5kVG8gPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIG9iamVjdC5hcHBlbmQodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAkLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIG5vZGVzID0gdGhpcy5ub2RlcywgbGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbWF4ID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGogPSBub2Rlcy5pbmRleE9mKGFyZ3VtZW50c1tpXSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKG5vZGVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5lbWl0KFwicmVtb3ZlXCIsIGxpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQucmVtb3ZlRnJvbSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgb2JqZWN0LnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQucmVtb3ZlQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMubm9kZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8uZW1pdChcInJlbW92ZVwiLCBsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQucmVtb3ZlQXRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMubm9kZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmVtaXQoXCJyZW1vdmVcIiwgW2l0ZW1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLl8uZW1pdChcIm1lc3NhZ2VcIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAkLnRvID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgVGltYnJlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmFwcGVuZCh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGljdGlvbmFyeShhcmdzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgyLCAwLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgxLCAwLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gVC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5zcGxpY2UgPSBmdW5jdGlvbihpbnMsIG9iaiwgcmVtKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuXy5kYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucyBpbnN0YW5jZW9mIFRpbWJyZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbSBpbnN0YW5jZW9mIFRpbWJyZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW0uXy5kYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtLl8uZGFjLl8ubm9kZSA9IGlucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zLl8uZGFjID0gcmVtLl8uZGFjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0uXy5kYWMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnMubm9kZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl8uZGFjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuXy5kYWMuXy5ub2RlID0gaW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnMuXy5kYWMgPSB0aGlzLl8uZGFjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8uZGFjID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zLm5vZGVzLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlbSBpbnN0YW5jZW9mIFRpbWJyZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbS5fLmRhYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbS5fLmRhYy5fLm5vZGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuXy5kYWMgPSByZW0uXy5kYWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtLl8uZGFjID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRpbWJyZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpID0gb2JqLm5vZGVzLmluZGV4T2YocmVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoubm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnMgaW5zdGFuY2VvZiBUaW1icmVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucy5ub2Rlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLm5vZGVzLnB1c2goaW5zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5ub2Rlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRXZlbnRFbWl0dGVyXG4gICAgICAgICQub24gPSAkLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuXy5ldmVudHMub24odHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuXy5ldmVudHMub25jZSh0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAkLm9mZiA9ICQucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fLmV2ZW50cy5vZmYodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLl8uZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycyh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5ldmVudHMubGlzdGVuZXJzKHR5cGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgICQuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHgsIGRlc2MsIG1ldGEgPSB0aGlzLl8ubWV0YTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGtleSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0YVtrZXldKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInByb3BlcnR5XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgeCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih4LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhW2tleV0gPSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhW2tleV0gPSBcInByb3BlcnR5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgZm9yICh4IGluIGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh4LCBrZXlbeF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fLm1ldGFba2V5XSA9PT0gXCJwcm9wZXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAkLmJhbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuXy5lbWl0LmFwcGx5KHRoaXMsIFtcImJhbmdcIl0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5wcm9jZXNzID0gZm4ubm9wO1xuXG4gICAgICAgICQuYnlwYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl8uYnlwYXNzZWQgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgPyB0cnVlIDogISFhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAkLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkYWMgPSB0aGlzLl8uZGFjO1xuICAgICAgICAgICAgaWYgKGRhYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhYyA9IHRoaXMuXy5kYWMgPSBuZXcgU3lzdGVtSW5sZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGFjLnBsYXkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuXy5lbWl0LmFwcGx5KHRoaXMsIFtcInBsYXlcIl0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4uYnVkZGllc19zdGFydCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkYWMgPSB0aGlzLl8uZGFjO1xuICAgICAgICAgICAgaWYgKGRhYyAmJiBkYWMucGxheWJhY2tTdGF0ZSA9PT0gUExBWUlOR19TVEFURSkge1xuICAgICAgICAgICAgICAgIGRhYy5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuXy5kYWMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuXy5lbWl0KFwicGF1c2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbi5idWRkaWVzX3N0b3AodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAkLnN0YXJ0ID0gJC5zdG9wID0gJC5saXN0ZW4gPSAkLnVubGlzdGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAkLmFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggPT09IDApID8gdHJ1ZSA6ICEhYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl8ua3Jvbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5hciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5lbWl0KFwiYXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5rciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKChhcmd1bWVudHMubGVuZ3RoID09PSAwKSA/IHRydWUgOiAhIWFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fLmFyb25seSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8uYXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmVtaXQoXCJhclwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKF9lbnZ0eXBlID09PSBcImJyb3dzZXJcIikge1xuICAgICAgICAgICAgJC5wbG90ID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBvcHRzLnRhcmdldDtcblxuICAgICAgICAgICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCAgICA9IG9wdHMud2lkdGggIHx8IGNhbnZhcy53aWR0aCAgfHwgMzIwO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgICA9IG9wdHMuaGVpZ2h0IHx8IGNhbnZhcy5oZWlnaHQgfHwgMjQwO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRfeCA9IChvcHRzLnggfHwgMCkgKyAwLjU7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldF95ID0gKG9wdHMueSB8fCAwKTtcblxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICAgICAgICAgIHZhciBmb3JlZ3JvdW5kO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmZvcmVncm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JlZ3JvdW5kID0gb3B0cy5mb3JlZ3JvdW5kO1xuICAgICAgICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgZm9yZWdyb3VuZCA9IF8ucGxvdEZvcmVncm91bmQgfHwgXCJyZ2IoICAwLCAxMjgsIDI1NSlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJhY2tncm91bmQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQgPSBvcHRzLmJhY2tncm91bmQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZCA9IF8ucGxvdEJhY2tncm91bmQgfHwgXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCAgPSBvcHRzLmxpbmVXaWR0aCAgfHwgXy5wbG90TGluZVdpZHRoIHx8IDE7XG4gICAgICAgICAgICAgICAgdmFyIGN5Y2xpYyAgICAgPSAhIV8ucGxvdEN5Y2xpYztcblxuICAgICAgICAgICAgICAgIHZhciBkYXRhICA9IF8ucGxvdERhdGEgfHwgdGhpcy5jZWxsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBvcHRzLnJhbmdlIHx8IF8ucGxvdFJhbmdlIHx8IFstMS4yLCArMS4yXTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VNaW4gICA9IHJhbmdlWzBdO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZURlbHRhID0gaGVpZ2h0IC8gKHJhbmdlWzFdIC0gcmFuZ2VNaW4pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHgsIGR4ID0gKHdpZHRoIC8gZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciB5LCBkeSwgeTA7XG4gICAgICAgICAgICAgICAgdmFyIGksIGltYXggPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWN0KG9mZnNldF94LCBvZmZzZXRfeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dC5jbGlwKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFja2dyb3VuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGJhY2tncm91bmQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3Qob2Zmc2V0X3gsIG9mZnNldF95LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF8ucGxvdEJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBfLnBsb3RCZWZvcmUuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsIGNvbnRleHQsIG9mZnNldF94LCBvZmZzZXRfeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfLnBsb3RCYXJTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZvcmVncm91bmQ7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeSA9IChkYXRhW2ldIC0gcmFuZ2VNaW4pICogcmFuZ2VEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgID0gaGVpZ2h0IC0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHggKyBvZmZzZXRfeCwgeSArIG9mZnNldF95LCBkeCwgZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBmb3JlZ3JvdW5kO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCAgID0gbGluZVdpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgeCAgPSAwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IGhlaWdodCAtIChkYXRhWzBdIC0gcmFuZ2VNaW4pICogcmFuZ2VEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCArIG9mZnNldF94LCB5MCArIG9mZnNldF95KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBoZWlnaHQgLSAoZGF0YVtpXSAtIHJhbmdlTWluKSAqIHJhbmdlRGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgb2Zmc2V0X3gsIHkgKyBvZmZzZXRfeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN5Y2xpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCArIGR4ICsgb2Zmc2V0X3gsIHkwICsgb2Zmc2V0X3kpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCArIGR4ICsgb2Zmc2V0X3gsIHkgICsgb2Zmc2V0X3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF8ucGxvdEFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ucGxvdEFmdGVyLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLCBjb250ZXh0LCBvZmZzZXRfeCwgb2Zmc2V0X3ksIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJvcmRlciA9IG9wdHMuYm9yZGVyIHx8IF8ucGxvdEJvcmRlcjtcbiAgICAgICAgICAgICAgICBpZiAoYm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBib3JkZXIgPT09IFwic3RyaW5nXCIpID8gYm9yZGVyIDogXCIjMDAwXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KG9mZnNldF94LCBvZmZzZXRfeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLnBsb3QgPSBmbi5ub3A7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVGltYnJlT2JqZWN0O1xuICAgIH0pKCk7XG5cbiAgICB2YXIgQ2hhbm5lbE9iamVjdCA9IHRpbWJyZS5DaGFubmVsT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGFubmVsT2JqZWN0KHBhcmVudCkge1xuICAgICAgICAgICAgdGltYnJlLk9iamVjdC5jYWxsKHRoaXMsIC0xLCBbXSk7XG4gICAgICAgICAgICBmbi5maXhBUih0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5fLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuY2VsbCA9IG5ldyBmbi5TaWduYWxBcnJheShfc3lzLmNlbGxzaXplKTtcblxuICAgICAgICAgICAgdGhpcy5MID0gdGhpcy5SID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2VsbHNbMF0gPSB0aGlzLmNlbGxzWzFdID0gdGhpcy5jZWxsc1syXSA9IHRoaXMuY2VsbDtcblxuICAgICAgICAgICAgdGhpcy5udW1DaGFubmVscyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm4uZXh0ZW5kKENoYW5uZWxPYmplY3QpO1xuXG4gICAgICAgIENoYW5uZWxPYmplY3QucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuXy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnBhcmVudC5wcm9jZXNzKHRpY2tJRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIENoYW5uZWxPYmplY3Q7XG4gICAgfSkoKTtcblxuICAgIHZhciBBZGROb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBBZGROb2RlKF9hcmdzKSB7XG4gICAgICAgICAgICBUaW1icmVPYmplY3QuY2FsbCh0aGlzLCAyLCBfYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZm4uZXh0ZW5kKEFkZE5vZGUpO1xuXG4gICAgICAgIEFkZE5vZGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcbiAgICAgICAgICAgICAgICBpZiAoXy5hcikge1xuICAgICAgICAgICAgICAgICAgICBmbi5pbnB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzWzBdWzBdID0gZm4uaW5wdXRTaWduYWxLUih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsS1IodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIGZuLnJlZ2lzdGVyKFwiK1wiLCBBZGROb2RlKTtcblxuICAgICAgICByZXR1cm4gQWRkTm9kZTtcbiAgICB9KSgpO1xuXG4gICAgdmFyIE51bWJlcldyYXBwZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIE51bWJlcldyYXBwZXIoX2FyZ3MpIHtcbiAgICAgICAgICAgIFRpbWJyZU9iamVjdC5jYWxsKHRoaXMsIDEsIFtdKTtcbiAgICAgICAgICAgIGZuLmZpeEtSKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gX2FyZ3NbMF07XG5cbiAgICAgICAgICAgIGlmIChpc0RpY3Rpb25hcnkoX2FyZ3NbMV0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IF9hcmdzWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImluaXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uKFwic2V0QWRkXCIsIGZuLmNoYW5nZVdpdGhWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9uKFwic2V0TXVsXCIsIGZuLmNoYW5nZVdpdGhWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm4uZXh0ZW5kKE51bWJlcldyYXBwZXIpO1xuXG4gICAgICAgIHZhciAkID0gTnVtYmVyV3JhcHBlci5wcm90b3R5cGU7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuXy52YWx1ZSA9IGlzTmFOKHZhbHVlKSA/IDAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuLmNoYW5nZVdpdGhWYWx1ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIE51bWJlcldyYXBwZXI7XG4gICAgfSkoKTtcblxuICAgIHZhciBCb29sZWFuV3JhcHBlciA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQm9vbGVhbldyYXBwZXIoX2FyZ3MpIHtcbiAgICAgICAgICAgIFRpbWJyZU9iamVjdC5jYWxsKHRoaXMsIDEsIFtdKTtcbiAgICAgICAgICAgIGZuLmZpeEtSKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gX2FyZ3NbMF07XG5cbiAgICAgICAgICAgIGlmIChpc0RpY3Rpb25hcnkoX2FyZ3NbMV0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IF9hcmdzWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImluaXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uKFwic2V0QWRkXCIsIGZuLmNoYW5nZVdpdGhWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9uKFwic2V0TXVsXCIsIGZuLmNoYW5nZVdpdGhWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm4uZXh0ZW5kKEJvb2xlYW5XcmFwcGVyKTtcblxuICAgICAgICB2YXIgJCA9IEJvb2xlYW5XcmFwcGVyLnByb3RvdHlwZTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnZhbHVlID0gdmFsdWUgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgZm4uY2hhbmdlV2l0aFZhbHVlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl8udmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gQm9vbGVhbldyYXBwZXI7XG4gICAgfSkoKTtcblxuICAgIHZhciBGdW5jdGlvbldyYXBwZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEZ1bmN0aW9uV3JhcHBlcihfYXJncykge1xuICAgICAgICAgICAgVGltYnJlT2JqZWN0LmNhbGwodGhpcywgMSwgW10pO1xuICAgICAgICAgICAgZm4uZml4S1IodGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuZnVuYyAgICA9IF9hcmdzWzBdO1xuICAgICAgICAgICAgdGhpcy5fLnZhbHVlID0gMDtcblxuICAgICAgICAgICAgaWYgKGlzRGljdGlvbmFyeShfYXJnc1sxXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gX2FyZ3NbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiaW5pdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub24oXCJzZXRBZGRcIiwgZm4uY2hhbmdlV2l0aFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMub24oXCJzZXRNdWxcIiwgZm4uY2hhbmdlV2l0aFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmbi5leHRlbmQoRnVuY3Rpb25XcmFwcGVyKTtcblxuICAgICAgICB2YXIgJCA9IEZ1bmN0aW9uV3JhcHBlci5wcm90b3R5cGU7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8uZnVuYyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmZ1bmM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmFyZ3MgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuXy5hcmdzID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5hcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJC5iYW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLmNvbmNhdChfLmFyZ3MpO1xuICAgICAgICAgICAgdmFyIHggPSBfLmZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBfLnZhbHVlID0geDtcbiAgICAgICAgICAgICAgICBmbi5jaGFuZ2VXaXRoVmFsdWUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuXy5lbWl0KFwiYmFuZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBGdW5jdGlvbldyYXBwZXI7XG4gICAgfSkoKTtcblxuICAgIHZhciBBcnJheVdyYXBwZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFycmF5V3JhcHBlcihfYXJncykge1xuICAgICAgICAgICAgVGltYnJlT2JqZWN0LmNhbGwodGhpcywgMSwgW10pO1xuXG4gICAgICAgICAgICB2YXIgaSwgaW1heDtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGltYXggPSBfYXJnc1swXS5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoX2FyZ3NbMF1baV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNEaWN0aW9uYXJ5KF9hcmdzWzFdKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBfYXJnc1sxXTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJpbml0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZuLmV4dGVuZChBcnJheVdyYXBwZXIpO1xuXG4gICAgICAgIHZhciAkID0gQXJyYXlXcmFwcGVyLnByb3RvdHlwZTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJC5iYW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtcImJhbmdcIl0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgICAgICAgdmFyIGksIGltYXg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpbWF4ID0gbm9kZXMubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbaV0uYmFuZy5hcHBseShub2Rlc1tpXSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAkLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgICAgICAgIHZhciBpLCBpbWF4O1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IG5vZGVzLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIG5vZGVzW2ldLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG4gICAgICAgICAgICAgICAgaWYgKF8uYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uaW5wdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxsc1swXVswXSA9IGZuLmlucHV0U2lnbmFsS1IodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEtSKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBBcnJheVdyYXBwZXI7XG4gICAgfSkoKTtcblxuICAgIHZhciBPYmplY3RXcmFwcGVyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3RXcmFwcGVyKF9hcmdzKSB7XG4gICAgICAgICAgICBUaW1icmVPYmplY3QuY2FsbCh0aGlzLCAxLCBbXSk7XG4gICAgICAgICAgICBmbi5maXhLUih0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGlzRGljdGlvbmFyeShfYXJnc1sxXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gX2FyZ3NbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiaW5pdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbi5leHRlbmQoT2JqZWN0V3JhcHBlcik7XG5cbiAgICAgICAgdmFyICQgPSBPYmplY3RXcmFwcGVyLnByb3RvdHlwZTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdFdyYXBwZXI7XG4gICAgfSkoKTtcblxuICAgIHZhciBTeXN0ZW1JbmxldCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gU3lzdGVtSW5sZXQob2JqZWN0KSB7XG4gICAgICAgICAgICBUaW1icmVPYmplY3QuY2FsbCh0aGlzLCAyLCBbXSk7XG5cbiAgICAgICAgICAgIHRoaXMucGxheWJhY2tTdGF0ZSA9IEZJTklTSEVEX1NUQVRFO1xuICAgICAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgICAgICBfLm5vZGUgPSBvYmplY3Q7XG4gICAgICAgICAgICBfLm9ucGxheSAgPSBtYWtlX29ucGxheSh0aGlzKTtcbiAgICAgICAgICAgIF8ub25wYXVzZSA9IG1ha2Vfb25wYXVzZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBmbi5leHRlbmQoU3lzdGVtSW5sZXQpO1xuXG4gICAgICAgIHZhciBtYWtlX29ucGxheSA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3N5cy5pbmxldHMuaW5kZXhPZihzZWxmKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3N5cy5pbmxldHMucHVzaChzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgX3N5cy5ldmVudHMuZW1pdChcImFkZE9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5YmFja1N0YXRlID0gUExBWUlOR19TVEFURTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fLmVtaXQoXCJwbGF5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1ha2Vfb25wYXVzZSA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IF9zeXMuaW5sZXRzLmluZGV4T2Yoc2VsZik7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zeXMuaW5sZXRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5YmFja1N0YXRlID0gRklOSVNIRURfU1RBVEU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuXy5lbWl0KFwicGF1c2VcIik7XG4gICAgICAgICAgICAgICAgICAgIF9zeXMuZXZlbnRzLmVtaXQoXCJyZW1vdmVPYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgJCA9IFN5c3RlbUlubGV0LnByb3RvdHlwZTtcblxuICAgICAgICAkLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9zeXMubmV4dFRpY2sodGhpcy5fLm9ucGxheSk7XG4gICAgICAgICAgICByZXR1cm4gKF9zeXMuaW5sZXRzLmluZGV4T2YodGhpcykgPT09IC0xKTtcbiAgICAgICAgfTtcblxuICAgICAgICAkLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfc3lzLm5leHRUaWNrKHRoaXMuXy5vbnBhdXNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fLm5vZGU7XG4gICAgICAgICAgICBpZiAobm9kZS5wbGF5YmFja1N0YXRlICYgMSkge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvY2Vzcyh0aWNrSUQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHNbMV0uc2V0KG5vZGUuY2VsbHNbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHNbMl0uc2V0KG5vZGUuY2VsbHNbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzWzFdLnNldChmbi5lbXB0eWNlbGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHNbMl0uc2V0KGZuLmVtcHR5Y2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFN5c3RlbUlubGV0O1xuICAgIH0pKCk7XG5cbiAgICB2YXIgU291bmRTeXN0ZW0gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNvdW5kU3lzdGVtKCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW1wbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmFtcCAgPSAwLjg7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEZJTklTSEVEX1NUQVRFO1xuICAgICAgICAgICAgdGhpcy5zYW1wbGVyYXRlID0gNDQxMDA7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzICAgPSAyO1xuICAgICAgICAgICAgdGhpcy5jZWxsc2l6ZSAgID0gNjQ7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbW1zZWMgPSAyMDtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtc2l6ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMubmV4dFRpY2tzID0gW107XG4gICAgICAgICAgICB0aGlzLmlubGV0cyAgICA9IFtdO1xuICAgICAgICAgICAgdGhpcy50aW1lcnMgICAgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZWNTdGFydCAgID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVjQnVmZmVycyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRlbGF5UHJvY2VzcyA9IG1ha2VfZGVsYXlQcm9jZXNzKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IG51bGw7XG5cbiAgICAgICAgICAgIGZuLmN1cnJlbnRUaW1lSW5jciA9IHRoaXMuY2VsbHNpemUgKiAxMDAwIC8gdGhpcy5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgZm4uZW1wdHljZWxsID0gbmV3IGZuLlNpZ25hbEFycmF5KHRoaXMuY2VsbHNpemUpO1xuXG4gICAgICAgICAgICB0aGlzLnJlc2V0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ha2VfZGVsYXlQcm9jZXNzID0gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVjU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHNlbGYucHJvY2VzcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgJCA9IFNvdW5kU3lzdGVtLnByb3RvdHlwZTtcblxuICAgICAgICAkLmJpbmQgPSBmdW5jdGlvbihLbGFzcywgb3B0cykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBLbGFzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYXllciA9IG5ldyBLbGFzcyh0aGlzLCBvcHRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmltcGwgPSBwbGF5ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1wbC5kZWZhdWx0U2FtcGxlcmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZXJhdGUgPSB0aGlzLmltcGwuZGVmYXVsdFNhbXBsZXJhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5zZXR1cCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoQUNDRVBUX1NBTVBMRVJBVEVTLmluZGV4T2YocGFyYW1zLnNhbXBsZXJhdGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnNhbXBsZXJhdGUgPD0gdGhpcy5pbXBsLm1heFNhbXBsZXJhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlcmF0ZSA9IHBhcmFtcy5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVyYXRlID0gdGhpcy5pbXBsLm1heFNhbXBsZXJhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFDQ0VQVF9DRUxMU0laRVMuaW5kZXhPZihwYXJhbXMuY2VsbHNpemUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzaXplID0gcGFyYW1zLmNlbGxzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgcGFyYW1zLmY2NCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBfZjY0bW9kZSA9ICEhcGFyYW1zLmY2NDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9mNjRtb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbi5TaWduYWxBcnJheSA9IEZsb2F0NjRBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuLlNpZ25hbEFycmF5ID0gRmxvYXQzMkFycmF5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4uY3VycmVudFRpbWVJbmNyID0gdGhpcy5jZWxsc2l6ZSAqIDEwMDAgLyB0aGlzLnNhbXBsZXJhdGU7XG4gICAgICAgICAgICBmbi5lbXB0eWNlbGwgPSBuZXcgZm4uU2lnbmFsQXJyYXkodGhpcy5jZWxsc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAkLmdldEFkanVzdFNhbXBsZXMgPSBmdW5jdGlvbihzYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICB2YXIgc2FtcGxlcywgYml0cztcbiAgICAgICAgICAgIHNhbXBsZXJhdGUgPSBzYW1wbGVyYXRlIHx8IHRoaXMuc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIHNhbXBsZXMgPSB0aGlzLnN0cmVhbW1zZWMgLyAxMDAwICogc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIGJpdHMgPSBNYXRoLmNlaWwoTWF0aC5sb2coc2FtcGxlcykgKiBNYXRoLkxPRzJFKTtcbiAgICAgICAgICAgIGJpdHMgPSAoYml0cyA8IDgpID8gOCA6IChiaXRzID4gMTQpID8gMTQgOiBiaXRzO1xuICAgICAgICAgICAgcmV0dXJuIDEgPDwgYml0cztcbiAgICAgICAgfTtcblxuICAgICAgICAkLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRklOSVNIRURfU1RBVEUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFBMQVlJTkdfU1RBVEU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbXNpemUgPSB0aGlzLmdldEFkanVzdFNhbXBsZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm1MID0gbmV3IGZuLlNpZ25hbEFycmF5KHRoaXMuc3RyZWFtc2l6ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJtUiA9IG5ldyBmbi5TaWduYWxBcnJheSh0aGlzLnN0cmVhbXNpemUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5pbXBsLnBsYXkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KFwicGxheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gUExBWUlOR19TVEFURSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gRklOSVNIRURfU1RBVEU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBsLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdChcInBhdXNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5yZXNldCA9IGZ1bmN0aW9uKGRlZXApIHtcbiAgICAgICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKHRoaXMpLm9uKFwiYWRkT2JqZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEZJTklTSEVEX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLm9uKFwicmVtb3ZlT2JqZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFBMQVlJTkdfU1RBVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlubGV0cy5sZW5ndGggKyB0aGlzLnRpbWVycy5sZW5ndGggKyB0aGlzLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy5uZXh0VGlja3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5sZXRzICAgID0gW107XG4gICAgICAgICAgICB0aGlzLnRpbWVycyAgICA9IFtdO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRpY2tJRCA9IHRoaXMudGlja0lEO1xuICAgICAgICAgICAgdmFyIHN0cm1MID0gdGhpcy5zdHJtTCwgc3RybVIgPSB0aGlzLnN0cm1SO1xuICAgICAgICAgICAgdmFyIGFtcCA9IHRoaXMuYW1wO1xuICAgICAgICAgICAgdmFyIHgsIHRtcEwsIHRtcFI7XG4gICAgICAgICAgICB2YXIgaSwgaW1heCA9IHRoaXMuc3RyZWFtc2l6ZSwgc2F2ZWRfaSA9IDA7XG4gICAgICAgICAgICB2YXIgaiwgam1heDtcbiAgICAgICAgICAgIHZhciBrLCBrbWF4ID0gdGhpcy5jZWxsc2l6ZTtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5zdHJlYW1zaXplIC8gdGhpcy5jZWxsc2l6ZTtcbiAgICAgICAgICAgIHZhciBuZXh0VGlja3M7XG4gICAgICAgICAgICB2YXIgdGltZXJzICAgID0gdGhpcy50aW1lcnM7XG4gICAgICAgICAgICB2YXIgaW5sZXRzICAgID0gdGhpcy5pbmxldHM7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnM7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWVJbmNyID0gZm4uY3VycmVudFRpbWVJbmNyO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3RybUxbaV0gPSBzdHJtUltpXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICArK3RpY2tJRDtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGptYXggPSB0aW1lcnMubGVuZ3RoOyBqIDwgam1heDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcnNbal0ucGxheWJhY2tTdGF0ZSAmIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyc1tqXS5wcm9jZXNzKHRpY2tJRCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqbWF4ID0gaW5sZXRzLmxlbmd0aDsgaiA8IGptYXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gaW5sZXRzW2pdO1xuICAgICAgICAgICAgICAgICAgICB4LnByb2Nlc3ModGlja0lEKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucGxheWJhY2tTdGF0ZSAmIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcEwgPSB4LmNlbGxzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wUiA9IHguY2VsbHNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBpID0gc2F2ZWRfaTsgayA8IGttYXg7ICsraywgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RybUxbaV0gKz0gdG1wTFtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJtUltpXSArPSB0bXBSW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhdmVkX2kgKz0ga21heDtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGptYXggPSBsaXN0ZW5lcnMubGVuZ3RoOyBqIDwgam1heDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbal0ucGxheWJhY2tTdGF0ZSAmIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tqXS5wcm9jZXNzKHRpY2tJRCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGN1cnJlbnRUaW1lSW5jcjtcblxuICAgICAgICAgICAgICAgIG5leHRUaWNrcyA9IHRoaXMubmV4dFRpY2tzLnNwbGljZSgwKTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqbWF4ID0gbmV4dFRpY2tzLmxlbmd0aDsgaiA8IGptYXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBuZXh0VGlja3Nbal0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICB4ID0gc3RybUxbaV0gKiBhbXA7XG4gICAgICAgICAgICAgICAgaWYgKHggPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh4ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RybUxbaV0gPSB4O1xuICAgICAgICAgICAgICAgIHggPSBzdHJtUltpXSAqIGFtcDtcbiAgICAgICAgICAgICAgICBpZiAoeCA8IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJtUltpXSA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFNDSEVEVUxFRF9TVEFURSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY0NoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjQnVmZmVycy5wdXNoKG5ldyBmbi5TaWduYWxBcnJheShzdHJtTCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY0J1ZmZlcnMucHVzaChuZXcgZm4uU2lnbmFsQXJyYXkoc3RybVIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBmbi5TaWduYWxBcnJheShzdHJtTC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpbWF4ID0gc3RybS5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm1baV0gPSAoc3RybUxbaV0gKyBzdHJtUltpXSkgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNCdWZmZXJzLnB1c2goc3RybSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID49IHRoaXMubWF4RHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5zdWIucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VGltZSA+PSB0aGlzLnJlY0R1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQuc3ViLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChub3cgLSB0aGlzLnJlY1N0YXJ0KSA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZGVsYXlQcm9jZXNzLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAkLm5leHRUaWNrID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBGSU5JU0hFRF9TVEFURSkge1xuICAgICAgICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0VGlja3MucHVzaChmdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAkLnJlYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4uZml4X2lPUzZfMV9wcm9ibGVtKHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgZGZkID0gbmV3IERlZmVycmVkKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInJlYyBkZWZlcnJlZCBpcyBleGlzdHM/P1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGZkLnJlamVjdCgpLnByb21pc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBGSU5JU0hFRF9TVEFURSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhdHVzIGlzIG5vdCBub25lXCIsIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGZkLnJlamVjdCgpLnByb21pc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSAwLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdmFyIG9wdHMgPSBpc0RpY3Rpb25hcnkoYXJnc1tpXSkgPyBhcmdzW2krK10gOiB7fTtcbiAgICAgICAgICAgIHZhciBmdW5jID0gYXJnc1tpXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBlcnJvcj8/XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwibm8gZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRmZC5yZWplY3QoKS5wcm9taXNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQgPSBkZmQ7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFNDSEVEVUxFRF9TVEFURTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICAgICAgdmFyIHJlY19pbmxldCA9IG5ldyBUKFwiK1wiKTtcbiAgICAgICAgICAgIHZhciBpbmxldF9kZmQgPSBuZXcgRGVmZXJyZWQodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBvdXRsZXQgPSB7XG4gICAgICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlubGV0X2RmZC5yZXNvbHZlLmFwcGx5KGlubGV0X2RmZCwgc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZWNfaW5sZXQuYXBwZW5kLmFwcGx5KHJlY19pbmxldCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpbmxldF9kZmQudGhlbihyZWNkb25lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmbi5maXhfaU9TNl8xX3Byb2JsZW0oZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlY2RvbmUuY2FsbChzZWxmLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnN1YiA9IGlubGV0X2RmZDtcblxuICAgICAgICAgICAgdGhpcy5zYXZlZFNhbXBsZXJhdGUgPSB0aGlzLnNhbXBsZXJhdGU7XG4gICAgICAgICAgICB0aGlzLnNhbXBsZXJhdGUgID0gb3B0cy5zYW1wbGVyYXRlICB8fCB0aGlzLnNhbXBsZXJhdGU7XG4gICAgICAgICAgICB0aGlzLnJlY0R1cmF0aW9uID0gb3B0cy5yZWNEdXJhdGlvbiB8fCBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMubWF4RHVyYXRpb24gPSBvcHRzLm1heER1cmF0aW9uIHx8IDEwICogNjAgKiAxMDAwO1xuICAgICAgICAgICAgdGhpcy5yZWNDaCA9IG9wdHMuY2ggfHwgMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY0NoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNDaCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlY0J1ZmZlcnMgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5zdHJlYW1zaXplID0gdGhpcy5nZXRBZGp1c3RTYW1wbGVzKCk7XG4gICAgICAgICAgICB0aGlzLnN0cm1MID0gbmV3IGZuLlNpZ25hbEFycmF5KHRoaXMuc3RyZWFtc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnN0cm1SID0gbmV3IGZuLlNpZ25hbEFycmF5KHRoaXMuc3RyZWFtc2l6ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5sZXRzLnB1c2gocmVjX2lubGV0KTtcblxuICAgICAgICAgICAgZnVuYyhvdXRsZXQpO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZGVsYXlQcm9jZXNzLCAxMCk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZmQucHJvbWlzZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZWNkb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEZJTklTSEVEX1NUQVRFO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgICAgICB2YXIgcmVjQnVmZmVycyA9IHRoaXMucmVjQnVmZmVycztcbiAgICAgICAgICAgIHZhciBzYW1wbGVyYXRlID0gdGhpcy5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgdmFyIHN0cmVhbXNpemUgPSB0aGlzLnN0cmVhbXNpemU7XG4gICAgICAgICAgICB2YXIgYnVmZmVyTGVuZ3RoO1xuXG4gICAgICAgICAgICB0aGlzLnNhbXBsZXJhdGUgPSB0aGlzLnNhdmVkU2FtcGxlcmF0ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucmVjRHVyYXRpb24gIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyTGVuZ3RoID0gKHRoaXMucmVjRHVyYXRpb24gKiBzYW1wbGVyYXRlICogMC4wMDEpfDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckxlbmd0aCA9IChyZWNCdWZmZXJzLmxlbmd0aCA+PiAodGhpcy5yZWNDaC0xKSkgKiBzdHJlYW1zaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIGksIGltYXggPSAoYnVmZmVyTGVuZ3RoIC8gc3RyZWFtc2l6ZSl8MDtcbiAgICAgICAgICAgIHZhciBqID0gMCwgayA9IDA7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gYnVmZmVyTGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yZWNDaCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBMID0gbmV3IGZuLlNpZ25hbEFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIFIgPSBuZXcgZm4uU2lnbmFsQXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWl4ZWQgPSBuZXcgZm4uU2lnbmFsQXJyYXkoYnVmZmVyTGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgTC5zZXQocmVjQnVmZmVyc1tqKytdLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgUi5zZXQocmVjQnVmZmVyc1tqKytdLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgayArPSBzdHJlYW1zaXplO1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgLT0gc3RyZWFtc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA+IDAgJiYgcmVtYWluaW5nIDwgc3RyZWFtc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTC5zZXQocmVjQnVmZmVyc1tqKytdLnN1YmFycmF5KDAsIHJlbWFpbmluZyksIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgUi5zZXQocmVjQnVmZmVyc1tqKytdLnN1YmFycmF5KDAsIHJlbWFpbmluZyksIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IGJ1ZmZlckxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBtaXhlZFtpXSA9IChMW2ldICsgUltpXSkgKiAwLjU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyYXRlOiBzYW1wbGVyYXRlLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVscyAgOiAyLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IFttaXhlZCwgTCwgUl1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBuZXcgZm4uU2lnbmFsQXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQocmVjQnVmZmVyc1tqKytdLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgayArPSBzdHJlYW1zaXplO1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgLT0gc3RyZWFtc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA+IDAgJiYgcmVtYWluaW5nIDwgc3RyZWFtc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnNldChyZWNCdWZmZXJzW2orK10uc3ViYXJyYXkoMCwgcmVtYWluaW5nKSwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXJhdGU6IHNhbXBsZXJhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzICA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogW2J1ZmZlcl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLmNvbmNhdC5hcHBseShbcmVzdWx0XSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZS5hcHBseSh0aGlzLmRlZmVycmVkLCBhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQgPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEV2ZW50RW1pdHRlclxuICAgICAgICAkLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vbih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgICB9O1xuICAgICAgICAkLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uY2UodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgJC5vZmYgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMub2ZmKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgJC5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcnModHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgICQubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLmxpc3RlbmVycyh0eXBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAkLmZpeF9pT1M2XzFfcHJvYmxlbSA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmltcGwuZml4X2lPUzZfMV9wcm9ibGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBsLmZpeF9pT1M2XzFfcHJvYmxlbShmbGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gU291bmRTeXN0ZW07XG4gICAgfSkoKTtcblxuICAgIC8vIHBsYXllclxuICAgIHZhciBJbXBsQ2xhc3MgICAgPSBudWxsO1xuICAgIHZhciBBdWRpb0NvbnRleHQgPSBudWxsO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBBdWRpb0NvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgSW1wbENsYXNzID0gZnVuY3Rpb24oc3lzKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciBqc05vZGU7XG5cbiAgICAgICAgICAgIGZuLl9hdWRpb0NvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgICAgICAgICB0aGlzLm1heFNhbXBsZXJhdGUgICAgID0gY29udGV4dC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2FtcGxlcmF0ZSA9IGNvbnRleHQuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIHRoaXMuZW52ID0gXCJ3ZWJraXRcIjtcblxuICAgICAgICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgICAgIGlmICh1YS5tYXRjaCgvbGludXgvaSkpIHtcbiAgICAgICAgICAgICAgICBzeXMuc3RyZWFtbXNlYyAqPSA4O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1YS5tYXRjaCgvd2luKGRvd3MpP1xccyoobnQgNVxcLjF8eHApL2kpKSB7XG4gICAgICAgICAgICAgICAgc3lzLnN0cmVhbW1zZWMgKj0gNDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uYXVkaW9wcm9jZXNzO1xuICAgICAgICAgICAgICAgIHZhciBqc25fc3RyZWFtc2l6ZSA9IHN5cy5nZXRBZGp1c3RTYW1wbGVzKGNvbnRleHQuc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHN5c19zdHJlYW1zaXplID0gc3lzLnN0cmVhbXNpemU7XG4gICAgICAgICAgICAgICAgdmFyIHgsIGR4O1xuXG4gICAgICAgICAgICAgICAgaWYgKHN5cy5zYW1wbGVyYXRlID09PSBjb250ZXh0LnNhbXBsZVJhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cyA9IGUub3V0cHV0QnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3lzLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHMuZ2V0Q2hhbm5lbERhdGEoMCkuc2V0KHN5cy5zdHJtTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRzLmdldENoYW5uZWxEYXRhKDEpLnNldChzeXMuc3RybVIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3lzLnNhbXBsZXJhdGUgKiAyID09PSBjb250ZXh0LnNhbXBsZVJhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5MID0gc3lzLnN0cm1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluUiA9IHN5cy5zdHJtUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRzID0gZS5vdXRwdXRCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0TCA9IG91dHMuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0UiA9IG91dHMuZ2V0Q2hhbm5lbERhdGEoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaW1heCA9IG91dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGo7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN5cy5wcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMDsgaSA8IGltYXg7IGkgKz0gMiwgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0TFtpXSA9IG91dExbaSsxXSA9IGluTFtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRSW2ldID0gb3V0UltpKzFdID0gaW5SW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggID0gc3lzX3N0cmVhbXNpemU7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gc3lzLnNhbXBsZXJhdGUgLyBjb250ZXh0LnNhbXBsZVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIG9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluTCA9IHN5cy5zdHJtTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpblIgPSBzeXMuc3RybVI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cyA9IGUub3V0cHV0QnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dEwgPSBvdXRzLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dFIgPSBvdXRzLmdldENoYW5uZWxEYXRhKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGltYXggPSBvdXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID49IHN5c19zdHJlYW1zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5cy5wcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLT0gc3lzX3N0cmVhbXNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dExbaV0gPSBpbkxbeHwwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRSW2ldID0gaW5SW3h8MF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBqc05vZGUgPSBjb250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcihqc25fc3RyZWFtc2l6ZSwgMiwgc3lzLmNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICBqc05vZGUub25hdWRpb3Byb2Nlc3MgPSBvbmF1ZGlvcHJvY2VzcztcbiAgICAgICAgICAgICAgICBqc05vZGUuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqc05vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKF9lbnZtb2JpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiAgID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeF9pT1M2XzFfcHJvYmxlbSA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBmbGFnID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLm5vdGVPbigwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5jb25uZWN0KGNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEltcGxDbGFzcyA9IGZ1bmN0aW9uKHN5cykge1xuICAgICAgICAgICAgdGhpcy5tYXhTYW1wbGVyYXRlICAgICA9IDQ4MDAwO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2FtcGxlcmF0ZSA9IDQ0MTAwO1xuICAgICAgICAgICAgdGhpcy5lbnYgPSBcIm5vcFwiO1xuICAgICAgICAgICAgdGhpcy5wbGF5ICA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfc3lzID0gbmV3IFNvdW5kU3lzdGVtKCkuYmluZChJbXBsQ2xhc3MpO1xuXG4gICAgdmFyIGV4cG9ydHMgPSB0aW1icmU7XG5cbiAgICBpZiAoX2VudnR5cGUgPT09IFwibm9kZVwiIHx8IHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC50aW1icmUgPSBleHBvcnRzO1xuICAgIH0gZWxzZSBpZiAoX2VudnR5cGUgPT09IFwiYnJvd3NlclwiKSB7XG4gICAgICAgIGV4cG9ydHMubm9Db25mbGljdCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdmFyIF90ID0gd2luZG93LnRpbWJyZSwgX1QgPSB3aW5kb3cuVDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkZWVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5UID09PSBleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5UID0gX1Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWVwICYmIHdpbmRvdy50aW1icmUgPT09IGV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnRpbWJyZSA9IF90O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgd2luZG93LnRpbWJyZSA9IHdpbmRvdy5UID0gZXhwb3J0cztcbiAgICB9XG5cbiAgICAvLyBGbGFzaCBmYWxsYmFja1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF9zeXMuaW1wbC5lbnYgIT09IFwibm9wXCIgfHwgX2VudnR5cGUgIT09IFwiYnJvd3NlclwiIHx8IF9lbnZtb2JpbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF2ID0gbmF2aWdhdG9yO1xuXG4gICAgICAgIC8qanNoaW50IGxhdGVkZWY6dHJ1ZSAqL1xuICAgICAgICBpZiAoZ2V0Rmxhc2hQbGF5ZXJWZXJzaW9uKDApIDwgMTApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKmpzaGludCBsYXRlZGVmOmZhbHNlICovXG5cbiAgICAgICAgdmFyIHN3ZiwgUGxheWVyRGl2SUQgPSBcIlRpbWJyZUZsYXNoUGxheWVyRGl2XCI7XG4gICAgICAgIHZhciBzcmMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgaWYgKHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtLCBpID0gMCwgaW1heCA9IHNjcmlwdHMubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobSA9IC9eKC4qXFwvKXRpbWJyZSg/OlxcLmRldik/XFwuanMkL2kuZXhlYyhzY3JpcHRzW2ldLnNyYykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVsxXSArIFwidGltYnJlLnN3ZlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHdpbmRvdy50aW1icmVqc19mbGFzaGZhbGxiYWNrX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRpbWJyZUZsYXNoUGxheWVyKHN5cykge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lcklkID0gMDtcblxuICAgICAgICAgICAgICAgIHRoaXMubWF4U2FtcGxlcmF0ZSAgICAgPSA0NDEwMDtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRTYW1wbGVyYXRlID0gNDQxMDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnYgPSBcImZsYXNoXCI7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uYXVkaW9wcm9jZXNzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJsZWF2ZWQgPSBuZXcgQXJyYXkoc3lzLnN0cmVhbXNpemUgKiBzeXMuY2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyZWFtbXNlYyAgPSBzeXMuc3RyZWFtbXNlYztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyaXR0ZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JpdHRlbkluY3IgPSBzeXMuc3RyZWFtc2l6ZSAvIHN5cy5zYW1wbGVyYXRlICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgICAgICAgICBvbmF1ZGlvcHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdyaXR0ZW4gPiBEYXRlLm5vdygpIC0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5MID0gc3lzLnN0cm1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluUiA9IHN5cy5zdHJtUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gaW50ZXJsZWF2ZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBpbkwubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3lzLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmxlYXZlZFstLWldID0gKGluUltqXSAqIDMyNzY4KXwwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkWy0taV0gPSAoaW5MW2pdICogMzI3NjgpfDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2Yud3JpdGVBdWRpbyhpbnRlcmxlYXZlZC5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuICs9IHdyaXR0ZW5JbmNyO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzd2Yuc2V0dXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3Zi5zZXR1cChzeXMuY2hhbm5lbHMsIHN5cy5zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVySWQgPSBzZXRJbnRlcnZhbChvbmF1ZGlvcHJvY2Vzcywgc3RyZWFtbXNlYyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW5ub3QgZmluZCBcIiArIHNyYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXJJZCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dmLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVySWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zeXMuYmluZChUaW1icmVGbGFzaFBsYXllcik7XG4gICAgICAgICAgICBkZWxldGUgd2luZG93LnRpbWJyZWpzX2ZsYXNoZmFsbGJhY2tfaW5pdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbywgcDtcbiAgICAgICAgdmFyIHN3ZlNyYyAgPSBzcmM7XG4gICAgICAgIHZhciBzd2ZOYW1lID0gc3dmU3JjICsgXCI/XCIgKyAoK25ldyBEYXRlKCkpO1xuICAgICAgICB2YXIgc3dmSWQgICA9IFwiVGltYnJlRmxhc2hQbGF5ZXJcIjtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IFBsYXllckRpdklEO1xuICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCI7XG4gICAgICAgIGRpdi53aWR0aCA9IGRpdi5oZWlnaHQgPSAxO1xuXG4gICAgICAgIGlmIChuYXYucGx1Z2lucyAmJiBuYXYubWltZVR5cGVzICYmIG5hdi5taW1lVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBuc1xuICAgICAgICAgICAgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3RcIik7XG4gICAgICAgICAgICBvLmlkID0gc3dmSWQ7XG4gICAgICAgICAgICBvLmNsYXNzaWQgPSBcImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMFwiO1xuICAgICAgICAgICAgby53aWR0aCA9IG8uaGVpZ2h0ID0gMTtcbiAgICAgICAgICAgIG8uc2V0QXR0cmlidXRlKFwiZGF0YVwiLCBzd2ZOYW1lKTtcbiAgICAgICAgICAgIG8uc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCIpO1xuICAgICAgICAgICAgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwYXJhbVwiKTtcbiAgICAgICAgICAgIHAuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcImFsbG93U2NyaXB0QWNjZXNzXCIpO1xuICAgICAgICAgICAgcC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBcImFsd2F5c1wiKTtcbiAgICAgICAgICAgIG8uYXBwZW5kQ2hpbGQocCk7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZVxuICAgICAgICAgICAgLypqc2hpbnQgcXVvdG1hcms6c2luZ2xlICovXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzxvYmplY3QgaWQ9XCInICsgc3dmSWQgKyAnXCIgY2xhc3NpZD1cImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMFwiIHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIj48cGFyYW0gbmFtZT1cIm1vdmllXCIgdmFsdWU9XCInICsgc3dmTmFtZSArICdcIiAvPjxwYXJhbSBuYW1lPVwiYmdjb2xvclwiIHZhbHVlPVwiI0ZGRkZGRlwiIC8+PHBhcmFtIG5hbWU9XCJxdWFsaXR5XCIgdmFsdWU9XCJoaWdoXCIgLz48cGFyYW0gbmFtZT1cImFsbG93U2NyaXB0QWNjZXNzXCIgdmFsdWU9XCJhbHdheXNcIiAvPjwvb2JqZWN0Pic7XG4gICAgICAgICAgICAvKmpzaGludCBxdW90bWFyazpkb3VibGUgKi9cbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICBzd2YgPSBkb2N1bWVudFtzd2ZJZF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldEZsYXNoUGxheWVyVmVyc2lvbihzdWJzKSB7XG4gICAgICAgICAgICAvKmdsb2JhbCBBY3RpdmVYT2JqZWN0OnRydWUgKi9cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hdi5wbHVnaW5zICYmIG5hdi5taW1lVHlwZXMgJiYgbmF2Lm1pbWVUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hdi5wbHVnaW5zW1wiU2hvY2t3YXZlIEZsYXNoXCJdLmRlc2NyaXB0aW9uLm1hdGNoKC8oWzAtOV0rKS8pW3N1YnNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBBY3RpdmVYT2JqZWN0KFwiU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2hcIikpLkdldFZhcmlhYmxlKFwiJHZlcnNpb25cIikubWF0Y2goLyhbMC05XSspLylbc3Vic107XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypnbG9iYWwgQWN0aXZlWE9iamVjdDpmYWxzZSAqL1xuICAgICAgICB9XG4gICAgfSkoKTtcblxufSkoKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBCaXF1YWQoc2FtcGxlcmF0ZSkge1xuICAgICAgICB0aGlzLnNhbXBsZXJhdGUgPSBzYW1wbGVyYXRlO1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IDM0MDtcbiAgICAgICAgdGhpcy5RICAgICAgICAgPSAxO1xuICAgICAgICB0aGlzLmdhaW4gICAgICA9IDA7XG5cbiAgICAgICAgdGhpcy54MUwgPSB0aGlzLngyTCA9IHRoaXMueTFMID0gdGhpcy55MkwgPSAwO1xuICAgICAgICB0aGlzLngxUiA9IHRoaXMueDJSID0gdGhpcy55MVIgPSB0aGlzLnkyUiA9IDA7XG4gICAgICAgIHRoaXMuYjAgPSB0aGlzLmIxID0gdGhpcy5iMiA9IHRoaXMuYTEgPSB0aGlzLmEyID0gMDtcblxuICAgICAgICB0aGlzLnNldFR5cGUoXCJscGZcIik7XG4gICAgfVxuXG4gICAgdmFyICQgPSBCaXF1YWQucHJvdG90eXBlO1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24oY2VsbEwsIGNlbGxSKSB7XG4gICAgICAgIHZhciB4TCwgeFIsIHlMLCB5UjtcbiAgICAgICAgdmFyIHgxTCA9IHRoaXMueDFMLCB4MkwgPSB0aGlzLngyTCwgeTFMID0gdGhpcy55MUwsIHkyTCA9IHRoaXMueTJMO1xuICAgICAgICB2YXIgeDFSID0gdGhpcy54MVIsIHgyUiA9IHRoaXMueDJSLCB5MVIgPSB0aGlzLnkxUiwgeTJSID0gdGhpcy55MlI7XG4gICAgICAgIHZhciBiMCA9IHRoaXMuYjAsIGIxID0gdGhpcy5iMSwgYjIgPSB0aGlzLmIyLCBhMSA9IHRoaXMuYTEsIGEyID0gdGhpcy5hMjtcbiAgICAgICAgdmFyIGksIGltYXg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IGNlbGxMLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgeEwgPSBjZWxsTFtpXTtcbiAgICAgICAgICAgIHlMID0gYjAgKiB4TCArIGIxICogeDFMICsgYjIgKiB4MkwgLSBhMSAqIHkxTCAtIGEyICogeTJMO1xuICAgICAgICAgICAgeDJMID0geDFMOyB4MUwgPSB4TDsgeTJMID0geTFMOyB5MUwgPSB5TDtcblxuICAgICAgICAgICAgeFIgPSBjZWxsUltpXTtcbiAgICAgICAgICAgIHlSID0gYjAgKiB4UiArIGIxICogeDFSICsgYjIgKiB4MlIgLSBhMSAqIHkxUiAtIGEyICogeTJSO1xuICAgICAgICAgICAgeDJSID0geDFSOyB4MVIgPSB4UjsgeTJSID0geTFSOyB5MVIgPSB5UjtcblxuICAgICAgICAgICAgY2VsbExbaV0gPSB5TDtcbiAgICAgICAgICAgIGNlbGxSW2ldID0geVI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54MUwgPSB4MUw7IHRoaXMueDJMID0geDJMOyB0aGlzLnkxTCA9IHkxTDsgdGhpcy55MkwgPSB5Mkw7XG4gICAgICAgIHRoaXMueDFSID0geDFSOyB0aGlzLngyUiA9IHgyUjsgdGhpcy55MVIgPSB5MVI7IHRoaXMueTJSID0geTJSO1xuICAgIH07XG5cbiAgICAkLnNldFR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBmO1xuICAgICAgICBpZiAoKGYgPSBzZXRQYXJhbXNbdHlwZV0pKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgZi5jYWxsKHRoaXMsIHRoaXMuZnJlcXVlbmN5LCB0aGlzLlEsIHRoaXMuZ2Fpbik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5zZXRQYXJhbXMgPSBmdW5jdGlvbihmcmVxdWVuY3ksIFEsIGRiR2Fpbikge1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IGZyZXF1ZW5jeTtcbiAgICAgICAgdGhpcy5RID0gUTtcbiAgICAgICAgdGhpcy5nYWluID0gZGJHYWluO1xuXG4gICAgICAgIHZhciBmID0gc2V0UGFyYW1zW3RoaXMudHlwZV07XG4gICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICBmLmNhbGwodGhpcywgZnJlcXVlbmN5LCBRLCBkYkdhaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG4gICAgdmFyIHNldFBhcmFtcyA9IHtcbiAgICAgICAgbG93cGFzczogZnVuY3Rpb24oY3V0b2ZmLCByZXNvbmFuY2UpIHtcbiAgICAgICAgICAgIGN1dG9mZiAvPSAodGhpcy5zYW1wbGVyYXRlICogMC41KTtcblxuICAgICAgICAgICAgaWYgKGN1dG9mZiA+PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iMCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5iMSA9IHRoaXMuYjIgPSB0aGlzLmExID0gdGhpcy5hMiA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1dG9mZiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iMCA9IHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbmFuY2UgPSAocmVzb25hbmNlIDwgMCkgPyAwIDogcmVzb25hbmNlO1xuICAgICAgICAgICAgICAgIHZhciBnID0gTWF0aC5wb3coMTAuMCwgMC4wNSAqIHJlc29uYW5jZSk7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoKDQgLSBNYXRoLnNxcnQoMTYgLSAxNiAvIChnICogZykpKSAqIDAuNSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBNYXRoLlBJICogY3V0b2ZmO1xuICAgICAgICAgICAgICAgIHZhciBzbiA9IDAuNSAqIGQgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgICAgICAgICAgdmFyIGJldGEgPSAwLjUgKiAoMSAtIHNuKSAvICgxICsgc24pO1xuICAgICAgICAgICAgICAgIHZhciBnYW1tYSA9ICgwLjUgKyBiZXRhKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSAwLjI1ICogKDAuNSArIGJldGEgLSBnYW1tYSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmIwID0gMiAqIGFscGhhO1xuICAgICAgICAgICAgICAgIHRoaXMuYjEgPSA0ICogYWxwaGE7XG4gICAgICAgICAgICAgICAgdGhpcy5iMiA9IHRoaXMuYjA7IC8vIDIgKiBhbHBoYTtcbiAgICAgICAgICAgICAgICB0aGlzLmExID0gMiAqIC1nYW1tYTtcbiAgICAgICAgICAgICAgICB0aGlzLmEyID0gMiAqIGJldGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhpZ2hwYXNzOiBmdW5jdGlvbihjdXRvZmYsIHJlc29uYW5jZSkge1xuICAgICAgICAgICAgY3V0b2ZmIC89ICh0aGlzLnNhbXBsZXJhdGUgKiAwLjUpO1xuICAgICAgICAgICAgaWYgKGN1dG9mZiA+PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iMCA9IHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXRvZmYgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYjAgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbmFuY2UgPSAocmVzb25hbmNlIDwgMCkgPyAwIDogcmVzb25hbmNlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGcgPSBNYXRoLnBvdygxMC4wLCAwLjA1ICogcmVzb25hbmNlKTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydCgoNCAtIE1hdGguc3FydCgxNiAtIDE2IC8gKGcgKiBnKSkpIC8gMik7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBNYXRoLlBJICogY3V0b2ZmO1xuICAgICAgICAgICAgICAgIHZhciBzbiA9IDAuNSAqIGQgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgICAgICAgICAgdmFyIGJldGEgPSAwLjUgKiAoMSAtIHNuKSAvICgxICsgc24pO1xuICAgICAgICAgICAgICAgIHZhciBnYW1tYSA9ICgwLjUgKyBiZXRhKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSAwLjI1ICogKDAuNSArIGJldGEgKyBnYW1tYSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmIwID0gMiAqIGFscGhhO1xuICAgICAgICAgICAgICAgIHRoaXMuYjEgPSAtNCAqIGFscGhhO1xuICAgICAgICAgICAgICAgIHRoaXMuYjIgPSB0aGlzLmIwOyAvLyAyICogYWxwaGE7XG4gICAgICAgICAgICAgICAgdGhpcy5hMSA9IDIgKiAtZ2FtbWE7XG4gICAgICAgICAgICAgICAgdGhpcy5hMiA9IDIgKiBiZXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYW5kcGFzczogZnVuY3Rpb24oZnJlcXVlbmN5LCBRKSB7XG4gICAgICAgICAgICBmcmVxdWVuY3kgLz0gKHRoaXMuc2FtcGxlcmF0ZSAqIDAuNSk7XG4gICAgICAgICAgICBpZiAoZnJlcXVlbmN5ID4gMCAmJiBmcmVxdWVuY3kgPCAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKFEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3MCA9IE1hdGguUEkgKiBmcmVxdWVuY3k7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFscGhhID0gTWF0aC5zaW4odzApIC8gKDIgKiBRKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmNvcyh3MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlhMCA9IDEgLyAoMSArIGFscGhhKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmIwID0gYWxwaGEgKiBpYTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYjEgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmIyID0gLWFscGhhICogaWEwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmExID0gLTIgKiBrICogaWEwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmEyID0gKDEgLSBhbHBoYSkgKiBpYTA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iMCA9IHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iMCA9IHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb3dzaGVsZjogZnVuY3Rpb24oZnJlcXVlbmN5LCBfZHVtbXlfLCBkYkdhaW4pIHtcbiAgICAgICAgICAgIGZyZXF1ZW5jeSAvPSAodGhpcy5zYW1wbGVyYXRlICogMC41KTtcblxuICAgICAgICAgICAgdmFyIEEgPSBNYXRoLnBvdygxMC4wLCBkYkdhaW4gLyA0MCk7XG5cbiAgICAgICAgICAgIGlmIChmcmVxdWVuY3kgPj0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYjAgPSBBKiBBO1xuICAgICAgICAgICAgICAgIHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmVxdWVuY3kgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYjAgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdzAgPSBNYXRoLlBJICogZnJlcXVlbmN5O1xuICAgICAgICAgICAgICAgIHZhciBTID0gMTsgLy8gZmlsdGVyIHNsb3BlICgxIGlzIG1heCB2YWx1ZSlcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSAwLjUgKiBNYXRoLnNpbih3MCkgKiBNYXRoLnNxcnQoKEEgKyAxIC8gQSkgKiAoMSAvIFMgLSAxKSArIDIpO1xuICAgICAgICAgICAgICAgIHZhciBrID0gTWF0aC5jb3ModzApO1xuICAgICAgICAgICAgICAgIHZhciBrMiA9IDIgKiBNYXRoLnNxcnQoQSkgKiBhbHBoYTtcbiAgICAgICAgICAgICAgICB2YXIgYVBsdXNPbmUgPSBBICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgYU1pbnVzT25lID0gQSAtIDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgaWEwID0gMSAvIChhUGx1c09uZSArIGFNaW51c09uZSAqIGsgKyBrMik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmIwID0gKEEgKiAoYVBsdXNPbmUgLSBhTWludXNPbmUgKiBrICsgazIpKSAqIGlhMDtcbiAgICAgICAgICAgICAgICB0aGlzLmIxID0gKDIgKiBBICogKGFNaW51c09uZSAtIGFQbHVzT25lICogaykpICogaWEwO1xuICAgICAgICAgICAgICAgIHRoaXMuYjIgPSAoQSAqIChhUGx1c09uZSAtIGFNaW51c09uZSAqIGsgLSBrMikpICogaWEwO1xuICAgICAgICAgICAgICAgIHRoaXMuYTEgPSAoLTIgKiAoYU1pbnVzT25lICsgYVBsdXNPbmUgKiBrKSkgKiBpYTA7XG4gICAgICAgICAgICAgICAgdGhpcy5hMiA9IChhUGx1c09uZSArIGFNaW51c09uZSAqIGsgLSBrMikgKiBpYTA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhpZ2hzaGVsZjogZnVuY3Rpb24oZnJlcXVlbmN5LCBfZHVtbXlfLCBkYkdhaW4pIHtcbiAgICAgICAgICAgIGZyZXF1ZW5jeSAvPSAodGhpcy5zYW1wbGVyYXRlICogMC41KTtcblxuICAgICAgICAgICAgdmFyIEEgPSBNYXRoLnBvdygxMC4wLCBkYkdhaW4gLyA0MCk7XG5cbiAgICAgICAgICAgIGlmIChmcmVxdWVuY3kgPj0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYjAgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmVxdWVuY3kgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYjAgPSBBICogQTtcbiAgICAgICAgICAgICAgICB0aGlzLmIxID0gdGhpcy5iMiA9IHRoaXMuYTEgPSB0aGlzLmEyID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHcwID0gTWF0aC5QSSAqIGZyZXF1ZW5jeTtcbiAgICAgICAgICAgICAgICB2YXIgUyA9IDE7IC8vIGZpbHRlciBzbG9wZSAoMSBpcyBtYXggdmFsdWUpXG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gMC41ICogTWF0aC5zaW4odzApICogTWF0aC5zcXJ0KChBICsgMSAvIEEpICogKDEgLyBTIC0gMSkgKyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGguY29zKHcwKTtcbiAgICAgICAgICAgICAgICB2YXIgazIgPSAyICogTWF0aC5zcXJ0KEEpICogYWxwaGE7XG4gICAgICAgICAgICAgICAgdmFyIGFQbHVzT25lID0gQSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGFNaW51c09uZSA9IEEgLSAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlhMCA9IDEgLyAoYVBsdXNPbmUgLSBhTWludXNPbmUgKiBrICsgazIpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5iMCA9IChBICogKGFQbHVzT25lICsgYU1pbnVzT25lICogayArIGsyKSkgKiBpYTA7XG4gICAgICAgICAgICAgICAgdGhpcy5iMSA9ICgtMiAqIEEgKiAoYU1pbnVzT25lICsgYVBsdXNPbmUgKiBrKSkgKiBpYTA7XG4gICAgICAgICAgICAgICAgdGhpcy5iMiA9IChBICogKGFQbHVzT25lICsgYU1pbnVzT25lICogayAtIGsyKSkgKiBpYTA7XG4gICAgICAgICAgICAgICAgdGhpcy5hMSA9ICgyICogKGFNaW51c09uZSAtIGFQbHVzT25lICogaykpICogaWEwO1xuICAgICAgICAgICAgICAgIHRoaXMuYTIgPSAoYVBsdXNPbmUgLSBhTWludXNPbmUgKiBrIC0gazIpICogaWEwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwZWFraW5nOiBmdW5jdGlvbihmcmVxdWVuY3ksIFEsIGRiR2Fpbikge1xuICAgICAgICAgICAgZnJlcXVlbmN5IC89ICh0aGlzLnNhbXBsZXJhdGUgKiAwLjUpO1xuXG4gICAgICAgICAgICBpZiAoZnJlcXVlbmN5ID4gMCAmJiBmcmVxdWVuY3kgPCAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIEEgPSBNYXRoLnBvdygxMC4wLCBkYkdhaW4gLyA0MCk7XG4gICAgICAgICAgICAgICAgaWYgKFEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3MCA9IE1hdGguUEkgKiBmcmVxdWVuY3k7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IE1hdGguc2luKHcwKSAvICgyICogUSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gTWF0aC5jb3ModzApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWEwID0gMSAvICgxICsgYWxwaGEgLyBBKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmIwID0gKDEgKyBhbHBoYSAqIEEpICogaWEwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmIxID0gKC0yICogaykgKiBpYTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYjIgPSAoMSAtIGFscGhhICogQSkgKiBpYTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYTEgPSB0aGlzLmIxOyAvLyAoLTIgKiBrKSAqIGlhMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hMiA9ICgxIC0gYWxwaGEgLyBBKSAqIGlhMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmIwID0gQSAqIEE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iMCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5iMSA9IHRoaXMuYjIgPSB0aGlzLmExID0gdGhpcy5hMiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vdGNoOiBmdW5jdGlvbihmcmVxdWVuY3ksIFEpIHtcbiAgICAgICAgICAgIGZyZXF1ZW5jeSAvPSAodGhpcy5zYW1wbGVyYXRlICogMC41KTtcblxuICAgICAgICAgICAgaWYgKGZyZXF1ZW5jeSA+IDAgJiYgZnJlcXVlbmN5IDwgMSkge1xuICAgICAgICAgICAgICAgIGlmIChRID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdzAgPSBNYXRoLlBJICogZnJlcXVlbmN5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLnNpbih3MCkgLyAoMiAqIFEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGguY29zKHcwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlhMCA9IDEgLyAoMSArIGFscGhhKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmIwID0gaWEwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmIxID0gKC0yICogaykgKiBpYTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYjIgPSBpYTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYTEgPSB0aGlzLmIxOyAvLyAoLTIgKiBrKSAqIGlhMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hMiA9ICgxIC0gYWxwaGEpICogaWEwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYjAgPSB0aGlzLmIxID0gdGhpcy5iMiA9IHRoaXMuYTEgPSB0aGlzLmEyID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYjAgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhbGxwYXNzOiBmdW5jdGlvbihmcmVxdWVuY3ksIFEpIHtcbiAgICAgICAgICAgIGZyZXF1ZW5jeSAvPSAodGhpcy5zYW1wbGVyYXRlICogMC41KTtcblxuICAgICAgICAgICAgaWYgKGZyZXF1ZW5jeSA+IDAgJiYgZnJlcXVlbmN5IDwgMSkge1xuICAgICAgICAgICAgICAgIGlmIChRID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdzAgPSBNYXRoLlBJICogZnJlcXVlbmN5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLnNpbih3MCkgLyAoMiAqIFEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGguY29zKHcwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlhMCA9IDEgLyAoMSArIGFscGhhKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmIwID0gKDEgLSBhbHBoYSkgKiBpYTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYjEgPSAoLTIgKiBrKSAqIGlhMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iMiA9ICgxICsgYWxwaGEpICogaWEwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmExID0gdGhpcy5iMTsgLy8gKC0yICogaykgKiBpYTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYTIgPSB0aGlzLmIwOyAvLyAoMSAtIGFscGhhKSAqIGlhMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmIwID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYjEgPSB0aGlzLmIyID0gdGhpcy5hMSA9IHRoaXMuYTIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iMCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5iMSA9IHRoaXMuYjIgPSB0aGlzLmExID0gdGhpcy5hMiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0UGFyYW1zLmxwZiA9IHNldFBhcmFtcy5sb3dwYXNzO1xuICAgIHNldFBhcmFtcy5ocGYgPSBzZXRQYXJhbXMuaGlnaHBhc3M7XG4gICAgc2V0UGFyYW1zLmJwZiA9IHNldFBhcmFtcy5iYW5kcGFzcztcbiAgICBzZXRQYXJhbXMuYmVmID0gc2V0UGFyYW1zLm5vdGNoO1xuICAgIHNldFBhcmFtcy5icmYgPSBzZXRQYXJhbXMubm90Y2g7XG4gICAgc2V0UGFyYW1zLmFwZiA9IHNldFBhcmFtcy5hbGxwYXNzO1xuXG4gICAgVC5tb2R1bGVzLkJpcXVhZCA9IEJpcXVhZDtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBDaG9ydXMoc2FtcGxlcmF0ZSkge1xuICAgICAgICB0aGlzLnNhbXBsZXJhdGUgPSBzYW1wbGVyYXRlO1xuXG4gICAgICAgIHZhciBiaXRzID0gTWF0aC5yb3VuZChNYXRoLmxvZyhzYW1wbGVyYXRlICogMC4xKSAqIE1hdGguTE9HMkUpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnNpemUgPSAxIDw8IGJpdHM7XG4gICAgICAgIHRoaXMuYnVmZmVyTCA9IG5ldyBULmZuLlNpZ25hbEFycmF5KHRoaXMuYnVmZmVyc2l6ZSArIDEpO1xuICAgICAgICB0aGlzLmJ1ZmZlclIgPSBuZXcgVC5mbi5TaWduYWxBcnJheSh0aGlzLmJ1ZmZlcnNpemUgKyAxKTtcblxuICAgICAgICB0aGlzLndhdmUgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLl93YXZlICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLndyaXRlSW5kZXggPSB0aGlzLmJ1ZmZlcnNpemUgPj4gMTtcbiAgICAgICAgdGhpcy5yZWFkSW5kZXggID0gMDtcbiAgICAgICAgdGhpcy5kZWxheVRpbWUgID0gMjA7XG4gICAgICAgIHRoaXMucmF0ZSAgICAgICA9IDQ7XG4gICAgICAgIHRoaXMuZGVwdGggICAgICA9IDIwO1xuICAgICAgICB0aGlzLmZlZWRiYWNrICAgPSAwLjI7XG4gICAgICAgIHRoaXMud2V0ICAgICAgICA9IDAuNTtcbiAgICAgICAgdGhpcy5waGFzZSAgICAgID0gMDtcbiAgICAgICAgdGhpcy5waGFzZUluY3IgID0gMDtcbiAgICAgICAgdGhpcy5waGFzZVN0ZXAgID0gNDtcblxuICAgICAgICB0aGlzLnNldFdhdmVUeXBlKFwic2luXCIpO1xuICAgICAgICB0aGlzLnNldERlbGF5VGltZSh0aGlzLmRlbGF5VGltZSk7XG4gICAgICAgIHRoaXMuc2V0UmF0ZSh0aGlzLnJhdGUpO1xuICAgIH1cblxuICAgIHZhciAkID0gQ2hvcnVzLnByb3RvdHlwZTtcblxuICAgIHZhciB3YXZlcyA9IFtdO1xuICAgIHdhdmVzWzBdID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2F2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoNTEyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MTI7ICsraSkge1xuICAgICAgICAgICAgd2F2ZVtpXSA9IE1hdGguc2luKDIgKiBNYXRoLlBJICogKGkvNTEyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhdmU7XG4gICAgfSkoKTtcbiAgICB3YXZlc1sxXSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdhdmUgPSBuZXcgRmxvYXQzMkFycmF5KDUxMik7XG4gICAgICAgIGZvciAodmFyIHgsIGkgPSAwOyBpIDwgNTEyOyArK2kpIHtcbiAgICAgICAgICAgIHggPSAoaSAvIDUxMikgLSAwLjI1O1xuICAgICAgICAgICAgd2F2ZVtpXSA9IDEuMCAtIDQuMCAqIE1hdGguYWJzKE1hdGgucm91bmQoeCkgLSB4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F2ZTtcbiAgICB9KSgpO1xuXG4gICAgJC5zZXRXYXZlVHlwZSA9IGZ1bmN0aW9uKHdhdmVUeXBlKSB7XG4gICAgICAgIGlmICh3YXZlVHlwZSA9PT0gXCJzaW5cIikge1xuICAgICAgICAgICAgdGhpcy53YXZlID0gd2F2ZVR5cGU7XG4gICAgICAgICAgICB0aGlzLl93YXZlID0gd2F2ZXNbMF07XG4gICAgICAgIH0gZWxzZSBpZiAod2F2ZVR5cGUgPT09IFwidHJpXCIpIHtcbiAgICAgICAgICAgIHRoaXMud2F2ZSA9IHdhdmVUeXBlO1xuICAgICAgICAgICAgdGhpcy5fd2F2ZSA9IHdhdmVzWzFdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuc2V0RGVsYXlUaW1lID0gZnVuY3Rpb24oZGVsYXlUaW1lKSB7XG4gICAgICAgIHRoaXMuZGVsYXlUaW1lID0gZGVsYXlUaW1lO1xuICAgICAgICB2YXIgcmVhZEluZGV4ID0gdGhpcy53cml0ZUluZGV4IC0gKChkZWxheVRpbWUgKiB0aGlzLnNhbXBsZXJhdGUgKiAwLjAwMSl8MCk7XG4gICAgICAgIHdoaWxlIChyZWFkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZWFkSW5kZXggKz0gdGhpcy5idWZmZXJzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZEluZGV4ID0gcmVhZEluZGV4O1xuICAgIH07XG5cbiAgICAkLnNldFJhdGUgPSBmdW5jdGlvbihyYXRlKSB7XG4gICAgICAgIHRoaXMucmF0ZSAgICAgID0gcmF0ZTtcbiAgICAgICAgdGhpcy5waGFzZUluY3IgPSAoNTEyICogdGhpcy5yYXRlIC8gdGhpcy5zYW1wbGVyYXRlKSAqIHRoaXMucGhhc2VTdGVwO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbihjZWxsTCwgY2VsbFIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlckwgPSB0aGlzLmJ1ZmZlckw7XG4gICAgICAgIHZhciBidWZmZXJSID0gdGhpcy5idWZmZXJSO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuYnVmZmVyc2l6ZTtcbiAgICAgICAgdmFyIG1hc2sgPSBzaXplIC0gMTtcbiAgICAgICAgdmFyIHdhdmUgICAgICAgPSB0aGlzLl93YXZlO1xuICAgICAgICB2YXIgcGhhc2UgICAgICA9IHRoaXMucGhhc2U7XG4gICAgICAgIHZhciBwaGFzZUluY3IgID0gdGhpcy5waGFzZUluY3I7XG4gICAgICAgIHZhciB3cml0ZUluZGV4ID0gdGhpcy53cml0ZUluZGV4O1xuICAgICAgICB2YXIgcmVhZEluZGV4ICA9IHRoaXMucmVhZEluZGV4O1xuICAgICAgICB2YXIgZGVwdGggICAgICA9IHRoaXMuZGVwdGg7XG4gICAgICAgIHZhciBmZWVkYmFjayAgID0gdGhpcy5mZWVkYmFjaztcbiAgICAgICAgdmFyIHgsIGluZGV4LCBtb2Q7XG4gICAgICAgIHZhciB3ZXQgPSB0aGlzLndldCwgZHJ5ID0gMSAtIHdldDtcbiAgICAgICAgdmFyIGksIGltYXggPSBjZWxsTC5sZW5ndGg7XG4gICAgICAgIHZhciBqLCBqbWF4ID0gdGhpcy5waGFzZVN0ZXA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICkge1xuICAgICAgICAgICAgbW9kID0gd2F2ZVtwaGFzZXwwXSAqIGRlcHRoO1xuICAgICAgICAgICAgcGhhc2UgKz0gcGhhc2VJbmNyO1xuICAgICAgICAgICAgd2hpbGUgKHBoYXNlID4gNTEyKSB7XG4gICAgICAgICAgICAgICAgcGhhc2UgLT0gNTEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGptYXg7ICsraiwgKytpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAocmVhZEluZGV4ICsgc2l6ZSArIG1vZCkgJiBtYXNrO1xuXG4gICAgICAgICAgICAgICAgeCA9IChidWZmZXJMW2luZGV4XSArIGJ1ZmZlckxbaW5kZXggKyAxXSkgKiAwLjU7XG4gICAgICAgICAgICAgICAgYnVmZmVyTFt3cml0ZUluZGV4XSA9IGNlbGxMW2ldIC0geCAqIGZlZWRiYWNrO1xuICAgICAgICAgICAgICAgIGNlbGxMW2ldID0gKGNlbGxMW2ldICogZHJ5KSArICh4ICogd2V0KTtcblxuICAgICAgICAgICAgICAgIHggPSAoYnVmZmVyUltpbmRleF0gKyBidWZmZXJSW2luZGV4ICsgMV0pICogMC41O1xuICAgICAgICAgICAgICAgIGJ1ZmZlclJbd3JpdGVJbmRleF0gPSBjZWxsUltpXSAtIHggKiBmZWVkYmFjaztcbiAgICAgICAgICAgICAgICBjZWxsUltpXSA9IChjZWxsUltpXSAqIGRyeSkgKyAoeCAqIHdldCk7XG5cbiAgICAgICAgICAgICAgICB3cml0ZUluZGV4ID0gKHdyaXRlSW5kZXggKyAxKSAmIG1hc2s7XG4gICAgICAgICAgICAgICAgcmVhZEluZGV4ICA9IChyZWFkSW5kZXggICsgMSkgJiBtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICAgICAgICB0aGlzLndyaXRlSW5kZXggPSB3cml0ZUluZGV4O1xuICAgICAgICB0aGlzLnJlYWRJbmRleCAgPSByZWFkSW5kZXg7XG4gICAgfTtcblxuICAgIFQubW9kdWxlcy5DaG9ydXMgPSBDaG9ydXM7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIE1heFByZURlbGF5RnJhbWVzICAgICA9IDEwMjQ7XG4gICAgdmFyIE1heFByZURlbGF5RnJhbWVzTWFzayA9IE1heFByZURlbGF5RnJhbWVzIC0gMTtcbiAgICB2YXIgRGVmYXVsdFByZURlbGF5RnJhbWVzID0gMjU2O1xuICAgIHZhciBrU3BhY2luZ0RiID0gNTtcblxuICAgIGZ1bmN0aW9uIENvbXByZXNzb3Ioc2FtcGxlcmF0ZSwgY2hhbm5lbHMpIHtcbiAgICAgICAgdGhpcy5zYW1wbGVyYXRlID0gc2FtcGxlcmF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IGNoYW5uZWxzO1xuXG4gICAgICAgIHRoaXMubGFzdFByZURlbGF5RnJhbWVzID0gMDtcbiAgICAgICAgdGhpcy5wcmVEZWxheVJlYWRJbmRleCAgPSAwO1xuICAgICAgICB0aGlzLnByZURlbGF5V3JpdGVJbmRleCA9IERlZmF1bHRQcmVEZWxheUZyYW1lcztcbiAgICAgICAgdGhpcy5yYXRpbyAgICAgICA9IC0xO1xuICAgICAgICB0aGlzLnNsb3BlICAgICAgID0gLTE7XG4gICAgICAgIHRoaXMubGluZWFyVGhyZXNob2xkID0gLTE7XG4gICAgICAgIHRoaXMuZGJUaHJlc2hvbGQgPSAtMTtcbiAgICAgICAgdGhpcy5kYktuZWUgICAgICA9IC0xO1xuICAgICAgICB0aGlzLmtuZWVUaHJlc2hvbGQgICAgPSAtMTtcbiAgICAgICAgdGhpcy5rbmVlVGhyZXNob2xkRGIgID0gLTE7XG4gICAgICAgIHRoaXMueWtuZWVUaHJlc2hvbGREYiA9IC0xO1xuICAgICAgICB0aGlzLksgPSAtMTtcblxuICAgICAgICB0aGlzLmF0dGFja1RpbWUgID0gMC4wMDM7XG4gICAgICAgIHRoaXMucmVsZWFzZVRpbWUgPSAwLjI1O1xuXG4gICAgICAgIHRoaXMucHJlRGVsYXlUaW1lID0gMC4wMDY7XG4gICAgICAgIHRoaXMuZGJQb3N0R2FpbiAgID0gMDtcbiAgICAgICAgdGhpcy5lZmZlY3RCbGVuZCAgPSAxO1xuICAgICAgICB0aGlzLnJlbGVhc2Vab25lMSA9IDAuMDk7XG4gICAgICAgIHRoaXMucmVsZWFzZVpvbmUyID0gMC4xNjtcbiAgICAgICAgdGhpcy5yZWxlYXNlWm9uZTMgPSAwLjQyO1xuICAgICAgICB0aGlzLnJlbGVhc2Vab25lNCA9IDAuOTg7XG5cbiAgICAgICAgdGhpcy5kZXRlY3RvckF2ZXJhZ2UgPSAwO1xuICAgICAgICB0aGlzLmNvbXByZXNzb3JHYWluICA9IDE7XG4gICAgICAgIHRoaXMubWV0ZXJpbmdHYWluICAgID0gMTtcblxuICAgICAgICB0aGlzLmRlbGF5QnVmZmVyTCA9IG5ldyBULmZuLlNpZ25hbEFycmF5KE1heFByZURlbGF5RnJhbWVzKTtcbiAgICAgICAgaWYgKGNoYW5uZWxzID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5QnVmZmVyUiA9IG5ldyBULmZuLlNpZ25hbEFycmF5KE1heFByZURlbGF5RnJhbWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlCdWZmZXJSID0gdGhpcy5kZWxheUJ1ZmZlckw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVEZWxheVRpbWUgPSA2O1xuICAgICAgICB0aGlzLnByZURlbGF5UmVhZEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wcmVEZWxheVdyaXRlSW5kZXggPSBEZWZhdWx0UHJlRGVsYXlGcmFtZXM7XG4gICAgICAgIHRoaXMubWF4QXR0YWNrQ29tcHJlc3Npb25EaWZmRGIgPSAtMTtcbiAgICAgICAgdGhpcy5tZXRlcmluZ1JlbGVhc2VLID0gMSAtIE1hdGguZXhwKC0xIC8gKHRoaXMuc2FtcGxlcmF0ZSAqIDAuMzI1KSk7XG5cbiAgICAgICAgdGhpcy5zZXRBdHRhY2tUaW1lKHRoaXMuYXR0YWNrVGltZSk7XG4gICAgICAgIHRoaXMuc2V0UmVsZWFzZVRpbWUodGhpcy5yZWxlYXNlVGltZSk7XG4gICAgICAgIHRoaXMuc2V0UHJlRGVsYXlUaW1lKHRoaXMucHJlRGVsYXlUaW1lKTtcbiAgICAgICAgdGhpcy5zZXRQYXJhbXMoLTI0LCAzMCwgMTIpO1xuICAgIH1cblxuICAgIHZhciAkID0gQ29tcHJlc3Nvci5wcm90b3R5cGU7XG5cbiAgICAkLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdfaW5zdGFuY2UgPSBuZXcgQ29tcHJlc3Nvcih0aGlzLnNhbXBsZXJhdGUsIHRoaXMuY2hhbm5lbHMpO1xuICAgICAgICBuZXdfaW5zdGFuY2Uuc2V0QXR0YWNrVGltZSh0aGlzLmF0dGFja1RpbWUpO1xuICAgICAgICBuZXdfaW5zdGFuY2Uuc2V0UmVsZWFzZVRpbWUodGhpcy5yZWxlYXNlVGltZSk7XG4gICAgICAgIG5ld19pbnN0YW5jZS5zZXRQcmVEZWxheVRpbWUodGhpcy5wcmVEZWxheVRpbWUpO1xuICAgICAgICBuZXdfaW5zdGFuY2Uuc2V0UGFyYW1zKHRoaXMuZGJUaHJlc2hvbGQsIHRoaXMuZGJLbmVlLCB0aGlzLnJhdGlvKTtcbiAgICAgICAgcmV0dXJuIG5ld19pbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgJC5zZXRBdHRhY2tUaW1lID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5hdHRhY2tUaW1lID0gTWF0aC5tYXgoMC4wMDEsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fYXR0YWNrRnJhbWVzID0gdGhpcy5hdHRhY2tUaW1lICogdGhpcy5zYW1wbGVyYXRlO1xuICAgIH07XG5cbiAgICAkLnNldFJlbGVhc2VUaW1lID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZWxlYXNlVGltZSA9IE1hdGgubWF4KDAuMDAxLCB2YWx1ZSk7XG4gICAgICAgIHZhciByZWxlYXNlRnJhbWVzID0gdGhpcy5yZWxlYXNlVGltZSAqIHRoaXMuc2FtcGxlcmF0ZTtcblxuICAgICAgICB2YXIgc2F0UmVsZWFzZVRpbWUgPSAwLjAwMjU7XG4gICAgICAgIHRoaXMuX3NhdFJlbGVhc2VGcmFtZXMgPSBzYXRSZWxlYXNlVGltZSAqIHRoaXMuc2FtcGxlcmF0ZTtcblxuICAgICAgICB2YXIgeTEgPSByZWxlYXNlRnJhbWVzICogdGhpcy5yZWxlYXNlWm9uZTE7XG4gICAgICAgIHZhciB5MiA9IHJlbGVhc2VGcmFtZXMgKiB0aGlzLnJlbGVhc2Vab25lMjtcbiAgICAgICAgdmFyIHkzID0gcmVsZWFzZUZyYW1lcyAqIHRoaXMucmVsZWFzZVpvbmUzO1xuICAgICAgICB2YXIgeTQgPSByZWxlYXNlRnJhbWVzICogdGhpcy5yZWxlYXNlWm9uZTQ7XG5cbiAgICAgICAgdGhpcy5fa0EgPSAwLjk5OTk5OTk5OTk5OTk5OTgqeTEgKyAxLjg0MzIyMTk2ODQzMjM5MjNlLTE2KnkyIC0gMS45MzczMzk0MzUxNjc2NDIzZS0xNip5MyArIDguODI0NTE2MDExODE2MjQ1ZS0xOCp5NDtcbiAgICAgICAgdGhpcy5fa0IgPSAtMS41Nzg4MzIwMzUyODQ1ODg4KnkxICsgMi4zMzA1ODM3MDMyMDc0Mjg2KnkyIC0gMC45MTQxMTk0MjA0ODQwNDI5KnkzICsgMC4xNjIzNjc3NTI1NjEyMDMyKnk0O1xuICAgICAgICB0aGlzLl9rQyA9IDAuNTMzNDE0Mjg2OTEwNjQyNCp5MSAtIDEuMjcyNzM2Nzg5MjEzNjMxKnkyICsgMC45MjU4ODU2MDQyMjA3NTEyKnkzIC0gMC4xODY1NjMxMDE5MTc3NjIyNip5NDtcbiAgICAgICAgdGhpcy5fa0QgPSAwLjA4NzgzNDYzMTM4MjA3MjM0KnkxIC0gMC4xNjk0MTYyOTY3OTI1NjIyKnkyICsgMC4wODU4ODA1Nzk1MTU5NTI3Mip5MyAtIDAuMDA0Mjk4OTE0MTA1NDYyODMqeTQ7XG4gICAgICAgIHRoaXMuX2tFID0gLTAuMDQyNDE2ODgzMDA4MTIzMDc0KnkxICsgMC4xMTE1NjkzODI3OTg3NjAyKnkyIC0gMC4wOTc2NDY3NjMyNTI2NTg3Mip5MyArIDAuMDI4NDk0MjYzNDYyMDIxNTc2Knk0O1xuICAgIH07XG5cbiAgICAkLnNldFByZURlbGF5VGltZSA9IGZ1bmN0aW9uKHByZURlbGF5VGltZSkge1xuICAgICAgICB0aGlzLnByZURlbGF5VGltZSA9IHByZURlbGF5VGltZTtcbiAgICAgICAgdmFyIHByZURlbGF5RnJhbWVzID0gcHJlRGVsYXlUaW1lICogdGhpcy5zYW1wbGVyYXRlO1xuICAgICAgICBpZiAocHJlRGVsYXlGcmFtZXMgPiBNYXhQcmVEZWxheUZyYW1lcyAtIDEpIHtcbiAgICAgICAgICAgIHByZURlbGF5RnJhbWVzID0gTWF4UHJlRGVsYXlGcmFtZXMgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxhc3RQcmVEZWxheUZyYW1lcyAhPT0gcHJlRGVsYXlGcmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFByZURlbGF5RnJhbWVzID0gcHJlRGVsYXlGcmFtZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IHRoaXMuZGVsYXlCdWZmZXJMLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlCdWZmZXJMW2ldID0gdGhpcy5kZWxheUJ1ZmZlclJbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmVEZWxheVJlYWRJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLnByZURlbGF5V3JpdGVJbmRleCA9IHByZURlbGF5RnJhbWVzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuc2V0UGFyYW1zID0gZnVuY3Rpb24oZGJUaHJlc2hvbGQsIGRiS25lZSwgcmF0aW8pIHtcbiAgICAgICAgdGhpcy5fayA9IHRoaXMudXBkYXRlU3RhdGljQ3VydmVQYXJhbWV0ZXJzKGRiVGhyZXNob2xkLCBkYktuZWUsIHJhdGlvKTtcblxuICAgICAgICB2YXIgZnVsbFJhbmdlR2FpbiA9IHRoaXMuc2F0dXJhdGUoMSwgdGhpcy5fayk7XG4gICAgICAgIHZhciBmdWxsUmFuZ2VNYWtldXBHYWluID0gMSAvIGZ1bGxSYW5nZUdhaW47XG5cbiAgICAgICAgZnVsbFJhbmdlTWFrZXVwR2FpbiA9IE1hdGgucG93KGZ1bGxSYW5nZU1ha2V1cEdhaW4sIDAuNik7XG5cbiAgICAgICAgdGhpcy5fbWFzdGVyTGluZWFyR2FpbiA9IE1hdGgucG93KDEwLCAwLjA1ICogdGhpcy5kYlBvc3RHYWluKSAqIGZ1bGxSYW5nZU1ha2V1cEdhaW47XG4gICAgfTtcblxuICAgICQua25lZUN1cnZlID0gZnVuY3Rpb24oeCwgaykge1xuICAgICAgICBpZiAoeCA8IHRoaXMubGluZWFyVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saW5lYXJUaHJlc2hvbGQgKyAoMSAtIE1hdGguZXhwKC1rICogKHggLSB0aGlzLmxpbmVhclRocmVzaG9sZCkpKSAvIGs7XG4gICAgfTtcblxuICAgICQuc2F0dXJhdGUgPSBmdW5jdGlvbih4LCBrKSB7XG4gICAgICAgIHZhciB5O1xuICAgICAgICBpZiAoeCA8IHRoaXMua25lZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgeSA9IHRoaXMua25lZUN1cnZlKHgsIGspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHhEYiA9ICh4KSA/IDIwICogTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRSA6IC0xMDAwO1xuICAgICAgICAgICAgdmFyIHlEYiA9IHRoaXMueWtuZWVUaHJlc2hvbGREYiArIHRoaXMuc2xvcGUgKiAoeERiIC0gdGhpcy5rbmVlVGhyZXNob2xkRGIpO1xuICAgICAgICAgICAgeSA9IE1hdGgucG93KDEwLCAwLjA1ICogeURiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuXG4gICAgJC5zbG9wZUF0ID0gZnVuY3Rpb24oeCwgaykge1xuICAgICAgICBpZiAoeCA8IHRoaXMubGluZWFyVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MiAgID0geCAqIDEuMDAxO1xuICAgICAgICB2YXIgeERiICA9ICh4ICkgPyAyMCAqIE1hdGgubG9nKHggKSAqIE1hdGguTE9HMTBFIDogLTEwMDA7XG4gICAgICAgIHZhciB4MkRiID0gKHgyKSA/IDIwICogTWF0aC5sb2coeDIpICogTWF0aC5MT0cxMEUgOiAtMTAwMDtcbiAgICAgICAgdmFyIHkgID0gdGhpcy5rbmVlQ3VydmUoeCAsIGspO1xuICAgICAgICB2YXIgeTIgPSB0aGlzLmtuZWVDdXJ2ZSh4Miwgayk7XG4gICAgICAgIHZhciB5RGIgID0gKHkgKSA/IDIwICogTWF0aC5sb2coeSApICogTWF0aC5MT0cxMEUgOiAtMTAwMDtcbiAgICAgICAgdmFyIHkyRGIgPSAoeTIpID8gMjAgKiBNYXRoLmxvZyh5MikgKiBNYXRoLkxPRzEwRSA6IC0xMDAwO1xuXG4gICAgICAgIHJldHVybiAoeTJEYiAtIHlEYikgLyAoeDJEYiAtIHhEYik7XG4gICAgfTtcblxuICAgICQua0F0U2xvcGUgPSBmdW5jdGlvbihkZXNpcmVkU2xvcGUpIHtcbiAgICAgICAgdmFyIHhEYiA9IHRoaXMuZGJUaHJlc2hvbGQgKyB0aGlzLmRiS25lZTtcbiAgICAgICAgdmFyIHggICA9IE1hdGgucG93KDEwLCAwLjA1ICogeERiKTtcblxuICAgICAgICB2YXIgbWluSyA9IDAuMTtcbiAgICAgICAgdmFyIG1heEsgPSAxMDAwMDtcbiAgICAgICAgdmFyIGsgPSA1O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNsb3BlID0gdGhpcy5zbG9wZUF0KHgsIGspO1xuICAgICAgICAgICAgaWYgKHNsb3BlIDwgZGVzaXJlZFNsb3BlKSB7XG4gICAgICAgICAgICAgICAgbWF4SyA9IGs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbksgPSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayA9IE1hdGguc3FydChtaW5LICogbWF4Syk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGs7XG4gICAgfTtcblxuICAgICQudXBkYXRlU3RhdGljQ3VydmVQYXJhbWV0ZXJzID0gZnVuY3Rpb24oZGJUaHJlc2hvbGQsIGRiS25lZSwgcmF0aW8pIHtcbiAgICAgICAgdGhpcy5kYlRocmVzaG9sZCAgICAgPSBkYlRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5saW5lYXJUaHJlc2hvbGQgPSBNYXRoLnBvdygxMCwgMC4wNSAqIGRiVGhyZXNob2xkKTtcbiAgICAgICAgdGhpcy5kYktuZWUgICAgICAgICAgPSBkYktuZWU7XG5cbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvO1xuICAgICAgICB0aGlzLnNsb3BlID0gMSAvIHRoaXMucmF0aW87XG5cbiAgICAgICAgdGhpcy5rbmVlVGhyZXNob2xkRGIgPSBkYlRocmVzaG9sZCArIGRiS25lZTtcbiAgICAgICAgdGhpcy5rbmVlVGhyZXNob2xkICAgPSBNYXRoLnBvdygxMCwgMC4wNSAqIHRoaXMua25lZVRocmVzaG9sZERiKTtcblxuICAgICAgICB2YXIgayA9IHRoaXMua0F0U2xvcGUoMSAvIHRoaXMucmF0aW8pO1xuICAgICAgICB2YXIgeSA9IHRoaXMua25lZUN1cnZlKHRoaXMua25lZVRocmVzaG9sZCwgayk7XG4gICAgICAgIHRoaXMueWtuZWVUaHJlc2hvbGREYiA9ICh5KSA/IDIwICogTWF0aC5sb2coeSkgKiBNYXRoLkxPRzEwRSA6IC0xMDAwO1xuXG4gICAgICAgIHRoaXMuX2sgPSBrO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9rO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbihjZWxsTCwgY2VsbFIpIHtcbiAgICAgICAgdmFyIGRyeU1peCA9IDEgLSB0aGlzLmVmZmVjdEJsZW5kO1xuICAgICAgICB2YXIgd2V0TWl4ID0gdGhpcy5lZmZlY3RCbGVuZDtcbiAgICAgICAgdmFyIGsgPSB0aGlzLl9rO1xuICAgICAgICB2YXIgbWFzdGVyTGluZWFyR2FpbiA9IHRoaXMuX21hc3RlckxpbmVhckdhaW47XG4gICAgICAgIHZhciBzYXRSZWxlYXNlRnJhbWVzID0gdGhpcy5fc2F0UmVsZWFzZUZyYW1lcztcbiAgICAgICAgdmFyIGtBID0gdGhpcy5fa0E7XG4gICAgICAgIHZhciBrQiA9IHRoaXMuX2tCO1xuICAgICAgICB2YXIga0MgPSB0aGlzLl9rQztcbiAgICAgICAgdmFyIGtEID0gdGhpcy5fa0Q7XG4gICAgICAgIHZhciBrRSA9IHRoaXMuX2tFO1xuICAgICAgICB2YXIgbkRpdmlzaW9uRnJhbWVzID0gNjQ7XG4gICAgICAgIHZhciBuRGl2aXNpb25zID0gY2VsbEwubGVuZ3RoIC8gbkRpdmlzaW9uRnJhbWVzO1xuICAgICAgICB2YXIgZnJhbWVJbmRleCA9IDA7XG4gICAgICAgIHZhciBkZXNpcmVkR2FpbiA9IHRoaXMuZGV0ZWN0b3JBdmVyYWdlO1xuICAgICAgICB2YXIgY29tcHJlc3NvckdhaW4gPSB0aGlzLmNvbXByZXNzb3JHYWluO1xuICAgICAgICB2YXIgbWF4QXR0YWNrQ29tcHJlc3Npb25EaWZmRGIgPSB0aGlzLm1heEF0dGFja0NvbXByZXNzaW9uRGlmZkRiO1xuICAgICAgICB2YXIgaV9hdHRhY2tGcmFtZXMgPSAxIC8gdGhpcy5fYXR0YWNrRnJhbWVzO1xuICAgICAgICB2YXIgcHJlRGVsYXlSZWFkSW5kZXggPSB0aGlzLnByZURlbGF5UmVhZEluZGV4O1xuICAgICAgICB2YXIgcHJlRGVsYXlXcml0ZUluZGV4ID0gdGhpcy5wcmVEZWxheVdyaXRlSW5kZXg7XG4gICAgICAgIHZhciBkZXRlY3RvckF2ZXJhZ2UgPSB0aGlzLmRldGVjdG9yQXZlcmFnZTtcbiAgICAgICAgdmFyIGRlbGF5QnVmZmVyTCA9IHRoaXMuZGVsYXlCdWZmZXJMO1xuICAgICAgICB2YXIgZGVsYXlCdWZmZXJSID0gdGhpcy5kZWxheUJ1ZmZlclI7XG4gICAgICAgIHZhciBtZXRlcmluZ0dhaW4gPSB0aGlzLm1ldGVyaW5nR2FpbjtcbiAgICAgICAgdmFyIG1ldGVyaW5nUmVsZWFzZUsgPSB0aGlzLm1ldGVyaW5nUmVsZWFzZUs7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuRGl2aXNpb25zOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZWREZXNpcmVkR2FpbiA9IE1hdGguYXNpbihkZXNpcmVkR2FpbikgLyAoMC41ICogTWF0aC5QSSk7XG4gICAgICAgICAgICB2YXIgZW52ZWxvcGVSYXRlO1xuICAgICAgICAgICAgdmFyIGlzUmVsZWFzaW5nID0gc2NhbGVkRGVzaXJlZEdhaW4gPiBjb21wcmVzc29yR2FpbjtcbiAgICAgICAgICAgIHZhciB4ID0gY29tcHJlc3NvckdhaW4gLyBzY2FsZWREZXNpcmVkR2FpbjtcblxuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uRGlmZkRiID0gKHgpID8gMjAgKiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFIDogLTEwMDA7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Npb25EaWZmRGIgPT09IEluZmluaXR5IHx8IGlzTmFOKGNvbXByZXNzaW9uRGlmZkRiKSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uRGlmZkRiID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1JlbGVhc2luZykge1xuICAgICAgICAgICAgICAgIG1heEF0dGFja0NvbXByZXNzaW9uRGlmZkRiID0gLTE7XG5cbiAgICAgICAgICAgICAgICB4ID0gY29tcHJlc3Npb25EaWZmRGI7XG4gICAgICAgICAgICAgICAgaWYgKHggPCAtMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gMC4yNSAqICh4ICsgMTIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB4MiA9IHggKiB4O1xuICAgICAgICAgICAgICAgIHZhciB4MyA9IHgyICogeDtcbiAgICAgICAgICAgICAgICB2YXIgeDQgPSB4MiAqIHgyO1xuICAgICAgICAgICAgICAgIHZhciBfcmVsZWFzZUZyYW1lcyA9IGtBICsga0IgKiB4ICsga0MgKiB4MiArIGtEICogeDMgKyBrRSAqIHg0O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9kYlBlckZyYW1lID0ga1NwYWNpbmdEYiAvIF9yZWxlYXNlRnJhbWVzO1xuXG4gICAgICAgICAgICAgICAgZW52ZWxvcGVSYXRlID0gTWF0aC5wb3coMTAsIDAuMDUgKiBfZGJQZXJGcmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtYXhBdHRhY2tDb21wcmVzc2lvbkRpZmZEYiA9PT0gLTEgfHwgbWF4QXR0YWNrQ29tcHJlc3Npb25EaWZmRGIgPCBjb21wcmVzc2lvbkRpZmZEYikge1xuICAgICAgICAgICAgICAgICAgICBtYXhBdHRhY2tDb21wcmVzc2lvbkRpZmZEYiA9IGNvbXByZXNzaW9uRGlmZkRiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBlZmZBdHRlbkRpZmZEYiA9IE1hdGgubWF4KDAuNSwgbWF4QXR0YWNrQ29tcHJlc3Npb25EaWZmRGIpO1xuXG4gICAgICAgICAgICAgICAgeCA9IDAuMjUgLyBlZmZBdHRlbkRpZmZEYjtcbiAgICAgICAgICAgICAgICBlbnZlbG9wZVJhdGUgPSAxIC0gTWF0aC5wb3coeCwgaV9hdHRhY2tGcmFtZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbG9vcEZyYW1lcyA9IG5EaXZpc2lvbkZyYW1lcztcbiAgICAgICAgICAgIHdoaWxlIChsb29wRnJhbWVzLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcHJlc3NvcklucHV0ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciBhYnNVbmRlbGF5ZWRTb3VyY2UgPSAoY2VsbExbZnJhbWVJbmRleF0gKyBjZWxsUltmcmFtZUluZGV4XSkgKiAwLjU7XG4gICAgICAgICAgICAgICAgZGVsYXlCdWZmZXJMW3ByZURlbGF5V3JpdGVJbmRleF0gPSBjZWxsTFtmcmFtZUluZGV4XTtcbiAgICAgICAgICAgICAgICBkZWxheUJ1ZmZlclJbcHJlRGVsYXlXcml0ZUluZGV4XSA9IGNlbGxSW2ZyYW1lSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFic1VuZGVsYXllZFNvdXJjZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWJzVW5kZWxheWVkU291cmNlICo9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3NvcklucHV0IDwgYWJzVW5kZWxheWVkU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3JJbnB1dCA9IGFic1VuZGVsYXllZFNvdXJjZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYWJzSW5wdXQgPSBjb21wcmVzc29ySW5wdXQ7XG4gICAgICAgICAgICAgICAgaWYgKGFic0lucHV0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhYnNJbnB1dCAqPSAtMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc2hhcGVkSW5wdXQgPSB0aGlzLnNhdHVyYXRlKGFic0lucHV0LCBrKTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ZW51YXRpb24gPSBhYnNJbnB1dCA8PSAwLjAwMDEgPyAxIDogc2hhcGVkSW5wdXQgLyBhYnNJbnB1dDtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ZW51YXRpb25EYiA9IChhdHRlbnVhdGlvbikgPyAtMjAgKiBNYXRoLmxvZyhhdHRlbnVhdGlvbikgKiBNYXRoLkxPRzEwRSA6IDEwMDA7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVudWF0aW9uRGIgPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uRGIgPSAyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkYlBlckZyYW1lID0gYXR0ZW51YXRpb25EYiAvIHNhdFJlbGVhc2VGcmFtZXM7XG4gICAgICAgICAgICAgICAgdmFyIHNhdFJlbGVhc2VSYXRlID0gTWF0aC5wb3coMTAsIDAuMDUgKiBkYlBlckZyYW1lKSAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGlzUmVsZWFzZSA9IChhdHRlbnVhdGlvbiA+IGRldGVjdG9yQXZlcmFnZSk7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGUgPSBpc1JlbGVhc2UgPyBzYXRSZWxlYXNlUmF0ZSA6IDE7XG5cbiAgICAgICAgICAgICAgICBkZXRlY3RvckF2ZXJhZ2UgKz0gKGF0dGVudWF0aW9uIC0gZGV0ZWN0b3JBdmVyYWdlKSAqIHJhdGU7XG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdG9yQXZlcmFnZSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0b3JBdmVyYWdlID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZW52ZWxvcGVSYXRlIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yR2FpbiArPSAoc2NhbGVkRGVzaXJlZEdhaW4gLSBjb21wcmVzc29yR2FpbikgKiBlbnZlbG9wZVJhdGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NvckdhaW4gKj0gZW52ZWxvcGVSYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3NvckdhaW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yR2FpbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zdFdhcnBDb21wcmVzc29yR2FpbiA9IE1hdGguc2luKDAuNSAqIE1hdGguUEkgKiBjb21wcmVzc29yR2Fpbik7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsR2FpbiA9IGRyeU1peCArIHdldE1peCAqIG1hc3RlckxpbmVhckdhaW4gKiBwb3N0V2FycENvbXByZXNzb3JHYWluO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRiUmVhbEdhaW4gPSAyMCAqIE1hdGgubG9nKHBvc3RXYXJwQ29tcHJlc3NvckdhaW4pICogTWF0aC5MT0cxMEU7XG4gICAgICAgICAgICAgICAgaWYgKGRiUmVhbEdhaW4gPCBtZXRlcmluZ0dhaW4pICB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGVyaW5nR2FpbiA9IGRiUmVhbEdhaW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0ZXJpbmdHYWluICs9IChkYlJlYWxHYWluIC0gbWV0ZXJpbmdHYWluKSAqIG1ldGVyaW5nUmVsZWFzZUs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGxMW2ZyYW1lSW5kZXhdID0gZGVsYXlCdWZmZXJMW3ByZURlbGF5UmVhZEluZGV4XSAqIHRvdGFsR2FpbjtcbiAgICAgICAgICAgICAgICBjZWxsUltmcmFtZUluZGV4XSA9IGRlbGF5QnVmZmVyUltwcmVEZWxheVJlYWRJbmRleF0gKiB0b3RhbEdhaW47XG5cbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgcHJlRGVsYXlSZWFkSW5kZXggID0gKHByZURlbGF5UmVhZEluZGV4ICArIDEpICYgTWF4UHJlRGVsYXlGcmFtZXNNYXNrO1xuICAgICAgICAgICAgICAgIHByZURlbGF5V3JpdGVJbmRleCA9IChwcmVEZWxheVdyaXRlSW5kZXggKyAxKSAmIE1heFByZURlbGF5RnJhbWVzTWFzaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRldGVjdG9yQXZlcmFnZSA8IDFlLTYpIHtcbiAgICAgICAgICAgICAgICBkZXRlY3RvckF2ZXJhZ2UgPSAxZS02O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXByZXNzb3JHYWluIDwgMWUtNikge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3JHYWluID0gMWUtNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZURlbGF5UmVhZEluZGV4ICA9IHByZURlbGF5UmVhZEluZGV4O1xuICAgICAgICB0aGlzLnByZURlbGF5V3JpdGVJbmRleCA9IHByZURlbGF5V3JpdGVJbmRleDtcbiAgICAgICAgdGhpcy5kZXRlY3RvckF2ZXJhZ2UgICAgPSBkZXRlY3RvckF2ZXJhZ2U7XG4gICAgICAgIHRoaXMuY29tcHJlc3NvckdhaW4gPSBjb21wcmVzc29yR2FpbjtcbiAgICAgICAgdGhpcy5tYXhBdHRhY2tDb21wcmVzc2lvbkRpZmZEYiA9IG1heEF0dGFja0NvbXByZXNzaW9uRGlmZkRiO1xuICAgICAgICB0aGlzLm1ldGVyaW5nR2FpbiA9IG1ldGVyaW5nR2FpbjtcbiAgICB9O1xuXG4gICAgJC5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRldGVjdG9yQXZlcmFnZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcHJlc3NvckdhaW4gPSAxO1xuICAgICAgICB0aGlzLm1ldGVyaW5nR2FpbiA9IDE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSB0aGlzLmRlbGF5QnVmZmVyTC5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlCdWZmZXJMW2ldID0gdGhpcy5kZWxheUJ1ZmZlclJbaV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmVEZWxheVJlYWRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucHJlRGVsYXlXcml0ZUluZGV4ID0gRGVmYXVsdFByZURlbGF5RnJhbWVzO1xuXG4gICAgICAgIHRoaXMubWF4QXR0YWNrQ29tcHJlc3Npb25EaWZmRGIgPSAtMTtcbiAgICB9O1xuXG4gICAgVC5tb2R1bGVzLkNvbXByZXNzb3IgPSBDb21wcmVzc29yO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIERlY29kZXIoKSB7fVxuXG4gICAgRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3JjLCBvbmxvYWRlZG1ldGFkYXRhLCBvbmxvYWRlZGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgvXFwud2F2JC8udGVzdChzcmMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIud2F2X2RlY29kZShzcmMsIG9ubG9hZGVkbWV0YWRhdGEsIG9ubG9hZGVkZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKERlY29kZXIub2dnX2RlY29kZSAmJiAvXFwub2dnJC8udGVzdChzcmMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIub2dnX2RlY29kZShzcmMsIG9ubG9hZGVkbWV0YWRhdGEsIG9ubG9hZGVkZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKERlY29kZXIubXAzX2RlY29kZSAmJiAvXFwubXAzJC8udGVzdChzcmMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIubXAzX2RlY29kZShzcmMsIG9ubG9hZGVkbWV0YWRhdGEsIG9ubG9hZGVkZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHNyYy50eXBlID09PSBcIndhdlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIud2F2X2RlY29kZShzcmMuZGF0YSwgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoRGVjb2Rlci5vZ2dfZGVjb2RlICYmIHNyYy50eXBlID09PSBcIm9nZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIub2dnX2RlY29kZShzcmMuZGF0YSwgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoRGVjb2Rlci5tcDNfZGVjb2RlICYmIHNyYy50eXBlID09PSBcIm1wM1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIubXAzX2RlY29kZShzcmMuZGF0YSwgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoRGVjb2Rlci53ZWJraXRfZGVjb2RlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvZGVyLndlYmtpdF9kZWNvZGUoc3JjLmRhdGF8fHNyYywgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIud2Via2l0X2RlY29kZShzcmMsIG9ubG9hZGVkbWV0YWRhdGEsIG9ubG9hZGVkZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoRGVjb2Rlci5tb3pfZGVjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5tb3pfZGVjb2RlKHNyYywgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBvbmxvYWRlZG1ldGFkYXRhKGZhbHNlKTtcbiAgICB9O1xuICAgIFQubW9kdWxlcy5EZWNvZGVyID0gRGVjb2RlcjtcblxuICAgIGlmIChULmVudnR5cGUgPT09IFwiYnJvd3NlclwiKSB7XG4gICAgICAgIERlY29kZXIuZ2V0QmluYXJ5V2l0aFBhdGggPSBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgVC5mbi5maXhfaU9TNl8xX3Byb2JsZW0odHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIHBhdGgpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeGhyLnJlc3BvbnNlQm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKmdsb2JhbCBWQkFycmF5OnRydWUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBVaW50OEFycmF5KFZCQXJyYXkoeGhyLnJlc3BvbnNlQm9keSkudG9BcnJheSgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKmdsb2JhbCBWQkFycmF5OmZhbHNlICovXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgVC5mbi5maXhfaU9TNl8xX3Byb2JsZW0oZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIERlY29kZXIuZ2V0QmluYXJ5V2l0aFBhdGggPSBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soXCJubyBzdXBwb3J0XCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBfMjRiaXRfdG9fMzJiaXQgPSBmdW5jdGlvbih1aW50OCkge1xuICAgICAgICB2YXIgYjAsIGIxLCBiMiwgYmIsIHg7XG4gICAgICAgIHZhciBpbnQzMiA9IG5ldyBJbnQzMkFycmF5KHVpbnQ4Lmxlbmd0aCAvIDMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IHVpbnQ4Lmxlbmd0aCwgaiA9IDA7IGkgPCBpbWF4OyApIHtcbiAgICAgICAgICAgIGIwID0gdWludDhbaSsrXSAsYjEgPSB1aW50OFtpKytdLCBiMiA9IHVpbnQ4W2krK107XG4gICAgICAgICAgICBiYiA9IGIwICsgKGIxIDw8IDgpICsgKGIyIDw8IDE2KTtcbiAgICAgICAgICAgIHggPSAoYmIgJiAweDgwMDAwMCkgPyBiYiAtIDE2Nzc3MjE2IDogYmI7XG4gICAgICAgICAgICBpbnQzMltqKytdID0geDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50MzI7XG4gICAgfTtcblxuICAgIERlY29kZXIud2F2X2RlY29kZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9kZWNvZGUgPSBmdW5jdGlvbihkYXRhLCBvbmxvYWRlZG1ldGFkYXRhLCBvbmxvYWRlZGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10pICE9PSBcIlJJRkZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbmxvYWRlZG1ldGFkYXRhKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGwxID0gZGF0YVs0XSArIChkYXRhWzVdPDw4KSArIChkYXRhWzZdPDwxNikgKyAoZGF0YVs3XTw8MjQpO1xuICAgICAgICAgICAgaWYgKGwxICsgOCAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25sb2FkZWRtZXRhZGF0YShmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbOF0sIGRhdGFbOV0sIGRhdGFbMTBdLCBkYXRhWzExXSkgIT09IFwiV0FWRVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ubG9hZGVkbWV0YWRhdGEoZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzEyXSwgZGF0YVsxM10sIGRhdGFbMTRdLCBkYXRhWzE1XSkgIT09IFwiZm10IFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ubG9hZGVkbWV0YWRhdGEoZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hhbm5lbHMgICA9IGRhdGFbMjJdICsgKGRhdGFbMjNdPDw4KTtcbiAgICAgICAgICAgIHZhciBzYW1wbGVyYXRlID0gZGF0YVsyNF0gKyAoZGF0YVsyNV08PDgpICsgKGRhdGFbMjZdPDwxNikgKyAoZGF0YVsyN108PDI0KTtcbiAgICAgICAgICAgIHZhciBiaXRTaXplICAgID0gZGF0YVszNF0gKyAoZGF0YVszNV08PDgpO1xuXG4gICAgICAgICAgICB2YXIgaSA9IDM2O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0sIGRhdGFbaSsxXSwgZGF0YVtpKzJdLCBkYXRhW2krM10pID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25sb2FkZWRtZXRhZGF0YShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDQ7XG5cbiAgICAgICAgICAgIHZhciBsMiA9IGRhdGFbaV0gKyAoZGF0YVtpKzFdPDw4KSArIChkYXRhW2krMl08PDE2KSArIChkYXRhW2krM108PDI0KTtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9ICgobDIgLyBjaGFubmVscykgPj4gMSkgLyBzYW1wbGVyYXRlO1xuICAgICAgICAgICAgaSArPSA0O1xuXG4gICAgICAgICAgICBpZiAobDIgPiBkYXRhLmxlbmd0aCAtIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25sb2FkZWRtZXRhZGF0YShmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtaXhkb3duLCBidWZmZXJMLCBidWZmZXJSO1xuICAgICAgICAgICAgbWl4ZG93biA9IG5ldyBGbG9hdDMyQXJyYXkoKGR1cmF0aW9uICogc2FtcGxlcmF0ZSl8MCk7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbHMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJMID0gbmV3IEZsb2F0MzJBcnJheShtaXhkb3duLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyUiA9IG5ldyBGbG9hdDMyQXJyYXkobWl4ZG93bi5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbmxvYWRlZG1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICBzYW1wbGVyYXRlOiBzYW1wbGVyYXRlLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxzICA6IGNoYW5uZWxzLFxuICAgICAgICAgICAgICAgIGJ1ZmZlciAgICA6IFttaXhkb3duLCBidWZmZXJMLCBidWZmZXJSXSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiAgOiBkdXJhdGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChiaXRTaXplID09PSA4KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBJbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiaXRTaXplID09PSAxNikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgSW50MTZBcnJheShkYXRhLmJ1ZmZlciwgaSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJpdFNpemUgPT09IDMyKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBJbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYml0U2l6ZSA9PT0gMjQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gXzI0Yml0X3RvXzMyYml0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbWF4LCBqLCBrID0gMSAvICgoMSA8PCAoYml0U2l6ZS0xKSkgLSAxKSwgeDtcbiAgICAgICAgICAgIGlmIChjaGFubmVscyA9PT0gMikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCBpbWF4ID0gbWl4ZG93bi5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICBidWZmZXJMW2ldID0gZGF0YVtqKytdICogaztcbiAgICAgICAgICAgICAgICAgICAgeCArPSBidWZmZXJSW2ldID0gZGF0YVtqKytdICogaztcbiAgICAgICAgICAgICAgICAgICAgbWl4ZG93bltpXSA9IHggKiAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpbWF4ID0gbWl4ZG93bi5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbWl4ZG93bltpXSA9IGRhdGFbaV0gKiBrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25sb2FkZWRkYXRhKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNyYywgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIERlY29kZXIuZ2V0QmluYXJ5V2l0aFBhdGgoc3JjLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kZWNvZGUoZGF0YSwgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2RlY29kZShzcmMsIG9ubG9hZGVkbWV0YWRhdGEsIG9ubG9hZGVkZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIERlY29kZXIud2Via2l0X2RlY29kZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBULmZuLl9hdWRpb0NvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSBULmZuLl9hdWRpb0NvbnRleHQ7XG4gICAgICAgICAgICB2YXIgX2RlY29kZSA9IGZ1bmN0aW9uKGRhdGEsIG9ubG9hZGVkbWV0YWRhdGEsIG9ubG9hZGVkZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBzYW1wbGVyYXRlLCBjaGFubmVscywgYnVmZmVyTCwgYnVmZmVyUiwgZHVyYXRpb247XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ubG9hZGVkZGF0YShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBjdHguY3JlYXRlQnVmZmVyKGRhdGEuYnVmZmVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25sb2FkZWRtZXRhZGF0YShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2FtcGxlcmF0ZSA9IGN0eC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzICAgPSBidWZmZXIubnVtYmVyT2ZDaGFubmVscztcbiAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyTCA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUiA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJMID0gYnVmZmVyUiA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBidWZmZXJMLmxlbmd0aCAvIHNhbXBsZXJhdGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWl4ZG93biA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBtaXhkb3duLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBtaXhkb3duW2ldID0gKG1peGRvd25baV0gKyBidWZmZXJSW2ldKSAqIDAuNTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvbmxvYWRlZG1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcmF0ZTogc2FtcGxlcmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHMgIDogY2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciAgICA6IFttaXhkb3duLCBidWZmZXJMLCBidWZmZXJSXSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gIDogZHVyYXRpb25cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG9ubG9hZGVkZGF0YSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNyYywgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKSB7XG4gICAgICAgICAgICAgICAgLypnbG9iYWwgRmlsZTp0cnVlICovXG4gICAgICAgICAgICAgICAgaWYgKHNyYyBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVjb2RlKG5ldyBVaW50OEFycmF5KGUudGFyZ2V0LnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubG9hZGVkbWV0YWRhdGEsIG9ubG9hZGVkZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihzcmMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBEZWNvZGVyLmdldEJpbmFyeVdpdGhQYXRoKHNyYywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RlY29kZShkYXRhLCBvbmxvYWRlZG1ldGFkYXRhLCBvbmxvYWRlZGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZGVjb2RlKHNyYywgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypnbG9iYWwgRmlsZTpmYWxzZSAqL1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICBEZWNvZGVyLm1vel9kZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQXVkaW8gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgbmV3IEF1ZGlvKCkubW96U2V0dXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNyYywgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhbXBsZXJhdGUsIGNoYW5uZWxzLCBtaXhkb3duLCBidWZmZXJMLCBidWZmZXJSLCBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgd3JpdGVJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXVkaW8gPSBuZXcgQXVkaW8oc3JjKTtcbiAgICAgICAgICAgICAgICBhdWRpby52b2x1bWUgPSAwLjA7XG4gICAgICAgICAgICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyYXRlID0gYXVkaW8ubW96U2FtcGxlUmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHMgICA9IGF1ZGlvLm1vekNoYW5uZWxzO1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiAgID0gYXVkaW8uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIG1peGRvd24gPSBuZXcgRmxvYXQzMkFycmF5KChhdWRpby5kdXJhdGlvbiAqIHNhbXBsZXJhdGUpfDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckwgPSBuZXcgRmxvYXQzMkFycmF5KChhdWRpby5kdXJhdGlvbiAqIHNhbXBsZXJhdGUpfDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyUiA9IG5ldyBGbG9hdDMyQXJyYXkoKGF1ZGlvLmR1cmF0aW9uICogc2FtcGxlcmF0ZSl8MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKFwiTW96QXVkaW9BdmFpbGFibGVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4LCBzYW1wbGVzID0gZS5mcmFtZUJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IHNhbXBsZXMubGVuZ3RoOyBpIDwgaW1heDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSAgYnVmZmVyTFt3cml0ZUluZGV4XSA9IHNhbXBsZXNbaSAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBidWZmZXJSW3dyaXRlSW5kZXhdID0gc2FtcGxlc1tpKzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXhkb3duW3dyaXRlSW5kZXhdID0geCAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoXCJNb3pBdWRpb0F2YWlsYWJsZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhbXBsZXMgPSBlLmZyYW1lQnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbWF4ID0gc2FtcGxlcy5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWl4ZG93bltpXSA9IHNhbXBsZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXVkaW8ucGxheSgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25sb2FkZWRtZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlcmF0ZTogc2FtcGxlcmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVscyAgOiBjaGFubmVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgICAgOiBbbWl4ZG93biwgYnVmZmVyTCwgYnVmZmVyUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gIDogZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvbmxvYWRlZGRhdGEoKTtcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYXVkaW8ubG9hZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIEVudmVsb3BlKHNhbXBsZXJhdGUpIHtcbiAgICAgICAgdGhpcy5zYW1wbGVyYXRlID0gc2FtcGxlcmF0ZSB8fCA0NDEwMDtcbiAgICAgICAgdGhpcy52YWx1ZSAgPSBaRVJPO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFN0YXR1c1dhaXQ7XG4gICAgICAgIHRoaXMuY3VydmUgID0gXCJsaW5lYXJcIjtcbiAgICAgICAgdGhpcy5zdGVwICAgPSAxO1xuICAgICAgICB0aGlzLnJlbGVhc2VOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb29wTm9kZSAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZW52VmFsdWUgPSBuZXcgRW52ZWxvcGVWYWx1ZShzYW1wbGVyYXRlKTtcblxuICAgICAgICB0aGlzLl90YWJsZSAgPSBbXTtcbiAgICAgICAgdGhpcy5faW5pdFZhbHVlICA9IFpFUk87XG4gICAgICAgIHRoaXMuX2N1cnZlVmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl9kZWZhdWx0Q3VydmVUeXBlID0gQ3VydmVUeXBlTGluO1xuICAgICAgICB0aGlzLl9pbmRleCAgID0gMDtcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgfVxuXG4gICAgdmFyIFpFUk8gICAgICAgICAgID0gRW52ZWxvcGUuWkVSTyA9IDFlLTY7XG4gICAgdmFyIEN1cnZlVHlwZVNldCAgID0gRW52ZWxvcGUuQ3VydmVUeXBlU2V0ICAgPSAwO1xuICAgIHZhciBDdXJ2ZVR5cGVMaW4gICA9IEVudmVsb3BlLkN1cnZlVHlwZUxpbiAgID0gMTtcbiAgICB2YXIgQ3VydmVUeXBlRXhwICAgPSBFbnZlbG9wZS5DdXJ2ZVR5cGVFeHAgICA9IDI7XG4gICAgdmFyIEN1cnZlVHlwZVNpbiAgID0gRW52ZWxvcGUuQ3VydmVUeXBlU2luICAgPSAzO1xuICAgIHZhciBDdXJ2ZVR5cGVXZWwgICA9IEVudmVsb3BlLkN1cnZlVHlwZVdlbCAgID0gNDtcbiAgICB2YXIgQ3VydmVUeXBlQ3VydmUgPSBFbnZlbG9wZS5DdXJ2ZVR5cGVDdXJ2ZSA9IDU7XG4gICAgdmFyIEN1cnZlVHlwZVNxciAgID0gRW52ZWxvcGUuQ3VydmVUeXBlU3FyICAgPSA2O1xuICAgIHZhciBDdXJ2ZVR5cGVDdWIgICA9IEVudmVsb3BlLkN1cnZlVHlwZUN1YiAgID0gNztcblxuICAgIHZhciBTdGF0dXNXYWl0ICAgID0gRW52ZWxvcGUuU3RhdHVzV2FpdCAgICA9IDA7XG4gICAgdmFyIFN0YXR1c0dhdGUgICAgPSBFbnZlbG9wZS5TdGF0dXNHYXRlICAgID0gMTtcbiAgICB2YXIgU3RhdHVzU3VzdGFpbiA9IEVudmVsb3BlLlN0YXR1c1N1c3RhaW4gPSAyO1xuICAgIHZhciBTdGF0dXNSZWxlYXNlID0gRW52ZWxvcGUuU3RhdHVzUmVsZWFzZSA9IDM7XG4gICAgdmFyIFN0YXR1c0VuZCAgICAgPSBFbnZlbG9wZS5TdGF0dXNFbmQgICAgID0gNDtcblxuICAgIHZhciBDdXJ2ZVR5cGVEaWN0ID0ge1xuICAgICAgICBzZXQ6Q3VydmVUeXBlU2V0LFxuICAgICAgICBsaW46Q3VydmVUeXBlTGluLCBsaW5lYXIgICAgIDpDdXJ2ZVR5cGVMaW4sXG4gICAgICAgIGV4cDpDdXJ2ZVR5cGVFeHAsIGV4cG9uZW50aWFsOkN1cnZlVHlwZUV4cCxcbiAgICAgICAgc2luOkN1cnZlVHlwZVNpbiwgc2luZSAgICAgICA6Q3VydmVUeXBlU2luLFxuICAgICAgICB3ZWw6Q3VydmVUeXBlV2VsLCB3ZWxjaCAgICAgIDpDdXJ2ZVR5cGVXZWwsXG4gICAgICAgIHNxcjpDdXJ2ZVR5cGVTcXIsIHNxdWFyZWQgICAgOkN1cnZlVHlwZVNxcixcbiAgICAgICAgY3ViOkN1cnZlVHlwZUN1YiwgY3ViZWQgICAgICA6Q3VydmVUeXBlQ3ViXG4gICAgfTtcbiAgICBFbnZlbG9wZS5DdXJ2ZVR5cGVEaWN0ID0gQ3VydmVUeXBlRGljdDtcblxuICAgIHZhciAkID0gRW52ZWxvcGUucHJvdG90eXBlO1xuXG4gICAgJC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbmV3X2luc3RhbmNlID0gbmV3IEVudmVsb3BlKHRoaXMuc2FtcGxlcmF0ZSk7XG4gICAgICAgIG5ld19pbnN0YW5jZS5fdGFibGUgPSB0aGlzLl90YWJsZTtcbiAgICAgICAgbmV3X2luc3RhbmNlLl9pbml0VmFsdWUgPSB0aGlzLl9pbml0VmFsdWU7XG4gICAgICAgIG5ld19pbnN0YW5jZS5zZXRDdXJ2ZSh0aGlzLmN1cnZlKTtcbiAgICAgICAgaWYgKHRoaXMucmVsZWFzZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld19pbnN0YW5jZS5zZXRSZWxlYXNlTm9kZSh0aGlzLnJlbGVhc2VOb2RlICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9vcE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld19pbnN0YW5jZS5zZXRMb29wTm9kZSh0aGlzLmxvb3BOb2RlICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3X2luc3RhbmNlLnNldFN0ZXAodGhpcy5zdGVwKTtcbiAgICAgICAgbmV3X2luc3RhbmNlLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiBuZXdfaW5zdGFuY2U7XG4gICAgfTtcbiAgICAkLnNldFRhYmxlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5faW5pdFZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIHRoaXMuX3RhYmxlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9lbnZWYWx1ZS52YWx1ZSA9IHRoaXMuX2luaXRWYWx1ZTtcbiAgICAgICAgdGhpcy5faW5kZXggICA9IDA7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFN0YXR1c1dhaXQ7XG4gICAgfTtcbiAgICAkLnNldEN1cnZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikgIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRDdXJ2ZVR5cGUgPSBDdXJ2ZVR5cGVDdXJ2ZTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VydmUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRDdXJ2ZVR5cGUgPSBDdXJ2ZVR5cGVEaWN0W3ZhbHVlXSB8fCBudWxsO1xuICAgICAgICAgICAgdGhpcy5jdXJ2ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAkLnNldFJlbGVhc2VOb2RlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZU5vZGUgPSB2YWx1ZSAtIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgICQuc2V0TG9vcE5vZGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHZhbHVlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5sb29wTm9kZSA9IHZhbHVlIC0gMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgJC5zZXRTdGVwID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLl9lbnZWYWx1ZS5zdGVwID0gc3RlcDtcbiAgICB9O1xuICAgICQucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2VudlZhbHVlLnZhbHVlID0gdGhpcy5faW5pdFZhbHVlO1xuICAgICAgICB0aGlzLl9pbmRleCAgID0gMDtcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gU3RhdHVzV2FpdDtcbiAgICB9O1xuICAgICQucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZWxlYXNlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFN0YXR1c1JlbGVhc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgICQuZ2V0SW5mbyA9IGZ1bmN0aW9uKHN1c3RhaW5UaW1lKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMuX3RhYmxlO1xuICAgICAgICB2YXIgaSwgaW1heDtcbiAgICAgICAgdmFyIHRvdGFsRHVyYXRpb24gICAgPSAwO1xuICAgICAgICB2YXIgbG9vcEJlZ2luVGltZSAgICA9IEluZmluaXR5O1xuICAgICAgICB2YXIgcmVsZWFzZUJlZ2luVGltZSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgaXNFbmRsZXNzTG9vcCAgICA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwLCBpbWF4ID0gdGFibGUubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb29wTm9kZSA9PT0gaSkge1xuICAgICAgICAgICAgICAgIGxvb3BCZWdpblRpbWUgPSB0b3RhbER1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmVsZWFzZU5vZGUgPT09IGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG90YWxEdXJhdGlvbiA8IHN1c3RhaW5UaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsRHVyYXRpb24gKz0gc3VzdGFpblRpbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxEdXJhdGlvbiAgPSBzdXN0YWluVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVsZWFzZUJlZ2luVGltZSA9IHRvdGFsRHVyYXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRhYmxlW2ldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgdG90YWxEdXJhdGlvbiArPSBpdGVtc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9vcEJlZ2luVGltZSAhPT0gSW5maW5pdHkgJiYgcmVsZWFzZUJlZ2luVGltZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRvdGFsRHVyYXRpb24gKz0gc3VzdGFpblRpbWU7XG4gICAgICAgICAgICBpc0VuZGxlc3NMb29wID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3RhbER1cmF0aW9uICAgOiB0b3RhbER1cmF0aW9uLFxuICAgICAgICAgICAgbG9vcEJlZ2luVGltZSAgIDogbG9vcEJlZ2luVGltZSxcbiAgICAgICAgICAgIHJlbGVhc2VCZWdpblRpbWU6IHJlbGVhc2VCZWdpblRpbWUsXG4gICAgICAgICAgICBpc0VuZGxlc3NMb29wICAgOiBpc0VuZGxlc3NMb29wXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgICQuY2FsY1N0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhdHVzICA9IHRoaXMuc3RhdHVzO1xuICAgICAgICB2YXIgdGFibGUgICA9IHRoaXMuX3RhYmxlO1xuICAgICAgICB2YXIgaW5kZXggICA9IHRoaXMuX2luZGV4O1xuICAgICAgICB2YXIgY291bnRlciA9IHRoaXMuX2NvdW50ZXI7XG5cbiAgICAgICAgdmFyIGN1cnZlVmFsdWUgPSB0aGlzLl9jdXJ2ZVZhbHVlO1xuICAgICAgICB2YXIgZGVmYXVsdEN1cnZlVHlwZSA9IHRoaXMuX2RlZmF1bHRDdXJ2ZVR5cGU7XG4gICAgICAgIHZhciBsb29wTm9kZSAgICA9IHRoaXMubG9vcE5vZGU7XG4gICAgICAgIHZhciByZWxlYXNlTm9kZSA9IHRoaXMucmVsZWFzZU5vZGU7XG4gICAgICAgIHZhciBlbnZWYWx1ZSA9IHRoaXMuX2VudlZhbHVlO1xuICAgICAgICB2YXIgaXRlbXMsIGVuZFZhbHVlLCB0aW1lLCBjdXJ2ZVR5cGUsIGVtaXQgPSBudWxsO1xuXG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgU3RhdHVzV2FpdDpcbiAgICAgICAgY2FzZSBTdGF0dXNFbmQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF0dXNHYXRlOlxuICAgICAgICBjYXNlIFN0YXR1c1JlbGVhc2U6XG4gICAgICAgICAgICB3aGlsZSAoY291bnRlciA8PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHRhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBTdGF0dXNHYXRlICYmIGxvb3BOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGxvb3BOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzICAgID0gU3RhdHVzRW5kO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyICAgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgY3VydmVUeXBlID0gQ3VydmVUeXBlU2V0O1xuICAgICAgICAgICAgICAgICAgICBlbWl0ICAgICAgPSBcImVuZGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBTdGF0dXNHYXRlICYmIGluZGV4ID09PSByZWxlYXNlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9vcE5vZGUgIT09IG51bGwgJiYgbG9vcE5vZGUgPCByZWxlYXNlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBsb29wTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyAgICA9IFN0YXR1c1N1c3RhaW47XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXIgICA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJ2ZVR5cGUgPSBDdXJ2ZVR5cGVTZXQ7XG4gICAgICAgICAgICAgICAgICAgIGVtaXQgICAgICA9IFwic3VzdGFpbmVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtcyA9IHRhYmxlW2luZGV4KytdO1xuXG4gICAgICAgICAgICAgICAgZW5kVmFsdWUgPSBpdGVtc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXNbMl0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VydmVUeXBlID0gZGVmYXVsdEN1cnZlVHlwZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJ2ZVR5cGUgPSBpdGVtc1syXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnZlVHlwZSA9PT0gQ3VydmVUeXBlQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VydmVWYWx1ZSA9IGl0ZW1zWzNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoY3VydmVWYWx1ZSkgPCAwLjAwMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVUeXBlID0gQ3VydmVUeXBlTGluO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWUgPSBpdGVtc1sxXTtcblxuICAgICAgICAgICAgICAgIGNvdW50ZXIgPSBlbnZWYWx1ZS5zZXROZXh0KGVuZFZhbHVlLCB0aW1lLCBjdXJ2ZVR5cGUsIGN1cnZlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5lbWl0ICAgPSBlbWl0O1xuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9jb3VudGVyID0gY291bnRlcjtcblxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH07XG5cbiAgICAkLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsY1N0YXR1cygpICYgMSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSAgPSB0aGlzLl9lbnZWYWx1ZS5uZXh0KCkgfHwgWkVSTztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb3VudGVyIC09IDE7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIHZhciBlbnZWYWx1ZSA9IHRoaXMuX2VudlZhbHVlO1xuICAgICAgICB2YXIgaSwgaW1heCA9IGNlbGwubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbGNTdGF0dXMoKSAmIDEpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBjZWxsW2ldID0gZW52VmFsdWUubmV4dCgpIHx8IFpFUk87XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlIHx8IFpFUk87XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2VsbFtpXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBjZWxsW2ltYXgtMV07XG5cbiAgICAgICAgdGhpcy5fY291bnRlciAtPSBjZWxsLmxlbmd0aDtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBFbnZlbG9wZVZhbHVlKHNhbXBsZXJhdGUpIHtcbiAgICAgICAgdGhpcy5zYW1wbGVyYXRlID0gc2FtcGxlcmF0ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFpFUk87XG4gICAgICAgIHRoaXMuc3RlcCAgPSAxO1xuXG4gICAgICAgIHRoaXMuX2N1cnZlVHlwZSAgPSBDdXJ2ZVR5cGVMaW47XG4gICAgICAgIHRoaXMuX2N1cnZlVmFsdWUgPSAwO1xuXG4gICAgICAgIHRoaXMuX2dyb3cgPSAwO1xuXG4gICAgICAgIHRoaXMuX2EyID0gMDtcbiAgICAgICAgdGhpcy5fYjEgPSAwO1xuICAgICAgICB0aGlzLl95MSA9IDA7XG4gICAgICAgIHRoaXMuX3kyID0gMDtcbiAgICB9XG4gICAgRW52ZWxvcGVWYWx1ZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uKGVuZFZhbHVlLCB0aW1lLCBjdXJ2ZVR5cGUsIGN1cnZlVmFsdWUpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnN0ZXA7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBncm93LCB3LCBhMSwgYTIsIGIxLCB5MSwgeTI7XG5cbiAgICAgICAgdmFyIGNvdW50ZXIgPSAoKHRpbWUgKiAwLjAwMSAqIHRoaXMuc2FtcGxlcmF0ZSkgLyBuKXwwO1xuICAgICAgICBpZiAoY291bnRlciA8IDEpIHtcbiAgICAgICAgICAgIGNvdW50ZXIgICA9IDE7XG4gICAgICAgICAgICBjdXJ2ZVR5cGUgPSBDdXJ2ZVR5cGVTZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGN1cnZlVHlwZSkge1xuICAgICAgICBjYXNlIEN1cnZlVHlwZVNldDpcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBlbmRWYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEN1cnZlVHlwZUxpbjpcbiAgICAgICAgICAgIGdyb3cgPSAoZW5kVmFsdWUgLSB2YWx1ZSkgLyBjb3VudGVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ3VydmVUeXBlRXhwOlxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZ3JvdyA9IE1hdGgucG93KFxuICAgICAgICAgICAgICAgICAgICBlbmRWYWx1ZSAvIHZhbHVlLCAxIC8gY291bnRlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyb3cgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ3VydmVUeXBlU2luOlxuICAgICAgICAgICAgdyA9IE1hdGguUEkgLyBjb3VudGVyO1xuICAgICAgICAgICAgYTIgPSAoZW5kVmFsdWUgKyB2YWx1ZSkgKiAwLjU7XG4gICAgICAgICAgICBiMSA9IDIgKiBNYXRoLmNvcyh3KTtcbiAgICAgICAgICAgIHkxID0gKGVuZFZhbHVlIC0gdmFsdWUpICogMC41O1xuICAgICAgICAgICAgeTIgPSB5MSAqIE1hdGguc2luKE1hdGguUEkgKiAwLjUgLSB3KTtcbiAgICAgICAgICAgIHZhbHVlID0gYTIgLSB5MTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEN1cnZlVHlwZVdlbDpcbiAgICAgICAgICAgIHcgPSAoTWF0aC5QSSAqIDAuNSkgLyBjb3VudGVyO1xuICAgICAgICAgICAgYjEgPSAyICogTWF0aC5jb3Modyk7XG4gICAgICAgICAgICBpZiAoZW5kVmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhMiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHkxID0gMDtcbiAgICAgICAgICAgICAgICB5MiA9IC1NYXRoLnNpbih3KSAqIChlbmRWYWx1ZSAtIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYTIgPSBlbmRWYWx1ZTtcbiAgICAgICAgICAgICAgICB5MSA9IHZhbHVlIC0gZW5kVmFsdWU7XG4gICAgICAgICAgICAgICAgeTIgPSBNYXRoLmNvcyh3KSAqICh2YWx1ZSAtIGVuZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gYTIgKyB5MTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEN1cnZlVHlwZUN1cnZlOlxuICAgICAgICAgICAgYTEgPSAoZW5kVmFsdWUgLSB2YWx1ZSkgLyAoMS4wIC0gTWF0aC5leHAoY3VydmVWYWx1ZSkpO1xuICAgICAgICAgICAgYTIgPSB2YWx1ZSArIGExO1xuICAgICAgICAgICAgYjEgPSBhMTtcbiAgICAgICAgICAgIGdyb3cgPSBNYXRoLmV4cChjdXJ2ZVZhbHVlIC8gY291bnRlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDdXJ2ZVR5cGVTcXI6XG4gICAgICAgICAgICB5MSA9IE1hdGguc3FydCh2YWx1ZSk7XG4gICAgICAgICAgICB5MiA9IE1hdGguc3FydChlbmRWYWx1ZSk7XG4gICAgICAgICAgICBncm93ID0gKHkyIC0geTEpIC8gY291bnRlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEN1cnZlVHlwZUN1YjpcbiAgICAgICAgICAgIHkxID0gTWF0aC5wb3codmFsdWUgICAsIDAuMzMzMzMzMzMpO1xuICAgICAgICAgICAgeTIgPSBNYXRoLnBvdyhlbmRWYWx1ZSwgMC4zMzMzMzMzMyk7XG4gICAgICAgICAgICBncm93ID0gKHkyIC0geTEpIC8gY291bnRlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uZXh0ID0gTmV4dEZ1bmN0aW9uc1tjdXJ2ZVR5cGVdO1xuICAgICAgICB0aGlzLl9ncm93ID0gZ3JvdztcbiAgICAgICAgdGhpcy5fYTIgPSBhMjtcbiAgICAgICAgdGhpcy5fYjEgPSBiMTtcbiAgICAgICAgdGhpcy5feTEgPSB5MTtcbiAgICAgICAgdGhpcy5feTIgPSB5MjtcblxuICAgICAgICByZXR1cm4gY291bnRlcjtcbiAgICB9O1xuXG4gICAgdmFyIE5leHRGdW5jdGlvbnMgPSBbXTtcbiAgICBOZXh0RnVuY3Rpb25zW0N1cnZlVHlwZVNldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfTtcbiAgICBOZXh0RnVuY3Rpb25zW0N1cnZlVHlwZUxpbl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSArPSB0aGlzLl9ncm93O1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuICAgIE5leHRGdW5jdGlvbnNbQ3VydmVUeXBlRXhwXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnZhbHVlICo9IHRoaXMuX2dyb3c7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgTmV4dEZ1bmN0aW9uc1tDdXJ2ZVR5cGVTaW5dID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5MCA9IHRoaXMuX2IxICogdGhpcy5feTEgLSB0aGlzLl95MjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2EyIC0geTA7XG4gICAgICAgIHRoaXMuX3kyID0gdGhpcy5feTE7XG4gICAgICAgIHRoaXMuX3kxID0geTA7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgTmV4dEZ1bmN0aW9uc1tDdXJ2ZVR5cGVXZWxdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5MCA9IHRoaXMuX2IxICogdGhpcy5feTEgLSB0aGlzLl95MjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2EyICsgeTA7XG4gICAgICAgIHRoaXMuX3kyID0gdGhpcy5feTE7XG4gICAgICAgIHRoaXMuX3kxID0geTA7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgTmV4dEZ1bmN0aW9uc1tDdXJ2ZVR5cGVDdXJ2ZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYjEgKj0gdGhpcy5fZ3JvdztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2EyIC0gdGhpcy5fYjE7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgTmV4dEZ1bmN0aW9uc1tDdXJ2ZVR5cGVTcXJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3kxICs9IHRoaXMuX2dyb3c7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl95MSAqIHRoaXMuX3kxO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuICAgIE5leHRGdW5jdGlvbnNbQ3VydmVUeXBlQ3ViXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl95MSArPSB0aGlzLl9ncm93O1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5feTEgKiB0aGlzLl95MSAqIHRoaXMuX3kxO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuXG4gICAgRW52ZWxvcGVWYWx1ZS5wcm90b3R5cGUubmV4dCA9IE5leHRGdW5jdGlvbnNbQ3VydmVUeXBlU2V0XTtcblxuICAgIFQubW9kdWxlcy5FbnZlbG9wZSAgICAgID0gRW52ZWxvcGU7XG4gICAgVC5tb2R1bGVzLkVudmVsb3BlVmFsdWUgPSBFbnZlbG9wZVZhbHVlO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIEZGVChuKSB7XG4gICAgICAgIG4gPSAodHlwZW9mIG4gPT09IFwibnVtYmVyXCIpID8gbiA6IDUxMjtcbiAgICAgICAgbiA9IDEgPDwgTWF0aC5jZWlsKE1hdGgubG9nKG4pICogTWF0aC5MT0cyRSk7XG5cbiAgICAgICAgdGhpcy5sZW5ndGggID0gbjtcbiAgICAgICAgdGhpcy5idWZmZXIgID0gbmV3IFQuZm4uU2lnbmFsQXJyYXkobik7XG4gICAgICAgIHRoaXMucmVhbCAgICA9IG5ldyBULmZuLlNpZ25hbEFycmF5KG4pO1xuICAgICAgICB0aGlzLmltYWcgICAgPSBuZXcgVC5mbi5TaWduYWxBcnJheShuKTtcbiAgICAgICAgdGhpcy5fcmVhbCAgID0gbmV3IFQuZm4uU2lnbmFsQXJyYXkobik7XG4gICAgICAgIHRoaXMuX2ltYWcgICA9IG5ldyBULmZuLlNpZ25hbEFycmF5KG4pO1xuICAgICAgICB0aGlzLm1hZyAgICAgPSBuZXcgVC5mbi5TaWduYWxBcnJheShuPj4xKTtcblxuICAgICAgICB0aGlzLm1pbkRlY2liZWxzID0gIC0zMDtcbiAgICAgICAgdGhpcy5tYXhEZWNpYmVscyA9IC0xMDA7XG5cbiAgICAgICAgdmFyIHBhcmFtcyA9IEZGVFBhcmFtcy5nZXQobik7XG4gICAgICAgIHRoaXMuX2JpdHJldiAgID0gcGFyYW1zLmJpdHJldjtcbiAgICAgICAgdGhpcy5fc2ludGFibGUgPSBwYXJhbXMuc2ludGFibGU7XG4gICAgICAgIHRoaXMuX2Nvc3RhYmxlID0gcGFyYW1zLmNvc3RhYmxlO1xuICAgIH1cblxuICAgIHZhciAkID0gRkZULnByb3RvdHlwZTtcblxuICAgICQuc2V0V2luZG93ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgbSA9IC8oW0EtWmEtel0rKSg/OlxcKChbMDFdXFwuP1xcZCopXFwpKT8vLmV4ZWMoa2V5KTtcbiAgICAgICAgICAgIGlmIChtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBtWzFdLnRvTG93ZXJDYXNlKCksIGEgPSBtWzJdICE9PSB1bmRlZmluZWQgPyArbVsyXSA6IDAuMjU7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBXaW5kb3dGdW5jdGlvbnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl93aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpbmRvdyA9IG5ldyBULmZuLlNpZ25hbEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHRoaXMuX3dpbmRvdywgbiA9IDAsIE4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYSA9IChhIDwgMCkgPyAwIDogKGEgPiAxKSA/IDEgOiBhO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbiA8IE47ICsrbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgd1tuXSA9IGYobiwgTiwgYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aW5kb3dOYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZvcndhcmQgPSBmdW5jdGlvbihfYnVmZmVyKSB7XG4gICAgICAgIHZhciBidWZmZXIgICA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB2YXIgcmVhbCAgID0gdGhpcy5yZWFsO1xuICAgICAgICB2YXIgaW1hZyAgID0gdGhpcy5pbWFnO1xuICAgICAgICB2YXIgd2luZG93ID0gdGhpcy5fd2luZG93O1xuICAgICAgICB2YXIgYml0cmV2ID0gdGhpcy5fYml0cmV2O1xuICAgICAgICB2YXIgc2ludGFibGUgPSB0aGlzLl9zaW50YWJsZTtcbiAgICAgICAgdmFyIGNvc3RhYmxlID0gdGhpcy5fY29zdGFibGU7XG4gICAgICAgIHZhciBuID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdmFyIGksIGosIGssIGsyLCBoLCBkLCBjLCBzLCBpaywgZHgsIGR5O1xuXG4gICAgICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSBfYnVmZmVyW2ldICogd2luZG93W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLnNldChfYnVmZmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHJlYWxbaV0gPSBidWZmZXJbYml0cmV2W2ldXTtcbiAgICAgICAgICAgIGltYWdbaV0gPSAwLjA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGsgPSAxOyBrIDwgbjsgayA9IGsyKSB7XG4gICAgICAgICAgICBoID0gMDsgazIgPSBrICsgazsgZCA9IG4gLyBrMjtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjID0gY29zdGFibGVbaF07XG4gICAgICAgICAgICAgICAgcyA9IHNpbnRhYmxlW2hdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGo7IGkgPCBuOyBpICs9IGsyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlrID0gaSArIGs7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gcyAqIGltYWdbaWtdICsgYyAqIHJlYWxbaWtdO1xuICAgICAgICAgICAgICAgICAgICBkeSA9IGMgKiBpbWFnW2lrXSAtIHMgKiByZWFsW2lrXTtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFtpa10gPSByZWFsW2ldIC0gZHg7IHJlYWxbaV0gKz0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGltYWdbaWtdID0gaW1hZ1tpXSAtIGR5OyBpbWFnW2ldICs9IGR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoICs9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFnID0gdGhpcy5tYWc7XG4gICAgICAgIHZhciBydmFsLCBpdmFsO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBydmFsID0gcmVhbFtpXTtcbiAgICAgICAgICAgIGl2YWwgPSBpbWFnW2ldO1xuICAgICAgICAgICAgbWFnW2ldID0gTWF0aC5zcXJ0KHJ2YWwgKiBydmFsICsgaXZhbCAqIGl2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtyZWFsOnJlYWwsIGltYWc6aW1hZ307XG4gICAgfTtcblxuICAgICQuaW52ZXJzZSA9IGZ1bmN0aW9uKF9yZWFsLCBfaW1hZykge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHZhciByZWFsICAgPSB0aGlzLl9yZWFsO1xuICAgICAgICB2YXIgaW1hZyAgID0gdGhpcy5faW1hZztcbiAgICAgICAgdmFyIGJpdHJldiA9IHRoaXMuX2JpdHJldjtcbiAgICAgICAgdmFyIHNpbnRhYmxlID0gdGhpcy5fc2ludGFibGU7XG4gICAgICAgIHZhciBjb3N0YWJsZSA9IHRoaXMuX2Nvc3RhYmxlO1xuICAgICAgICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHZhciBpLCBqLCBrLCBrMiwgaCwgZCwgYywgcywgaWssIGR4LCBkeTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBqID0gYml0cmV2W2ldO1xuICAgICAgICAgICAgcmVhbFtpXSA9ICtfcmVhbFtqXTtcbiAgICAgICAgICAgIGltYWdbaV0gPSAtX2ltYWdbal07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGsgPSAxOyBrIDwgbjsgayA9IGsyKSB7XG4gICAgICAgICAgICBoID0gMDsgazIgPSBrICsgazsgZCA9IG4gLyBrMjtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjID0gY29zdGFibGVbaF07XG4gICAgICAgICAgICAgICAgcyA9IHNpbnRhYmxlW2hdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGo7IGkgPCBuOyBpICs9IGsyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlrID0gaSArIGs7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gcyAqIGltYWdbaWtdICsgYyAqIHJlYWxbaWtdO1xuICAgICAgICAgICAgICAgICAgICBkeSA9IGMgKiBpbWFnW2lrXSAtIHMgKiByZWFsW2lrXTtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFtpa10gPSByZWFsW2ldIC0gZHg7IHJlYWxbaV0gKz0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGltYWdbaWtdID0gaW1hZ1tpXSAtIGR5OyBpbWFnW2ldICs9IGR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoICs9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBidWZmZXJbaV0gPSByZWFsW2ldIC8gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH07XG5cbiAgICAkLmdldEZyZXF1ZW5jeURhdGEgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICB2YXIgbWluRGVjaWJlbHMgID0gdGhpcy5taW5EZWNpYmVscztcbiAgICAgICAgdmFyIGksIGltYXggPSBNYXRoLm1pbih0aGlzLm1hZy5sZW5ndGgsIGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGlmIChpbWF4KSB7XG4gICAgICAgICAgICB2YXIgeCwgbWFnID0gdGhpcy5tYWc7XG4gICAgICAgICAgICB2YXIgcGVhayA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgeCAgPSBtYWdbaV07XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSAheCA/IG1pbkRlY2liZWxzIDogMjAgKiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFO1xuICAgICAgICAgICAgICAgIGlmIChwZWFrIDwgYXJyYXlbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGVhayA9IGFycmF5W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfTtcblxuICAgIHZhciBGRlRQYXJhbXMgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24obikge1xuICAgICAgICAgICAgcmV0dXJuIEZGVFBhcmFtc1tuXSB8fCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpdHJldiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgsIGksIGosIGssIG4yO1xuICAgICAgICAgICAgICAgICAgICB4ID0gbmV3IEludDE2QXJyYXkobik7XG4gICAgICAgICAgICAgICAgICAgIG4yID0gbiA+PiAxO1xuICAgICAgICAgICAgICAgICAgICBpID0gaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhbaV0gPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsraSA+PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gbjI7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiAtPSBrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPj49IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IGs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaW1heCwgayA9IE1hdGguZmxvb3IoTWF0aC5sb2cobikgLyBNYXRoLkxOMik7XG4gICAgICAgICAgICAgICAgdmFyIHNpbnRhYmxlID0gbmV3IFQuZm4uU2lnbmFsQXJyYXkoKDE8PGspLTEpO1xuICAgICAgICAgICAgICAgIHZhciBjb3N0YWJsZSA9IG5ldyBULmZuLlNpZ25hbEFycmF5KCgxPDxrKS0xKTtcbiAgICAgICAgICAgICAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpbWF4ID0gc2ludGFibGUubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbnRhYmxlW2ldID0gTWF0aC5zaW4oUEkyICogKGkgLyBuKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvc3RhYmxlW2ldID0gTWF0aC5jb3MoUEkyICogKGkgLyBuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEZGVFBhcmFtc1tuXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYml0cmV2OiBiaXRyZXYsIHNpbnRhYmxlOnNpbnRhYmxlLCBjb3N0YWJsZTpjb3N0YWJsZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZGVFBhcmFtc1tuXTtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFdpbmRvd0Z1bmN0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIFBJICAgPSBNYXRoLlBJO1xuICAgICAgICB2YXIgUEkyICA9IE1hdGguUEkgKiAyO1xuICAgICAgICB2YXIgYWJzICA9IE1hdGguYWJzO1xuICAgICAgICB2YXIgcG93ICA9IE1hdGgucG93O1xuICAgICAgICB2YXIgY29zICA9IE1hdGguY29zO1xuICAgICAgICB2YXIgc2luICA9IE1hdGguc2luO1xuICAgICAgICB2YXIgc2luYyA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHNpbihQSSp4KSAvIChQSSp4KTsgfTtcbiAgICAgICAgdmFyIEUgICAgPSBNYXRoLkU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlY3Rhbmd1bGFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5uOiBmdW5jdGlvbihuLCBOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gY29zKChQSTIqbikgLyAoTi0xKSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbW1pbmc6IGZ1bmN0aW9uKG4sIE4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41NCAtIDAuNDYgKiBjb3MoKFBJMipuKSAvIChOLTEpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0dWtlcnk6IGZ1bmN0aW9uKG4sIE4sIGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIG4gPCAoYSAqIChOLTEpKS8yICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKCAxICsgY29zKFBJICogKCgoMipuKS8oYSooTi0xKSkpIC0gMSkpICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggKE4tMSkqKDEtKGEvMikpIDwgbiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqICggMSArIGNvcyhQSSAqICgoKDIqbikvKGEqKE4tMSkpKSAtICgyL2EpICsgMSkpICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvc2luZTogZnVuY3Rpb24obiwgTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW4oKFBJKm4pIC8gKE4tMSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhbmN6b3M6IGZ1bmN0aW9uKG4sIE4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2luYygoKDIqbikgLyAoTi0xKSkgLSAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmlhbmd1bGFyOiBmdW5jdGlvbihuLCBOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgyLyhOKzEpKSAqICgoKE4rMSkvMikgLSBhYnMobiAtICgoTi0xKS8yKSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhcnRsZXR0OiBmdW5jdGlvbihuLCBOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgyLyhOLTEpKSAqICgoKE4tMSkvMikgLSBhYnMobiAtICgoTi0xKS8yKSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdhdXNzaWFuOiBmdW5jdGlvbihuLCBOLCBhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvdyhFLCAtMC41ICogcG93KChuIC0gKE4tMSkgLyAyKSAvIChhICogKE4tMSkgLyAyKSwgMikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhcnRsZXR0SGFubjogZnVuY3Rpb24obiwgTikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjYyIC0gMC40OCAqIGFicygobiAvIChOLTEpKSAtIDAuNSkgLSAwLjM4ICogY29zKChQSTIqbikgLyAoTi0xKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmxhY2ttYW46IGZ1bmN0aW9uKG4sIE4sIGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTAgPSAoMSAtIGEpIC8gMiwgYTEgPSAwLjUsIGEyID0gYSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEwIC0gYTEgKiBjb3MoKFBJMipuKSAvIChOLTEpKSArIGEyICogY29zKCg0KlBJKm4pIC8gKE4tMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICBULm1vZHVsZXMuRkZUID0gRkZUO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIE9zY2lsbGF0b3Ioc2FtcGxlcmF0ZSkge1xuICAgICAgICB0aGlzLnNhbXBsZXJhdGUgPSBzYW1wbGVyYXRlIHx8IDQ0MTAwO1xuXG4gICAgICAgIHRoaXMud2F2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RlcCA9IDE7XG4gICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMucGhhc2UgPSAwO1xuICAgICAgICB0aGlzLmZlZWRiYWNrID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgIHRoaXMuX2xhc3RvdXRzID0gMDtcbiAgICAgICAgdGhpcy5fY29lZmYgPSBUQUJMRV9TSVpFIC8gdGhpcy5zYW1wbGVyYXRlO1xuICAgICAgICB0aGlzLl9yYWR0b2luYyA9IFRBQkxFX1NJWkUgLyAoTWF0aC5QSSAqIDIpO1xuICAgIH1cblxuICAgIHZhciBUQUJMRV9TSVpFID0gMTAyNDtcbiAgICB2YXIgVEFCTEVfTUFTSyA9IFRBQkxFX1NJWkUgLSAxO1xuXG4gICAgdmFyICQgPSBPc2NpbGxhdG9yLnByb3RvdHlwZTtcblxuICAgICQuc2V0V2F2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBpLCBkeCwgd2F2ZSA9IHRoaXMud2F2ZTtcbiAgICAgICAgaWYgKCF0aGlzLndhdmUpIHtcbiAgICAgICAgICAgIHRoaXMud2F2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoVEFCTEVfU0laRSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IFRBQkxFX1NJWkU7ICsraSkge1xuICAgICAgICAgICAgICAgIHdhdmVbaV0gPSB2YWx1ZShpIC8gVEFCTEVfU0laRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoVC5mbi5pc1NpZ25hbEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gd2F2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3YXZlLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR4ID0gdmFsdWUubGVuZ3RoIC8gVEFCTEVfU0laRTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgVEFCTEVfU0laRTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhdmVbaV0gPSB2YWx1ZVsoaSAqIGR4KXwwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGR4ID0gZ2V0V2F2ZXRhYmxlKHZhbHVlKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2F2ZS5zZXQoZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F2ZVtUQUJMRV9TSVpFXSA9IHRoaXMud2F2ZVswXTtcbiAgICB9O1xuXG4gICAgJC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbmV3X2luc3RhbmNlID0gbmV3IE9zY2lsbGF0b3IodGhpcy5zYW1wbGVyYXRlKTtcbiAgICAgICAgbmV3X2luc3RhbmNlLndhdmUgICAgICA9IHRoaXMud2F2ZTtcbiAgICAgICAgbmV3X2luc3RhbmNlLnN0ZXAgICAgICA9IHRoaXMuc3RlcDtcbiAgICAgICAgbmV3X2luc3RhbmNlLmZyZXF1ZW5jeSA9IHRoaXMuZnJlcXVlbmN5O1xuICAgICAgICBuZXdfaW5zdGFuY2UudmFsdWUgICAgID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbmV3X2luc3RhbmNlLnBoYXNlICAgICA9IHRoaXMucGhhc2U7XG4gICAgICAgIG5ld19pbnN0YW5jZS5mZWVkYmFjayAgPSB0aGlzLmZlZWRiYWNrO1xuICAgICAgICByZXR1cm4gbmV3X2luc3RhbmNlO1xuICAgIH07XG5cbiAgICAkLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3ggPSAwO1xuICAgIH07XG5cbiAgICAkLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLl94O1xuICAgICAgICB2YXIgaW5kZXggPSAoeCArIHRoaXMucGhhc2UgKiB0aGlzLl9yYWR0b2luYyl8MDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMud2F2ZVtpbmRleCAmIFRBQkxFX01BU0tdO1xuICAgICAgICB4ICs9IHRoaXMuZnJlcXVlbmN5ICogdGhpcy5fY29lZmYgKiB0aGlzLnN0ZXA7XG4gICAgICAgIGlmICh4ID4gVEFCTEVfU0laRSkge1xuICAgICAgICAgICAgeCAtPSBUQUJMRV9TSVpFO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICB2YXIgd2F2ZSA9IHRoaXMud2F2ZTtcbiAgICAgICAgdmFyIHJhZHRvaW5jID0gdGhpcy5fcmFkdG9pbmM7XG4gICAgICAgIHZhciBwaGFzZSwgeCA9IHRoaXMuX3g7XG4gICAgICAgIHZhciBpbmRleCwgZnJhYywgeDAsIHgxLCBkeCA9IHRoaXMuZnJlcXVlbmN5ICogdGhpcy5fY29lZmY7XG4gICAgICAgIHZhciBpLCBpbWF4ID0gdGhpcy5zdGVwO1xuXG4gICAgICAgIGlmICh0aGlzLmZlZWRiYWNrKSB7XG4gICAgICAgICAgICB2YXIgbGFzdG91dHMgPSB0aGlzLl9sYXN0b3V0cztcbiAgICAgICAgICAgIHJhZHRvaW5jICo9IHRoaXMucGhhc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcGhhc2UgPSB4ICsgbGFzdG91dHMgKiByYWR0b2luYztcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBoYXNlfDA7XG4gICAgICAgICAgICAgICAgZnJhYyAgPSBwaGFzZSAtIGluZGV4O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggJiBUQUJMRV9NQVNLO1xuICAgICAgICAgICAgICAgIHgwID0gd2F2ZVtpbmRleCAgXTtcbiAgICAgICAgICAgICAgICB4MSA9IHdhdmVbaW5kZXgrMV07XG4gICAgICAgICAgICAgICAgY2VsbFtpXSA9IGxhc3RvdXRzID0geDAgKyBmcmFjICogKHgxIC0geDApO1xuICAgICAgICAgICAgICAgIHggKz0gZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXN0b3V0cyA9IGxhc3RvdXRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBoYXNlb2Zmc2V0ID0gdGhpcy5waGFzZSAqIHJhZHRvaW5jO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBoYXNlID0geCArIHBoYXNlb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcGhhc2V8MDtcbiAgICAgICAgICAgICAgICBmcmFjICA9IHBoYXNlIC0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCAmIFRBQkxFX01BU0s7XG4gICAgICAgICAgICAgICAgeDAgPSB3YXZlW2luZGV4ICBdO1xuICAgICAgICAgICAgICAgIHgxID0gd2F2ZVtpbmRleCsxXTtcbiAgICAgICAgICAgICAgICBjZWxsW2ldID0geDAgKyBmcmFjICogKHgxIC0geDApO1xuICAgICAgICAgICAgICAgIHggKz0gZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPiBUQUJMRV9TSVpFKSB7XG4gICAgICAgICAgICB4IC09IFRBQkxFX1NJWkU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMudmFsdWUgPSBjZWxsW2NlbGwubGVuZ3RoIC0gMV07XG4gICAgfTtcblxuICAgICQucHJvY2Vzc1dpdGhGcmVxQXJyYXkgPSBmdW5jdGlvbihjZWxsLCBmcmVxcykge1xuICAgICAgICB2YXIgd2F2ZSA9IHRoaXMud2F2ZTtcbiAgICAgICAgdmFyIHJhZHRvaW5jID0gdGhpcy5fcmFkdG9pbmM7XG4gICAgICAgIHZhciBwaGFzZSwgeCA9IHRoaXMuX3g7XG4gICAgICAgIHZhciBpbmRleCwgZnJhYywgeDAsIHgxLCBkeCA9IHRoaXMuX2NvZWZmO1xuICAgICAgICB2YXIgaSwgaW1heCA9IHRoaXMuc3RlcDtcblxuICAgICAgICBpZiAodGhpcy5mZWVkYmFjaykge1xuICAgICAgICAgICAgdmFyIGxhc3RvdXRzID0gdGhpcy5fbGFzdG91dHM7XG4gICAgICAgICAgICByYWR0b2luYyAqPSB0aGlzLnBoYXNlO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBoYXNlID0geCArIGxhc3RvdXRzICogcmFkdG9pbmM7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBwaGFzZXwwO1xuICAgICAgICAgICAgICAgIGZyYWMgID0gcGhhc2UgLSBpbmRleDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4ICYgVEFCTEVfTUFTSztcbiAgICAgICAgICAgICAgICB4MCA9IHdhdmVbaW5kZXggIF07XG4gICAgICAgICAgICAgICAgeDEgPSB3YXZlW2luZGV4KzFdO1xuICAgICAgICAgICAgICAgIGNlbGxbaV0gPSBsYXN0b3V0cyA9IHgwICsgZnJhYyAqICh4MSAtIHgwKTtcbiAgICAgICAgICAgICAgICB4ICs9IGZyZXFzW2ldICogZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXN0b3V0cyA9IGxhc3RvdXRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBoYXNlb2Zmc2V0ID0gdGhpcy5waGFzZSAqIHRoaXMuX3JhZHRvaW5jO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBoYXNlID0geCArIHBoYXNlb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcGhhc2V8MDtcbiAgICAgICAgICAgICAgICBmcmFjICA9IHBoYXNlIC0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCAmIFRBQkxFX01BU0s7XG4gICAgICAgICAgICAgICAgeDAgPSB3YXZlW2luZGV4ICBdO1xuICAgICAgICAgICAgICAgIHgxID0gd2F2ZVtpbmRleCsxXTtcbiAgICAgICAgICAgICAgICBjZWxsW2ldID0geDAgKyBmcmFjICogKHgxIC0geDApO1xuICAgICAgICAgICAgICAgIHggKz0gZnJlcXNbaV0gKiBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA+IFRBQkxFX1NJWkUpIHtcbiAgICAgICAgICAgIHggLT0gVEFCTEVfU0laRTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNlbGxbY2VsbC5sZW5ndGggLSAxXTtcbiAgICB9O1xuXG4gICAgJC5wcm9jZXNzV2l0aFBoYXNlQXJyYXkgPSBmdW5jdGlvbihjZWxsLCBwaGFzZXMpIHtcbiAgICAgICAgdmFyIHdhdmUgPSB0aGlzLndhdmU7XG4gICAgICAgIHZhciByYWR0b2luYyA9IHRoaXMuX3JhZHRvaW5jO1xuICAgICAgICB2YXIgcGhhc2UsIHggPSB0aGlzLl94O1xuICAgICAgICB2YXIgaW5kZXgsIGZyYWMsIHgwLCB4MSwgZHggPSB0aGlzLmZyZXF1ZW5jeSAqIHRoaXMuX2NvZWZmO1xuICAgICAgICB2YXIgaSwgaW1heCA9IHRoaXMuc3RlcDtcblxuICAgICAgICBpZiAodGhpcy5mZWVkYmFjaykge1xuICAgICAgICAgICAgdmFyIGxhc3RvdXRzID0gdGhpcy5fbGFzdG91dHM7XG4gICAgICAgICAgICByYWR0b2luYyAqPSB0aGlzLnBoYXNlO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBoYXNlID0geCArIGxhc3RvdXRzICogcmFkdG9pbmM7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBwaGFzZXwwO1xuICAgICAgICAgICAgICAgIGZyYWMgID0gcGhhc2UgLSBpbmRleDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4ICYgVEFCTEVfTUFTSztcbiAgICAgICAgICAgICAgICB4MCA9IHdhdmVbaW5kZXggIF07XG4gICAgICAgICAgICAgICAgeDEgPSB3YXZlW2luZGV4KzFdO1xuICAgICAgICAgICAgICAgIGNlbGxbaV0gPSBsYXN0b3V0cyA9IHgwICsgZnJhYyAqICh4MSAtIHgwKTtcbiAgICAgICAgICAgICAgICB4ICs9IGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGFzdG91dHMgPSBsYXN0b3V0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBwaGFzZSA9IHggKyBwaGFzZXNbaV0gKiByYWR0b2luYztcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBoYXNlfDA7XG4gICAgICAgICAgICAgICAgZnJhYyAgPSBwaGFzZSAtIGluZGV4O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggJiBUQUJMRV9NQVNLO1xuICAgICAgICAgICAgICAgIHgwID0gd2F2ZVtpbmRleCAgXTtcbiAgICAgICAgICAgICAgICB4MSA9IHdhdmVbaW5kZXgrMV07XG4gICAgICAgICAgICAgICAgY2VsbFtpXSA9IHgwICsgZnJhYyAqICh4MSAtIHgwKTtcbiAgICAgICAgICAgICAgICB4ICs9IGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ID4gVEFCTEVfU0laRSkge1xuICAgICAgICAgICAgeCAtPSBUQUJMRV9TSVpFO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLnZhbHVlID0gY2VsbFtjZWxsLmxlbmd0aCAtIDFdO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3NXaXRoRnJlcUFuZFBoYXNlQXJyYXkgPSBmdW5jdGlvbihjZWxsLCBmcmVxcywgcGhhc2VzKSB7XG4gICAgICAgIHZhciB3YXZlID0gdGhpcy53YXZlO1xuICAgICAgICB2YXIgcmFkdG9pbmMgPSB0aGlzLl9yYWR0b2luYztcbiAgICAgICAgdmFyIHBoYXNlLCB4ID0gdGhpcy5feDtcbiAgICAgICAgdmFyIGluZGV4LCBmcmFjLCB4MCwgeDEsIGR4ID0gdGhpcy5fY29lZmY7XG4gICAgICAgIHZhciBpLCBpbWF4ID0gdGhpcy5zdGVwO1xuXG4gICAgICAgIGlmICh0aGlzLmZlZWRiYWNrKSB7XG4gICAgICAgICAgICB2YXIgbGFzdG91dHMgPSB0aGlzLl9sYXN0b3V0cztcbiAgICAgICAgICAgIHJhZHRvaW5jICo9IHRoaXMucGhhc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcGhhc2UgPSB4ICsgbGFzdG91dHMgKiByYWR0b2luYztcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBoYXNlfDA7XG4gICAgICAgICAgICAgICAgZnJhYyAgPSBwaGFzZSAtIGluZGV4O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggJiBUQUJMRV9NQVNLO1xuICAgICAgICAgICAgICAgIHgwID0gd2F2ZVtpbmRleCAgXTtcbiAgICAgICAgICAgICAgICB4MSA9IHdhdmVbaW5kZXgrMV07XG4gICAgICAgICAgICAgICAgY2VsbFtpXSA9IGxhc3RvdXRzID0geDAgKyBmcmFjICogKHgxIC0geDApO1xuICAgICAgICAgICAgICAgIHggKz0gZnJlcXNbaV0gKiBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xhc3RvdXRzID0gbGFzdG91dHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcGhhc2UgPSB4ICsgcGhhc2VzW2ldICogVEFCTEVfU0laRTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBoYXNlfDA7XG4gICAgICAgICAgICAgICAgZnJhYyAgPSBwaGFzZSAtIGluZGV4O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggJiBUQUJMRV9NQVNLO1xuICAgICAgICAgICAgICAgIHgwID0gd2F2ZVtpbmRleCAgXTtcbiAgICAgICAgICAgICAgICB4MSA9IHdhdmVbaW5kZXgrMV07XG4gICAgICAgICAgICAgICAgY2VsbFtpXSA9IHgwICsgZnJhYyAqICh4MSAtIHgwKTtcbiAgICAgICAgICAgICAgICB4ICs9IGZyZXFzW2ldICogZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPiBUQUJMRV9TSVpFKSB7XG4gICAgICAgICAgICB4IC09IFRBQkxFX1NJWkU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMudmFsdWUgPSBjZWxsW2NlbGwubGVuZ3RoIC0gMV07XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gd2F2ZXNoYXBlKHNpZ24sIG5hbWUsIHNoYXBlLCB3aWR0aCkge1xuICAgICAgICB2YXIgd2F2ZSA9IFdhdmV0YWJsZXNbbmFtZV07XG4gICAgICAgIHZhciBfd2F2ZTtcbiAgICAgICAgdmFyIGksIGltYXgsIGosIGptYXg7XG5cbiAgICAgICAgaWYgKHdhdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3YXZlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhdmUgPSB3YXZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHNoYXBlKSB7XG4gICAgICAgIGNhc2UgXCJAMVwiOlxuICAgICAgICAgICAgZm9yIChpID0gNTEyOyBpIDwgMTAyNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgd2F2ZVtpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkAyXCI6XG4gICAgICAgICAgICBmb3IgKGkgPSA1MTI7IGkgPCAxMDI0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB3YXZlW2ldID0gTWF0aC5hYnMod2F2ZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkAzXCI6XG4gICAgICAgICAgICBmb3IgKGkgPSAyNTY7IGkgPCAgNTEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICB3YXZlW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDUxMjsgaSA8ICA3Njg7ICsraSkge1xuICAgICAgICAgICAgICAgIHdhdmVbaV0gPSBNYXRoLmFicyh3YXZlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDc2ODsgaSA8IDEwMjQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHdhdmVbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJANFwiOlxuICAgICAgICAgICAgX3dhdmUgPSBuZXcgRmxvYXQzMkFycmF5KDEwMjQpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDUxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgX3dhdmVbaV0gPSB3YXZlW2k8PDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2F2ZSA9IF93YXZlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJANVwiOlxuICAgICAgICAgICAgX3dhdmUgPSBuZXcgRmxvYXQzMkFycmF5KDEwMjQpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDUxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgX3dhdmVbaV0gPSBNYXRoLmFicyh3YXZlW2k8PDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhdmUgPSBfd2F2ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHV0eS1jeWNsZVxuICAgICAgICBpZiAod2lkdGggIT09IHVuZGVmaW5lZCAmJiB3aWR0aCAhPT0gNTApIHtcbiAgICAgICAgICAgIHdpZHRoICo9IDAuMDE7XG4gICAgICAgICAgICB3aWR0aCA9ICh3aWR0aCA8IDApID8gMCA6ICh3aWR0aCA+IDEpID8gMSA6IHdpZHRoO1xuXG4gICAgICAgICAgICBfd2F2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMTAyNCk7XG4gICAgICAgICAgICBpbWF4ID0gKDEwMjQgKiB3aWR0aCl8MDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBfd2F2ZVtpXSA9IHdhdmVbKGkgLyBpbWF4ICogNTEyKXwwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGptYXggPSAoMTAyNCAtIGltYXgpO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaSA8IDEwMjQ7ICsraSwgKytqKSB7XG4gICAgICAgICAgICAgICAgX3dhdmVbaV0gPSB3YXZlWyhqIC8gam1heCAqIDUxMiArIDUxMil8MF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXZlID0gX3dhdmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lnbiA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMDI0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB3YXZlW2ldID0gd2F2ZVtpXSAqIDAuNSArIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaWduID09PSBcIi1cIikge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEwMjQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHdhdmVbaV0gKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhdmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2F2YihzcmMpIHtcbiAgICAgICAgdmFyIHdhdmUgPSBuZXcgRmxvYXQzMkFycmF5KDEwMjQpO1xuICAgICAgICB2YXIgbiA9IHNyYy5sZW5ndGggPj4gMTtcbiAgICAgICAgaWYgKFsyLDQsOCwxNiwzMiw2NCwxMjgsMjU2LDUxMiwxMDI0XS5pbmRleE9mKG4pICE9PSAtMSkge1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KHNyYy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG5cbiAgICAgICAgICAgICAgICB4ID0gKHggJiAweDgwKSA/ICh4LTI1NikgLyAxMjguMCA6IHggLyAxMjcuMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgam1heCA9IDEwMjQgLyBuOyBqIDwgam1heDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhdmVbaysrXSA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXZlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhdmMoc3JjKSB7XG4gICAgICAgIHZhciB3YXZlID0gbmV3IEZsb2F0MzJBcnJheSgxMDI0KTtcbiAgICAgICAgaWYgKHNyYy5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHBhcnNlSW50KHNyYywgMTYpO1xuICAgICAgICAgICAgdmFyIGJhciAgID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcbiAgICAgICAgICAgIHZhciBpLCBqO1xuXG4gICAgICAgICAgICBiYXJbMF0gPSAxO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIGJhcltpKzFdID0gKGNvbG9yICYgMHgwZikgKiAwLjA2MjU7IC8vIDAuMDYyNSA9IDEvMTZcbiAgICAgICAgICAgICAgICBjb2xvciA+Pj0gNDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gMCwgZHggPSAoaSArIDEpIC8gMTAyNDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgMTAyNDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhdmVbal0gKz0gTWF0aC5zaW4oMiAqIE1hdGguUEkgKiB4KSAqIGJhcltpXTtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYXh4ID0gMCwgYWJzeDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMDI0OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4eCA8IChhYnN4ID0gTWF0aC5hYnMod2F2ZVtpXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heHggPSBhYnN4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXh4ID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMDI0OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgd2F2ZVtpXSAvPSBtYXh4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F2ZTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0V2F2ZXRhYmxlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciB3YXZlID0gV2F2ZXRhYmxlc1trZXldO1xuICAgICAgICBpZiAod2F2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdhdmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHdhdmUgPSB3YXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2F2ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtO1xuICAgICAgICAvLyB3YXZlIHNoYXBpbmdcbiAgICAgICAgbSA9IC9eKFtcXC0rXT8pKFxcdyspKD86XFwoKEBbMC03XSk/Oj8oXFxkKyk/XFwpKT8kLy5leGVjKGtleSk7XG4gICAgICAgIGlmIChtICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc2lnbiA9IG1bMV0sIG5hbWUgPSBtWzJdLCBzaGFwZSA9IG1bM10sIHdpZHRoID0gbVs0XTtcbiAgICAgICAgICAgIHdhdmUgPSB3YXZlc2hhcGUoc2lnbiwgbmFtZSwgc2hhcGUsIHdpZHRoKTtcbiAgICAgICAgICAgIGlmICh3YXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBXYXZldGFibGVzW2tleV0gPSB3YXZlO1xuICAgICAgICAgICAgICAgIHJldHVybiB3YXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2F2ZSBieXRlc1xuICAgICAgICBtID0gL153YXZiXFwoKCg/OlswLTlhLWZBLUZdWzAtOWEtZkEtRl0pKylcXCkkLy5leGVjKGtleSk7XG4gICAgICAgIGlmIChtICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2F2YihtWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdhdmUgY29sb3JcbiAgICAgICAgbSA9IC9ed2F2Y1xcKChbMC05YS1mQS1GXXs4fSlcXCkkLy5leGVjKGtleSk7XG4gICAgICAgIGlmIChtICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2F2YyhtWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdhcm4gbWVzc2FnZVxuICAgIH07XG4gICAgT3NjaWxsYXRvci5nZXRXYXZldGFibGUgPSBnZXRXYXZldGFibGU7XG5cbiAgICB2YXIgc2V0V2F2ZXRhYmxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGR4LCB3YXZlID0gbmV3IEZsb2F0MzJBcnJheSgxMDI0KTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEwMjQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHdhdmVbaV0gPSB2YWx1ZShpIC8gMTAyNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoVC5mbi5pc1NpZ25hbEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gd2F2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3YXZlLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR4ID0gdmFsdWUubGVuZ3RoIC8gMTAyNDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTAyNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhdmVbaV0gPSB2YWx1ZVsoaSAqIGR4KXwwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgV2F2ZXRhYmxlc1tuYW1lXSA9IHdhdmU7XG4gICAgfTtcbiAgICBPc2NpbGxhdG9yLnNldFdhdmV0YWJsZSA9IHNldFdhdmV0YWJsZTtcblxuICAgIHZhciBXYXZldGFibGVzID0ge1xuICAgICAgICBzaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHdhdmUgPSBuZXcgRmxvYXQzMkFycmF5KDEwMjQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDI0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB3YXZlW2ldID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgKiAoaS8xMDI0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2F2ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YXZlID0gbmV3IEZsb2F0MzJBcnJheSgxMDI0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTAyNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgd2F2ZVtpXSA9IE1hdGguY29zKDIgKiBNYXRoLlBJICogKGkvMTAyNCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdhdmU7XG4gICAgICAgIH0sXG4gICAgICAgIHB1bHNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YXZlID0gbmV3IEZsb2F0MzJBcnJheSgxMDI0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTAyNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgd2F2ZVtpXSA9IChpIDwgNTEyKSA/ICsxIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2F2ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YXZlID0gbmV3IEZsb2F0MzJBcnJheSgxMDI0KTtcbiAgICAgICAgICAgIGZvciAodmFyIHgsIGkgPSAwOyBpIDwgMTAyNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgeCA9IChpIC8gMTAyNCkgLSAwLjI1O1xuICAgICAgICAgICAgICAgIHdhdmVbaV0gPSAxLjAgLSA0LjAgKiBNYXRoLmFicyhNYXRoLnJvdW5kKHgpIC0geCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2F2ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2F3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YXZlID0gbmV3IEZsb2F0MzJBcnJheSgxMDI0KTtcbiAgICAgICAgICAgIGZvciAodmFyIHgsIGkgPSAwOyBpIDwgMTAyNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgeCA9IChpIC8gMTAyNCk7XG4gICAgICAgICAgICAgICAgd2F2ZVtpXSA9ICsyLjAgKiAoeCAtIE1hdGgucm91bmQoeCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdhdmU7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbWk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSBbICswLjAwMCwgKzAuMTI1LCArMC4yNTAsICswLjM3NSwgKzAuNTAwLCArMC42MjUsICswLjc1MCwgKzAuODc1LFxuICAgICAgICAgICAgICAgICAgICAgICswLjg3NSwgKzAuNzUwLCArMC42MjUsICswLjUwMCwgKzAuMzc1LCArMC4yNTAsICswLjEyNSwgKzAuMDAwLFxuICAgICAgICAgICAgICAgICAgICAgIC0wLjEyNSwgLTAuMjUwLCAtMC4zNzUsIC0wLjUwMCwgLTAuNjI1LCAtMC43NTAsIC0wLjg3NSwgLTEuMDAwLFxuICAgICAgICAgICAgICAgICAgICAgIC0xLjAwMCwgLTAuODc1LCAtMC43NTAsIC0wLjYyNSwgLTAuNTAwLCAtMC4zNzUsIC0wLjI1MCwgLTAuMTI1IF07XG4gICAgICAgICAgICB2YXIgd2F2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMTAyNCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwMjQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHdhdmVbaV0gPSBkWyhpIC8gMTAyNCAqIGQubGVuZ3RoKXwwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3YXZlO1xuICAgICAgICB9LFxuICAgICAgICBrb25hbWk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSBbLTAuNjI1LCAtMC44NzUsIC0wLjEyNSwgKzAuNzUwLCArIDAuNTAwLCArMC4xMjUsICswLjUwMCwgKzAuNzUwLFxuICAgICAgICAgICAgICAgICAgICAgKzAuMjUwLCAtMC4xMjUsICswLjUwMCwgKzAuODc1LCArIDAuNjI1LCArMC4wMDAsICswLjI1MCwgKzAuMzc1LFxuICAgICAgICAgICAgICAgICAgICAgLTAuMTI1LCAtMC43NTAsICswLjAwMCwgKzAuNjI1LCArIDAuMTI1LCAtMC41MDAsIC0wLjM3NSwgLTAuMTI1LFxuICAgICAgICAgICAgICAgICAgICAgLTAuNzUwLCAtMS4wMDAsIC0wLjYyNSwgKzAuMDAwLCAtIDAuMzc1LCAtMC44NzUsIC0wLjYyNSwgLTAuMjUwIF07XG4gICAgICAgICAgICB2YXIgd2F2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMTAyNCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwMjQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHdhdmVbaV0gPSBkWyhpIC8gMTAyNCAqIGQubGVuZ3RoKXwwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3YXZlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFQubW9kdWxlcy5Pc2NpbGxhdG9yID0gT3NjaWxsYXRvcjtcblxufSkodGltYnJlKTtcbi8qKlxuICogUG9ydCBvZiB0aGUgRnJlZXZlcmIgU2Nocm9kb2VyL01vb3JlciByZXZlcmIgbW9kZWwuXG4gKiBodHRwczovL2Njcm1hLnN0YW5mb3JkLmVkdS9+am9zL3Bhc3AvRnJlZXZlcmIuaHRtbFxuKi9cbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgQ29tYlBhcmFtcyAgICA9IFsxMTE2LDExODgsMTI3NywxMzU2LDE0MjIsMTQ5MSwxNTU3LDE2MTddO1xuICAgIHZhciBBbGxwYXNzUGFyYW1zID0gWzIyNSw1NTYsNDQxLDM0MV07XG5cbiAgICBmdW5jdGlvbiBSZXZlcmIoc2FtcGxlcmF0ZSwgYnVmZmVyc2l6ZSkge1xuICAgICAgICB0aGlzLnNhbXBsZXJhdGUgPSBzYW1wbGVyYXRlO1xuXG4gICAgICAgIHZhciBpLCBpbWF4O1xuICAgICAgICB2YXIgayA9IHNhbXBsZXJhdGUgLyA0NDEwMDtcblxuICAgICAgICBpbWF4ID0gQ29tYlBhcmFtcy5sZW5ndGggKiAyO1xuICAgICAgICB0aGlzLmNvbWIgPSBuZXcgQXJyYXkoaW1heCk7XG4gICAgICAgIHRoaXMuY29tYm91dCA9IG5ldyBBcnJheShpbWF4KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5jb21iW2ldICAgID0gbmV3IENvbWJGaWx0ZXIoQ29tYlBhcmFtc1tpICUgQ29tYlBhcmFtcy5sZW5ndGhdICogayk7XG4gICAgICAgICAgICB0aGlzLmNvbWJvdXRbaV0gPSBuZXcgVC5mbi5TaWduYWxBcnJheShidWZmZXJzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltYXggPSBBbGxwYXNzUGFyYW1zLmxlbmd0aCAqIDI7XG4gICAgICAgIHRoaXMuYWxscGFzcyA9IG5ldyBBcnJheShpbWF4KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hbGxwYXNzW2ldID0gbmV3IEFsbHBhc3NGaWx0ZXIoQWxscGFzc1BhcmFtc1tpICUgQWxscGFzc1BhcmFtcy5sZW5ndGhdICogayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRzID0gWyBuZXcgVC5mbi5TaWduYWxBcnJheShidWZmZXJzaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVC5mbi5TaWduYWxBcnJheShidWZmZXJzaXplKSBdO1xuICAgICAgICB0aGlzLmRhbXAgPSAwO1xuICAgICAgICB0aGlzLndldCAgPSAwLjMzO1xuXG4gICAgICAgIHRoaXMuc2V0Um9vbVNpemUoMC41KTtcbiAgICAgICAgdGhpcy5zZXREYW1wKDAuNSk7XG4gICAgfVxuXG4gICAgdmFyICQgPSBSZXZlcmIucHJvdG90eXBlO1xuXG4gICAgJC5zZXRSb29tU2l6ZSA9IGZ1bmN0aW9uKHJvb21zaXplKSB7XG4gICAgICAgIHZhciBjb21iID0gdGhpcy5jb21iO1xuICAgICAgICB2YXIgdmFsdWUgPSAocm9vbXNpemUgKiAwLjI4KSArIDAuNztcbiAgICAgICAgdGhpcy5yb29tc2l6ZSA9IHJvb21zaXplO1xuICAgICAgICBjb21iWzBdLmZlZWRiYWNrID0gY29tYlsxXS5mZWVkYmFjayA9IGNvbWJbMl0uZmVlZGJhY2sgPSBjb21iWzNdLmZlZWRiYWNrID0gY29tYls0XS5mZWVkYmFjayA9IGNvbWJbNV0uZmVlZGJhY2sgPSBjb21iWzZdLmZlZWRiYWNrID0gY29tYls3XS5mZWVkYmFjayA9IGNvbWJbOF0uZmVlZGJhY2sgPSBjb21iWzldLmZlZWRiYWNrID0gY29tYlsxMF0uZmVlZGJhY2sgPSBjb21iWzExXS5mZWVkYmFjayA9IGNvbWJbMTJdLmZlZWRiYWNrID0gY29tYlsxM10uZmVlZGJhY2sgPSBjb21iWzE0XS5mZWVkYmFjayA9IGNvbWJbMTVdLmZlZWRiYWNrID0gdmFsdWU7XG4gICAgfTtcbiAgICAkLnNldERhbXAgPSBmdW5jdGlvbihkYW1wKSB7XG4gICAgICAgIHZhciBjb21iID0gdGhpcy5jb21iO1xuICAgICAgICB2YXIgdmFsdWUgPSBkYW1wICogMC40O1xuICAgICAgICB0aGlzLmRhbXAgPSBkYW1wO1xuICAgICAgICBjb21iWzBdLmRhbXAgPSBjb21iWzFdLmRhbXAgPSBjb21iWzJdLmRhbXAgPSBjb21iWzNdLmRhbXAgPSBjb21iWzRdLmRhbXAgPSBjb21iWzVdLmRhbXAgPSBjb21iWzZdLmRhbXAgPSBjb21iWzddLmRhbXAgPSBjb21iWzhdLmRhbXAgPSBjb21iWzldLmRhbXAgPSBjb21iWzEwXS5kYW1wID0gY29tYlsxMV0uZGFtcCA9IGNvbWJbMTJdLmRhbXAgPSBjb21iWzEzXS5kYW1wID0gY29tYlsxNF0uZGFtcCA9IGNvbWJbMTVdLmRhbXAgPSB2YWx1ZTtcblxuICAgIH07XG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24oY2VsbEwsIGNlbGxSKSB7XG4gICAgICAgIHZhciBjb21iID0gdGhpcy5jb21iO1xuICAgICAgICB2YXIgY29tYm91dCA9IHRoaXMuY29tYm91dDtcbiAgICAgICAgdmFyIGFsbHBhc3MgPSB0aGlzLmFsbHBhc3M7XG4gICAgICAgIHZhciBvdXRwdXQwID0gdGhpcy5vdXRwdXRzWzBdO1xuICAgICAgICB2YXIgb3V0cHV0MSA9IHRoaXMub3V0cHV0c1sxXTtcbiAgICAgICAgdmFyIHdldCA9IHRoaXMud2V0LCBkcnkgPSAxIC0gd2V0O1xuICAgICAgICB2YXIgaSwgaW1heCA9IGNlbGxMLmxlbmd0aDtcblxuICAgICAgICBjb21iWzBdLnByb2Nlc3MoY2VsbEwsIGNvbWJvdXRbMF0pO1xuICAgICAgICBjb21iWzFdLnByb2Nlc3MoY2VsbEwsIGNvbWJvdXRbMV0pO1xuICAgICAgICBjb21iWzJdLnByb2Nlc3MoY2VsbEwsIGNvbWJvdXRbMl0pO1xuICAgICAgICBjb21iWzNdLnByb2Nlc3MoY2VsbEwsIGNvbWJvdXRbM10pO1xuICAgICAgICBjb21iWzRdLnByb2Nlc3MoY2VsbEwsIGNvbWJvdXRbNF0pO1xuICAgICAgICBjb21iWzVdLnByb2Nlc3MoY2VsbEwsIGNvbWJvdXRbNV0pO1xuICAgICAgICBjb21iWzZdLnByb2Nlc3MoY2VsbEwsIGNvbWJvdXRbNl0pO1xuICAgICAgICBjb21iWzddLnByb2Nlc3MoY2VsbEwsIGNvbWJvdXRbN10pO1xuXG4gICAgICAgIGNvbWJbIDhdLnByb2Nlc3MoY2VsbFIsIGNvbWJvdXRbIDhdKTtcbiAgICAgICAgY29tYlsgOV0ucHJvY2VzcyhjZWxsUiwgY29tYm91dFsgOV0pO1xuICAgICAgICBjb21iWzEwXS5wcm9jZXNzKGNlbGxSLCBjb21ib3V0WzEwXSk7XG4gICAgICAgIGNvbWJbMTFdLnByb2Nlc3MoY2VsbFIsIGNvbWJvdXRbMTFdKTtcbiAgICAgICAgY29tYlsxMl0ucHJvY2VzcyhjZWxsUiwgY29tYm91dFsxMl0pO1xuICAgICAgICBjb21iWzEzXS5wcm9jZXNzKGNlbGxSLCBjb21ib3V0WzEzXSk7XG4gICAgICAgIGNvbWJbMTRdLnByb2Nlc3MoY2VsbFIsIGNvbWJvdXRbMTRdKTtcbiAgICAgICAgY29tYlsxNV0ucHJvY2VzcyhjZWxsUiwgY29tYm91dFsxNV0pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgIG91dHB1dDBbaV0gPSBjb21ib3V0WzBdW2ldICsgY29tYm91dFsxXVtpXSArIGNvbWJvdXRbMl1baV0gKyBjb21ib3V0WzNdW2ldICsgY29tYm91dFs0XVtpXSArIGNvbWJvdXRbNV1baV0gKyBjb21ib3V0WzZdW2ldICsgY29tYm91dFs3XVtpXTtcbiAgICAgICAgICAgIG91dHB1dDFbaV0gPSBjb21ib3V0WzhdW2ldICsgY29tYm91dFs5XVtpXSArIGNvbWJvdXRbMTBdW2ldICsgY29tYm91dFsxMV1baV0gKyBjb21ib3V0WzEyXVtpXSArIGNvbWJvdXRbMTNdW2ldICsgY29tYm91dFsxNF1baV0gKyBjb21ib3V0WzE1XVtpXTtcbiAgICAgICAgfVxuICAgICAgICBhbGxwYXNzWzBdLnByb2Nlc3Mob3V0cHV0MCwgb3V0cHV0MCk7XG4gICAgICAgIGFsbHBhc3NbMV0ucHJvY2VzcyhvdXRwdXQwLCBvdXRwdXQwKTtcbiAgICAgICAgYWxscGFzc1syXS5wcm9jZXNzKG91dHB1dDAsIG91dHB1dDApO1xuICAgICAgICBhbGxwYXNzWzNdLnByb2Nlc3Mob3V0cHV0MCwgb3V0cHV0MCk7XG5cbiAgICAgICAgYWxscGFzc1s0XS5wcm9jZXNzKG91dHB1dDEsIG91dHB1dDEpO1xuICAgICAgICBhbGxwYXNzWzVdLnByb2Nlc3Mob3V0cHV0MSwgb3V0cHV0MSk7XG4gICAgICAgIGFsbHBhc3NbNl0ucHJvY2VzcyhvdXRwdXQxLCBvdXRwdXQxKTtcbiAgICAgICAgYWxscGFzc1s3XS5wcm9jZXNzKG91dHB1dDEsIG91dHB1dDEpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgIGNlbGxMW2ldID0gb3V0cHV0MFtpXSAqIHdldCArIGNlbGxMW2ldICogZHJ5O1xuICAgICAgICAgICAgY2VsbFJbaV0gPSBvdXRwdXQxW2ldICogd2V0ICsgY2VsbFJbaV0gKiBkcnk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQ29tYkZpbHRlcihidWZmZXJzaXplKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFQuZm4uU2lnbmFsQXJyYXkoYnVmZmVyc2l6ZXwwKTtcbiAgICAgICAgdGhpcy5idWZmZXJzaXplID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ1ZmlkeCA9IDA7XG4gICAgICAgIHRoaXMuZmVlZGJhY2sgPSAgMDtcbiAgICAgICAgdGhpcy5maWx0ZXJzdG9yZSA9IDA7XG4gICAgICAgIHRoaXMuZGFtcCA9IDA7XG4gICAgfVxuXG4gICAgQ29tYkZpbHRlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGlucywgb3V0cztcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB2YXIgYnVmZmVyc2l6ZSA9IHRoaXMuYnVmZmVyc2l6ZTtcbiAgICAgICAgdmFyIGJ1ZmlkeCA9IHRoaXMuYnVmaWR4O1xuICAgICAgICB2YXIgZmlsdGVyc3RvcmUgPSB0aGlzLmZpbHRlcnN0b3JlO1xuICAgICAgICB2YXIgZmVlZGJhY2sgPSB0aGlzLmZlZWRiYWNrO1xuICAgICAgICB2YXIgZGFtcDEgPSB0aGlzLmRhbXAsIGRhbXAyID0gMSAtIGRhbXAxO1xuICAgICAgICB2YXIgaSwgaW1heCA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICBpbnMgPSBpbnB1dFtpXSAqIDAuMDE1O1xuICAgICAgICAgICAgb3V0cyA9IGJ1ZmZlcltidWZpZHhdO1xuXG4gICAgICAgICAgICBmaWx0ZXJzdG9yZSA9IChvdXRzICogZGFtcDIpICsgKGZpbHRlcnN0b3JlICogZGFtcDEpO1xuXG4gICAgICAgICAgICBidWZmZXJbYnVmaWR4XSA9IGlucyArIChmaWx0ZXJzdG9yZSAqIGZlZWRiYWNrKTtcblxuICAgICAgICAgICAgaWYgKCsrYnVmaWR4ID49IGJ1ZmZlcnNpemUpIHtcbiAgICAgICAgICAgICAgICBidWZpZHggPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXRwdXRbaV0gPSBvdXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWZpZHggPSBidWZpZHg7XG4gICAgICAgIHRoaXMuZmlsdGVyc3RvcmUgPSBmaWx0ZXJzdG9yZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQWxscGFzc0ZpbHRlcihidWZmZXJzaXplKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFQuZm4uU2lnbmFsQXJyYXkoYnVmZmVyc2l6ZXwwKTtcbiAgICAgICAgdGhpcy5idWZmZXJzaXplID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ1ZmlkeCA9IDA7XG4gICAgfVxuXG4gICAgQWxscGFzc0ZpbHRlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGlucywgb3V0cywgYnVmb3V0O1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHZhciBidWZmZXJzaXplID0gdGhpcy5idWZmZXJzaXplO1xuICAgICAgICB2YXIgYnVmaWR4ID0gdGhpcy5idWZpZHg7XG4gICAgICAgIHZhciBpLCBpbWF4ID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgIGlucyA9IGlucHV0W2ldO1xuXG4gICAgICAgICAgICBidWZvdXQgPSBidWZmZXJbYnVmaWR4XTtcblxuICAgICAgICAgICAgb3V0cyA9IC1pbnMgKyBidWZvdXQ7XG4gICAgICAgICAgICBidWZmZXJbYnVmaWR4XSA9IGlucyArIChidWZvdXQgKiAwLjUpO1xuXG4gICAgICAgICAgICBpZiAoKytidWZpZHggPj0gYnVmZmVyc2l6ZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmlkeCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dHB1dFtpXSA9IG91dHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1ZmlkeCA9IGJ1ZmlkeDtcbiAgICB9O1xuXG4gICAgVC5tb2R1bGVzLlJldmVyYiA9IFJldmVyYjtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgRHVtbXlCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KDYwKTtcblxuICAgIGZ1bmN0aW9uIFNjaXNzb3Ioc291bmRidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXBlKHNvdW5kYnVmZmVyKTtcbiAgICB9XG5cbiAgICB2YXIgc2lsZW5jZWJ1ZmZlciA9IHtcbiAgICAgICAgYnVmZmVyOkR1bW15QnVmZmVyLCBzYW1wbGVyYXRlOjFcbiAgICB9O1xuXG4gICAgU2Npc3Nvci5zaWxlbmNlID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2lzc29yKHNpbGVuY2VidWZmZXIpLnNsaWNlKDAsIDEpLmZpbGwoZHVyYXRpb24pO1xuICAgIH07XG5cbiAgICBTY2lzc29yLmpvaW4gPSBmdW5jdGlvbih0YXBlcykge1xuICAgICAgICB2YXIgbmV3X2luc3RhbmNlID0gbmV3IFRhcGUoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGFwZXNbaV0gaW5zdGFuY2VvZiBUYXBlKSB7XG4gICAgICAgICAgICAgICAgbmV3X2luc3RhbmNlLmFkZF9mcmFnbWVudHModGFwZXNbaV0uZnJhZ21lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdfaW5zdGFuY2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFRhcGUoc291bmRidWZmZXIpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgICAgICAgaWYgKHNvdW5kYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgc2FtcGxlcmF0ZSA9IHNvdW5kYnVmZmVyLnNhbXBsZXJhdGUgfHwgNDQxMDA7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gICA9IHNvdW5kYnVmZmVyLmJ1ZmZlclswXS5sZW5ndGggLyBzYW1wbGVyYXRlO1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgRnJhZ21lbnQoc291bmRidWZmZXIsIDAsIGR1cmF0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTY2lzc29yLlRhcGUgPSBUYXBlO1xuXG4gICAgVGFwZS5wcm90b3R5cGUuYWRkX2ZyYWdtZW50ID0gZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMucHVzaChmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBUYXBlLnByb3RvdHlwZS5hZGRfZnJhZ21lbnRzID0gZnVuY3Rpb24oZnJhZ21lbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50cy5wdXNoKGZyYWdtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFRhcGUucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5mcmFnbWVudHNbaV0uZHVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBUYXBlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpO1xuICAgICAgICBpZiAoc3RhcnQgKyBsZW5ndGggPiBkdXJhdGlvbikge1xuICAgICAgICAgICAgbGVuZ3RoID0gZHVyYXRpb24gLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdfaW5zdGFuY2UgID0gbmV3IFRhcGUoKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ3N0YXJ0ICA9IHN0YXJ0O1xuICAgICAgICB2YXIgcmVtYWluaW5nbGVuZ3RoID0gbGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gZnJhZ21lbnQuY3JlYXRlKHJlbWFpbmluZ3N0YXJ0LCByZW1haW5pbmdsZW5ndGgpO1xuICAgICAgICAgICAgdmFyIG5ld19mcmFnbWVudCA9IGl0ZW1zWzBdO1xuICAgICAgICAgICAgcmVtYWluaW5nc3RhcnQgID0gaXRlbXNbMV07XG4gICAgICAgICAgICByZW1haW5pbmdsZW5ndGggPSBpdGVtc1syXTtcbiAgICAgICAgICAgIGlmIChuZXdfZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBuZXdfaW5zdGFuY2UuYWRkX2ZyYWdtZW50KG5ld19mcmFnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3X2luc3RhbmNlO1xuICAgIH07XG4gICAgVGFwZS5wcm90b3R5cGUuY3V0ID0gVGFwZS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICBUYXBlLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICB2YXIgbmV3X2luc3RhbmNlID0gbmV3IFRhcGUoKTtcbiAgICAgICAgbmV3X2luc3RhbmNlLmFkZF9mcmFnbWVudHModGhpcy5mcmFnbWVudHMpO1xuICAgICAgICBuZXdfaW5zdGFuY2UuYWRkX2ZyYWdtZW50cyhvdGhlci5mcmFnbWVudHMpO1xuICAgICAgICByZXR1cm4gbmV3X2luc3RhbmNlO1xuICAgIH07XG5cbiAgICBUYXBlLnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvcmlnX2ZyYWdtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9yaWdfZnJhZ21lbnRzLnB1c2godGhpcy5mcmFnbWVudHNbaV0uY2xvbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld19pbnN0YW5jZSA9IG5ldyBUYXBlKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrICkge1xuICAgICAgICAgICAgbmV3X2luc3RhbmNlLmFkZF9mcmFnbWVudHMob3JpZ19mcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdfaW5zdGFuY2U7XG4gICAgfTtcblxuICAgIFRhcGUucHJvdG90eXBlLnRpbWVzID0gVGFwZS5wcm90b3R5cGUubG9vcDtcblxuICAgIFRhcGUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgdmFyIHNwbGl0dGVkX2R1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpIC8gY291bnQ7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuc2xpY2UoaSAqIHNwbGl0dGVkX2R1cmF0aW9uLCBzcGxpdHRlZF9kdXJhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICBUYXBlLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24oZmlsbGVkX2R1cmF0aW9uKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkVtcHR5RnJhZ21lbnRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9vcF9jb3VudCA9IChmaWxsZWRfZHVyYXRpb24gLyBkdXJhdGlvbil8MDtcbiAgICAgICAgdmFyIHJlbWFpbiA9IGZpbGxlZF9kdXJhdGlvbiAlIGR1cmF0aW9uO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxvb3AobG9vcF9jb3VudCkucGx1cyh0aGlzLnNsaWNlKDAsIHJlbWFpbikpO1xuICAgIH07XG5cbiAgICBUYXBlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oc3RhcnQsIGxlbmd0aCwgcmVwbGFjZWQpIHtcbiAgICAgICAgdmFyIG5ld19pbnN0YW5jZSA9IG5ldyBUYXBlKCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgICBuZXdfaW5zdGFuY2UgPSBuZXdfaW5zdGFuY2UucGx1cyh0aGlzLnNsaWNlKDAsIHN0YXJ0KSk7XG5cbiAgICAgICAgdmFyIG5ld19pbnN0YW5jZV9kdXJhdGlvbiA9IG5ld19pbnN0YW5jZS5kdXJhdGlvbigpO1xuICAgICAgICBpZiAobmV3X2luc3RhbmNlX2R1cmF0aW9uIDwgc3RhcnQpIHtcbiAgICAgICAgICAgIG5ld19pbnN0YW5jZSA9IG5ld19pbnN0YW5jZS5wbHVzKFNjaXNzb3Iuc2lsZW5jZShzdGFydC1uZXdfaW5zdGFuY2VfZHVyYXRpb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld19pbnN0YW5jZSA9IG5ld19pbnN0YW5jZS5wbHVzKHJlcGxhY2VkKTtcblxuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCk7XG4gICAgICAgIGlmIChkdXJhdGlvbiA+IG9mZnNldCkge1xuICAgICAgICAgICAgbmV3X2luc3RhbmNlID0gbmV3X2luc3RhbmNlLnBsdXModGhpcy5zbGljZShvZmZzZXQsIGR1cmF0aW9uIC0gb2Zmc2V0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3X2luc3RhbmNlO1xuICAgIH07XG5cbiAgICBUYXBlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdfaW5zdGFuY2UgPSBuZXcgVGFwZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1tpXS5jbG9uZSgpO1xuICAgICAgICAgICAgZnJhZ21lbnQucmV2ZXJzZSA9ICFmcmFnbWVudC5pc1JldmVyc2VkKCk7XG4gICAgICAgICAgICBuZXdfaW5zdGFuY2UuYWRkX2ZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdfaW5zdGFuY2U7XG4gICAgfTtcblxuICAgIFRhcGUucHJvdG90eXBlLnBpdGNoID0gZnVuY3Rpb24ocGl0Y2gsIHN0cmV0Y2gpIHtcbiAgICAgICAgdmFyIG5ld19pbnN0YW5jZSA9IG5ldyBUYXBlKCk7XG5cbiAgICAgICAgc3RyZXRjaCA9IHN0cmV0Y2ggfHwgZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzW2ldLmNsb25lKCk7XG4gICAgICAgICAgICBmcmFnbWVudC5waXRjaCAgKj0gcGl0Y2ggKiAwLjAxO1xuICAgICAgICAgICAgZnJhZ21lbnQuc3RyZXRjaCA9IHN0cmV0Y2g7XG4gICAgICAgICAgICBuZXdfaW5zdGFuY2UuYWRkX2ZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdfaW5zdGFuY2U7XG4gICAgfTtcblxuICAgIFRhcGUucHJvdG90eXBlLnN0cmV0Y2ggPSBmdW5jdGlvbihmYWN0b3IpIHtcbiAgICAgICAgdmFyIGZhY3Rvcl9mb3JfcGl0Y2ggPSAxIC8gKGZhY3RvciAqIDAuMDEpICogMTAwO1xuICAgICAgICByZXR1cm4gdGhpcy5waXRjaChmYWN0b3JfZm9yX3BpdGNoLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgVGFwZS5wcm90b3R5cGUucGFuID0gZnVuY3Rpb24ocmlnaHRfcGVyY2VudCkge1xuICAgICAgICB2YXIgbmV3X2luc3RhbmNlID0gbmV3IFRhcGUoKTtcbiAgICAgICAgaWYgKHJpZ2h0X3BlcmNlbnQgPiAxMDApIHtcbiAgICAgICAgICAgIHJpZ2h0X3BlcmNlbnQgPSAxMDA7XG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHRfcGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgIHJpZ2h0X3BlcmNlbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzW2ldLmNsb25lKCk7XG4gICAgICAgICAgICBmcmFnbWVudC5wYW4gPSByaWdodF9wZXJjZW50O1xuICAgICAgICAgICAgbmV3X2luc3RhbmNlLmFkZF9mcmFnbWVudChmcmFnbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3X2luc3RhbmNlO1xuICAgIH07XG5cbiAgICBUYXBlLnByb3RvdHlwZS5zaWxlbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTY2lzc29yLnNpbGVuY2UodGhpcy5kdXJhdGlvbigpKTtcbiAgICB9O1xuXG4gICAgVGFwZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKHRhcGVzKSB7XG4gICAgICAgIHZhciBuZXdfaW5zdGFuY2UgPSBuZXcgVGFwZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0YXBlc1tpXSBpbnN0YW5jZW9mIFRhcGUpIHtcbiAgICAgICAgICAgICAgICBuZXdfaW5zdGFuY2UuYWRkX2ZyYWdtZW50cyh0YXBlc1tpXS5mcmFnbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld19pbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgVGFwZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzYW1wbGVyYXRlID0gNDQxMDA7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzYW1wbGVyYXRlID0gdGhpcy5mcmFnbWVudHNbMF0uc2FtcGxlcmF0ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZWFtID0gbmV3IFRhcGVTdHJlYW0odGhpcywgc2FtcGxlcmF0ZSk7XG4gICAgICAgIHZhciB0b3RhbF9zYW1wbGVzID0gKHRoaXMuZHVyYXRpb24oKSAqIHNhbXBsZXJhdGUpfDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzYW1wbGVyYXRlOiBzYW1wbGVyYXRlLFxuICAgICAgICAgICAgYnVmZmVyICAgIDogc3RyZWFtLmZldGNoKHRvdGFsX3NhbXBsZXMpXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZyYWdtZW50KHNvdW5kYnVmZmVyLCBzdGFydCwgZHVyYXRpb24sIHJldmVyc2UsIHBpdGNoLCBzdHJldGNoLCBwYW4pIHtcbiAgICAgICAgaWYgKCFzb3VuZGJ1ZmZlcikge1xuICAgICAgICAgICAgc291bmRidWZmZXIgPSBzaWxlbmNlYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyICAgICA9IHNvdW5kYnVmZmVyLmJ1ZmZlclswXTtcbiAgICAgICAgdGhpcy5zYW1wbGVyYXRlID0gc291bmRidWZmZXIuc2FtcGxlcmF0ZSB8fCA0NDEwMDtcbiAgICAgICAgdGhpcy5zdGFydCAgICAgPSBzdGFydDtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5yZXZlcnNlID0gcmV2ZXJzZSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5waXRjaCAgID0gcGl0Y2ggICB8fCAxMDA7XG4gICAgICAgIHRoaXMuc3RyZXRjaCA9IHN0cmV0Y2ggfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucGFuICAgICA9IHBhbiAgICAgfHwgNTA7XG4gICAgfVxuXG4gICAgRnJhZ21lbnQucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbiAqICgxMDAgLyB0aGlzLnBpdGNoKTtcbiAgICB9O1xuICAgIEZyYWdtZW50LnByb3RvdHlwZS5vcmlnaW5hbF9kdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gICAgfTtcbiAgICBGcmFnbWVudC5wcm90b3R5cGUuaXNSZXZlcnNlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlO1xuICAgIH07XG4gICAgRnJhZ21lbnQucHJvdG90eXBlLmlzU3RyZXRjaGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmV0Y2hlZDtcbiAgICB9O1xuICAgIEZyYWdtZW50LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihyZW1haW5pbmdfc3RhcnQsIHJlbWFpbmluZ19sZW5ndGgpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpO1xuICAgICAgICBpZiAocmVtYWluaW5nX3N0YXJ0ID49IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIHJlbWFpbmluZ19zdGFydCAtIGR1cmF0aW9uLCByZW1haW5pbmdfbGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXZlX3JlbWFpbl90b19yZXR1ZW4gPSAocmVtYWluaW5nX3N0YXJ0ICsgcmVtYWluaW5nX2xlbmd0aCkgPj0gZHVyYXRpb247XG5cbiAgICAgICAgdmFyIG5ld19sZW5ndGg7XG4gICAgICAgIGlmIChoYXZlX3JlbWFpbl90b19yZXR1ZW4pIHtcbiAgICAgICAgICAgIG5ld19sZW5ndGggPSBkdXJhdGlvbiAtIHJlbWFpbmluZ19zdGFydDtcbiAgICAgICAgICAgIHJlbWFpbmluZ19sZW5ndGggLT0gbmV3X2xlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld19sZW5ndGggPSByZW1haW5pbmdfbGVuZ3RoO1xuICAgICAgICAgICAgcmVtYWluaW5nX2xlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3X2ZyYWdtZW50ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBuZXdfZnJhZ21lbnQuc3RhcnQgICAgID0gdGhpcy5zdGFydCArIHJlbWFpbmluZ19zdGFydCAqIHRoaXMucGl0Y2ggKiAwLjAxO1xuICAgICAgICBuZXdfZnJhZ21lbnQuX2R1cmF0aW9uID0gbmV3X2xlbmd0aCAqIHRoaXMucGl0Y2ggKiAwLjAxO1xuICAgICAgICBuZXdfZnJhZ21lbnQucmV2ZXJzZSAgID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBbbmV3X2ZyYWdtZW50LCAwLCByZW1haW5pbmdfbGVuZ3RoXTtcbiAgICB9O1xuXG4gICAgRnJhZ21lbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdfaW5zdGFuY2UgPSBuZXcgRnJhZ21lbnQoKTtcbiAgICAgICAgbmV3X2luc3RhbmNlLmJ1ZmZlciAgICAgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbmV3X2luc3RhbmNlLnNhbXBsZXJhdGUgPSB0aGlzLnNhbXBsZXJhdGU7XG4gICAgICAgIG5ld19pbnN0YW5jZS5zdGFydCAgICAgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBuZXdfaW5zdGFuY2UuX2R1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIG5ld19pbnN0YW5jZS5yZXZlcnNlICAgPSB0aGlzLnJldmVyc2U7XG4gICAgICAgIG5ld19pbnN0YW5jZS5waXRjaCAgICAgPSB0aGlzLnBpdGNoO1xuICAgICAgICBuZXdfaW5zdGFuY2Uuc3RyZXRjaCAgID0gdGhpcy5zdHJldGNoO1xuICAgICAgICBuZXdfaW5zdGFuY2UucGFuICAgICAgID0gdGhpcy5wYW47XG4gICAgICAgIHJldHVybiBuZXdfaW5zdGFuY2U7XG4gICAgfTtcbiAgICBTY2lzc29yLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5cblxuICAgIGZ1bmN0aW9uIFRhcGVTdHJlYW0odGFwZSwgc2FtcGxlcmF0ZSkge1xuICAgICAgICB0aGlzLnRhcGUgPSB0YXBlO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyAgPSB0YXBlLmZyYWdtZW50cztcbiAgICAgICAgdGhpcy5zYW1wbGVyYXRlID0gc2FtcGxlcmF0ZSB8fCA0NDEwMDtcblxuICAgICAgICB0aGlzLmlzRW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgID0gbnVsbDtcbiAgICAgICAgdGhpcy5idWZmZXJJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVySW5kZXhJbmNyICA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyQmVnaW5JbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyRW5kSW5kZXggICA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucGFuTCA9IDAuNTtcbiAgICAgICAgdGhpcy5wYW5SID0gMC41O1xuICAgIH1cbiAgICBTY2lzc29yLlRhcGVTdHJlYW0gPSBUYXBlU3RyZWFtO1xuXG4gICAgVGFwZVN0cmVhbS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pc0VuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyICA9IG51bGw7XG4gICAgICAgIHRoaXMuYnVmZmVySW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlckluZGV4SW5jciAgPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlckJlZ2luSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlckVuZEluZGV4ICAgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYWdtZW50SW5kZXggPSAwO1xuICAgICAgICB0aGlzLnBhbkwgPSAwLjU7XG4gICAgICAgIHRoaXMucGFuUiA9IDAuNTtcbiAgICAgICAgdGhpcy5pc0xvb3BlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVGFwZVN0cmVhbS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBjZWxsTCA9IG5ldyBULmZuLlNpZ25hbEFycmF5KG4pO1xuICAgICAgICB2YXIgY2VsbFIgPSBuZXcgVC5mbi5TaWduYWxBcnJheShuKTtcbiAgICAgICAgdmFyIGZyYWdtZW50cyAgICAgPSB0aGlzLmZyYWdtZW50cztcblxuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjZWxsTCwgY2VsbFJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNhbXBsZXJhdGUgID0gdGhpcy5zYW1wbGVyYXRlICogMTAwO1xuICAgICAgICB2YXIgYnVmZmVyICAgICAgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdmFyIGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJJbmRleDtcbiAgICAgICAgdmFyIGJ1ZmZlckluZGV4SW5jciA9IHRoaXMuYnVmZmVySW5kZXhJbmNyO1xuICAgICAgICB2YXIgYnVmZmVyQmVnaW5JbmRleCA9IHRoaXMuYnVmZmVyQmVnaW5JbmRleDtcbiAgICAgICAgdmFyIGJ1ZmZlckVuZEluZGV4ICAgPSB0aGlzLmJ1ZmZlckVuZEluZGV4O1xuICAgICAgICB2YXIgZnJhZ21lbnQgICAgICA9IHRoaXMuZnJhZ21lbnQ7XG4gICAgICAgIHZhciBmcmFnbWVudEluZGV4ID0gdGhpcy5mcmFnbWVudEluZGV4O1xuICAgICAgICB2YXIgcGFuO1xuICAgICAgICB2YXIgcGFuTCA9IHRoaXMucGFuTDtcbiAgICAgICAgdmFyIHBhblIgPSB0aGlzLnBhblI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHdoaWxlICghYnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXggPCBidWZmZXJCZWdpbkluZGV4IHx8IGJ1ZmZlckluZGV4ID49IGJ1ZmZlckVuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmcmFnbWVudCB8fCBmcmFnbWVudEluZGV4IDwgZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50c1tmcmFnbWVudEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgICA9IGZyYWdtZW50LmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhJbmNyID0gZnJhZ21lbnQuc2FtcGxlcmF0ZSAvIHNhbXBsZXJhdGUgKiBmcmFnbWVudC5waXRjaDtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyQmVnaW5JbmRleCA9IGZyYWdtZW50LnN0YXJ0ICogZnJhZ21lbnQuc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyRW5kSW5kZXggICA9IGJ1ZmZlckJlZ2luSW5kZXggKyBmcmFnbWVudC5vcmlnaW5hbF9kdXJhdGlvbigpICogZnJhZ21lbnQuc2FtcGxlcmF0ZTtcblxuICAgICAgICAgICAgICAgICAgICBwYW4gPSAoZnJhZ21lbnQucGFuICogMC4wMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhbkwgPSAxIC0gcGFuO1xuICAgICAgICAgICAgICAgICAgICBwYW5SID0gcGFuO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5yZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleEluY3IgKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleCA9IGJ1ZmZlckVuZEluZGV4ICsgYnVmZmVySW5kZXhJbmNyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXggPSBidWZmZXJCZWdpbkluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMb29wZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhJbmNyICA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJCZWdpbkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckVuZEluZGV4ICAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgICAgICA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNFbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgICA9IER1bW15QnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhJbmNyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbExbaV0gPSBidWZmZXJbYnVmZmVySW5kZXh8MF0gKiBwYW5MO1xuICAgICAgICAgICAgY2VsbFJbaV0gPSBidWZmZXJbYnVmZmVySW5kZXh8MF0gKiBwYW5SO1xuICAgICAgICAgICAgYnVmZmVySW5kZXggKz0gYnVmZmVySW5kZXhJbmNyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyICAgICAgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVySW5kZXggPSBidWZmZXJJbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXJJbmRleEluY3IgID0gYnVmZmVySW5kZXhJbmNyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJlZ2luSW5kZXggPSBidWZmZXJCZWdpbkluZGV4O1xuICAgICAgICB0aGlzLmJ1ZmZlckVuZEluZGV4ICAgPSBidWZmZXJFbmRJbmRleDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCAgICAgID0gZnJhZ21lbnQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRJbmRleCA9IGZyYWdtZW50SW5kZXg7XG4gICAgICAgIHRoaXMucGFuTCA9IHBhbkw7XG4gICAgICAgIHRoaXMucGFuUiA9IHBhblI7XG5cbiAgICAgICAgcmV0dXJuIFtjZWxsTCwgY2VsbFJdO1xuICAgIH07XG5cbiAgICBULm1vZHVsZXMuU2Npc3NvciA9IFNjaXNzb3I7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gU3RlcmVvRGVsYXkoc2FtcGxlcmF0ZSkge1xuICAgICAgICB0aGlzLnNhbXBsZXJhdGUgPSBzYW1wbGVyYXRlO1xuXG4gICAgICAgIHZhciBiaXRzID0gTWF0aC5jZWlsKE1hdGgubG9nKHNhbXBsZXJhdGUgKiAxLjUpICogTWF0aC5MT0cyRSk7XG5cbiAgICAgICAgdGhpcy5idWZmZXJzaXplID0gMSA8PCBiaXRzO1xuICAgICAgICB0aGlzLmJ1ZmZlcm1hc2sgPSB0aGlzLmJ1ZmZlcnNpemUgLSAxO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyTCA9IG5ldyBULmZuLlNpZ25hbEFycmF5KHRoaXMuYnVmZmVyc2l6ZSk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJSID0gbmV3IFQuZm4uU2lnbmFsQXJyYXkodGhpcy5idWZmZXJzaXplKTtcbiAgICAgICAgdGhpcy5yZWFkQnVmZmVyTCA9IHRoaXMud3JpdGVCdWZmZXJMO1xuICAgICAgICB0aGlzLnJlYWRCdWZmZXJSID0gdGhpcy53cml0ZUJ1ZmZlclI7XG4gICAgICAgIHRoaXMuZGVsYXl0aW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5mZWVkYmFjayAgPSBudWxsO1xuICAgICAgICB0aGlzLmNyb3NzID0gbnVsbDtcbiAgICAgICAgdGhpcy5taXggICA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldkwgPSAwO1xuICAgICAgICB0aGlzLnByZXZSID0gMDtcblxuICAgICAgICB0aGlzLnJlYWRJbmRleCAgPSAwO1xuICAgICAgICB0aGlzLndyaXRlSW5kZXggPSAwO1xuXG4gICAgICAgIHRoaXMuc2V0UGFyYW1zKDEyNSwgMC4yNSwgZmFsc2UsIDAuNDUpO1xuICAgIH1cblxuICAgIHZhciAkID0gU3RlcmVvRGVsYXkucHJvdG90eXBlO1xuXG4gICAgJC5zZXRQYXJhbXMgPSBmdW5jdGlvbihkZWxheXRpbWUsIGZlZWRiYWNrLCBjcm9zcyAsbWl4KSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5dGltZSAhPT0gZGVsYXl0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5dGltZSA9IGRlbGF5dGltZTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoZGVsYXl0aW1lICogMC4wMDEgKiB0aGlzLnNhbXBsZXJhdGUpfDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gdGhpcy5idWZmZXJtYXNrKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5idWZmZXJtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4ID0gKHRoaXMucmVhZEluZGV4ICsgb2Zmc2V0KSAmIHRoaXMuYnVmZmVybWFzaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mZWVkYmFjayAhPT0gZmVlZGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2sgPSBmZWVkYmFjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jcm9zcyAhPT0gY3Jvc3MpIHtcbiAgICAgICAgICAgIHRoaXMuY3Jvc3MgPSBjcm9zcztcbiAgICAgICAgICAgIGlmIChjcm9zcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlckwgPSB0aGlzLndyaXRlQnVmZmVyUjtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRCdWZmZXJSID0gdGhpcy53cml0ZUJ1ZmZlckw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlckwgPSB0aGlzLndyaXRlQnVmZmVyTDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRCdWZmZXJSID0gdGhpcy53cml0ZUJ1ZmZlclI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWl4ICE9PSBtaXgpIHtcbiAgICAgICAgICAgIHRoaXMubWl4ID0gbWl4O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKGNlbGxMLCBjZWxsUikge1xuICAgICAgICB2YXIgcmVhZEJ1ZmZlckwgPSB0aGlzLnJlYWRCdWZmZXJMO1xuICAgICAgICB2YXIgcmVhZEJ1ZmZlclIgPSB0aGlzLnJlYWRCdWZmZXJSO1xuICAgICAgICB2YXIgd3JpdGVCdWZmZXJMID0gdGhpcy53cml0ZUJ1ZmZlckw7XG4gICAgICAgIHZhciB3cml0ZUJ1ZmZlclIgPSB0aGlzLndyaXRlQnVmZmVyUjtcbiAgICAgICAgdmFyIHJlYWRJbmRleCAgPSB0aGlzLnJlYWRJbmRleDtcbiAgICAgICAgdmFyIHdyaXRlSW5kZXggPSB0aGlzLndyaXRlSW5kZXg7XG4gICAgICAgIHZhciBtYXNrID0gdGhpcy5idWZmZXJtYXNrO1xuICAgICAgICB2YXIgZmIgPSB0aGlzLmZlZWRiYWNrO1xuICAgICAgICB2YXIgd2V0ID0gdGhpcy5taXgsIGRyeSA9IDEgLSB3ZXQ7XG4gICAgICAgIHZhciBwcmV2TCA9IHRoaXMucHJldkw7XG4gICAgICAgIHZhciBwcmV2UiA9IHRoaXMucHJldlI7XG5cbiAgICAgICAgdmFyIHg7XG4gICAgICAgIHZhciBpLCBpbWF4ID0gY2VsbEwubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgIHggPSByZWFkQnVmZmVyTFtyZWFkSW5kZXhdO1xuICAgICAgICAgICAgd3JpdGVCdWZmZXJMW3dyaXRlSW5kZXhdID0gY2VsbExbaV0gLSB4ICogZmI7XG4gICAgICAgICAgICBjZWxsTFtpXSA9IHByZXZMID0gKChjZWxsTFtpXSAqIGRyeSkgKyAoeCAqIHdldCkgKyBwcmV2TCkgKiAwLjU7XG5cbiAgICAgICAgICAgIHggPSByZWFkQnVmZmVyUltyZWFkSW5kZXhdO1xuICAgICAgICAgICAgd3JpdGVCdWZmZXJSW3dyaXRlSW5kZXhdID0gY2VsbFJbaV0gLSB4ICogZmI7XG4gICAgICAgICAgICBjZWxsUltpXSA9IHByZXZSID0gKChjZWxsUltpXSAqIGRyeSkgKyAoeCAqIHdldCkgKyBwcmV2UikgKiAwLjU7XG5cbiAgICAgICAgICAgIHJlYWRJbmRleCAgKz0gMTtcbiAgICAgICAgICAgIHdyaXRlSW5kZXggPSAod3JpdGVJbmRleCArIDEpICYgbWFzaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVhZEluZGV4ICA9IHJlYWRJbmRleCAgJiB0aGlzLmJ1ZmZlcm1hc2s7XG4gICAgICAgIHRoaXMud3JpdGVJbmRleCA9IHdyaXRlSW5kZXg7XG4gICAgICAgIHRoaXMucHJldkwgPSBwcmV2TDtcbiAgICAgICAgdGhpcy5wcmV2UiA9IHByZXZSO1xuICAgIH07XG5cbiAgICBULm1vZHVsZXMuU3RlcmVvRGVsYXkgPSBTdGVyZW9EZWxheTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuICAgIHZhciBtb2R1bGVzID0gVC5tb2R1bGVzO1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJhdWRpb1wiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICB2YXIgQnVmZmVyTm9kZSA9IGZuLmdldENsYXNzKFwiYnVmZmVyXCIpO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQnVmZmVyTm9kZShfYXJncyk7XG5cbiAgICAgICAgaW5zdGFuY2UucGxheWJhY2tTdGF0ZSA9IGZuLkZJTklTSEVEX1NUQVRFO1xuICAgICAgICBpbnN0YW5jZS5fLmlzTG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW5zdGFuY2UsIHtcbiAgICAgICAgICAgIGlzTG9hZGVkOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5pc0xvYWRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGluc3RhbmNlLmxvYWQgICAgID0gbG9hZDtcbiAgICAgICAgaW5zdGFuY2UubG9hZHRoaXMgPSBsb2FkdGhpcztcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSk7XG5cbiAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uKHNyYykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIF8gPSB0aGlzLl87XG4gICAgICAgIHZhciBkZmQgPSBuZXcgbW9kdWxlcy5EZWZlcnJlZCh0aGlzKTtcblxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cywgaSA9IDE7XG5cbiAgICAgICAgZGZkLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl8uZW1pdChcImRvbmVcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkZmQuZG9uZShhcmdzW2krK10pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBkZmQuZmFpbChhcmdzW2krK10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXy5sb2FkZWRUaW1lID0gMDtcblxuICAgICAgICB2YXIgb25sb2FkZWRtZXRhZGF0YSA9IGZ1bmN0aW9uKHJlc3VsdCwgbXNnKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHNlbGYuXztcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXliYWNrU3RhdGUgPSBmbi5QTEFZSU5HX1NUQVRFO1xuICAgICAgICAgICAgICAgIF8uc2FtcGxlcmF0ZSA9IHJlc3VsdC5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgICAgIF8uY2hhbm5lbHMgICA9IHJlc3VsdC5jaGFubmVscztcbiAgICAgICAgICAgICAgICBfLmJ1ZmZlck1peCAgPSBudWxsO1xuICAgICAgICAgICAgICAgIF8uYnVmZmVyICAgICA9IHJlc3VsdC5idWZmZXI7XG4gICAgICAgICAgICAgICAgXy5waGFzZSAgICAgID0gMDtcbiAgICAgICAgICAgICAgICBfLnBoYXNlSW5jciAgPSByZXN1bHQuc2FtcGxlcmF0ZSAvIFQuc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgICAgICBfLmR1cmF0aW9uICAgPSByZXN1bHQuZHVyYXRpb24gKiAxMDAwO1xuICAgICAgICAgICAgICAgIF8uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChfLmlzUmV2ZXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5waGFzZUluY3IgKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgIF8ucGhhc2UgPSByZXN1bHQuYnVmZmVyWzBdLmxlbmd0aCArIF8ucGhhc2VJbmNyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLl8uZW1pdChcImxvYWRlZG1ldGFkYXRhXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZmQucmVqZWN0KG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9ubG9hZGVkZGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fLmlzTG9hZGVkICA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLl8ucGxvdEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYuXy5lbWl0KFwibG9hZGVkZGF0YVwiKTtcbiAgICAgICAgICAgIGRmZC5yZXNvbHZlV2l0aChzZWxmKTtcbiAgICAgICAgfTtcblxuICAgICAgICBuZXcgbW9kdWxlcy5EZWNvZGVyKCkuZGVjb2RlKHNyYywgb25sb2FkZWRtZXRhZGF0YSwgb25sb2FkZWRkYXRhKTtcblxuICAgICAgICByZXR1cm4gZGZkLnByb21pc2UoKTtcbiAgICB9O1xuXG4gICAgdmFyIGxvYWR0aGlzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gID0gVC5mbjtcbiAgICB2YXIgRkZUID0gVC5tb2R1bGVzLkZGVDtcbiAgICB2YXIgQmlxdWFkID0gVC5tb2R1bGVzLkJpcXVhZDtcbiAgICB2YXIgUExPVF9MT1dfRlJFUSA9IDIwO1xuXG4gICAgZnVuY3Rpb24gQmlxdWFkTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDIsIF9hcmdzKTtcbiAgICAgICAgZm4uZml4QVIodGhpcyk7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIF8uYmlxdWFkID0gbmV3IEJpcXVhZChfLnNhbXBsZXJhdGUpO1xuICAgICAgICBfLmZyZXEgPSBUKDM0MCk7XG4gICAgICAgIF8uYmFuZCA9IFQoMSk7XG4gICAgICAgIF8uZ2FpbiA9IFQoMCk7XG5cbiAgICAgICAgXy5wbG90QmVmb3JlID0gcGxvdEJlZm9yZTtcbiAgICAgICAgXy5wbG90UmFuZ2UgID0gWy0xOCwgMThdO1xuICAgICAgICBfLnBsb3RGbHVzaCAgPSB0cnVlO1xuICAgIH1cbiAgICBmbi5leHRlbmQoQmlxdWFkTm9kZSk7XG5cbiAgICB2YXIgcGxvdEJlZm9yZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZ2IoMTkyLCAxOTIsIDE5MilcIjtcbiAgICAgICAgdmFyIG55cXVpc3QgPSB0aGlzLl8uc2FtcGxlcmF0ZSAqIDAuNTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMTA7ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBpICogTWF0aC5wb3coMTAsIGopO1xuICAgICAgICAgICAgICAgIGlmIChmIDw9IFBMT1RfTE9XX0ZSRVEgfHwgbnlxdWlzdCA8PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBfeCA9IChNYXRoLmxvZyhmL1BMT1RfTE9XX0ZSRVEpKSAvIChNYXRoLmxvZyhueXF1aXN0L1BMT1RfTE9XX0ZSRVEpKTtcbiAgICAgICAgICAgICAgICBfeCA9ICgoX3ggKiB3aWR0aCArIHgpfDApICsgMC41O1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKF94LCB5KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhfeCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoID0gaGVpZ2h0IC8gNjtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHZhciBfeSA9ICgoeSArIChpICogaCkpfDApICsgMC41O1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgX3kpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCArIHdpZHRoLCBfeSk7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciAkID0gQmlxdWFkTm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IF8uYmlxdWFkLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5iaXF1YWQuc2V0VHlwZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIF8ucGxvdEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmJpcXVhZC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcmVxOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmZyZXEgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZnJlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3V0b2ZmOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmZyZXEgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZnJlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmJhbmQgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uYmFuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgUToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuXy5iYW5kID0gVCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmJhbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJhbmQ6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8uYmFuZCA9IFQodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5iYW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnYWluOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmdhaW4gPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZ2FpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgZm4uaW5wdXRTaWduYWxBUih0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGZyZXEgPSBfLmZyZXEucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgdmFyIGJhbmQgPSBfLmJhbmQucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgdmFyIGdhaW4gPSBfLmdhaW4ucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgaWYgKF8ucHJldkZyZXEgIT09IGZyZXEgfHwgXy5wcmV2YmFuZCAhPT0gYmFuZCB8fCBfLnByZXZHYWluICE9PSBnYWluKSB7XG4gICAgICAgICAgICAgICAgXy5wcmV2RnJlcSA9IGZyZXE7XG4gICAgICAgICAgICAgICAgXy5wcmV2YmFuZCA9IGJhbmQ7XG4gICAgICAgICAgICAgICAgXy5wcmV2R2FpbiA9IGdhaW47XG4gICAgICAgICAgICAgICAgXy5iaXF1YWQuc2V0UGFyYW1zKGZyZXEsIGJhbmQsIGdhaW4pO1xuICAgICAgICAgICAgICAgIF8ucGxvdEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfLmJ5cGFzc2VkKSB7XG4gICAgICAgICAgICAgICAgXy5iaXF1YWQucHJvY2Vzcyh0aGlzLmNlbGxzWzFdLCB0aGlzLmNlbGxzWzJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIGZmdCA9IG5ldyBGRlQoMjA0OCk7XG4gICAgdmFyIHN1cGVyX3Bsb3QgPSBULk9iamVjdC5wcm90b3R5cGUucGxvdDtcblxuICAgICQucGxvdCA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuXy5wbG90Rmx1c2gpIHtcbiAgICAgICAgICAgIHZhciBiaXF1YWQgPSBuZXcgQmlxdWFkKHRoaXMuXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgIGJpcXVhZC5zZXRUeXBlKHRoaXMudHlwZSk7XG4gICAgICAgICAgICBiaXF1YWQuc2V0UGFyYW1zKHRoaXMuZnJlcS52YWx1ZU9mKCksIHRoaXMuYmFuZC52YWx1ZU9mKCksIHRoaXMuZ2Fpbi52YWx1ZU9mKCkpO1xuXG4gICAgICAgICAgICB2YXIgaW1wbHVzZSA9IG5ldyBGbG9hdDMyQXJyYXkoZmZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpbXBsdXNlWzBdID0gMTtcblxuICAgICAgICAgICAgYmlxdWFkLnByb2Nlc3MoaW1wbHVzZSwgaW1wbHVzZSk7XG4gICAgICAgICAgICBmZnQuZm9yd2FyZChpbXBsdXNlKTtcblxuICAgICAgICAgICAgdmFyIHNpemUgPSA1MTI7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICB2YXIgbnlxdWlzdCAgPSB0aGlzLl8uc2FtcGxlcmF0ZSAqIDAuNTtcbiAgICAgICAgICAgIHZhciBzcGVjdHJ1bSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICB2YXIgaSwgaiwgZiwgaW5kZXgsIGRlbHRhLCB4MCwgeDEsIHh4O1xuXG4gICAgICAgICAgICBmZnQuZ2V0RnJlcXVlbmN5RGF0YShzcGVjdHJ1bSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICAgICAgZiA9IE1hdGgucG93KG55cXVpc3QgLyBQTE9UX0xPV19GUkVRLCBpIC8gc2l6ZSkgKiBQTE9UX0xPV19GUkVRO1xuICAgICAgICAgICAgICAgIGogPSBmIC8gKG55cXVpc3QgLyBzcGVjdHJ1bS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0ganwwO1xuICAgICAgICAgICAgICAgIGRlbHRhID0gaiAtIGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB4MSA9IHgwID0geHggPSBzcGVjdHJ1bVtpbmRleF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeDAgPSBzcGVjdHJ1bVtpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB4MSA9IHNwZWN0cnVtW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgeHggPSAoKDEuMCAtIGRlbHRhKSAqIHgwICsgZGVsdGEgKiB4MSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSB4eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuXy5wbG90RGF0YSAgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5fLnBsb3RGbHVzaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyX3Bsb3QuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJiaXF1YWRcIiwgQmlxdWFkTm9kZSk7XG4gICAgZm4ucmVnaXN0ZXIoXCJsb3dwYXNzXCIsIGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlxdWFkTm9kZShfYXJncykuc2V0KFwidHlwZVwiLCBcImxvd3Bhc3NcIik7XG4gICAgfSk7XG4gICAgZm4ucmVnaXN0ZXIoXCJoaWdocGFzc1wiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IEJpcXVhZE5vZGUoX2FyZ3MpLnNldChcInR5cGVcIiwgXCJoaWdocGFzc1wiKTtcbiAgICB9KTtcbiAgICBmbi5yZWdpc3RlcihcImJhbmRwYXNzXCIsIGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlxdWFkTm9kZShfYXJncykuc2V0KFwidHlwZVwiLCBcImJhbmRwYXNzXCIpO1xuICAgIH0pO1xuICAgIGZuLnJlZ2lzdGVyKFwibG93c2hlbGZcIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXF1YWROb2RlKF9hcmdzKS5zZXQoXCJ0eXBlXCIsIFwibG93c2hlbGZcIik7XG4gICAgfSk7XG4gICAgZm4ucmVnaXN0ZXIoXCJoaWdoc2hlbGZcIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXF1YWROb2RlKF9hcmdzKS5zZXQoXCJ0eXBlXCIsIFwiaGlnaHNoZWxmXCIpO1xuICAgIH0pO1xuICAgIGZuLnJlZ2lzdGVyKFwicGVha2luZ1wiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IEJpcXVhZE5vZGUoX2FyZ3MpLnNldChcInR5cGVcIiwgXCJwZWFraW5nXCIpO1xuICAgIH0pO1xuICAgIGZuLnJlZ2lzdGVyKFwibm90Y2hcIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXF1YWROb2RlKF9hcmdzKS5zZXQoXCJ0eXBlXCIsIFwibm90Y2hcIik7XG4gICAgfSk7XG4gICAgZm4ucmVnaXN0ZXIoXCJhbGxwYXNzXCIsIGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlxdWFkTm9kZShfYXJncykuc2V0KFwidHlwZVwiLCBcImFsbHBhc3NcIik7XG4gICAgfSk7XG5cbiAgICBmbi5hbGlhcyhcImxwZlwiLCBcImxvd3Bhc3NcIik7XG4gICAgZm4uYWxpYXMoXCJocGZcIiwgXCJoaWdocGFzc1wiKTtcbiAgICBmbi5hbGlhcyhcImJwZlwiLCBcImJhbmRwYXNzXCIpO1xuICAgIGZuLmFsaWFzKFwiYmVmXCIsIFwibm90Y2hcIik7XG4gICAgZm4uYWxpYXMoXCJicmZcIiwgXCJub3RjaFwiKTtcbiAgICBmbi5hbGlhcyhcImFwZlwiLCBcImFsbHBhc3NcIik7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcbiAgICB2YXIgVGFwZSA9IFQubW9kdWxlcy5TY2lzc29yLlRhcGU7XG4gICAgdmFyIGlzU2lnbmFsQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIGZuLmlzU2lnbmFsQXJyYXkob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEJ1ZmZlck5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAxLCBfYXJncyk7XG4gICAgICAgIGZuLmZpeEFSKHRoaXMpO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLnBpdGNoICAgICAgPSBUKDEpO1xuICAgICAgICBfLnNhbXBsZXJhdGUgPSA0NDEwMDtcbiAgICAgICAgXy5jaGFubmVscyAgID0gMDtcbiAgICAgICAgXy5idWZmZXJNaXggID0gbnVsbDtcbiAgICAgICAgXy5idWZmZXIgICAgID0gW107XG4gICAgICAgIF8uaXNMb29wZWQgICA9IGZhbHNlO1xuICAgICAgICBfLmlzUmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAgICAgXy5kdXJhdGlvbiAgICA9IDA7XG4gICAgICAgIF8uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICBfLmN1cnJlbnRUaW1lT2JqID0gbnVsbDtcbiAgICAgICAgXy5waGFzZSA9IDA7XG4gICAgICAgIF8ucGhhc2VJbmNyID0gMDtcbiAgICAgICAgXy5vbmVuZGVkICA9IGZuLm1ha2Vfb25lbmRlZCh0aGlzLCAwKTtcbiAgICAgICAgXy5vbmxvb3BlZCA9IG1ha2Vfb25sb29wZWQodGhpcyk7XG4gICAgfVxuICAgIGZuLmV4dGVuZChCdWZmZXJOb2RlKTtcblxuICAgIHZhciBtYWtlX29ubG9vcGVkID0gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHNlbGYuXztcbiAgICAgICAgICAgIGlmIChfLnBoYXNlID49IF8uYnVmZmVyWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF8ucGhhc2UgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLnBoYXNlIDwgMCkge1xuICAgICAgICAgICAgICAgIF8ucGhhc2UgPSBfLmJ1ZmZlclswXS5sZW5ndGggKyBfLnBoYXNlSW5jcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuXy5lbWl0KFwibG9vcGVkXCIpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgJCA9IEJ1ZmZlck5vZGUucHJvdG90eXBlO1xuXG4gICAgdmFyIHNldEJ1ZmZlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gW10sIHNhbXBsZXJhdGUsIGNoYW5uZWxzO1xuXG4gICAgICAgICAgICBpZiAoaXNTaWduYWxBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjaGFubmVscyA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFQuT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuYnVmZmVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBUYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZ2V0QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLmJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2lnbmFsQXJyYXkodmFsdWUuYnVmZmVyWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2lnbmFsQXJyYXkodmFsdWUuYnVmZmVyWzFdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2lnbmFsQXJyYXkodmFsdWUuYnVmZmVyWzJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSB2YWx1ZS5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBbdmFsdWUuYnVmZmVyWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTaWduYWxBcnJheSh2YWx1ZS5idWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gW3ZhbHVlLmJ1ZmZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUuc2FtcGxlcmF0ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyYXRlID0gdmFsdWUuc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVyYXRlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfLnNhbXBsZXJhdGUgPSB2YWx1ZS5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLmJ1ZmZlck1peCA9IG51bGw7XG4gICAgICAgICAgICAgICAgXy5idWZmZXIgID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIF8ucGhhc2UgICAgID0gMDtcbiAgICAgICAgICAgICAgICBfLnBoYXNlSW5jciA9IF8uc2FtcGxlcmF0ZSAvIFQuc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgICAgICBfLmR1cmF0aW9uICA9IF8uYnVmZmVyWzBdLmxlbmd0aCAqIDEwMDAgLyBfLnNhbXBsZXJhdGU7XG4gICAgICAgICAgICAgICAgXy5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgICAgICAgICAgXy5wbG90Rmx1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZShfLmlzUmV2ZXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgYnVmZmVyOiB7XG4gICAgICAgICAgICBzZXQ6IHNldEJ1ZmZlcixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcmF0ZTogXy5zYW1wbGVyYXRlLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVscyAgOiBfLmNoYW5uZWxzLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgICAgOiBfLmJ1ZmZlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBpdGNoOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLnBpdGNoID0gVCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnBpdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc0xvb3BlZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmlzTG9vcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc1JldmVyc2VkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uaXNSZXZlcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2FtcGxlcmF0ZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnNhbXBsZXJhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbnRUaW1lOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gXy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5waGFzZSA9ICh2YWx1ZSAvIDEwMDApICogXy5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50VGltZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFQuT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5jdXJyZW50VGltZU9iaiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmN1cnJlbnRUaW1lT2JqID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fLmN1cnJlbnRUaW1lT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uY3VycmVudFRpbWVPYmo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZuLmNsb25lKHRoaXMpO1xuXG4gICAgICAgIGlmIChfLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNldEJ1ZmZlci5jYWxsKGluc3RhbmNlLCB7XG4gICAgICAgICAgICAgICAgYnVmZmVyICAgIDogXy5idWZmZXIsXG4gICAgICAgICAgICAgICAgc2FtcGxlcmF0ZTogXy5zYW1wbGVyYXRlLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxzICA6IF8uY2hhbm5lbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmxvb3AoXy5pc0xvb3BlZCk7XG4gICAgICAgIGluc3RhbmNlLnJldmVyc2UoXy5pc1JldmVyc2VkKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcblxuICAgICQuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBUKF8ub3JpZ2lua2V5KTtcbiAgICAgICAgdmFyIGlzUmV2ZXJzZWQgPSBfLmlzUmV2ZXJzZWQ7XG5cbiAgICAgICAgaWYgKF8uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gXCJudW1iZXJcIiApe1xuICAgICAgICAgICAgICAgIGJlZ2luID0gKGJlZ2luICogMC4wMDEgKiBfLnNhbXBsZXJhdGUpfDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJlZ2luID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZW5kICAgPSAoZW5kICAgKiAwLjAwMSAqIF8uc2FtcGxlcmF0ZSl8MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gXy5idWZmZXJbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlZ2luID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IGJlZ2luO1xuICAgICAgICAgICAgICAgIGJlZ2luID0gZW5kO1xuICAgICAgICAgICAgICAgIGVuZCAgID0gdG1wO1xuICAgICAgICAgICAgICAgIGlzUmV2ZXJzZWQgPSAhaXNSZXZlcnNlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF8uY2hhbm5lbHMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzZXRCdWZmZXIuY2FsbChpbnN0YW5jZSwge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgICA6IFsgZm4ucG9pbnRlcihfLmJ1ZmZlclswXSwgYmVnaW4sIGVuZC1iZWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5wb2ludGVyKF8uYnVmZmVyWzFdLCBiZWdpbiwgZW5kLWJlZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLnBvaW50ZXIoXy5idWZmZXJbMl0sIGJlZ2luLCBlbmQtYmVnaW4pIF0sXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXJhdGU6IF8uc2FtcGxlcmF0ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRCdWZmZXIuY2FsbChpbnN0YW5jZSwge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGZuLnBvaW50ZXIoXy5idWZmZXJbMF0sIGJlZ2luLCBlbmQtYmVnaW4pLFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyYXRlOiBfLnNhbXBsZXJhdGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLnBsYXliYWNrU3RhdGUgPSBmbi5QTEFZSU5HX1NUQVRFO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmxvb3AoXy5pc0xvb3BlZCk7XG4gICAgICAgIGluc3RhbmNlLnJldmVyc2UoXy5pc1JldmVyc2VkKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcblxuICAgICQucmV2ZXJzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIF8uaXNSZXZlcnNlZCA9ICEhdmFsdWU7XG4gICAgICAgIGlmIChfLmlzUmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIGlmIChfLnBoYXNlSW5jciA+IDApIHtcbiAgICAgICAgICAgICAgICBfLnBoYXNlSW5jciAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfLnBoYXNlID09PSAwICYmIF8uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF8ucGhhc2UgPSBfLmJ1ZmZlclswXS5sZW5ndGggKyBfLnBoYXNlSW5jcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfLnBoYXNlSW5jciA8IDApIHtcbiAgICAgICAgICAgICAgICBfLnBoYXNlSW5jciAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLmxvb3AgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl8uaXNMb29wZWQgPSAhIXZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5iYW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gKHZhbHVlID09PSBmYWxzZSA/IGZuLkZJTklTSEVEX1NUQVRFIDogZm4uUExBWUlOR19TVEFURSk7XG4gICAgICAgIHRoaXMuXy5waGFzZSA9IDA7XG4gICAgICAgIHRoaXMuXy5lbWl0KFwiYmFuZ1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAoIV8uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciBjZWxsTCA9IHRoaXMuY2VsbHNbMV07XG4gICAgICAgICAgICB2YXIgY2VsbFIgPSB0aGlzLmNlbGxzWzJdO1xuICAgICAgICAgICAgdmFyIHBoYXNlICA9IF8ucGhhc2U7XG4gICAgICAgICAgICB2YXIgaSwgaW1heCA9IF8uY2VsbHNpemU7XG5cbiAgICAgICAgICAgIHZhciBidWZmZXJMLCBidWZmZXJSO1xuICAgICAgICAgICAgaWYgKF8uY2hhbm5lbHMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJMID0gXy5idWZmZXJbMV07XG4gICAgICAgICAgICAgICAgYnVmZmVyUiA9IF8uYnVmZmVyWzJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXJMID0gYnVmZmVyUiA9IF8uYnVmZmVyWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5jdXJyZW50VGltZU9iaikge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBfLmN1cnJlbnRUaW1lT2JqLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgdCwgc3IgPSBfLnNhbXBsZXJhdGUgKiAwLjAwMTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBwb3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBoYXNlID0gdCAqIHNyO1xuICAgICAgICAgICAgICAgICAgICBjZWxsTFtpXSA9IChidWZmZXJMW3BoYXNlfDBdIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICBjZWxsUltpXSA9IChidWZmZXJSW3BoYXNlfDBdIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLnBoYXNlID0gcGhhc2U7XG4gICAgICAgICAgICAgICAgXy5jdXJyZW50VGltZSA9IHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwaXRjaCAgPSBfLnBpdGNoLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXVswXTtcbiAgICAgICAgICAgICAgICB2YXIgcGhhc2VJbmNyID0gXy5waGFzZUluY3IgKiBwaXRjaDtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbExbaV0gPSAoYnVmZmVyTFtwaGFzZXwwXSB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFJbaV0gPSAoYnVmZmVyUltwaGFzZXwwXSB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcGhhc2UgKz0gcGhhc2VJbmNyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwaGFzZSA+PSBidWZmZXJMLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc0xvb3BlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4ubmV4dFRpY2soXy5vbmxvb3BlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbi5uZXh0VGljayhfLm9uZW5kZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwaGFzZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNMb29wZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuLm5leHRUaWNrKF8ub25sb29wZWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4ubmV4dFRpY2soXy5vbmVuZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLnBoYXNlID0gcGhhc2U7XG4gICAgICAgICAgICAgICAgXy5jdXJyZW50VGltZSArPSBmbi5jdXJyZW50VGltZUluY3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBzdXBlcl9wbG90ID0gVC5PYmplY3QucHJvdG90eXBlLnBsb3Q7XG5cbiAgICAkLnBsb3QgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICB2YXIgYnVmZmVyTCwgYnVmZmVyUjtcbiAgICAgICAgaWYgKF8ucGxvdEZsdXNoKSB7XG4gICAgICAgICAgICBpZiAoXy5jaGFubmVscyA9PT0gMikge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckwgPSBfLmJ1ZmZlclsxXTtcbiAgICAgICAgICAgICAgICBidWZmZXJSID0gXy5idWZmZXJbMl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckwgPSBidWZmZXJSID0gXy5idWZmZXJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMjA0OCk7XG4gICAgICAgICAgICB2YXIgeCA9IDAsIHhJbmNyID0gYnVmZmVyTC5sZW5ndGggLyAyMDQ4O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDQ4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhW2ldID0gKGJ1ZmZlckxbeHwwXSArIGJ1ZmZlclJbeHwwXSkgKiAwLjU7XG4gICAgICAgICAgICAgICAgeCArPSB4SW5jcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8ucGxvdERhdGEgID0gZGF0YTtcbiAgICAgICAgICAgIF8ucGxvdEZsdXNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXJfcGxvdC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcImJ1ZmZlclwiLCBCdWZmZXJOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gID0gVC5mbjtcbiAgICB2YXIgQ2hvcnVzID0gVC5tb2R1bGVzLkNob3J1cztcblxuICAgIGZ1bmN0aW9uIENob3J1c05vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAyLCBfYXJncyk7XG4gICAgICAgIGZuLmZpeEFSKHRoaXMpO1xuXG4gICAgICAgIHZhciBjaG9ydXMgPSBuZXcgQ2hvcnVzKHRoaXMuXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgY2hvcnVzLnNldERlbGF5VGltZSgyMCk7XG4gICAgICAgIGNob3J1cy5zZXRSYXRlKDQpO1xuICAgICAgICBjaG9ydXMuZGVwdGggPSAyMDtcbiAgICAgICAgY2hvcnVzLmZlZWRiYWNrID0gMC4yO1xuICAgICAgICBjaG9ydXMubWl4ID0gMC4zMztcbiAgICAgICAgdGhpcy5fLmNob3J1cyA9IGNob3J1cztcbiAgICB9XG4gICAgZm4uZXh0ZW5kKENob3J1c05vZGUpO1xuXG4gICAgdmFyICQgPSBDaG9ydXNOb2RlLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuXy5jaG9ydXMuc2V0RGVsYXlUaW1lKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uY2hvcnVzLndhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGF5OiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKDAuNSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSA4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8uY2hvcnVzLnNldERlbGF5VGltZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5jaG9ydXMuZGVsYXlUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByYXRlOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmNob3J1cy5zZXRSYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmNob3J1cy5yYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXB0aDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAqPSB0aGlzLl8uc2FtcGxlcmF0ZSAvIDQ0MTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmNob3J1cy5kZXB0aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5jaG9ydXMuZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZiOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmNob3J1cy5mZWVkYmFjayA9IHZhbHVlICogMC45OTk5NjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uY2hvcnVzLmZlZWRiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtaXg6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8ubWl4ID0gVCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLm1peDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgZm4uaW5wdXRTaWduYWxBUih0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCFfLmJ5cGFzc2VkKSB7XG4gICAgICAgICAgICAgICAgXy5jaG9ydXMucHJvY2Vzcyh0aGlzLmNlbGxzWzFdLCB0aGlzLmNlbGxzWzJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJjaG9ydXNcIiwgQ2hvcnVzTm9kZSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcblxuICAgIGZ1bmN0aW9uIENsaXBOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMiwgX2FyZ3MpO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLm1pbiA9IC0wLjg7XG4gICAgICAgIF8ubWF4ID0gKzAuODtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKENsaXBOb2RlKTtcblxuICAgIHZhciAkID0gQ2xpcE5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICBtaW5tYXg6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubWluID0gLU1hdGguYWJzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgXy5tYXggPSAtXy5taW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5tYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8ubWF4IDwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubWF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5taW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgXy5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5tYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciBjZWxsTCA9IHRoaXMuY2VsbHNbMV07XG4gICAgICAgICAgICB2YXIgY2VsbFIgPSB0aGlzLmNlbGxzWzJdO1xuICAgICAgICAgICAgdmFyIGksIGltYXggPSBjZWxsTC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbWluID0gXy5taW4sIG1heCA9IF8ubWF4O1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoXy5hcikge1xuICAgICAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNlbGxMW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWluO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjZWxsTFtpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNlbGxSW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWluO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjZWxsUltpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmbi5pbnB1dFNpZ25hbEtSKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1pbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzWzBdWzBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsS1IodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwiY2xpcFwiLCBDbGlwTm9kZSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcbiAgICB2YXIgdGltZXZhbHVlID0gVC50aW1ldmFsdWU7XG4gICAgdmFyIENvbXByZXNzb3IgPSBULm1vZHVsZXMuQ29tcHJlc3NvcjtcblxuICAgIGZ1bmN0aW9uIENvbXByZXNzb3JOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMiwgX2FyZ3MpO1xuICAgICAgICBmbi5maXhBUih0aGlzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5wcmV2VGhyZXNoID0gLTI0O1xuICAgICAgICBfLnByZXZLbmVlICAgPSAgMzA7XG4gICAgICAgIF8ucHJldlJhdGlvICA9ICAxMjtcbiAgICAgICAgXy50aHJlc2ggPSBUKF8ucHJldlRocmVzaCk7XG4gICAgICAgIF8ua25lZSAgID0gVChfLnByZXZLbmVlKTtcbiAgICAgICAgXy5yYXRpbyAgPSBUKF8ucHJldlJhdGlvKTtcbiAgICAgICAgXy5wb3N0R2FpbiAgPSA2O1xuICAgICAgICBfLnJlZHVjdGlvbiA9IDA7XG4gICAgICAgIF8uYXR0YWNrID0gMztcbiAgICAgICAgXy5yZWxlYXNlID0gMjU7XG5cbiAgICAgICAgXy5jb21wID0gbmV3IENvbXByZXNzb3IoXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgXy5jb21wLmRiUG9zdEdhaW4gPSBfLnBvc3RHYWluO1xuICAgICAgICBfLmNvbXAuc2V0QXR0YWNrVGltZShfLmF0dGFjayAqIDAuMDAxKTtcbiAgICAgICAgXy5jb21wLnNldFJlbGVhc2VUaW1lKF8ucmVsZWFzZSAqIDAuMDAxKTtcbiAgICAgICAgXy5jb21wLnNldFByZURlbGF5VGltZSg2KTtcbiAgICAgICAgXy5jb21wLnNldFBhcmFtcyhfLnByZXZUaHJlc2gsIF8ucHJldktuZWUsIF8ucHJldlJhdGlvKTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKENvbXByZXNzb3JOb2RlKTtcblxuICAgIHZhciAkID0gQ29tcHJlc3Nvck5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICB0aHJlc2g6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8udGhyZXNoID0gVCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnRocmVzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGhyZToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuXy50aHJlc2ggPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8udGhyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAga25lZToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuXy5rbmUgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ua25lZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmF0aW86IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8ucmF0aW8gPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ucmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdhaW46IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5jb21wLmRiUG9zdEdhaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmNvbXAuZGJQb3N0R2FpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXR0YWNrOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRpbWV2YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPCAwKSA/IDAgOiAoMTAwMCA8IHZhbHVlKSA/IDEwMDAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmF0dGFjayA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8uY29tcC5zZXRBdHRhY2tUaW1lKHZhbHVlICogMC4wMDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uYXR0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWxlYXNlOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRpbWV2YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPCAwKSA/IDAgOiAoMTAwMCA8IHZhbHVlKSA/IDEwMDAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnJlbGVhc2UgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmNvbXAuc2V0UmVsZWFzZVRpbWUodmFsdWUgKiAwLjAwMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5yZWxlYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWR1Y3Rpb246IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5yZWR1Y3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aHJlc2ggPSBfLnRocmVzaC5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF1bMF07XG4gICAgICAgICAgICB2YXIga25lZSAgID0gXy5rbmVlLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXVswXTtcbiAgICAgICAgICAgIHZhciByYXRpbyAgPSBfLnJhdGlvLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXVswXTtcbiAgICAgICAgICAgIGlmIChfLnByZXZUaHJlc2ggIT09IHRocmVzaCB8fCBfLnByZXZLbmVlICE9PSBrbmVlIHx8IF8ucHJldlJhdGlvICE9PSByYXRpbykge1xuICAgICAgICAgICAgICAgIF8ucHJldlRocmVzaCA9IHRocmVzaDtcbiAgICAgICAgICAgICAgICBfLnByZXZLbmVlICAgPSBrbmVlO1xuICAgICAgICAgICAgICAgIF8ucHJldlJhdGlvICA9IHJhdGlvO1xuICAgICAgICAgICAgICAgIF8uY29tcC5zZXRQYXJhbXModGhyZXNoLCBrbmVlLCByYXRpbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghXy5ieXBhc3NlZCkge1xuICAgICAgICAgICAgICAgIF8uY29tcC5wcm9jZXNzKHRoaXMuY2VsbHNbMV0sIHRoaXMuY2VsbHNbMl0pO1xuICAgICAgICAgICAgICAgIF8ucmVkdWN0aW9uID0gXy5jb21wLm1ldGVyaW5nR2FpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJjb21wXCIsIENvbXByZXNzb3JOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuICAgIHZhciB0aW1ldmFsdWUgPSBULnRpbWV2YWx1ZTtcbiAgICB2YXIgU3RlcmVvRGVsYXkgPSBULm1vZHVsZXMuU3RlcmVvRGVsYXk7XG5cbiAgICBmdW5jdGlvbiBEZWxheU5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAyLCBfYXJncyk7XG4gICAgICAgIGZuLmZpeEFSKHRoaXMpO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLnRpbWUgID0gVCgxMDApO1xuICAgICAgICBfLmZiICAgID0gVCgwLjIpO1xuICAgICAgICBfLmNyb3NzID0gVChmYWxzZSk7XG4gICAgICAgIF8ubWl4ICAgPSAwLjMzO1xuXG4gICAgICAgIF8uZGVsYXkgPSBuZXcgU3RlcmVvRGVsYXkoXy5zYW1wbGVyYXRlKTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKERlbGF5Tm9kZSk7XG5cbiAgICB2YXIgJCA9IERlbGF5Tm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIHRpbWU6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGltZXZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fLnRpbWUgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8udGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmI6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8uZmIgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZmI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyb3NzOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmNyb3NzID0gVCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmNyb3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtaXg6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID4gMSkgPyAxIDogKHZhbHVlIDwgMCkgPyAwIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5taXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLm1peDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgdmFyIHRpbWUgID0gXy50aW1lLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXVswXTtcbiAgICAgICAgICAgIHZhciBmYiAgICA9IF8uZmIucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgdmFyIGNyb3NzID0gXy5jcm9zcy5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF1bMF0gIT09IDA7XG4gICAgICAgICAgICB2YXIgbWl4ICAgPSBfLm1peDtcblxuICAgICAgICAgICAgaWYgKF8ucHJldlRpbWUgIT09IHRpbWUgfHwgXy5wcmV2RmIgIT09IGZiIHx8IF8ucHJldkNyb3NzICE9PSBjcm9zcyB8fCBfLnByZXZNaXggIT09IG1peCkge1xuICAgICAgICAgICAgICAgIF8ucHJldlRpbWUgID0gdGltZTtcbiAgICAgICAgICAgICAgICBfLnByZXZGYiAgICA9IGZiO1xuICAgICAgICAgICAgICAgIF8ucHJldkNyb3NzID0gY3Jvc3M7XG4gICAgICAgICAgICAgICAgXy5wcmV2TWl4ICAgPSBtaXg7XG4gICAgICAgICAgICAgICAgXy5kZWxheS5zZXRQYXJhbXModGltZSwgZmIsIGNyb3NzLCBtaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbi5pbnB1dFNpZ25hbEFSKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoIV8uYnlwYXNzZWQpIHtcbiAgICAgICAgICAgICAgICBfLmRlbGF5LnByb2Nlc3ModGhpcy5jZWxsc1sxXSwgdGhpcy5jZWxsc1syXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwiZGVsYXlcIiwgRGVsYXlOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gRGlzdE5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAyLCBfYXJncyk7XG4gICAgICAgIGZuLmZpeEFSKHRoaXMpO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLnByZSAgPSBUKCA2MCk7XG4gICAgICAgIF8ucG9zdCA9IFQoLTE4KTtcbiAgICAgICAgXy54MUwgPSBfLngyTCA9IF8ueTFMID0gXy55MkwgPSAwO1xuICAgICAgICBfLngxUiA9IF8ueDJSID0gXy55MVIgPSBfLnkyUiA9IDA7XG4gICAgICAgIF8uYjAgPSBfLmIxID0gXy5iMiA9IF8uYTEgPSBfLmEyID0gMDtcbiAgICAgICAgXy5jdXRvZmYgPSAwO1xuICAgICAgICBfLlEgPSAxO1xuICAgICAgICBfLnByZVNjYWxlID0gMDtcbiAgICAgICAgXy5wb3N0U2NhbGUgPSAwO1xuICAgIH1cbiAgICBmbi5leHRlbmQoRGlzdE5vZGUpO1xuXG4gICAgdmFyICQgPSBEaXN0Tm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIGN1dG9mZjoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5jdXRvZmYgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmN1dG9mZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLnByZSA9IFQodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5wcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Q6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8ucG9zdCA9IFQodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5wb3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICBmbi5pbnB1dFNpZ25hbEFSKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgcHJlR2FpbiAgPSAtXy5wcmUucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgdmFyIHBvc3RHYWluID0gLV8ucG9zdC5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF1bMF07XG5cbiAgICAgICAgICAgIGlmIChfLnByZXZQcmVHYWluICE9PSBwcmVHYWluIHx8IF8ucHJldlBvc3RHYWluICE9PSBwb3N0R2Fpbikge1xuICAgICAgICAgICAgICAgIF8ucHJldlByZUdhaW4gID0gcHJlR2FpbjtcbiAgICAgICAgICAgICAgICBfLnByZXZQb3N0R2FpbiA9IHBvc3RHYWluO1xuICAgICAgICAgICAgICAgIF8ucHJlU2NhbGUgID0gTWF0aC5wb3coMTAsIC1wcmVHYWluICAqIDAuMDUpO1xuICAgICAgICAgICAgICAgIF8ucG9zdFNjYWxlID0gTWF0aC5wb3coMTAsIC1wb3N0R2FpbiAqIDAuMDUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV8uYnlwYXNzZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbEwgPSB0aGlzLmNlbGxzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsUiA9IHRoaXMuY2VsbHNbMl07XG4gICAgICAgICAgICAgICAgdmFyIHByZVNjYWxlICA9IF8ucHJlU2NhbGU7XG4gICAgICAgICAgICAgICAgdmFyIHBvc3RTY2FsZSA9IF8ucG9zdFNjYWxlO1xuICAgICAgICAgICAgICAgIHZhciBpLCBpbWF4LCB2YWx1ZSwgeDAsIHkwO1xuXG4gICAgICAgICAgICAgICAgaWYgKF8uY3V0b2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLnByZXZDdXRvZmYgIT09IF8uY3V0b2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnByZXZDdXRvZmYgPSBfLmN1dG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd3Bhc3NfcGFyYW1zKF8pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxTCA9IF8ueDFMLCB4MkwgPSBfLngyTCwgeTFMID0gXy55MUwsIHkyTCA9IF8ueTJMO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDFSID0gXy54MVIsIHgyUiA9IF8ueDJSLCB5MVIgPSBfLnkxUiwgeTJSID0gXy55MlI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiMCA9IF8uYjAsIGIxID0gXy5iMSwgYjIgPSBfLmIyLCBhMSA9IF8uYTEsIGEyID0gXy5hMjtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpbWF4ID0gY2VsbEwubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IGNlbGxMW2ldICogcHJlU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IGIwICogeDAgKyBiMSAqIHgxTCArIGIyICogeDJMIC0gYTEgKiB5MUwgLSBhMiAqIHkyTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0geTAgKiBwb3N0U2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxMW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MkwgPSB4MUw7IHgxTCA9IHgwOyB5MkwgPSB5MUw7IHkxTCA9IHkwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IGNlbGxSW2ldICogcHJlU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IGIwICogeDAgKyBiMSAqIHgxUiArIGIyICogeDJSIC0gYTEgKiB5MVIgLSBhMiAqIHkyUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0geTAgKiBwb3N0U2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxSW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MlIgPSB4MVI7IHgxUiA9IHgwOyB5MlIgPSB5MVI7IHkxUiA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgXy54MUwgPSB4MUw7IF8ueDJMID0geDJMOyBfLnkxTCA9IHkxTDsgXy55MkwgPSB5Mkw7XG4gICAgICAgICAgICAgICAgICAgIF8ueDFSID0geDFSOyBfLngyUiA9IHgyUjsgXy55MVIgPSB5MVI7IF8ueTJSID0geTJSO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGltYXggPSBjZWxsTC5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2VsbExbaV0gKiBwcmVTY2FsZSAqIHBvc3RTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbExbaV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjZWxsUltpXSAqIHByZVNjYWxlICogcG9zdFNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsUltpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgbG93cGFzc19wYXJhbXMgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIHZhciB3MCA9IDIgKiBNYXRoLlBJICogXy5jdXRvZmYgLyBfLnNhbXBsZXJhdGU7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh3MCk7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih3MCk7XG4gICAgICAgIHZhciBhbHBoYSA9IHNpbiAvICgyICogXy5RKTtcblxuICAgICAgICB2YXIgaWEwID0gMSAvICgxICsgYWxwaGEpO1xuICAgICAgICBfLmIwID0gICgxIC0gY29zKSAqIDAuNSAqIGlhMDtcbiAgICAgICAgXy5iMSA9ICAgMSAtIGNvcyAqIGlhMDtcbiAgICAgICAgXy5iMiA9ICAoMSAtIGNvcykgKiAwLjUgKiBpYTA7XG4gICAgICAgIF8uYTEgPSAgLTIgKiBjb3MgKiBpYTA7XG4gICAgICAgIF8uYTIgPSAgIDEgLSBhbHBoYSAqIGlhMDtcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJkaXN0XCIsIERpc3ROb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gRGl2Tm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDIsIF9hcmdzKTtcbiAgICAgICAgdGhpcy5fLmFyID0gZmFsc2U7XG4gICAgfVxuICAgIGZuLmV4dGVuZChEaXZOb2RlKTtcblxuICAgIHZhciAkID0gRGl2Tm9kZS5wcm90b3R5cGU7XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgICAgICAgIHZhciBjZWxsICA9IHRoaXMuY2VsbHNbMF07XG4gICAgICAgICAgICB2YXIgY2VsbEwgPSB0aGlzLmNlbGxzWzFdO1xuICAgICAgICAgICAgdmFyIGNlbGxSID0gdGhpcy5jZWxsc1syXTtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4ID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGosIGptYXggPSBjZWxsLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0bXAsIHRtcEwsIHRtcFIsIGRpdjtcblxuICAgICAgICAgICAgaWYgKF8uYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1swXS5wcm9jZXNzKHRpY2tJRCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcEwgPSBub2Rlc1swXS5jZWxsc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdG1wUiA9IG5vZGVzWzBdLmNlbGxzWzJdO1xuICAgICAgICAgICAgICAgICAgICBjZWxsTC5zZXQodG1wTCk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxSLnNldCh0bXBSKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0ucHJvY2Vzcyh0aWNrSUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wTCA9IG5vZGVzW2ldLmNlbGxzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wUiA9IG5vZGVzW2ldLmNlbGxzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGptYXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdiA9IHRtcExbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbExbal0gPSAoZGl2ID09PSAwKSA/IDAgOiBjZWxsTFtqXSAvIGRpdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXYgPSB0bXBSW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxSW2pdID0gKGRpdiA9PT0gMCkgPyAwIDogY2VsbFJbal0gLyBkaXY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgam1heDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsTFtqXSA9IGNlbGxSW2ldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gbm9kZXNbMF0ucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXYgPSBub2Rlc1tpXS5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSAoZGl2ID09PSAwKSA/IDAgOiB0bXAgLyBkaXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsWzBdID0gdG1wO1xuICAgICAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEtSKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwiL1wiLCBEaXZOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuICAgIHZhciB0aW1ldmFsdWUgPSBULnRpbWV2YWx1ZTtcbiAgICB2YXIgRW52ZWxvcGUgID0gVC5tb2R1bGVzLkVudmVsb3BlO1xuICAgIHZhciBpc0RpY3Rpb25hcnkgPSBmbi5pc0RpY3Rpb25hcnk7XG5cbiAgICBmdW5jdGlvbiBFbnZOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMiwgX2FyZ3MpO1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5lbnYgPSBuZXcgRW52ZWxvcGUoXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgXy5lbnYuc2V0U3RlcChfLmNlbGxzaXplKTtcbiAgICAgICAgXy50bXAgPSBuZXcgZm4uU2lnbmFsQXJyYXkoXy5jZWxsc2l6ZSk7XG4gICAgICAgIF8uYXIgPSBmYWxzZTtcbiAgICAgICAgXy5wbG90Rmx1c2ggPSB0cnVlO1xuICAgICAgICBfLm9uZW5kZWQgPSBtYWtlX29uZW5kZWQodGhpcyk7XG4gICAgICAgIHRoaXMub24oXCJhclwiLCBvbmFyKTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKEVudk5vZGUpO1xuXG4gICAgdmFyIG9uYXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl8uZW52LnNldFN0ZXAoKHZhbHVlKSA/IDEgOiB0aGlzLl8uY2VsbHNpemUpO1xuICAgIH07XG5cbiAgICB2YXIgbWFrZV9vbmVuZGVkID0gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl8uZW1pdChcImVuZGVkXCIpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgJCA9IEVudk5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICB0YWJsZToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUYWJsZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnBsb3RGbHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5lbnYudGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnZlOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmVudi5zZXRDdXJ2ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmVudi5jdXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVsZWFzZU5vZGU6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8uZW52LnNldFJlbGVhc2VOb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl8ucGxvdEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZW52LnJlbGVhc2VOb2RlICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9vcE5vZGU6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8uZW52LnNldExvb3BOb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl8ucGxvdEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZW52Lmxvb3BOb2RlICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmbi5jbG9uZSh0aGlzKTtcbiAgICAgICAgaW5zdGFuY2UuXy5lbnYgPSB0aGlzLl8uZW52LmNsb25lKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgJC5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl8uZW52LnJlc2V0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIF8uZW52LnJlbGVhc2UoKTtcbiAgICAgICAgXy5lbWl0KFwicmVsZWFzZWRcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLmJhbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIF8uZW52LnJlc2V0KCk7XG4gICAgICAgIF8uZW52LnN0YXR1cyA9IEVudmVsb3BlLlN0YXR1c0dhdGU7XG4gICAgICAgIF8uZW1pdChcImJhbmdcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICB2YXIgY2VsbEwgPSB0aGlzLmNlbGxzWzFdO1xuICAgICAgICAgICAgdmFyIGNlbGxSID0gdGhpcy5jZWxsc1syXTtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4ID0gXy5jZWxsc2l6ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm4uaW5wdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsTFtpXSA9IGNlbGxSW2ldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSwgZW1pdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoXy5hcikge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBfLnRtcDtcbiAgICAgICAgICAgICAgICBfLmVudi5wcm9jZXNzKHRtcCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsTFtpXSAqPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgICAgIGNlbGxSW2ldICo9IHRtcFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW1pdCA9IF8uZW52LmVtaXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXy5lbnYubmV4dCgpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbExbaV0gKj0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxSW2ldICo9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbWl0ID0gXy5lbnYuZW1pdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtaXQgPT09IFwiZW5kZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBmbi5uZXh0VGljayhfLm9uZW5kZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5lbWl0KGVtaXQsIF8udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgc2V0VGFibGUgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgIHZhciBlbnYgPSB0aGlzLl8uZW52O1xuXG4gICAgICAgIHZhciB0YWJsZSA9IFtsaXN0WzBdIHx8IFpFUk9dO1xuXG4gICAgICAgIHZhciB2YWx1ZSwgdGltZSwgY3VydmVUeXBlLCBjdXJ2ZVZhbHVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgaW1heCA9IGxpc3QubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV1bMF0gfHwgWkVSTztcbiAgICAgICAgICAgIHRpbWUgID0gbGlzdFtpXVsxXTtcbiAgICAgICAgICAgIGN1cnZlVHlwZSA9IGxpc3RbaV1bMl07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aW1lID0gdGltZXZhbHVlKHRpbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWUgPSAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnZlVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGN1cnZlVmFsdWUgPSBjdXJ2ZVR5cGU7XG4gICAgICAgICAgICAgICAgY3VydmVUeXBlICA9IEVudmVsb3BlLkN1cnZlVHlwZUN1cnZlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJ2ZVR5cGUgID0gRW52ZWxvcGUuQ3VydmVUeXBlRGljdFtjdXJ2ZVR5cGVdIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgY3VydmVWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5wdXNoKFt2YWx1ZSwgdGltZSwgY3VydmVUeXBlLCBjdXJ2ZVZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnYuc2V0VGFibGUodGFibGUpO1xuICAgIH07XG5cbiAgICB2YXIgc3VwZXJfcGxvdCA9IFQuT2JqZWN0LnByb3RvdHlwZS5wbG90O1xuXG4gICAgJC5wbG90ID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgICBpZiAodGhpcy5fLnBsb3RGbHVzaCkge1xuICAgICAgICAgICAgdmFyIGVudiA9IHRoaXMuXy5lbnYuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBpbmZvID0gZW52LmdldEluZm8oMTAwMCk7XG5cbiAgICAgICAgICAgIHZhciB0b3RhbER1cmF0aW9uICAgID0gaW5mby50b3RhbER1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGxvb3BCZWdpblRpbWUgICAgPSBpbmZvLmxvb3BCZWdpblRpbWU7XG4gICAgICAgICAgICB2YXIgcmVsZWFzZUJlZ2luVGltZSA9IGluZm8ucmVsZWFzZUJlZ2luVGltZTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSgyNTYpO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbkluY3IgPSB0b3RhbER1cmF0aW9uIC8gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaXNSZWxlYXNlZCAgID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc2FtcGxlcyA9ICh0b3RhbER1cmF0aW9uICogMC4wMDEgKiB0aGlzLl8uc2FtcGxlcmF0ZSl8MDtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4O1xuXG4gICAgICAgICAgICBzYW1wbGVzIC89IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgZW52LnNldFN0ZXAoc2FtcGxlcyk7XG4gICAgICAgICAgICBlbnYuc3RhdHVzID0gRW52ZWxvcGUuU3RhdHVzR2F0ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGltYXggPSBkYXRhLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBlbnYubmV4dCgpO1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uICs9IGR1cmF0aW9uSW5jcjtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVsZWFzZWQgJiYgZHVyYXRpb24gPj0gcmVsZWFzZUJlZ2luVGltZSkge1xuICAgICAgICAgICAgICAgICAgICBlbnYucmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpc1JlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl8ucGxvdERhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgICB0aGlzLl8ucGxvdEJlZm9yZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeDEsIHc7XG4gICAgICAgICAgICAgICAgaWYgKGxvb3BCZWdpblRpbWUgIT09IEluZmluaXR5ICYmIHJlbGVhc2VCZWdpblRpbWUgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHgxID0geCArICh3aWR0aCAqIChsb29wQmVnaW5UaW1lICAgIC8gdG90YWxEdXJhdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICB3ICA9IHggKyAod2lkdGggKiAocmVsZWFzZUJlZ2luVGltZSAvIHRvdGFsRHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgdyAgPSB3IC0geDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDIyNCwgMjI0LCAyMjQsIDAuOClcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCh4MSwgMCwgdywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlbGVhc2VCZWdpblRpbWUgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHgxID0geCArICh3aWR0aCAqIChyZWxlYXNlQmVnaW5UaW1lIC8gdG90YWxEdXJhdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICB3ICA9IHdpZHRoIC0geDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDIxMiwgMjEyLCAyMTIsIDAuOClcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCh4MSwgMCwgdywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyB5LXJhbmdlXG4gICAgICAgICAgICB2YXIgbWluVmFsdWUgPSBJbmZpbml0eSwgbWF4VmFsdWUgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPCBtaW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW2ldID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhWYWx1ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl8ucGxvdFJhbmdlID0gW21pblZhbHVlLCBtYXhWYWx1ZV07XG5cbiAgICAgICAgICAgIHRoaXMuXy5wbG90RGF0YSAgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5fLnBsb3RGbHVzaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyX3Bsb3QuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9O1xuICAgIGZuLnJlZ2lzdGVyKFwiZW52XCIsIEVudk5vZGUpO1xuXG5cbiAgICBmdW5jdGlvbiBlbnZWYWx1ZShvcHRzLCBtaW4sIGRlZiwgbmFtZTEsIG5hbWUyLCBmdW5jKSB7XG4gICAgICAgIHZhciB4ID0gZGVmO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHNbbmFtZTFdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gb3B0c1tuYW1lMV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHNbbmFtZTJdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gb3B0c1tuYW1lMl07XG4gICAgICAgIH0gZWxzZSBpZiAoZnVuYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzW25hbWUxXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHggPSBmdW5jKG9wdHNbbmFtZTFdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHNbbmFtZTJdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgeCA9IGZ1bmMob3B0c1tuYW1lMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh4IDwgbWluKSB7XG4gICAgICAgICAgICB4ID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIHZhciBaRVJPID0gRW52ZWxvcGUuWkVSTztcblxuICAgIGZuLnJlZ2lzdGVyKFwicGVyY1wiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICBpZiAoIWlzRGljdGlvbmFyeShfYXJnc1swXSkpIHtcbiAgICAgICAgICAgIF9hcmdzLnVuc2hpZnQoe30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdHMgPSBfYXJnc1swXTtcbiAgICAgICAgdmFyIGEgID0gZW52VmFsdWUob3B0cywgICAxMCwgICAxMCwgXCJhXCIgLCBcImF0dGFja1RpbWVcIiAsIHRpbWV2YWx1ZSk7XG4gICAgICAgIHZhciByICA9IGVudlZhbHVlKG9wdHMsICAgMTAsIDEwMDAsIFwiclwiICwgXCJyZWxlYXNlVGltZVwiLCB0aW1ldmFsdWUpO1xuICAgICAgICB2YXIgbHYgPSBlbnZWYWx1ZShvcHRzLCBaRVJPLCAgICAxLCBcImx2XCIsIFwibGV2ZWxcIiAgICAgKTtcblxuICAgICAgICBvcHRzLnRhYmxlID0gW1pFUk8sIFtsdiwgYV0sIFtaRVJPLCByXV07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBFbnZOb2RlKF9hcmdzKTtcbiAgICB9KTtcblxuICAgIGZuLnJlZ2lzdGVyKFwiYWRzclwiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICBpZiAoIWlzRGljdGlvbmFyeShfYXJnc1swXSkpIHtcbiAgICAgICAgICAgIF9hcmdzLnVuc2hpZnQoe30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdHMgPSBfYXJnc1swXTtcbiAgICAgICAgdmFyIGEgID0gZW52VmFsdWUob3B0cywgICAxMCwgICAxMCwgXCJhXCIgLCBcImF0dGFja1RpbWVcIiAgLCB0aW1ldmFsdWUpO1xuICAgICAgICB2YXIgZCAgPSBlbnZWYWx1ZShvcHRzLCAgIDEwLCAgMzAwLCBcImRcIiAsIFwiZGVjYXlUaW1lXCIgICAsIHRpbWV2YWx1ZSk7XG4gICAgICAgIHZhciBzICA9IGVudlZhbHVlKG9wdHMsIFpFUk8sICAwLjUsIFwic1wiICwgXCJzdXN0YWluTGV2ZWxcIik7XG4gICAgICAgIHZhciByICA9IGVudlZhbHVlKG9wdHMsICAgMTAsIDEwMDAsIFwiclwiICwgXCJkZWNheVRpbWVcIiAgICwgdGltZXZhbHVlKTtcbiAgICAgICAgdmFyIGx2ID0gZW52VmFsdWUob3B0cywgWkVSTywgICAgMSwgXCJsdlwiLCBcImxldmVsXCIgICAgICAgKTtcblxuICAgICAgICBvcHRzLnRhYmxlID0gW1pFUk8sIFtsdiwgYV0sIFtzLCBkXSwgW1pFUk8sIHJdXTtcbiAgICAgICAgb3B0cy5yZWxlYXNlTm9kZSA9IDM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBFbnZOb2RlKF9hcmdzKTtcbiAgICB9KTtcblxuICAgIGZuLnJlZ2lzdGVyKFwiYWRzaHJcIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgaWYgKCFpc0RpY3Rpb25hcnkoX2FyZ3NbMF0pKSB7XG4gICAgICAgICAgICBfYXJncy51bnNoaWZ0KHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRzID0gX2FyZ3NbMF07XG4gICAgICAgIHZhciBhICA9IGVudlZhbHVlKG9wdHMsICAgMTAsICAgMTAsIFwiYVwiICwgXCJhdHRhY2tUaW1lXCIgICwgdGltZXZhbHVlKTtcbiAgICAgICAgdmFyIGQgID0gZW52VmFsdWUob3B0cywgICAxMCwgIDMwMCwgXCJkXCIgLCBcImRlY2F5VGltZVwiICAgLCB0aW1ldmFsdWUpO1xuICAgICAgICB2YXIgcyAgPSBlbnZWYWx1ZShvcHRzLCBaRVJPLCAgMC41LCBcInNcIiAsIFwic3VzdGFpbkxldmVsXCIpO1xuICAgICAgICB2YXIgaCAgPSBlbnZWYWx1ZShvcHRzLCAgIDEwLCAgNTAwLCBcImhcIiAsIFwiaG9sZFRpbWVcIiAgICAsIHRpbWV2YWx1ZSk7XG4gICAgICAgIHZhciByICA9IGVudlZhbHVlKG9wdHMsICAgMTAsIDEwMDAsIFwiclwiICwgXCJkZWNheVRpbWVcIiAgICwgdGltZXZhbHVlKTtcbiAgICAgICAgdmFyIGx2ID0gZW52VmFsdWUob3B0cywgWkVSTywgICAgMSwgXCJsdlwiLCBcImxldmVsXCIgICAgICAgKTtcblxuICAgICAgICBvcHRzLnRhYmxlID0gW1pFUk8sIFtsdiwgYV0sIFtzLCBkXSwgW3MsIGhdLCBbWkVSTywgcl1dO1xuXG4gICAgICAgIHJldHVybiBuZXcgRW52Tm9kZShfYXJncyk7XG4gICAgfSk7XG5cbiAgICBmbi5yZWdpc3RlcihcImFzclwiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICBpZiAoIWlzRGljdGlvbmFyeShfYXJnc1swXSkpIHtcbiAgICAgICAgICAgIF9hcmdzLnVuc2hpZnQoe30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdHMgPSBfYXJnc1swXTtcbiAgICAgICAgdmFyIGEgID0gZW52VmFsdWUob3B0cywgICAxMCwgICAxMCwgXCJhXCIgLCBcImF0dGFja1RpbWVcIiAgLCB0aW1ldmFsdWUpO1xuICAgICAgICB2YXIgcyAgPSBlbnZWYWx1ZShvcHRzLCBaRVJPLCAgMC41LCBcInNcIiAsIFwic3VzdGFpbkxldmVsXCIpO1xuICAgICAgICB2YXIgciAgPSBlbnZWYWx1ZShvcHRzLCAgIDEwLCAxMDAwLCBcInJcIiAsIFwicmVsZWFzZVRpbWVcIiAsIHRpbWV2YWx1ZSk7XG5cbiAgICAgICAgb3B0cy50YWJsZSA9IFtaRVJPLCBbcywgYV0sIFtaRVJPLCByXV07XG4gICAgICAgIG9wdHMucmVsZWFzZU5vZGUgPSAyO1xuXG4gICAgICAgIHJldHVybiBuZXcgRW52Tm9kZShfYXJncyk7XG4gICAgfSk7XG5cbiAgICBmbi5yZWdpc3RlcihcImRhZHNyXCIsIGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgICAgIGlmICghaXNEaWN0aW9uYXJ5KF9hcmdzWzBdKSkge1xuICAgICAgICAgICAgX2FyZ3MudW5zaGlmdCh7fSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0cyA9IF9hcmdzWzBdO1xuICAgICAgICB2YXIgZGwgPSBlbnZWYWx1ZShvcHRzLCAgIDEwLCAgMTAwLCBcImRsXCIsIFwiZGVsYXlUaW1lXCIgICAsIHRpbWV2YWx1ZSk7XG4gICAgICAgIHZhciBhICA9IGVudlZhbHVlKG9wdHMsICAgMTAsICAgMTAsIFwiYVwiICwgXCJhdHRhY2tUaW1lXCIgICwgdGltZXZhbHVlKTtcbiAgICAgICAgdmFyIGQgID0gZW52VmFsdWUob3B0cywgICAxMCwgIDMwMCwgXCJkXCIgLCBcImRlY2F5VGltZVwiICAgLCB0aW1ldmFsdWUpO1xuICAgICAgICB2YXIgcyAgPSBlbnZWYWx1ZShvcHRzLCBaRVJPLCAgMC41LCBcInNcIiAsIFwic3VzdGFpbkxldmVsXCIpO1xuICAgICAgICB2YXIgciAgPSBlbnZWYWx1ZShvcHRzLCAgIDEwLCAxMDAwLCBcInJcIiAsIFwicmVsYXNlVGltZVwiICAsIHRpbWV2YWx1ZSk7XG4gICAgICAgIHZhciBsdiA9IGVudlZhbHVlKG9wdHMsIFpFUk8sICAgIDEsIFwibHZcIiwgXCJsZXZlbFwiICAgICAgICk7XG5cbiAgICAgICAgb3B0cy50YWJsZSA9IFtaRVJPLCBbWkVSTywgZGxdLCBbbHYsIGFdLCBbcywgZF0sIFtaRVJPLCByXV07XG4gICAgICAgIG9wdHMucmVsZWFzZU5vZGUgPSA0O1xuXG4gICAgICAgIHJldHVybiBuZXcgRW52Tm9kZShfYXJncyk7XG4gICAgfSk7XG5cbiAgICBmbi5yZWdpc3RlcihcImFoZHNmclwiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICBpZiAoIWlzRGljdGlvbmFyeShfYXJnc1swXSkpIHtcbiAgICAgICAgICAgIF9hcmdzLnVuc2hpZnQoe30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdHMgPSBfYXJnc1swXTtcbiAgICAgICAgdmFyIGEgID0gZW52VmFsdWUob3B0cywgICAxMCwgICAxMCwgXCJhXCIgLCBcImF0dGFja1RpbWVcIiAgLCB0aW1ldmFsdWUpO1xuICAgICAgICB2YXIgaCAgPSBlbnZWYWx1ZShvcHRzLCAgIDEwLCAgIDEwLCBcImhcIiAsIFwiaG9sZFRpbWVcIiAgICAsIHRpbWV2YWx1ZSk7XG4gICAgICAgIHZhciBkICA9IGVudlZhbHVlKG9wdHMsICAgMTAsICAzMDAsIFwiZFwiICwgXCJkZWNheVRpbWVcIiAgICwgdGltZXZhbHVlKTtcbiAgICAgICAgdmFyIHMgID0gZW52VmFsdWUob3B0cywgWkVSTywgIDAuNSwgXCJzXCIgLCBcInN1c3RhaW5MZXZlbFwiKTtcbiAgICAgICAgdmFyIGYgID0gZW52VmFsdWUob3B0cywgICAxMCwgNTAwMCwgXCJmXCIgLCBcImZhZGVUaW1lXCIgICAgLCB0aW1ldmFsdWUpO1xuICAgICAgICB2YXIgciAgPSBlbnZWYWx1ZShvcHRzLCAgIDEwLCAxMDAwLCBcInJcIiAsIFwicmVsYXNlVGltZVwiICAsIHRpbWV2YWx1ZSk7XG4gICAgICAgIHZhciBsdiA9IGVudlZhbHVlKG9wdHMsIFpFUk8sICAgIDEsIFwibHZcIiwgXCJsZXZlbFwiICAgICAgICk7XG5cbiAgICAgICAgb3B0cy50YWJsZSA9IFtaRVJPLCBbbHYsIGFdLCBbbHYsIGhdLCBbcywgZF0sIFtaRVJPLCBmXSwgW1pFUk8sIHJdXTtcbiAgICAgICAgb3B0cy5yZWxlYXNlTm9kZSA9IDU7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBFbnZOb2RlKF9hcmdzKTtcbiAgICB9KTtcblxuICAgIGZuLnJlZ2lzdGVyKFwibGluZW5cIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgaWYgKCFpc0RpY3Rpb25hcnkoX2FyZ3NbMF0pKSB7XG4gICAgICAgICAgICBfYXJncy51bnNoaWZ0KHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRzID0gX2FyZ3NbMF07XG4gICAgICAgIHZhciBhICA9IGVudlZhbHVlKG9wdHMsICAgMTAsICAgMTAsIFwiYVwiICwgXCJhdHRhY2tUaW1lXCIgLCB0aW1ldmFsdWUpO1xuICAgICAgICB2YXIgcyAgPSBlbnZWYWx1ZShvcHRzLCAgIDEwLCAxMDAwLCBcInNcIiAsIFwic3VzdGFpblRpbWVcIiwgdGltZXZhbHVlKTtcbiAgICAgICAgdmFyIHIgID0gZW52VmFsdWUob3B0cywgICAxMCwgMTAwMCwgXCJyXCIgLCBcInJlbGVhc2VUaW1lXCIsIHRpbWV2YWx1ZSk7XG4gICAgICAgIHZhciBsdiA9IGVudlZhbHVlKG9wdHMsIFpFUk8sICAgIDEsIFwibHZcIiwgXCJsZXZlbFwiICAgICAgKTtcblxuICAgICAgICBvcHRzLnRhYmxlID0gW1pFUk8sIFtsdiwgYV0sIFtsdiwgc10sIFtaRVJPLCByXV07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBFbnZOb2RlKF9hcmdzKTtcbiAgICB9KTtcblxuICAgIGZuLnJlZ2lzdGVyKFwiZW52LnRyaVwiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICBpZiAoIWlzRGljdGlvbmFyeShfYXJnc1swXSkpIHtcbiAgICAgICAgICAgIF9hcmdzLnVuc2hpZnQoe30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdHMgPSBfYXJnc1swXTtcbiAgICAgICAgdmFyIGR1ciA9IGVudlZhbHVlKG9wdHMsICAgMjAsIDEwMDAsIFwiZHVyXCIsIFwiZHVyYXRpb25cIiwgdGltZXZhbHVlKTtcbiAgICAgICAgdmFyIGx2ICA9IGVudlZhbHVlKG9wdHMsIFpFUk8sICAgIDEsIFwibHZcIiAsIFwibGV2ZWxcIiAgICk7XG5cbiAgICAgICAgZHVyICo9IDAuNTtcbiAgICAgICAgb3B0cy50YWJsZSA9IFtaRVJPLCBbbHYsIGR1cl0sIFtaRVJPLCBkdXJdXTtcblxuICAgICAgICByZXR1cm4gbmV3IEVudk5vZGUoX2FyZ3MpO1xuICAgIH0pO1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJlbnYuY3V0b2ZmXCIsIGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgICAgIGlmICghaXNEaWN0aW9uYXJ5KF9hcmdzWzBdKSkge1xuICAgICAgICAgICAgX2FyZ3MudW5zaGlmdCh7fSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0cyA9IF9hcmdzWzBdO1xuICAgICAgICB2YXIgciAgPSBlbnZWYWx1ZShvcHRzLCAgIDEwLCAxMDAsIFwiclwiICwgXCJyZWxhc2VUaW1lXCIsIHRpbWV2YWx1ZSk7XG4gICAgICAgIHZhciBsdiA9IGVudlZhbHVlKG9wdHMsIFpFUk8sICAgMSwgXCJsdlwiLCBcImxldmVsXCIgICAgKTtcblxuICAgICAgICBvcHRzLnRhYmxlID0gW2x2LCBbWkVSTywgcl1dO1xuXG4gICAgICAgIHJldHVybiBuZXcgRW52Tm9kZShfYXJncyk7XG4gICAgfSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcbiAgICB2YXIgRkZUID0gVC5tb2R1bGVzLkZGVDtcbiAgICB2YXIgQmlxdWFkID0gVC5tb2R1bGVzLkJpcXVhZDtcbiAgICB2YXIgUExPVF9MT1dfRlJFUSA9IDIwO1xuICAgIHZhciBQQVJBTV9OQU1FUyA9IHtcbiAgICAgICAgaHBmOjAsIGxmOjEsIGxtZjoyLCBtZjozLCBobWY6NCwgaGY6NSwgbHBmOjZcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRVFOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMiwgX2FyZ3MpO1xuICAgICAgICBmbi5maXhBUih0aGlzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5iaXF1YWRzID0gbmV3IEFycmF5KDcpO1xuXG4gICAgICAgIF8ucGxvdEJlZm9yZSA9IHBsb3RCZWZvcmU7XG4gICAgICAgIF8ucGxvdFJhbmdlICA9IFstMTgsIDE4XTtcbiAgICAgICAgXy5wbG90Rmx1c2ggID0gdHJ1ZTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKEVRTm9kZSk7XG5cbiAgICB2YXIgcGxvdEJlZm9yZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZ2IoMTkyLCAxOTIsIDE5MilcIjtcbiAgICAgICAgdmFyIG55cXVpc3QgPSB0aGlzLl8uc2FtcGxlcmF0ZSAqIDAuNTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMTA7ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBpICogTWF0aC5wb3coMTAsIGopO1xuICAgICAgICAgICAgICAgIGlmIChmIDw9IFBMT1RfTE9XX0ZSRVEgfHwgbnlxdWlzdCA8PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBfeCA9IChNYXRoLmxvZyhmL1BMT1RfTE9XX0ZSRVEpKSAvIChNYXRoLmxvZyhueXF1aXN0L1BMT1RfTE9XX0ZSRVEpKTtcbiAgICAgICAgICAgICAgICBfeCA9ICgoX3ggKiB3aWR0aCArIHgpfDApICsgMC41O1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKF94LCB5KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhfeCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoID0gaGVpZ2h0IC8gNjtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHZhciBfeSA9ICgoeSArIChpICogaCkpfDApICsgMC41O1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgX3kpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCArIHdpZHRoLCBfeSk7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciAkID0gRVFOb2RlLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBrZXlzLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gdmFsdWVba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhrZXlzW2ldLCBpdGVtc1swXSwgaXRlbXNbMV0sIGl0ZW1zWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQuc2V0UGFyYW1zID0gZnVuY3Rpb24oaW5kZXgsIGZyZXEsIFEsIGdhaW4pIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluZGV4ID0gUEFSQU1fTkFNRVNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwIDw9IGluZGV4ICYmIGluZGV4IDwgXy5iaXF1YWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaW5kZXggfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJlcSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgUSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2FpbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBnYWluID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJpcXVhZCA9IF8uYmlxdWFkc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCFiaXF1YWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmlxdWFkID0gXy5iaXF1YWRzW2luZGV4XSA9IG5ldyBCaXF1YWQoXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXF1YWQuc2V0VHlwZShcImhpZ2hwYXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXy5iaXF1YWRzLmxlbmd0aCAtIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXF1YWQuc2V0VHlwZShcImxvd3Bhc3NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpcXVhZC5zZXRUeXBlKFwicGVha2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpcXVhZC5zZXRQYXJhbXMoZnJlcSwgUSwgZ2Fpbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8uYmlxdWFkc1tpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLnBsb3RGbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQuZ2V0UGFyYW1zID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIHZhciBiaXF1YWQgPSBfLmJpcXVhZHNbaW5kZXh8MF07XG4gICAgICAgIGlmIChiaXF1YWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7ZnJlcTpiaXF1YWQuZnJlcXVlbmN5LCBROmJpcXVhZC5RLCBnYWluOmJpcXVhZC5nYWlufTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICBmbi5pbnB1dFNpZ25hbEFSKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoIV8uYnlwYXNzZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbEwgPSB0aGlzLmNlbGxzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsUiA9IHRoaXMuY2VsbHNbMl07XG4gICAgICAgICAgICAgICAgdmFyIGJpcXVhZHMgPSBfLmJpcXVhZHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBiaXF1YWRzLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmlxdWFkc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmlxdWFkc1tpXS5wcm9jZXNzKGNlbGxMLCBjZWxsUik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBmZnQgPSBuZXcgRkZUKDIwNDgpO1xuICAgIHZhciBzdXBlcl9wbG90ID0gVC5PYmplY3QucHJvdG90eXBlLnBsb3Q7XG5cbiAgICAkLnBsb3QgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLl8ucGxvdEZsdXNoKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgIHZhciBpbXBsdXNlID0gbmV3IEZsb2F0MzJBcnJheShmZnQubGVuZ3RoKTtcbiAgICAgICAgICAgIGltcGx1c2VbMF0gPSAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBfLmJpcXVhZHMubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0UGFyYW1zKGkpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpcXVhZCA9IG5ldyBCaXF1YWQoXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpcXVhZC5zZXRUeXBlKFwiaGlnaHBhc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gaW1heCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpcXVhZC5zZXRUeXBlKFwibG93cGFzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpcXVhZC5zZXRUeXBlKFwicGVha2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiaXF1YWQuc2V0UGFyYW1zKHBhcmFtcy5mcmVxLCBwYXJhbXMuUSwgcGFyYW1zLmdhaW4pO1xuICAgICAgICAgICAgICAgICAgICBiaXF1YWQucHJvY2VzcyhpbXBsdXNlLCBpbXBsdXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZmdC5mb3J3YXJkKGltcGx1c2UpO1xuXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IDUxMjtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIHZhciBueXF1aXN0ICA9IF8uc2FtcGxlcmF0ZSAqIDAuNTtcbiAgICAgICAgICAgIHZhciBzcGVjdHJ1bSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICB2YXIgaiwgZiwgaW5kZXgsIGRlbHRhLCB4MCwgeDEsIHh4O1xuXG4gICAgICAgICAgICBmZnQuZ2V0RnJlcXVlbmN5RGF0YShzcGVjdHJ1bSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICAgICAgZiA9IE1hdGgucG93KG55cXVpc3QgLyBQTE9UX0xPV19GUkVRLCBpIC8gc2l6ZSkgKiBQTE9UX0xPV19GUkVRO1xuICAgICAgICAgICAgICAgIGogPSBmIC8gKG55cXVpc3QgLyBzcGVjdHJ1bS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0ganwwO1xuICAgICAgICAgICAgICAgIGRlbHRhID0gaiAtIGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB4MSA9IHgwID0geHggPSBzcGVjdHJ1bVtpbmRleF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeDAgPSBzcGVjdHJ1bVtpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB4MSA9IHNwZWN0cnVtW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgeHggPSAoKDEuMCAtIGRlbHRhKSAqIHgwICsgZGVsdGEgKiB4MSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSB4eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuXy5wbG90RGF0YSAgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5fLnBsb3RGbHVzaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyX3Bsb3QuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJlcVwiLCBFUU5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiAgPSBULmZuO1xuICAgIHZhciBGRlQgPSBULm1vZHVsZXMuRkZUO1xuXG4gICAgZnVuY3Rpb24gRkZUTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDIsIF9hcmdzKTtcbiAgICAgICAgZm4ubGlzdGVuZXIodGhpcyk7XG4gICAgICAgIGZuLmZpeEFSKHRoaXMpO1xuXG4gICAgICAgIHRoaXMucmVhbCA9IG5ldyBULkNoYW5uZWxPYmplY3QodGhpcyk7XG4gICAgICAgIHRoaXMuaW1hZyA9IG5ldyBULkNoYW5uZWxPYmplY3QodGhpcyk7XG4gICAgICAgIHRoaXMuY2VsbHNbM10gPSB0aGlzLnJlYWwuY2VsbDtcbiAgICAgICAgdGhpcy5jZWxsc1s0XSA9IHRoaXMuaW1hZy5jZWxsO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLmZmdCA9IG5ldyBGRlQoXy5jZWxsc2l6ZSAqIDIpO1xuICAgICAgICBfLmZmdENlbGwgID0gbmV3IGZuLlNpZ25hbEFycmF5KF8uZmZ0Lmxlbmd0aCk7XG4gICAgICAgIF8ucHJldkNlbGwgPSBuZXcgZm4uU2lnbmFsQXJyYXkoXy5jZWxsc2l6ZSk7XG4gICAgICAgIF8uZnJlcXMgICAgPSBuZXcgZm4uU2lnbmFsQXJyYXkoXy5mZnQubGVuZ3RoPj4xKTtcblxuICAgICAgICBfLnBsb3RGbHVzaCA9IHRydWU7XG4gICAgICAgIF8ucGxvdFJhbmdlID0gWzAsIDMyXTtcbiAgICAgICAgXy5wbG90QmFyU3R5bGUgPSB0cnVlO1xuICAgIH1cbiAgICBmbi5leHRlbmQoRkZUTm9kZSk7XG5cbiAgICB2YXIgJCA9IEZGVE5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICB3aW5kb3c6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8uZmZ0LnNldFdpbmRvdyh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmZmdC53aW5kb3dOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzcGVjdHJ1bToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmZmdC5nZXRGcmVxdWVuY3lEYXRhKHRoaXMuXy5mcmVxcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuICAgICAgICAgICAgdmFyIGNlbGxzaXplID0gXy5jZWxsc2l6ZTtcblxuICAgICAgICAgICAgXy5mZnRDZWxsLnNldChfLnByZXZDZWxsKTtcbiAgICAgICAgICAgIF8uZmZ0Q2VsbC5zZXQoY2VsbCwgY2VsbHNpemUpO1xuICAgICAgICAgICAgXy5mZnQuZm9yd2FyZChfLmZmdENlbGwpO1xuICAgICAgICAgICAgXy5wcmV2Q2VsbC5zZXQoY2VsbCk7XG4gICAgICAgICAgICBfLnBsb3RGbHVzaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuY2VsbHNbM10uc2V0KF8uZmZ0LnJlYWwuc3ViYXJyYXkoMCwgY2VsbHNpemUpKTtcbiAgICAgICAgICAgIHRoaXMuY2VsbHNbNF0uc2V0KF8uZmZ0LmltYWcuc3ViYXJyYXkoMCwgY2VsbHNpemUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgc3VwZXJfcGxvdCA9IFQuT2JqZWN0LnByb3RvdHlwZS5wbG90O1xuXG4gICAgJC5wbG90ID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgICBpZiAodGhpcy5fLnBsb3RGbHVzaCkge1xuICAgICAgICAgICAgdGhpcy5fLnBsb3REYXRhICA9IHRoaXMuc3BlY3RydW07XG4gICAgICAgICAgICB0aGlzLl8ucGxvdEZsdXNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXJfcGxvdC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcImZmdFwiLCBGRlROb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gRk5vaXNlTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcbiAgICAgICAgZm4uZml4QVIodGhpcyk7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIF8uZnJlcSA9IFQoNDQwKTtcbiAgICAgICAgXy5yZWcgPSAweDgwMDA7XG4gICAgICAgIF8uc2hvcnRGbGFnID0gZmFsc2U7XG4gICAgICAgIF8ucGhhc2UgICAgID0gMDtcbiAgICAgICAgXy5sYXN0VmFsdWUgPSAwO1xuICAgIH1cbiAgICBmbi5leHRlbmQoRk5vaXNlTm9kZSk7XG5cbiAgICB2YXIgJCA9IEZOb2lzZU5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICBzaG9ydEZsYWc6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8uc2hvcnRGbGFnID0gISF2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uc2hvcnRGbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcmVxOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmZyZXEgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZnJlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNbMF07XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICB2YXIgbGFzdFZhbHVlID0gXy5sYXN0VmFsdWU7XG4gICAgICAgICAgICB2YXIgcGhhc2UgICAgID0gXy5waGFzZTtcbiAgICAgICAgICAgIHZhciBwaGFzZVN0ZXAgPSBfLmZyZXEucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdIC8gXy5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgdmFyIHJlZyA9IF8ucmVnO1xuICAgICAgICAgICAgdmFyIG11bCA9IF8ubXVsLCBhZGQgPSBfLmFkZDtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4O1xuXG4gICAgICAgICAgICBpZiAoXy5zaG9ydEZsYWcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpbWF4ID0gY2VsbC5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBoYXNlID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZyA+Pj0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZyB8PSAoKHJlZyBeIChyZWcgPj4gNikpICYgMSkgPDwgMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSAoKHJlZyAmIDEpIC0gMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2VsbFtpXSA9IGxhc3RWYWx1ZSAqIG11bCArIGFkZDtcbiAgICAgICAgICAgICAgICAgICAgcGhhc2UgKz0gcGhhc2VTdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IGNlbGwubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaGFzZSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWcgPj49IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWcgfD0gKChyZWcgXiAocmVnID4+IDEpKSAmIDEpIDw8IDE1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gKChyZWcgJiAxKSAtIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaGFzZSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbaV0gPSBsYXN0VmFsdWUgKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgICAgIHBoYXNlICs9IHBoYXNlU3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLnJlZyAgICAgICA9IHJlZztcbiAgICAgICAgICAgIF8ucGhhc2UgICAgID0gcGhhc2U7XG4gICAgICAgICAgICBfLmxhc3RWYWx1ZSA9IGxhc3RWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcImZub2lzZVwiLCBGTm9pc2VOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgdmFyIEdhdGVDaGFubmVsTm9kZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gR2F0ZUNoYW5uZWxOb2RlKHBhcmVudCkge1xuICAgICAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAyLCBbXSk7XG4gICAgICAgICAgICBmbi5maXhBUih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuXy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZm4uZXh0ZW5kKEdhdGVDaGFubmVsTm9kZSk7XG5cbiAgICAgICAgR2F0ZUNoYW5uZWxOb2RlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuICAgICAgICAgICAgICAgIHRoaXMuXy5wYXJlbnQucHJvY2Vzcyh0aWNrSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEdhdGVDaGFubmVsTm9kZTtcbiAgICB9KSgpO1xuXG4gICAgZnVuY3Rpb24gR2F0ZU5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAyLCBfYXJncyk7XG4gICAgICAgIGZuLmZpeEFSKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuXy5zZWxlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMuXy5vdXRwdXRzICA9IFtdO1xuICAgIH1cbiAgICBmbi5leHRlbmQoR2F0ZU5vZGUpO1xuXG4gICAgdmFyICQgPSBHYXRlTm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBfLnNlbGVjdGVkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRzID0gXy5vdXRwdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IG91dHB1dHMubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHNbaV0uY2VsbHNbMF0uc2V0KGZuLmVtcHR5Y2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0c1tpXS5jZWxsc1sxXS5zZXQoZm4uZW1wdHljZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzW2ldLmNlbGxzWzJdLnNldChmbi5lbXB0eWNlbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5zZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5hdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICB2YXIgb3V0cHV0ID0gXy5vdXRwdXRzW2luZGV4XTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgIF8ub3V0cHV0c1tpbmRleF0gPSBvdXRwdXQgPSBuZXcgR2F0ZUNoYW5uZWxOb2RlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IF8ub3V0cHV0c1tfLnNlbGVjdGVkXTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuY2VsbHNbMF0uc2V0KHRoaXMuY2VsbHNbMF0pO1xuICAgICAgICAgICAgICAgIG91dHB1dC5jZWxsc1sxXS5zZXQodGhpcy5jZWxsc1sxXSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmNlbGxzWzJdLnNldCh0aGlzLmNlbGxzWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcImdhdGVcIiwgR2F0ZU5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiAgPSBULmZuO1xuICAgIHZhciBGRlQgPSBULm1vZHVsZXMuRkZUO1xuXG4gICAgZnVuY3Rpb24gSUZGVE5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAxLCBfYXJncyk7XG4gICAgICAgIGZuLmZpeEFSKHRoaXMpO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLmZmdCA9IG5ldyBGRlQoXy5jZWxsc2l6ZSAqIDIpO1xuICAgICAgICBfLmZmdENlbGwgICAgPSBuZXcgZm4uU2lnbmFsQXJyYXkodGhpcy5fLmZmdC5sZW5ndGgpO1xuICAgICAgICBfLnJlYWxCdWZmZXIgPSBuZXcgZm4uU2lnbmFsQXJyYXkodGhpcy5fLmZmdC5sZW5ndGgpO1xuICAgICAgICBfLmltYWdCdWZmZXIgPSBuZXcgZm4uU2lnbmFsQXJyYXkodGhpcy5fLmZmdC5sZW5ndGgpO1xuICAgIH1cbiAgICBmbi5leHRlbmQoSUZGVE5vZGUpO1xuXG4gICAgdmFyICQgPSBJRkZUTm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIHJlYWw6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8ucmVhbCA9IFQodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5yZWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbWFnOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmltYWcgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uaW1hZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgaWYgKF8ucmVhbCAmJiBfLmltYWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHJlYWwgPSBfLnJlYWxCdWZmZXI7XG4gICAgICAgICAgICAgICAgdmFyIGltYWcgPSBfLmltYWdCdWZmZXI7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWFsID0gXy5yZWFsLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgX2ltYWcgPSBfLmltYWcucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdO1xuXG4gICAgICAgICAgICAgICAgcmVhbC5zZXQoX3JlYWwpO1xuICAgICAgICAgICAgICAgIGltYWcuc2V0KF9pbWFnKTtcblxuICAgICAgICAgICAgICAgIGNlbGwuc2V0KF8uZmZ0LmludmVyc2UocmVhbCwgaW1hZykuc3ViYXJyYXkoMCwgXy5jZWxsc2l6ZSkpO1xuXG4gICAgICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJpZmZ0XCIsIElGRlROb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuICAgIHZhciB0aW1ldmFsdWUgPSBULnRpbWV2YWx1ZTtcblxuICAgIGZ1bmN0aW9uIEludGVydmFsTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcbiAgICAgICAgZm4udGltZXIodGhpcyk7XG4gICAgICAgIGZuLmZpeEtSKHRoaXMpO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLmludGVydmFsID0gVCgxMDAwKTtcbiAgICAgICAgXy5jb3VudCA9IDA7XG4gICAgICAgIF8uZGVsYXkgICA9IDA7XG4gICAgICAgIF8udGltZW91dCA9IEluZmluaXR5O1xuICAgICAgICBfLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgXy5kZWxheVNhbXBsZXMgPSAwO1xuICAgICAgICBfLmNvdW50U2FtcGxlcyA9IDA7XG4gICAgICAgIF8ub25lbmRlZCA9IGZuLm1ha2Vfb25lbmRlZCh0aGlzKTtcblxuICAgICAgICB0aGlzLm9uKFwic3RhcnRcIiwgb25zdGFydCk7XG4gICAgfVxuICAgIGZuLmV4dGVuZChJbnRlcnZhbE5vZGUpO1xuXG4gICAgdmFyIG9uc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIHRoaXMucGxheWJhY2tTdGF0ZSA9IGZuLlBMQVlJTkdfU1RBVEU7XG4gICAgICAgIF8uZGVsYXlTYW1wbGVzID0gKF8uc2FtcGxlcmF0ZSAqIChfLmRlbGF5ICogMC4wMDEpKXwwO1xuICAgICAgICBfLmNvdW50U2FtcGxlcyA9IF8uY291bnQgPSBfLmN1cnJlbnRUaW1lID0gMDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvbnN0YXJ0LCBcInVucmVtb3ZhYmxlXCIsIHtcbiAgICAgICAgdmFsdWU6dHJ1ZSwgd3JpdGFibGU6ZmFsc2VcbiAgICB9KTtcblxuICAgIHZhciAkID0gSW50ZXJ2YWxOb2RlLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgaW50ZXJ2YWw6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGltZXZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl8uaW50ZXJ2YWwgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uaW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGF5OiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRpbWV2YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8uZGVsYXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmRlbGF5U2FtcGxlcyA9ICh0aGlzLl8uc2FtcGxlcmF0ZSAqICh2YWx1ZSAqIDAuMDAxKSl8MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmRlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb3VudDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmNvdW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGltZW91dDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aW1ldmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHZhbHVlID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnRpbWVvdXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbnRUaW1lOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uY3VycmVudFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQuYmFuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gZm4uUExBWUlOR19TVEFURTtcbiAgICAgICAgXy5kZWxheVNhbXBsZXMgPSAoXy5zYW1wbGVyYXRlICogKF8uZGVsYXkgKiAwLjAwMSkpfDA7XG4gICAgICAgIF8uY291bnRTYW1wbGVzID0gXy5jb3VudCA9IF8uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICBfLmVtaXQoXCJiYW5nXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1swXTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIGlmIChfLmRlbGF5U2FtcGxlcyA+IDApIHtcbiAgICAgICAgICAgICAgICBfLmRlbGF5U2FtcGxlcyAtPSBjZWxsLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gXy5pbnRlcnZhbC5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF1bMF07XG5cbiAgICAgICAgICAgIGlmIChfLmRlbGF5U2FtcGxlcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgXy5jb3VudFNhbXBsZXMgLT0gY2VsbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKF8uY291bnRTYW1wbGVzIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgXy5jb3VudFNhbXBsZXMgKz0gKF8uc2FtcGxlcmF0ZSAqIGludGVydmFsICogMC4wMDEpfDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCAgPSBfLmNvdW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGNvdW50ICogXy5tdWwgKyBfLmFkZDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGptYXggPSBjZWxsLmxlbmd0aDsgaiA8IGptYXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFtqXSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBub2Rlcy5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLmJhbmcoY291bnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF8uY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmN1cnJlbnRUaW1lICs9IGZuLmN1cnJlbnRUaW1lSW5jcjtcblxuICAgICAgICAgICAgaWYgKF8uY3VycmVudFRpbWUgPj0gXy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgZm4ubmV4dFRpY2soXy5vbmVuZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJpbnRlcnZhbFwiLCBJbnRlcnZhbE5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG4gICAgdmFyIHRpbWV2YWx1ZSA9IFQudGltZXZhbHVlO1xuXG4gICAgZnVuY3Rpb24gTGFnTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcbiAgICAgICAgZm4uZml4QVIodGhpcyk7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIHZhciBiaXRzID0gTWF0aC5jZWlsKE1hdGgubG9nKF8uc2FtcGxlcmF0ZSkgKiBNYXRoLkxPRzJFKTtcbiAgICAgICAgXy5idWZmZXJzaXplID0gMSA8PCBiaXRzO1xuICAgICAgICBfLmJ1ZmZlcm1hc2sgPSBfLmJ1ZmZlcnNpemUgLSAxO1xuICAgICAgICBfLmJ1ZmZlciA9IG5ldyBmbi5TaWduYWxBcnJheShfLmJ1ZmZlcnNpemUpO1xuICAgICAgICBfLnRpbWUgPSAwO1xuICAgICAgICBfLnJlYWRJbmRleCAgPSAwO1xuICAgICAgICBfLndyaXRlSW5kZXggPSAwO1xuICAgIH1cbiAgICBmbi5leHRlbmQoTGFnTm9kZSk7XG5cbiAgICB2YXIgJCA9IExhZ05vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICB0aW1lOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRpbWV2YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgICAgICAgICBfLnRpbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9ICh2YWx1ZSAqIDAuMDAxICogXy5zYW1wbGVyYXRlKXwwO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID4gXy5idWZmZXJtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBfLmJ1ZmZlcm1hc2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXy53cml0ZUluZGV4ID0gKF8ucmVhZEluZGV4ICsgb2Zmc2V0KSAmIF8uYnVmZmVybWFzaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1swXTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBfLmJ1ZmZlcjtcbiAgICAgICAgICAgIHZhciBtYXNrICAgPSBfLmJ1ZmZlcm1hc2s7XG4gICAgICAgICAgICB2YXIgcmVhZEluZGV4ICA9IF8ucmVhZEluZGV4O1xuICAgICAgICAgICAgdmFyIHdyaXRlSW5kZXggPSBfLndyaXRlSW5kZXg7XG4gICAgICAgICAgICB2YXIgaSwgaW1heCA9IGNlbGwubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW3dyaXRlSW5kZXhdID0gY2VsbFtpXTtcbiAgICAgICAgICAgICAgICBjZWxsW2ldID0gYnVmZmVyW3JlYWRJbmRleF07XG5cbiAgICAgICAgICAgICAgICByZWFkSW5kZXggICs9IDE7XG4gICAgICAgICAgICAgICAgd3JpdGVJbmRleCA9ICh3cml0ZUluZGV4ICsgMSkgJiBtYXNrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLnJlYWRJbmRleCAgPSByZWFkSW5kZXggJiBtYXNrO1xuICAgICAgICAgICAgXy53cml0ZUluZGV4ID0gd3JpdGVJbmRleDtcblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJsYWdcIiwgTGFnTm9kZSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcblxuICAgIGZ1bmN0aW9uIE1hcE5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAxLCBfYXJncyk7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLmlucHV0ICA9IDA7XG4gICAgICAgIF8udmFsdWUgPSAwO1xuICAgICAgICBfLnByZXYgICA9IG51bGw7XG4gICAgICAgIF8uYXIgICAgID0gZmFsc2U7XG4gICAgICAgIF8ubWFwICAgID0gZGVmYXVsdEZ1bmN0aW9uO1xuICAgIH1cbiAgICBmbi5leHRlbmQoTWFwTm9kZSk7XG5cbiAgICB2YXIgZGVmYXVsdEZ1bmN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuXG4gICAgdmFyICQgPSBNYXBOb2RlLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5pbnB1dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8ubWFwID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQuYmFuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl8ucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuXy5lbWl0KFwiYmFuZ1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQuYXQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuXy5tYXApID8gdGhpcy5fLm1hcChpbnB1dCkgOiAwO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4ID0gY2VsbC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChfLmFyICYmIGxlbikge1xuICAgICAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IF8ubWFwO1xuICAgICAgICAgICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFtpXSA9IG1hcChjZWxsW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLnZhbHVlID0gY2VsbFtpbWF4LTFdO1xuICAgICAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBsZW4gPyBmbi5pbnB1dFNpZ25hbEtSKHRoaXMpIDogXy5pbnB1dDtcbiAgICAgICAgICAgICAgICBpZiAoXy5tYXAgJiYgXy5wcmV2ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBfLnByZXYgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgXy52YWx1ZSA9IF8ubWFwKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gXy52YWx1ZSAqIF8ubXVsICsgXy5hZGQ7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwibWFwXCIsIE1hcE5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG5cbiAgICBmdW5jdGlvbiBNYXhOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMSwgX2FyZ3MpO1xuICAgIH1cbiAgICBmbi5leHRlbmQoTWF4Tm9kZSk7XG5cbiAgICB2YXIgJCA9IE1heE5vZGUucHJvdG90eXBlO1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1swXTtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgICAgICAgdmFyIGksIGltYXggPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaiwgam1heCA9IGNlbGwubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRtcCwgdmFsO1xuXG4gICAgICAgICAgICBpZiAoXy5hcikge1xuICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IG5vZGVzWzBdLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5zZXQodG1wKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbm9kZXNbaV0ucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGptYXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHRtcFtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbFtqXSA8IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsW2pdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqbWF4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxbal0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSBub2Rlc1swXS5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG5vZGVzW2ldLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXAgPCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsWzBdID0gdG1wO1xuICAgICAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEtSKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwibWF4XCIsIE1heE5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChULmVudnR5cGUgIT09IFwiYnJvd3NlclwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuICAgIHZhciBCVUZGRVJfU0laRSA9IDQwOTY7XG4gICAgdmFyIEJVRkZFUl9NQVNLID0gQlVGRkVSX1NJWkUgLSAxO1xuXG4gICAgZnVuY3Rpb24gTWVkaWFTdHJlYW1Ob2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMiwgX2FyZ3MpO1xuICAgICAgICBmbi5maXhBUih0aGlzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5zcmMgPSBfLmZ1bmMgPSBudWxsO1xuICAgICAgICBfLmJ1ZmZlckwgPSBuZXcgZm4uU2lnbmFsQXJyYXkoQlVGRkVSX1NJWkUpO1xuICAgICAgICBfLmJ1ZmZlclIgPSBuZXcgZm4uU2lnbmFsQXJyYXkoQlVGRkVSX1NJWkUpO1xuICAgICAgICBfLnJlYWRJbmRleCAgPSAwO1xuICAgICAgICBfLndyaXRlSW5kZXggPSAwO1xuICAgICAgICBfLnRvdGFsUmVhZCAgPSAwO1xuICAgICAgICBfLnRvdGFsV3JpdGUgPSAwO1xuICAgIH1cbiAgICBmbi5leHRlbmQoTWVkaWFTdHJlYW1Ob2RlKTtcblxuICAgIHZhciAkID0gTWVkaWFTdHJlYW1Ob2RlLnByb3RvdHlwZTtcblxuICAgICQubGlzdGVuID0gZnVuY3Rpb24oYXVkaW8pIHtcbiAgICAgICAgdmFyIF9pbXBsID0gaW1wbFtULmVudl07XG4gICAgICAgIGlmIChfaW1wbCkge1xuICAgICAgICAgICAgX2ltcGwuc2V0LmNhbGwodGhpcywgYXVkaW8pO1xuICAgICAgICAgICAgX2ltcGwubGlzdGVuLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC51bmxpc3RlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ltcGwgPSBpbXBsW1QuZW52XTtcbiAgICAgICAgaWYgKF9pbXBsKSB7XG4gICAgICAgICAgICBfaW1wbC51bmxpc3Rlbi5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jZWxsc1swXS5zZXQoZm4uZW1wdHljZWxsKTtcbiAgICAgICAgdGhpcy5jZWxsc1sxXS5zZXQoZm4uZW1wdHljZWxsKTtcbiAgICAgICAgdGhpcy5jZWxsc1syXS5zZXQoZm4uZW1wdHljZWxsKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgdmFyIGJ1ZmZlckwgPSBfLmJ1ZmZlckwsIGJ1ZmZlclIgPSBfLmJ1ZmZlclI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbWF4ID0gYnVmZmVyTC5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxbaV0gPSBidWZmZXJSW2ldID0gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKF8uc3JjID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgdmFyIGNlbGxzaXplID0gXy5jZWxsc2l6ZTtcbiAgICAgICAgICAgIGlmIChfLnRvdGFsV3JpdGUgPiBfLnRvdGFsUmVhZCArIGNlbGxzaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlZ2luID0gXy5yZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCAgID0gYmVnaW4gKyBjZWxsc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzWzFdLnNldChfLmJ1ZmZlckwuc3ViYXJyYXkoYmVnaW4sIGVuZCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHNbMl0uc2V0KF8uYnVmZmVyUi5zdWJhcnJheShiZWdpbiwgZW5kKSk7XG4gICAgICAgICAgICAgICAgXy5yZWFkSW5kZXggPSBlbmQgJiBCVUZGRVJfTUFTSztcbiAgICAgICAgICAgICAgICBfLnRvdGFsUmVhZCArPSBjZWxsc2l6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIGltcGwgPSB7fTtcbiAgICBpbXBsLndlYmtpdCA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgLypnbG9iYWwgSFRNTE1lZGlhRWxlbWVudDp0cnVlICovXG4gICAgICAgICAgICBpZiAoc3JjIGluc3RhbmNlb2YgSFRNTE1lZGlhRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZm4uX2F1ZGlvQ29udGV4dDtcbiAgICAgICAgICAgICAgICBfLnNyYyA9IGNvbnRleHQuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKHNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKmdsb2JhbCBIVE1MTWVkaWFFbGVtZW50OmZhbHNlICovXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZm4uX2F1ZGlvQ29udGV4dDtcbiAgICAgICAgICAgIF8uZ2FpbiA9IGNvbnRleHQuY3JlYXRlR2Fpbk5vZGUoKTtcbiAgICAgICAgICAgIF8uZ2Fpbi5nYWluLnZhbHVlID0gMDtcbiAgICAgICAgICAgIF8ubm9kZSA9IGNvbnRleHQuY3JlYXRlSmF2YVNjcmlwdE5vZGUoMTAyNCwgMiwgMik7XG4gICAgICAgICAgICBfLm5vZGUub25hdWRpb3Byb2Nlc3MgPSBvbmF1ZGlvcHJvY2Vzcyh0aGlzKTtcbiAgICAgICAgICAgIF8uc3JjLmNvbm5lY3QoXy5ub2RlKTtcbiAgICAgICAgICAgIF8ubm9kZS5jb25uZWN0KF8uZ2Fpbik7XG4gICAgICAgICAgICBfLmdhaW4uY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5saXN0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgICAgICBpZiAoXy5zcmMpIHtcbiAgICAgICAgICAgICAgICBfLnNyYy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXy5nYWluKSB7XG4gICAgICAgICAgICAgICAgXy5nYWluLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfLm5vZGUpIHtcbiAgICAgICAgICAgICAgICBfLm5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHNlbGYuXztcbiAgICAgICAgICAgIHZhciBpbnMgPSBlLmlucHV0QnVmZmVyO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGlucy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgd3JpdGVJbmRleCA9IF8ud3JpdGVJbmRleDtcblxuICAgICAgICAgICAgXy5idWZmZXJMLnNldChpbnMuZ2V0Q2hhbm5lbERhdGEoMCksIHdyaXRlSW5kZXgpO1xuICAgICAgICAgICAgXy5idWZmZXJSLnNldChpbnMuZ2V0Q2hhbm5lbERhdGEoMSksIHdyaXRlSW5kZXgpO1xuICAgICAgICAgICAgXy53cml0ZUluZGV4ID0gKHdyaXRlSW5kZXggKyBsZW5ndGgpICYgQlVGRkVSX01BU0s7XG4gICAgICAgICAgICBfLnRvdGFsV3JpdGUgKz0gbGVuZ3RoO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBpbXBsLm1veiA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgLypnbG9iYWwgSFRNTEF1ZGlvRWxlbWVudDp0cnVlICovXG4gICAgICAgICAgICBpZiAoc3JjIGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF8uc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgIF8uaXN0ZXAgPSBfLnNhbXBsZXJhdGUgLyBzcmMubW96U2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qZ2xvYmFsIEhUTUxBdWRpb0VsZW1lbnQ6ZmFsc2UgKi9cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgdmFyIG8wID0gXy5idWZmZXJMO1xuICAgICAgICAgICAgdmFyIG8xID0gXy5idWZmZXJSO1xuICAgICAgICAgICAgdmFyIHByZXYwID0gMCwgcHJldjEgPSAwO1xuICAgICAgICAgICAgaWYgKF8uc3JjLm1vekNoYW5uZWxzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgXy54ID0gMDtcbiAgICAgICAgICAgICAgICBfLmZ1bmMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cml0ZUluZGV4ID0gXy53cml0ZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxXcml0ZSA9IF8udG90YWxXcml0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbXBsZXMgPSBlLmZyYW1lQnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCwgaXN0ZXAgPSBfLmlzdGVwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaW1heCA9IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB4ID0gXy54O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgaSs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gaXN0ZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoeCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvMFt3cml0ZUluZGV4XSA9IChzYW1wbGVzW2kgIF0gKyBwcmV2MCkgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbzFbd3JpdGVJbmRleF0gPSAoc2FtcGxlc1tpKzFdICsgcHJldjEpICogMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSW5kZXggPSAod3JpdGVJbmRleCArIDEpICYgQlVGRkVSX01BU0s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0b3RhbFdyaXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYwID0gc2FtcGxlc1tpICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldjEgPSBzYW1wbGVzW2krMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXy54ID0geDtcbiAgICAgICAgICAgICAgICAgICAgXy53cml0ZUluZGV4ID0gd3JpdGVJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgXy50b3RhbFdyaXRlID0gdG90YWxXcml0ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfLnggPSAwO1xuICAgICAgICAgICAgICAgIF8uZnVuYyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyaXRlSW5kZXggPSBfLndyaXRlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFdyaXRlID0gXy50b3RhbFdyaXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FtcGxlcyA9IGUuZnJhbWVCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4LCBpc3RlcCA9IF8uaXN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBpbWF4ID0gc2FtcGxlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHggPSBfLng7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gaXN0ZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbzBbd3JpdGVJbmRleF0gPSBvMVt3cml0ZUluZGV4XSA9IChzYW1wbGVzW2ldICsgcHJldjApICogMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSW5kZXggPSAod3JpdGVJbmRleCArIDEpICYgQlVGRkVSX01BU0s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0b3RhbFdyaXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYwID0gc2FtcGxlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfLnggPSB4O1xuICAgICAgICAgICAgICAgICAgICBfLndyaXRlSW5kZXggPSB3cml0ZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICBfLnRvdGFsV3JpdGUgPSB0b3RhbFdyaXRlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLnNyYy5hZGRFdmVudExpc3RlbmVyKFwiTW96QXVkaW9BdmFpbGFibGVcIiwgXy5mdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5saXN0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgICAgICBpZiAoXy5mdW5jKSB7XG4gICAgICAgICAgICAgICAgXy5zcmMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1vekF1ZGlvQXZhaWxhYmxlXCIsIF8uZnVuYyk7XG4gICAgICAgICAgICAgICAgXy5mdW5jID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcIm1lZGlhc3RyZWFtXCIsIE1lZGlhU3RyZWFtTm9kZSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcblxuICAgIGZ1bmN0aW9uIE1pZGlDcHNOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMSwgX2FyZ3MpO1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5taWRpID0gMDtcbiAgICAgICAgXy52YWx1ZSA9IDA7XG4gICAgICAgIF8ucHJldiAgPSBudWxsO1xuICAgICAgICBfLmE0ICAgID0gNDQwO1xuICAgICAgICBfLmFyICAgID0gZmFsc2U7XG4gICAgfVxuICAgIGZuLmV4dGVuZChNaWRpQ3BzTm9kZSk7XG5cbiAgICB2YXIgJCA9IE1pZGlDcHNOb2RlLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgbWlkaToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLm1pZGkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLm1pZGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGE0OiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8uYTQgICA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8ucHJldiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5hNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5iYW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuXy5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fLmVtaXQoXCJiYW5nXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5hdCA9IGZ1bmN0aW9uKG1pZGkpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIHJldHVybiBfLmE0ICogTWF0aC5wb3coMiwgKG1pZGkgLSA2OSkgLyAxMik7XG4gICAgfTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1swXTtcbiAgICAgICAgICAgIHZhciBsZW4gID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaSwgaW1heCA9IGNlbGwubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoXy5hciAmJiBsZW4pIHtcbiAgICAgICAgICAgICAgICBmbi5pbnB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBhNCA9IF8uYTQ7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsW2ldID0gYTQgKiBNYXRoLnBvdygyLCAoY2VsbFtpXSAtIDY5KSAvIDEyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy52YWx1ZSA9IGNlbGxbaW1heC0xXTtcbiAgICAgICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gKGxlbikgPyBmbi5pbnB1dFNpZ25hbEtSKHRoaXMpIDogXy5taWRpO1xuICAgICAgICAgICAgICAgIGlmIChfLnByZXYgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIF8ucHJldiA9IGlucHV0O1xuICAgICAgICAgICAgICAgICAgICBfLnZhbHVlID0gXy5hNCAqIE1hdGgucG93KDIsIChpbnB1dCAtIDY5KSAvIDEyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbFswXSA9IF8udmFsdWU7XG4gICAgICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsS1IodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJtaWRpY3BzXCIsIE1pZGlDcHNOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gTWlkaVJhdGlvTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIF8ubWlkaSA9IDA7XG4gICAgICAgIF8udmFsdWUgPSAwO1xuICAgICAgICBfLnByZXYgID0gbnVsbDtcbiAgICAgICAgXy5yYW5nZSA9IDEyO1xuICAgICAgICBfLmFyICAgID0gZmFsc2U7XG4gICAgfVxuICAgIGZuLmV4dGVuZChNaWRpUmF0aW9Ob2RlKTtcblxuICAgIHZhciAkID0gTWlkaVJhdGlvTm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIG1pZGk6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5taWRpID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5taWRpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5yYW5nZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ucmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQuYmFuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl8ucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuXy5lbWl0KFwiYmFuZ1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQuYXQgPSBmdW5jdGlvbihtaWRpKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgbWlkaSAvIF8ucmFuZ2UpO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4ID0gY2VsbC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChfLmFyICYmIGxlbikge1xuICAgICAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gXy5yYW5nZTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbaV0gPSBNYXRoLnBvdygyLCBjZWxsW2ldIC8gcmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLnZhbHVlID0gY2VsbFtpbWF4LTFdO1xuICAgICAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSAodGhpcy5ub2Rlcy5sZW5ndGgpID8gZm4uaW5wdXRTaWduYWxLUih0aGlzKSA6IF8ubWlkaTtcbiAgICAgICAgICAgICAgICBpZiAoXy5wcmV2ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBfLnByZXYgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgXy52YWx1ZSA9IE1hdGgucG93KDIsIGlucHV0IC8gXy5yYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF8udmFsdWUgKiBfLm11bCArIF8uYWRkO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFtpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcIm1pZGlyYXRpb1wiLCBNaWRpUmF0aW9Ob2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gTWluTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKE1pbk5vZGUpO1xuXG4gICAgdmFyICQgPSBNaW5Ob2RlLnByb3RvdHlwZTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNbMF07XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgICAgICAgIHZhciBpLCBpbWF4ID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGosIGptYXggPSBjZWxsLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0bXAsIHZhbDtcblxuICAgICAgICAgICAgaWYgKF8uYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSBub2Rlc1swXS5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0KHRtcCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG5vZGVzW2ldLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqbWF4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0bXBbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxbal0gPiB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFtqXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgam1heDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsW2pdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gbm9kZXNbMF0ucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBub2Rlc1tpXS5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wID4gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbFswXSA9IHRtcDtcbiAgICAgICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxLUih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcIm1pblwiLCBNaW5Ob2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gTU1MKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMCwgX2FyZ3MpO1xuICAgICAgICBmbi50aW1lcih0aGlzKTtcbiAgICAgICAgZm4uZml4S1IodGhpcyk7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIF8udHJhY2tzICA9IFtdO1xuICAgICAgICBfLm9uZW5kZWQgPSBmbi5tYWtlX29uZW5kZWQodGhpcyk7XG4gICAgICAgIF8uY3VycmVudFRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMub24oXCJzdGFydFwiLCBvbnN0YXJ0KTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKE1NTCk7XG5cbiAgICB2YXIgb25zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIF8gPSB0aGlzLl87XG4gICAgICAgIHZhciBtbWwgID0gXy5tbWw7XG4gICAgICAgIGlmICh0eXBlb2YgbW1sID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtbWwgPSBbbW1sXTtcbiAgICAgICAgfVxuICAgICAgICBfLnRyYWNrcyA9IG1tbC5tYXAoZnVuY3Rpb24obW1sLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1NTFRyYWNrKHNlbGYsIGksIG1tbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gZm4uUExBWUlOR19TVEFURTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvbnN0YXJ0LCBcInVucmVtb3ZlZFwiLCB7XG4gICAgICAgIHZhbHVlOnRydWUsIHdyaXRhYmxlOmZhbHNlXG4gICAgfSk7XG5cbiAgICB2YXIgJCA9IE1NTC5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIG1tbDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5tbWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLm1tbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudFRpbWU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5vbiA9ICQuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJtbWxcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwiZGF0YVwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSAnbW1sJyBldmVudCBsaXN0ZW5lciB3YXMgZGVwcmVjYXRlZCBpbiB+djEzLjAzLjAxLiB1c2UgJ2RhdGEnIGV2ZW50IGxpc3RlbmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl8uZXZlbnRzLm9uKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIm1tbFwiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJkYXRhXCI7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBICdtbWwnIGV2ZW50IGxpc3RlbmVyIHdhcyBkZXByZWNhdGVkIGluIH52MTMuMDMuMDEuIHVzZSAnZGF0YScgZXZlbnQgbGlzdGVuZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuXy5ldmVudHMub25jZSh0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLm9mZiA9ICQucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJtbWxcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwiZGF0YVwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSAnbW1sJyBldmVudCBsaXN0ZW5lciB3YXMgZGVwcmVjYXRlZCBpbiB+djEzLjAzLjAxLiB1c2UgJ2RhdGEnIGV2ZW50IGxpc3RlbmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl8uZXZlbnRzLm9mZih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibW1sXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkEgJ21tbCcgZXZlbnQgbGlzdGVuZXIgd2FzIGRlcHJlY2F0ZWQgaW4gfnYxMy4wMy4wMS4gdXNlICdkYXRhJyBldmVudCBsaXN0ZW5lci5cIik7XG4gICAgICAgICAgICB0eXBlID0gXCJkYXRhXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fLmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnModHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibW1sXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkEgJ21tbCcgZXZlbnQgbGlzdGVuZXIgd2FzIGRlcHJlY2F0ZWQgaW4gfnYxMy4wMy4wMS4gdXNlICdkYXRhJyBldmVudCBsaXN0ZW5lci5cIik7XG4gICAgICAgICAgICB0eXBlID0gXCJkYXRhXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuXy5ldmVudHMubGlzdGVuZXJzKHR5cGUpO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICB2YXIgaSwgaW1heDtcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSBfLnRyYWNrcztcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IHRyYWNrcy5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICB0cmFja3NbaV0ucHJvY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja3NbaV0uZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZuLm5leHRUaWNrKF8ub25lbmRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmN1cnJlbnRUaW1lICs9IGZuLmN1cnJlbnRUaW1lSW5jcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcIm1tbFwiLCBNTUwpO1xuXG4gICAgdmFyIE1NTFRyYWNrID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBNTUxUcmFjayhzZXF1ZW5jZXIsIHRyYWNrTnVtLCBtbWwpIHtcbiAgICAgICAgICAgIHZhciBfID0gdGhpcy5fID0ge307XG4gICAgICAgICAgICBfLnNlcXVlbmNlciA9IHNlcXVlbmNlcjtcbiAgICAgICAgICAgIF8udHJhY2tOdW0gID0gdHJhY2tOdW07XG4gICAgICAgICAgICBfLmNvbW1hbmRzICA9IGNvbXBpbGUobW1sKTtcbiAgICAgICAgICAgIF8uc3RhdHVzID0ge3Q6MTIwLCBsOjQsIG86NCwgdjoxMiwgcTo2LCBkb3Q6MCwgdGllOmZhbHNlfTtcbiAgICAgICAgICAgIF8uaW5kZXggICAgPSAwO1xuICAgICAgICAgICAgXy5xdWV1ZSAgICA9IFtdO1xuICAgICAgICAgICAgXy5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgICAgICBfLnF1ZXVlVGltZSAgID0gMDtcbiAgICAgICAgICAgIF8uc2Vnbm9JbmRleCAgPSAtMTtcbiAgICAgICAgICAgIF8ubG9vcFN0YWNrICAgPSBbXTtcbiAgICAgICAgICAgIF8ucHJldk5vdGUgPSAwO1xuICAgICAgICAgICAgXy5yZW1haW4gICA9IEluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2NoZWQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgRU9GICAgICA9IDA7XG4gICAgICAgIHZhciBOT1RFT04gID0gMTtcbiAgICAgICAgdmFyIE5PVEVPRkYgPSAyO1xuICAgICAgICB2YXIgQ09NTUFORCA9IDM7XG5cbiAgICAgICAgTU1MVHJhY2sucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgdmFyIHNlcXVlbmNlciA9IF8uc2VxdWVuY2VyO1xuICAgICAgICAgICAgdmFyIHRyYWNrTnVtICA9IF8udHJhY2tOdW07XG4gICAgICAgICAgICB2YXIgcXVldWUgID0gXy5xdWV1ZTtcbiAgICAgICAgICAgIHZhciBlb2YgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZVswXVswXSA8PSBfLmN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SXRlbSA9IF8ucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuZXh0SXRlbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE5PVEVPTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVPbihzZXF1ZW5jZXIsIHRyYWNrTnVtLCBuZXh0SXRlbVsyXSwgbmV4dEl0ZW1bM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5yZW1haW4gPSBuZXh0SXRlbVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTk9URU9GRjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVPZmYoc2VxdWVuY2VyLCB0cmFja051bSwgbmV4dEl0ZW1bMl0sIG5leHRJdGVtWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENPTU1BTkQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kKHNlcXVlbmNlciwgbmV4dEl0ZW1bMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRU9GOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW9mID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5yZW1haW4gLT0gZm4uY3VycmVudFRpbWVJbmNyO1xuICAgICAgICAgICAgaWYgKGVvZikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5jdXJyZW50VGltZSArPSBmbi5jdXJyZW50VGltZUluY3I7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG5vdGVPbiA9IGZ1bmN0aW9uKHNlcXVlbmNlciwgdHJhY2tOdW0sIG5vdGVOdW0sIHZlbG9jaXR5KSB7XG4gICAgICAgICAgICB2YXIgZ2VuLCBpLCBpbWF4O1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gc2VxdWVuY2VyLm5vZGVzO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IG5vZGVzLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGdlbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChnZW4ubm90ZU9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5ub3RlT24obm90ZU51bSwgdmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5iYW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VxdWVuY2VyLl8uZW1pdChcImRhdGFcIiwgXCJub3RlT25cIiwge1xuICAgICAgICAgICAgICAgIHRyYWNrTnVtOnRyYWNrTnVtLCBub3RlTnVtOm5vdGVOdW0sIHZlbG9jaXR5OnZlbG9jaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbm90ZU9mZiA9IGZ1bmN0aW9uKHNlcXVlbmNlciwgdHJhY2tOdW0sIG5vdGVOdW0sIHZlbG9jaXR5KSB7XG4gICAgICAgICAgICB2YXIgZ2VuLCBpLCBpbWF4O1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gc2VxdWVuY2VyLm5vZGVzO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IG5vZGVzLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGdlbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChnZW4ubm90ZU9mZikge1xuICAgICAgICAgICAgICAgICAgICBnZW4ubm90ZU9mZihub3RlTnVtLCB2ZWxvY2l0eSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZW4ucmVsZWFzZSkge1xuICAgICAgICAgICAgICAgICAgICBnZW4ucmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcXVlbmNlci5fLmVtaXQoXCJkYXRhXCIsIFwibm90ZU9mZlwiLCB7XG4gICAgICAgICAgICAgICAgdHJhY2tOdW06dHJhY2tOdW0sIG5vdGVOdW06bm90ZU51bSwgdmVsb2NpdHk6dmVsb2NpdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjb21tYW5kID0gZnVuY3Rpb24oc2VxdWVuY2VyLCBjbWQpIHtcbiAgICAgICAgICAgIHNlcXVlbmNlci5fLmVtaXQoXCJkYXRhXCIsIFwiY29tbWFuZFwiLCB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogY21kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2NoZWQgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHNlbGYuXztcblxuICAgICAgICAgICAgdmFyIHNlcXVlbmNlciA9IF8uc2VxdWVuY2VyO1xuICAgICAgICAgICAgdmFyIGNtZCwgY29tbWFuZHMgPSBfLmNvbW1hbmRzO1xuICAgICAgICAgICAgdmFyIHF1ZXVlICA9IF8ucXVldWU7XG4gICAgICAgICAgICB2YXIgaW5kZXggID0gXy5pbmRleDtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBfLnN0YXR1cztcbiAgICAgICAgICAgIHZhciBxdWV1ZVRpbWUgPSBfLnF1ZXVlVGltZTtcbiAgICAgICAgICAgIHZhciBsb29wU3RhY2sgPSBfLmxvb3BTdGFjaztcbiAgICAgICAgICAgIHZhciB0ZW1wbywgdmFsLCBsZW4sIGRvdCwgdmVsO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uLCBxdWFudGl6ZSwgcGVuZGluZywgX3F1ZXVlVGltZTtcbiAgICAgICAgICAgIHZhciBwZWVrO1xuICAgICAgICAgICAgdmFyIGksIGltYXg7XG5cbiAgICAgICAgICAgIHBlbmRpbmcgPSBbXTtcblxuICAgICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kcy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uc2Vnbm9JbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IF8uc2Vnbm9JbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNtZCA9IGNvbW1hbmRzW2luZGV4KytdO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbWQubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJAXCI6XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goW3F1ZXVlVGltZSwgQ09NTUFORCwgY21kLnZhbF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgICAgICAgICB0ZW1wbyA9IHN0YXR1cy50IHx8IDEyMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtZC5sZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGNtZC5sZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3QgPSBjbWQuZG90IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0dXMubDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdCA9IGNtZC5kb3QgfHwgc3RhdHVzLmRvdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9ICg2MCAvIHRlbXBvKSAqICg0IC8gbGVuKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uICo9IFsxLCAxLjUsIDEuNzUsIDEuODc1XVtkb3RdIHx8IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgdmVsID0gc3RhdHVzLnYgPDwgMztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy50aWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHF1ZXVlLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVbaV1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBfLnByZXZOb3RlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gXy5wcmV2Tm90ZSA9IChjbWQudmFsKSArIChzdGF0dXMubyArIDEpICogMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFtxdWV1ZVRpbWUsIE5PVEVPTiwgdmFsLCB2ZWwsIGR1cmF0aW9uXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpemUgPSBzdGF0dXMucSAvIDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlT2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVhbnRpemUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3F1ZXVlVGltZSA9IHF1ZXVlVGltZSArIChkdXJhdGlvbiAqIHF1YW50aXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFtfcXVldWVUaW1lLCBOT1RFT0ZGLCB2YWwsIHZlbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGltYXggPSBwZW5kaW5nLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFtfcXVldWVUaW1lLCBOT1RFT0ZGLCBwZW5kaW5nW2ldLCB2ZWxdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVRpbWUgKz0gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXR1cy50aWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmcucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy50aWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJcIjpcbiAgICAgICAgICAgICAgICAgICAgdGVtcG8gPSBzdGF0dXMudCB8fCAxMjA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQubGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBjbWQubGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG90ID0gY21kLmRvdCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gc3RhdHVzLmw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3QgPSBjbWQuZG90IHx8IHN0YXR1cy5kb3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gKDYwIC8gdGVtcG8pICogKDQgLyBsZW4pICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uICo9IFsxLCAxLjUsIDEuNzUsIDEuODc1XVtkb3RdIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVRpbWUgKz0gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxcIjpcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmwgICA9IGNtZC52YWw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kb3QgPSBjbWQuZG90O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMubyA9IGNtZC52YWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMubyA8IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5vICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5vID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLm8gLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMudiA9IGNtZC52YWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudiA8IDE1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMudiArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy52IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnEgPSBjbWQudmFsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiJlwiOlxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMudGllID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgICAgICAgICAgXy5zZWdub0luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgICAgIGxvb3BTdGFjay5wdXNoKFtpbmRleCwgbnVsbCwgbnVsbF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgICAgICBwZWVrID0gbG9vcFN0YWNrW2xvb3BTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWVrWzFdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGVla1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgICAgICBwZWVrID0gbG9vcFN0YWNrW2xvb3BTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWVrWzFdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVla1sxXSA9IGNtZC5jb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWVrWzJdID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVrWzFdIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVla1sxXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3BTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwZWVrWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy50ID0gKGNtZC52YWwgPT09IG51bGwpID8gMTIwIDogY21kLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkVPRlwiOlxuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFtxdWV1ZVRpbWUsIEVPRl0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBfLnF1ZXVlVGltZSA9IHF1ZXVlVGltZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY29tcGlsZSA9IGZ1bmN0aW9uKG1tbCkge1xuICAgICAgICAgICAgdmFyIGRlZiwgcmUsIG0sIGNtZDtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4LCBqLCBqbWF4O1xuICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSBuZXcgQXJyYXkobW1sLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgY29tbWFuZHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IE1NTENvbW1hbmRzLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlZiA9IE1NTENvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIHJlICA9IGRlZi5yZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG0gPSByZS5leGVjKG1tbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tlZFttLmluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgam1heCA9IG1bMF0ubGVuZ3RoOyBqIDwgam1heDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZFttLmluZGV4ICsgal0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5mdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gZGVmLmZ1bmMobSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IHtuYW1lOm1bMF19O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZC5pbmRleCA9IG0uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kLm9yaWdpbiA9IG1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaChjbWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZS5sYXN0SW5kZXggPCBtbWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRbcmUubGFzdEluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKytyZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21tYW5kcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe25hbWU6XCJFT0ZcIn0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBNTUxDb21tYW5kcyA9IFtcbiAgICAgICAgICAgIHsgcmU6L0AoXFxkKikvZywgZnVuYzogZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWw6IG1bMV0gfHwgbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9fSxcbiAgICAgICAgICAgIHsgcmU6LyhbY2RlZmdhYl0pKFtcXC0rXT8pKFxcZCopKFxcLiopL2csIGZ1bmM6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm5cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsIDoge2M6MCxkOjIsZTo0LGY6NSxnOjcsYTo5LGI6MTF9W21bMV1dICsgKHtcIi1cIjotMSxcIitcIjorMX1bbVsyXV18fDApLFxuICAgICAgICAgICAgICAgICAgICBsZW4gOiAobVszXSA9PT0gXCJcIikgPyBudWxsIDogTWF0aC5taW4obVszXXwwLCA2NCksXG4gICAgICAgICAgICAgICAgICAgIGRvdCA6IG1bNF0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH19LFxuICAgICAgICAgICAgeyByZTovcihcXGQqKShcXC4qKS9nLCBmdW5jOiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJyXCIsXG4gICAgICAgICAgICAgICAgICAgIGxlbiA6IChtWzFdID09PSBcIlwiKSA/IG51bGwgOiBNYXRoLm1heCgxLCBNYXRoLm1pbihtWzFdfDAsIDY0KSksXG4gICAgICAgICAgICAgICAgICAgIGRvdCA6IG1bMl0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH19LFxuICAgICAgICAgICAgeyByZTovJi9nIH0sXG4gICAgICAgICAgICB7IHJlOi9sKFxcZCopKFxcLiopL2csIGZ1bmM6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImxcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsIDogKG1bMV0gPT09IFwiXCIpID8gNCA6IE1hdGgubWluKG1bMV18MCwgNjQpLFxuICAgICAgICAgICAgICAgICAgICBkb3QgOiBtWzJdLmxlbmd0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9fSxcbiAgICAgICAgICAgIHsgcmU6L28oWzAtOV0pL2csIGZ1bmM6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsIDogKG1bMV0gPT09IFwiXCIpID8gNCA6IG1bMV18MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9fSxcbiAgICAgICAgICAgIHsgcmU6L1s8Pl0vZyB9LFxuICAgICAgICAgICAgeyByZTovdihcXGQqKS9nLCBmdW5jOiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ2XCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbCA6IChtWzFdID09PSBcIlwiKSA/IDEyIDogTWF0aC5taW4obVsxXXwwLCAxNSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfX0sXG4gICAgICAgICAgICB7IHJlOi9bKCldL2cgfSxcbiAgICAgICAgICAgIHsgcmU6L3EoWzAtOF0pL2csIGZ1bmM6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInFcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsIDogKG1bMV0gPT09IFwiXCIpID8gNiA6IE1hdGgubWluKG1bMV18MCwgOClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfX0sXG4gICAgICAgICAgICB7IHJlOi9cXFsvZyB9LFxuICAgICAgICAgICAgeyByZTovXFx8L2cgfSxcbiAgICAgICAgICAgIHsgcmU6L1xcXShcXGQqKS9nLCBmdW5jOiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJdXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAobVsxXXwwKXx8MlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9fSxcbiAgICAgICAgICAgIHsgcmU6L3QoXFxkKikvZywgZnVuYzogZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwidFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWwgOiAobVsxXSA9PT0gXCJcIikgPyBudWxsIDogTWF0aC5tYXgoNSwgTWF0aC5taW4obVsxXXwwLCAzMDApKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9fSxcbiAgICAgICAgICAgIHsgcmU6L1xcJC9nIH1cbiAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4gTU1MVHJhY2s7XG4gICAgfSkoKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gID0gVC5mbjtcblxuICAgIGZ1bmN0aW9uIE1vbm9Ob2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMSwgX2FyZ3MpO1xuICAgIH1cbiAgICBmbi5leHRlbmQoTW9ub05vZGUpO1xuXG4gICAgTW9ub05vZGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcbiAgICAgICAgICAgIGlmIChfLmFyKSB7XG4gICAgICAgICAgICAgICAgZm4uaW5wdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsc1swXVswXSA9IGZuLmlucHV0U2lnbmFsS1IodGhpcyk7XG4gICAgICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsS1IodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBmbi5yZWdpc3RlcihcIm1vbm9cIiwgTW9ub05vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG5cbiAgICBmdW5jdGlvbiBNdWxOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMiwgX2FyZ3MpO1xuICAgIH1cbiAgICBmbi5leHRlbmQoTXVsTm9kZSk7XG5cbiAgICB2YXIgJCA9IE11bE5vZGUucHJvdG90eXBlO1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgICAgICAgIHZhciBjZWxsICA9IHRoaXMuY2VsbHNbMF07XG4gICAgICAgICAgICB2YXIgY2VsbEwgPSB0aGlzLmNlbGxzWzFdO1xuICAgICAgICAgICAgdmFyIGNlbGxSID0gdGhpcy5jZWxsc1syXTtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4ID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGosIGptYXggPSBjZWxsLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0bXAsIHRtcEwsIHRtcFI7XG5cbiAgICAgICAgICAgIGlmIChfLmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbMF0ucHJvY2Vzcyh0aWNrSUQpO1xuICAgICAgICAgICAgICAgICAgICB0bXBMID0gbm9kZXNbMF0uY2VsbHNbMV07XG4gICAgICAgICAgICAgICAgICAgIHRtcFIgPSBub2Rlc1swXS5jZWxsc1syXTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbEwuc2V0KHRtcEwpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsUi5zZXQodG1wUik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLnByb2Nlc3ModGlja0lEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcEwgPSBub2Rlc1tpXS5jZWxsc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcFIgPSBub2Rlc1tpXS5jZWxsc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqbWF4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTFtqXSAqPSB0bXBMW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxSW2pdICo9IHRtcFJbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgam1heDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsTFtqXSA9IGNlbGxSW2pdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gbm9kZXNbMF0ucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgKj0gbm9kZXNbaV0ucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbFswXSA9IHRtcDtcbiAgICAgICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxLUih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcIipcIiwgTXVsTm9kZSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcblxuICAgIGZ1bmN0aW9uIE5EaWN0Tm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5kZWZhdWx0VmFsdWUgPSAwO1xuICAgICAgICBfLmluZGV4ID0gMDtcbiAgICAgICAgXy5kaWN0ICA9IHt9O1xuICAgICAgICBfLmFyICAgID0gZmFsc2U7XG4gICAgfVxuICAgIGZuLmV4dGVuZChORGljdE5vZGUpO1xuXG4gICAgdmFyICQgPSBORGljdE5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICBkaWN0OiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8uZGljdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpY3QgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGljdFtpXSA9IHZhbHVlKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5kaWN0ID0gZGljdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmRpY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbmRleDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmluZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5hdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICByZXR1cm4gKF8uZGljdFtpbmRleHwwXSB8fCBfLmRlZmF1bHRWYWx1ZSkgKiBfLm11bCArIF8uYWRkO1xuICAgIH07XG5cbiAgICAkLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuXy5kaWN0ID0ge307XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpbmRleCwgdmFsdWU7XG4gICAgICAgICAgICB2YXIgZGljdCA9IF8uZGljdCwgZGVmYXVsdFZhbHVlID0gXy5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB2YXIgbXVsID0gXy5tdWwsIGFkZCA9IF8uYWRkO1xuICAgICAgICAgICAgdmFyIGksIGltYXggPSBjZWxsLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKF8uYXIgJiYgbGVuKSB7XG5cbiAgICAgICAgICAgICAgICBmbi5pbnB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjZWxsW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IChpbmRleCAtIDAuNSl8MDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4ICsgMC41KXwwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbaV0gPSAoZGljdFtpbmRleF0gfHwgZGVmYXVsdFZhbHVlKSAqIG11bCArIGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gKHRoaXMubm9kZXMubGVuZ3RoKSA/IGZuLmlucHV0U2lnbmFsS1IodGhpcykgOiBfLmluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggLSAwLjUpfDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggKyAwLjUpfDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gKGRpY3RbaW5kZXhdIHx8IGRlZmF1bHRWYWx1ZSkgKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwibmRpY3RcIiwgTkRpY3ROb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gTm9pc2VOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMSwgX2FyZ3MpO1xuICAgIH1cbiAgICBmbi5leHRlbmQoTm9pc2VOb2RlKTtcblxuICAgIHZhciAkID0gTm9pc2VOb2RlLnByb3RvdHlwZTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNbMF07XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgdmFyIG11bCA9IF8ubXVsLCBhZGQgPSBfLmFkZDtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4LCB4O1xuXG4gICAgICAgICAgICBpZiAoXy5hcikgeyAvLyBhdWRpby1yYXRlXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IGNlbGwubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbaV0gPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIG11bCArIGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAgICAvLyBjb250cm9sLXJhdGVcbiAgICAgICAgICAgICAgICB4ID0gKE1hdGgucmFuZG9tKCkgKiAyICsgMSkgKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IGNlbGwubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbaV0gPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJub2lzZVwiLCBOb2lzZU5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG4gICAgdmFyIHRpbWV2YWx1ZSAgPSBULnRpbWV2YWx1ZTtcbiAgICB2YXIgT3NjaWxsYXRvciA9IFQubW9kdWxlcy5Pc2NpbGxhdG9yO1xuXG4gICAgZnVuY3Rpb24gT3NjTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDIsIF9hcmdzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5mcmVxICA9IFQoNDQwKTtcbiAgICAgICAgXy5waGFzZSA9IFQoMCk7XG4gICAgICAgIF8ub3NjID0gbmV3IE9zY2lsbGF0b3IoXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgXy50bXAgPSBuZXcgZm4uU2lnbmFsQXJyYXkoXy5jZWxsc2l6ZSk7XG4gICAgICAgIF8ub3NjLnN0ZXAgPSBfLmNlbGxzaXplO1xuXG4gICAgICAgIHRoaXMub25jZShcImluaXRcIiwgb25pbml0KTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKE9zY05vZGUpO1xuXG4gICAgdmFyIG9uaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgaWYgKCF0aGlzLndhdmUpIHtcbiAgICAgICAgICAgIHRoaXMud2F2ZSA9IFwic2luXCI7XG4gICAgICAgIH1cbiAgICAgICAgXy5wbG90RGF0YSA9IF8ub3NjLndhdmU7XG4gICAgICAgIF8ucGxvdExpbmVXaWR0aCA9IDI7XG4gICAgICAgIF8ucGxvdEN5Y2xpYyA9IHRydWU7XG4gICAgICAgIF8ucGxvdEJlZm9yZSA9IHBsb3RCZWZvcmU7XG4gICAgfTtcblxuICAgIHZhciAkID0gT3NjTm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIHdhdmU6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8ub3NjLnNldFdhdmUodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5vc2Mud2F2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJlcToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aW1ldmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAxMDAwIC8gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fLmZyZXEgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZnJlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGhhc2U6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8ucGhhc2UgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl8ub3NjLmZlZWRiYWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnBoYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmYjoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuXy5waGFzZSA9IFQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuXy5vc2MuZmVlZGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5waGFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmbi5jbG9uZSh0aGlzKTtcbiAgICAgICAgaW5zdGFuY2UuXy5vc2MgPSB0aGlzLl8ub3NjLmNsb25lKCk7XG4gICAgICAgIGluc3RhbmNlLl8uZnJlcSAgPSB0aGlzLl8uZnJlcTtcbiAgICAgICAgaW5zdGFuY2UuXy5waGFzZSA9IHRoaXMuXy5waGFzZTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICAkLmJhbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fLm9zYy5yZXNldCgpO1xuICAgICAgICB0aGlzLl8uZW1pdChcImJhbmdcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICB2YXIgY2VsbEwgPSB0aGlzLmNlbGxzWzFdO1xuICAgICAgICAgICAgdmFyIGNlbGxSID0gdGhpcy5jZWxsc1syXTtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4ID0gXy5jZWxsc2l6ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm4uaW5wdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsTFtpXSA9IGNlbGxSW2ldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvc2MgPSBfLm9zYztcbiAgICAgICAgICAgIHZhciBmcmVxICA9IF8uZnJlcS5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF07XG4gICAgICAgICAgICB2YXIgcGhhc2UgPSBfLnBoYXNlLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXTtcblxuICAgICAgICAgICAgb3NjLmZyZXF1ZW5jeSA9IGZyZXFbMF07XG4gICAgICAgICAgICBvc2MucGhhc2UgICAgID0gcGhhc2VbMF07XG5cbiAgICAgICAgICAgIGlmIChfLmFyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCAgPSBfLnRtcDtcbiAgICAgICAgICAgICAgICBpZiAoXy5mcmVxLmlzQXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8ucGhhc2UuaXNBcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3NjLnByb2Nlc3NXaXRoRnJlcUFuZFBoYXNlQXJyYXkodG1wLCBmcmVxLCBwaGFzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvc2MucHJvY2Vzc1dpdGhGcmVxQXJyYXkodG1wLCBmcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLnBoYXNlLmlzQXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9zYy5wcm9jZXNzV2l0aFBoYXNlQXJyYXkodG1wLCBwaGFzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvc2MucHJvY2Vzcyh0bXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbExbaV0gKj0gdG1wW2ldO1xuICAgICAgICAgICAgICAgICAgICBjZWxsUltpXSAqPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvc2MubmV4dCgpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbExbaV0gKj0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxSW2ldICo9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBwbG90QmVmb3JlO1xuICAgIGlmIChULmVudnR5cGUgPT09IFwiYnJvd3NlclwiKSB7XG4gICAgICAgIHBsb3RCZWZvcmUgPSBmdW5jdGlvbihjb250ZXh0LCBvZmZzZXRfeCwgb2Zmc2V0X3ksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB5ID0gKGhlaWdodCA+PiAxKSArIDAuNTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcIiNjY2NcIjtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoICAgPSAxO1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKG9mZnNldF94LCB5ICsgb2Zmc2V0X3kpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ob2Zmc2V0X3ggKyB3aWR0aCwgeSArIG9mZnNldF95KTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm4ucmVnaXN0ZXIoXCJvc2NcIiwgT3NjTm9kZSk7XG5cbiAgICBmbi5yZWdpc3RlcihcInNpblwiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IE9zY05vZGUoX2FyZ3MpLnNldChcIndhdmVcIiwgXCJzaW5cIik7XG4gICAgfSk7XG4gICAgZm4ucmVnaXN0ZXIoXCJjb3NcIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPc2NOb2RlKF9hcmdzKS5zZXQoXCJ3YXZlXCIsIFwiY29zXCIpO1xuICAgIH0pO1xuICAgIGZuLnJlZ2lzdGVyKFwicHVsc2VcIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPc2NOb2RlKF9hcmdzKS5zZXQoXCJ3YXZlXCIsIFwicHVsc2VcIik7XG4gICAgfSk7XG4gICAgZm4ucmVnaXN0ZXIoXCJ0cmlcIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPc2NOb2RlKF9hcmdzKS5zZXQoXCJ3YXZlXCIsIFwidHJpXCIpO1xuICAgIH0pO1xuICAgIGZuLnJlZ2lzdGVyKFwic2F3XCIsIGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3NjTm9kZShfYXJncykuc2V0KFwid2F2ZVwiLCBcInNhd1wiKTtcbiAgICB9KTtcbiAgICBmbi5yZWdpc3RlcihcImZhbWlcIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPc2NOb2RlKF9hcmdzKS5zZXQoXCJ3YXZlXCIsIFwiZmFtaVwiKTtcbiAgICB9KTtcbiAgICBmbi5yZWdpc3RlcihcImtvbmFtaVwiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IE9zY05vZGUoX2FyZ3MpLnNldChcIndhdmVcIiwgXCJrb25hbWlcIik7XG4gICAgfSk7XG4gICAgZm4ucmVnaXN0ZXIoXCIrc2luXCIsIGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3NjTm9kZShfYXJncykuc2V0KFwid2F2ZVwiLCBcIitzaW5cIikua3IoKTtcbiAgICB9KTtcbiAgICBmbi5yZWdpc3RlcihcIitwdWxzZVwiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IE9zY05vZGUoX2FyZ3MpLnNldChcIndhdmVcIiwgXCIrcHVsc2VcIikua3IoKTtcbiAgICB9KTtcbiAgICBmbi5yZWdpc3RlcihcIit0cmlcIiwgZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPc2NOb2RlKF9hcmdzKS5zZXQoXCJ3YXZlXCIsIFwiK3RyaVwiKS5rcigpO1xuICAgIH0pO1xuICAgIGZuLnJlZ2lzdGVyKFwiK3Nhd1wiLCBmdW5jdGlvbihfYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IE9zY05vZGUoX2FyZ3MpLnNldChcIndhdmVcIiwgXCIrc2F3XCIpLmtyKCk7XG4gICAgfSk7XG5cbiAgICBmbi5hbGlhcyhcInNxdWFyZVwiLCBcInB1bHNlXCIpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG5cbiAgICBmdW5jdGlvbiBQYW5Ob2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMiwgX2FyZ3MpO1xuICAgICAgICBmbi5maXhBUih0aGlzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5wb3MgID0gVCgwKTtcbiAgICAgICAgXy5wYW5MID0gMC41O1xuICAgICAgICBfLnBhblIgPSAwLjU7XG4gICAgfVxuICAgIGZuLmV4dGVuZChQYW5Ob2RlKTtcblxuICAgIHZhciAkID0gUGFuTm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIHBvczoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuXy5wb3MgPSBUKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ucG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICB2YXIgcG9zID0gXy5wb3MucHJvY2Vzcyh0aWNrSUQpLmNlbGxzWzBdWzBdO1xuICAgICAgICAgICAgaWYgKF8ucHJldlBvcyAhPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcG9zICogMC41ICsgMC41O1xuICAgICAgICAgICAgICAgIF8ucGFuTCA9IDEgLSBwb3M7XG4gICAgICAgICAgICAgICAgXy5wYW5SID0gXy5wcmV2UG9zID0gcG9zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgICAgICAgdmFyIGNlbGxMID0gdGhpcy5jZWxsc1sxXTtcbiAgICAgICAgICAgIHZhciBjZWxsUiA9IHRoaXMuY2VsbHNbMl07XG4gICAgICAgICAgICB2YXIgaSwgaW1heCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBqLCBqbWF4ID0gY2VsbEwubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRtcDtcblxuICAgICAgICAgICAgaWYgKGltYXgpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBub2Rlc1swXS5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF07XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGptYXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBjZWxsTFtqXSA9IGNlbGxSW2pdID0gdG1wW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IG5vZGVzW2ldLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGptYXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbExbal0gPSAoY2VsbFJbal0gKz0gdG1wW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYW5MID0gXy5wYW5MO1xuICAgICAgICAgICAgICAgIHZhciBwYW5SID0gXy5wYW5SO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqbWF4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbExbal0gPSBjZWxsTFtqXSAqIHBhbkw7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxSW2pdID0gY2VsbFJbal0gKiBwYW5SO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxsTC5zZXQoZm4uZW1wdHljZWxsKTtcbiAgICAgICAgICAgICAgICBjZWxsUi5zZXQoZm4uZW1wdHljZWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJwYW5cIiwgUGFuTm9kZSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcbiAgICB2YXIgdGltZXZhbHVlID0gVC50aW1ldmFsdWU7XG4gICAgdmFyIEVudmVsb3BlICAgICAgPSBULm1vZHVsZXMuRW52ZWxvcGU7XG4gICAgdmFyIEVudmVsb3BlVmFsdWUgPSBULm1vZHVsZXMuRW52ZWxvcGVWYWx1ZTtcblxuICAgIGZ1bmN0aW9uIFBhcmFtTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDIsIF9hcmdzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy52YWx1ZSA9IDA7XG4gICAgICAgIF8uZW52ID0gbmV3IEVudmVsb3BlVmFsdWUoXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgXy5lbnYuc3RlcCA9IF8uY2VsbHNpemU7XG4gICAgICAgIF8uY3VydmUgICA9IFwibGluXCI7XG4gICAgICAgIF8uY291bnRlciA9IDA7XG4gICAgICAgIF8uYXIgPSBmYWxzZTtcbiAgICAgICAgXy5vbmVuZGVkID0gbWFrZV9vbmVuZGVkKHRoaXMpO1xuXG4gICAgICAgIHRoaXMub24oXCJhclwiLCBvbmFyKTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKFBhcmFtTm9kZSk7XG5cbiAgICB2YXIgbWFrZV9vbmVuZGVkID0gZnVuY3Rpb24oc2VsZiwgbGFzdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdFZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgID0gc2VsZi5jZWxsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbEwgPSBzZWxmLmNlbGxzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsUiA9IHNlbGYuY2VsbHNbMl07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5fLmVudi52YWx1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IGNlbGxMLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsWzBdID0gY2VsbExbaV0gPSBjZWxsUltpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuXy5lbWl0KFwiZW5kZWRcIik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBvbmFyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fLmVudi5zdGVwID0gKHZhbHVlKSA/IDEgOiB0aGlzLl8uY2VsbHNpemU7XG4gICAgfTtcblxuICAgIHZhciAkID0gUGFyYW1Ob2RlLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5lbnYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmVudi52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC50byA9IGZ1bmN0aW9uKG5leHRWYWx1ZSwgdGltZSwgY3VydmUpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIHZhciBlbnYgPSBfLmVudjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aW1lID0gdGltZXZhbHVlKHRpbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGN1cnZlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBfLmNvdW50ZXIgPSBlbnYuc2V0TmV4dChuZXh0VmFsdWUsIHRpbWUsIEVudmVsb3BlLkN1cnZlVHlwZUxpbik7XG4gICAgICAgICAgICBfLmN1cnZlID0gXCJsaW5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfY3VydmUgPSBFbnZlbG9wZS5DdXJ2ZVR5cGVEaWN0W2N1cnZlXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX2N1cnZlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgXy5jb3VudGVyID0gZW52LnNldE5leHQobmV4dFZhbHVlLCB0aW1lLCBFbnZlbG9wZS5DdXJ2ZVR5cGVDdXJ2ZSwgY3VydmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfLmNvdW50ZXIgPSBlbnYuc2V0TmV4dChuZXh0VmFsdWUsIHRpbWUsIF9jdXJ2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmN1cnZlID0gY3VydmU7XG4gICAgICAgIH1cbiAgICAgICAgXy5wbG90Rmx1c2ggPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5zZXRBdCA9IGZ1bmN0aW9uKG5leHRWYWx1ZSwgdGltZSkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgdGhpcy50byhfLmVudi52YWx1ZSwgdGltZSwgXCJzZXRcIik7XG4gICAgICAgIF8uYXRWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQubGluVG8gPSBmdW5jdGlvbihuZXh0VmFsdWUsIHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obmV4dFZhbHVlLCB0aW1lLCBcImxpblwiKTtcbiAgICB9O1xuXG4gICAgJC5leHBUbyA9IGZ1bmN0aW9uKG5leHRWYWx1ZSwgdGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhuZXh0VmFsdWUsIHRpbWUsIFwiZXhwXCIpO1xuICAgIH07XG5cbiAgICAkLnNpblRvID0gZnVuY3Rpb24obmV4dFZhbHVlLCB0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKG5leHRWYWx1ZSwgdGltZSwgXCJzaW5cIik7XG4gICAgfTtcblxuICAgICQud2VsVG8gPSBmdW5jdGlvbihuZXh0VmFsdWUsIHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obmV4dFZhbHVlLCB0aW1lLCBcIndlbFwiKTtcbiAgICB9O1xuXG4gICAgJC5zcXJUbyA9IGZ1bmN0aW9uKG5leHRWYWx1ZSwgdGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhuZXh0VmFsdWUsIHRpbWUsIFwic3FyXCIpO1xuICAgIH07XG5cbiAgICAkLmN1YlRvID0gZnVuY3Rpb24obmV4dFZhbHVlLCB0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKG5leHRWYWx1ZSwgdGltZSwgXCJjdWJcIik7XG4gICAgfTtcblxuICAgICQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLmNvdW50ZXIgPSBfLmVudi5zZXROZXh0KF8uZW52LnZhbHVlLCAwLCBFbnZlbG9wZS5DdXJ2ZVR5cGVTZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgdmFyIGNlbGxMID0gdGhpcy5jZWxsc1sxXTtcbiAgICAgICAgICAgIHZhciBjZWxsUiA9IHRoaXMuY2VsbHNbMl07XG4gICAgICAgICAgICB2YXIgaSwgaW1heCA9IF8uY2VsbHNpemU7XG4gICAgICAgICAgICB2YXIgZW52ID0gXy5lbnY7XG4gICAgICAgICAgICB2YXIgY291bnRlciA9IF8uY291bnRlcjtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm4uaW5wdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsTFtpXSA9IGNlbGxSW2ldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb3VudGVyIDw9IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5jdXJ2ZSA9PT0gXCJzZXRcIikge1xuICAgICAgICAgICAgICAgICAgICBlbnYuc2V0TmV4dChfLmF0VmFsdWUsIDAsIEVudmVsb3BlLkN1cnZlVHlwZVNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW52LnNldE5leHQoZW52LnZhbHVlLCAwLCBFbnZlbG9wZS5DdXJ2ZVR5cGVTZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbi5uZXh0VGljayhfLm9uZW5kZWQpO1xuICAgICAgICAgICAgICAgIF8uY291bnRlciA9IEluZmluaXR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5hcikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlbnYubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsTFtpXSAqPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFJbaV0gKj0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF8uY291bnRlciAtPSBfLmNlbGxzaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVudi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsTFtpXSAqPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFJbaV0gKj0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF8uY291bnRlciAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcblxuICAgICAgICAgICAgXy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBzdXBlcl9wbG90ID0gVC5PYmplY3QucHJvdG90eXBlLnBsb3Q7XG5cbiAgICAkLnBsb3QgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBpZiAoXy5wbG90Rmx1c2gpIHtcbiAgICAgICAgICAgIHZhciBlbnYgID0gbmV3IEVudmVsb3BlVmFsdWUoMTI4KTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxMjgpO1xuICAgICAgICAgICAgdmFyIGN1cnZlLCBpLCBpbWF4O1xuICAgICAgICAgICAgaWYgKF8uY3VydmUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxMDAsIGltYXggPSBkYXRhLmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnZlID0gRW52ZWxvcGUuQ3VydmVUeXBlRGljdFtfLmN1cnZlXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnZlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudi5zZXROZXh0KDEsIDEwMDAsIEVudmVsb3BlLkN1cnZlVHlwZUN1cnZlLCBfLmN1cnZlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbnYuc2V0TmV4dCgxLCAxMDAwLCBjdXJ2ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaW1heCA9IGRhdGEubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBlbnYubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8ucGxvdERhdGEgID0gZGF0YTtcbiAgICAgICAgICAgIF8ucGxvdFJhbmdlID0gWzAsIDFdO1xuICAgICAgICAgICAgXy5wbG90Rmx1c2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlcl9wbG90LmNhbGwodGhpcywgb3B0cyk7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwicGFyYW1cIiwgUGFyYW1Ob2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gID0gVC5mbjtcbiAgICB2YXIgQmlxdWFkID0gVC5tb2R1bGVzLkJpcXVhZDtcblxuICAgIGZ1bmN0aW9uIFBoYXNlck5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAyLCBfYXJncyk7XG4gICAgICAgIGZuLmZpeEFSKHRoaXMpO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLmZyZXEgPSBUKFwic2luXCIsIHtmcmVxOjEsIGFkZDoxMDAwLCBtdWw6MjUwfSkua3IoKTtcbiAgICAgICAgXy5RICAgID0gVCgxKTtcbiAgICAgICAgXy5hbGxwYXNzICA9IFtdO1xuXG4gICAgICAgIHRoaXMuc3RlcHMgPSAyO1xuICAgIH1cbiAgICBmbi5leHRlbmQoUGhhc2VyTm9kZSk7XG5cbiAgICB2YXIgJCA9IFBoYXNlck5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICBmcmVxOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmZyZXEgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZnJlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgUToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuXy5RID0gVCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLlE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXBzOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDIgfHwgdmFsdWUgPT09IDQgfHwgdmFsdWUgPT09IDggfHwgdmFsdWUgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxscGFzcyA9IHRoaXMuXy5hbGxwYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbHBhc3MubGVuZ3RoIDwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYWxscGFzcy5sZW5ndGg7IGkgPCB2YWx1ZTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbHBhc3NbaV0gPSBuZXcgQmlxdWFkKHRoaXMuXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxscGFzc1tpXS5zZXRUeXBlKFwiYWxscGFzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnN0ZXBzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5zdGVwcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgZm4uaW5wdXRTaWduYWxBUih0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCFfLmJ5cGFzc2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxMID0gdGhpcy5jZWxsc1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbFIgPSB0aGlzLmNlbGxzWzJdO1xuICAgICAgICAgICAgICAgIHZhciBmcmVxICA9IF8uZnJlcS5wcm9jZXNzKHRpY2tJRCkuY2VsbHNbMF1bMF07XG4gICAgICAgICAgICAgICAgdmFyIFEgICAgID0gXy5RLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXVswXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcHMgPSBfLnN0ZXBzO1xuICAgICAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHN0ZXBzOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5hbGxwYXNzW2kgIF0uc2V0UGFyYW1zKGZyZXEsIFEsIDApO1xuICAgICAgICAgICAgICAgICAgICBfLmFsbHBhc3NbaSAgXS5wcm9jZXNzKGNlbGxMLCBjZWxsUik7XG4gICAgICAgICAgICAgICAgICAgIF8uYWxscGFzc1tpKzFdLnNldFBhcmFtcyhmcmVxLCBRLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgXy5hbGxwYXNzW2krMV0ucHJvY2VzcyhjZWxsTCwgY2VsbFIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJwaGFzZXJcIiwgUGhhc2VyTm9kZSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gVm9zcyBhbGdvcml0aG1cbiAgICAvLyBodHRwOi8vd3d3LmZpcnN0cHIuY29tLmF1L2RzcC9waW5rLW5vaXNlL1xuXG4gICAgdmFyIE1BWF9LRVkgPSAzMTtcbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gUGlua05vaXNlTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcbiAgICAgICAgZm4uZml4QVIodGhpcyk7XG5cbiAgICAgICAgdmFyIHdoaXRlcyA9IG5ldyBVaW50OEFycmF5KDUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgd2hpdGVzW2ldID0gKChNYXRoLnJhbmRvbSgpICogKDE8PDMwKSl8MCkgJSAyNTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl8ud2hpdGVzID0gd2hpdGVzO1xuICAgICAgICB0aGlzLl8ua2V5ID0gMDtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKFBpbmtOb2lzZU5vZGUpO1xuXG4gICAgdmFyICQgPSBQaW5rTm9pc2VOb2RlLnByb3RvdHlwZTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNbMF07XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgdmFyIGksIGltYXgsIGo7XG4gICAgICAgICAgICB2YXIga2V5ID0gXy5rZXksIHdoaXRlcyA9IF8ud2hpdGVzO1xuICAgICAgICAgICAgdmFyIG11bCA9IF8ubXVsLCBhZGQgPSBfLmFkZDtcbiAgICAgICAgICAgIHZhciBsYXN0X2tleSwgc3VtLCBkaWZmO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpbWF4ID0gY2VsbC5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBsYXN0X2tleSA9IGtleSsrO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPiBNQVhfS0VZKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpZmYgPSBsYXN0X2tleSBeIGtleTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBzdW0gPSAwOyBqIDwgNTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmICYgKDEgPDwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc1tqXSA9ICgoTWF0aC5yYW5kb20oKSAqICgxPDwzMCkpfDApICUgMjU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IHdoaXRlc1tqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbFtpXSA9ICgoc3VtICogMC4wMTY2NjY2NikgLSAxKSAqIG11bCArIGFkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8ua2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcInBpbmtcIiwgUGlua05vaXNlTm9kZSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcblxuICAgIGZ1bmN0aW9uIFBsdWNrTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcblxuICAgICAgICB0aGlzLl8uZnJlcSAgID0gNDQwO1xuICAgICAgICB0aGlzLl8uYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fLmluZGV4ICA9IDA7XG4gICAgfVxuICAgIGZuLmV4dGVuZChQbHVja05vZGUpO1xuXG4gICAgdmFyICQgPSBQbHVja05vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICBmcmVxOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLmZyZXEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmZyZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQuYmFuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgdmFyIGZyZXEgICA9IF8uZnJlcTtcbiAgICAgICAgdmFyIHNpemUgICA9IChfLnNhbXBsZXJhdGUgLyBmcmVxICsgMC41KXwwO1xuICAgICAgICB2YXIgYnVmZmVyID0gXy5idWZmZXIgPSBuZXcgZm4uU2lnbmFsQXJyYXkoc2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICBidWZmZXJbaV0gPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgXy5pbmRleCA9IDA7XG4gICAgICAgIF8uZW1pdChcImJhbmdcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBfLmJ1ZmZlcjtcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfLmluZGV4LCB3cml0ZTtcbiAgICAgICAgICAgICAgICB2YXIgbXVsID0gXy5tdWwsIGFkZCA9IF8uYWRkO1xuICAgICAgICAgICAgICAgIHZhciB4LCBpLCBpbWF4ID0gY2VsbC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHggPSBidWZmZXJbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBidWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4ID0gKHggKyBidWZmZXJbaW5kZXhdKSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW3dyaXRlXSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxbaV0gPSB4ICogbXVsICsgYWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJwbHVja1wiLCBQbHVja05vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG4gICAgdmFyIHRpbWV2YWx1ZSA9IFQudGltZXZhbHVlO1xuXG4gICAgdmFyIFNUQVRVU19XQUlUID0gMDtcbiAgICB2YXIgU1RBVFVTX1JFQyAgPSAxO1xuXG4gICAgZnVuY3Rpb24gUmVjTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcbiAgICAgICAgZm4ubGlzdGVuZXIodGhpcyk7XG4gICAgICAgIGZuLmZpeEFSKHRoaXMpO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBfLnRpbWVvdXQgICAgPSA1MDAwO1xuICAgICAgICBfLnN0YXR1cyAgICAgPSBTVEFUVVNfV0FJVDtcbiAgICAgICAgXy53cml0ZUluZGV4ID0gMDtcbiAgICAgICAgXy53cml0ZUluZGV4SW5jciAgPSAxO1xuICAgICAgICBfLmN1cnJlbnRUaW1lICAgICA9IDA7XG4gICAgICAgIF8uY3VycmVudFRpbWVJbmNyID0gMTAwMCAvIF8uc2FtcGxlcmF0ZTtcbiAgICAgICAgXy5vbmVuZGVkID0gbWFrZV9vbmVuZGVkKHRoaXMpO1xuICAgIH1cbiAgICBmbi5leHRlbmQoUmVjTm9kZSk7XG5cbiAgICB2YXIgbWFrZV9vbmVuZGVkID0gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHNlbGYuXztcblxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBmbi5TaWduYWxBcnJheShfLmJ1ZmZlci5zdWJhcnJheSgwLCBfLndyaXRlSW5kZXh8MCkpO1xuXG4gICAgICAgICAgICBfLnN0YXR1cyAgICAgID0gU1RBVFVTX1dBSVQ7XG4gICAgICAgICAgICBfLndyaXRlSW5kZXggID0gMDtcbiAgICAgICAgICAgIF8uY3VycmVudFRpbWUgPSAwO1xuXG4gICAgICAgICAgICBfLmVtaXQoXCJlbmRlZFwiLCB7XG4gICAgICAgICAgICAgICAgYnVmZmVyOmJ1ZmZlciwgc2FtcGxlcmF0ZTpfLnNhbXBsZXJhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgJCA9IFJlY05vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICB0aW1lb3V0OiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRpbWV2YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy50aW1lb3V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy50aW1lb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzYW1wbGVyYXRlOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA8IHZhbHVlICYmIHZhbHVlIDw9IHRoaXMuXy5zYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8uc2FtcGxlcmF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50VGltZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fLCBsZW47XG4gICAgICAgIGlmIChfLnN0YXR1cyA9PT0gU1RBVFVTX1dBSVQpIHtcbiAgICAgICAgICAgIGxlbiA9IChfLnRpbWVvdXQgKiAwLjAxICogXy5zYW1wbGVyYXRlKXwwO1xuICAgICAgICAgICAgaWYgKCFfLmJ1ZmZlciB8fCBfLmJ1ZmZlci5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBfLmJ1ZmZlciA9IG5ldyBmbi5TaWduYWxBcnJheShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy53cml0ZUluZGV4ID0gMDtcbiAgICAgICAgICAgIF8ud3JpdGVJbmRleEluY3IgPSBfLnNhbXBsZXJhdGUgLyBULnNhbXBsZXJhdGU7XG4gICAgICAgICAgICBfLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgIF8uc3RhdHVzID0gU1RBVFVTX1JFQztcbiAgICAgICAgICAgIF8uZW1pdChcInN0YXJ0XCIpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBpZiAoXy5zdGF0dXMgPT09IFNUQVRVU19SRUMpIHtcbiAgICAgICAgICAgIF8uc3RhdHVzID0gU1RBVFVTX1dBSVQ7XG4gICAgICAgICAgICBfLmVtaXQoXCJzdG9wXCIpO1xuICAgICAgICAgICAgZm4ubmV4dFRpY2soXy5vbmVuZGVkKTtcbiAgICAgICAgICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5iYW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl8uc3RhdHVzID09PSBTVEFUVVNfV0FJVCkge1xuICAgICAgICAgICAgdGhpcy5zcmFydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuXy5zdGF0dXMgPT09IFNUQVRVU19SRUMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuXy5lbWl0KFwiYmFuZ1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgZm4uaW5wdXRTaWduYWxBUih0aGlzKTtcblxuICAgICAgICAgICAgaWYgKF8uc3RhdHVzID09PSBTVEFUVVNfUkVDKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGltYXggPSBjZWxsLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyICA9IF8uYnVmZmVyO1xuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gXy50aW1lb3V0O1xuICAgICAgICAgICAgICAgIHZhciB3cml0ZUluZGV4ICAgICAgPSBfLndyaXRlSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIHdyaXRlSW5kZXhJbmNyICA9IF8ud3JpdGVJbmRleEluY3I7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lICAgICA9IF8uY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lSW5jciA9IF8uY3VycmVudFRpbWVJbmNyO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbd3JpdGVJbmRleHwwXSA9IGNlbGxbaV07XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSW5kZXggKz0gd3JpdGVJbmRleEluY3I7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbWUgKz0gY3VycmVudFRpbWVJbmNyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCA8PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4ubmV4dFRpY2soXy5vbmVuZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLndyaXRlSW5kZXggID0gd3JpdGVJbmRleDtcbiAgICAgICAgICAgICAgICBfLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcInJlY29yZFwiLCBSZWNOb2RlKTtcbiAgICBmbi5hbGlhcyhcInJlY1wiLCBcInJlY29yZFwiKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuICAgIHZhciBSZXZlcmIgPSBULm1vZHVsZXMuUmV2ZXJiO1xuXG4gICAgZnVuY3Rpb24gUmV2ZXJiTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDIsIF9hcmdzKTtcbiAgICAgICAgZm4uZml4QVIodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fLnJldmVyYiA9IG5ldyBSZXZlcmIodGhpcy5fLnNhbXBsZXJhdGUsIHRoaXMuXy5jZWxsc2l6ZSk7XG4gICAgfVxuICAgIGZuLmV4dGVuZChSZXZlcmJOb2RlKTtcblxuICAgIHZhciAkID0gUmV2ZXJiTm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIHJvb206IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID4gMSkgPyAxIDogKHZhbHVlIDwgMCkgPyAwIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5yZXZlcmIuc2V0Um9vbVNpemUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ucmV2ZXJiLnJvb21zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYW1wOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA+IDEpID8gMSA6ICh2YWx1ZSA8IDApID8gMCA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8ucmV2ZXJiLnNldERhbXAodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ucmV2ZXJiLmRhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1peDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPiAxKSA/IDEgOiAodmFsdWUgPCAwKSA/IDAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnJldmVyYi53ZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnJldmVyYi53ZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG5cbiAgICAgICAgICAgIGlmICghXy5ieXBhc3NlZCkge1xuICAgICAgICAgICAgICAgIF8ucmV2ZXJiLnByb2Nlc3ModGhpcy5jZWxsc1sxXSwgdGhpcy5jZWxsc1syXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwicmV2ZXJiXCIsIFJldmVyYk5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG4gICAgdmFyIHRpbWV2YWx1ZSA9IFQudGltZXZhbHVlO1xuXG4gICAgZnVuY3Rpb24gU2NoZWR1bGVOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMCwgX2FyZ3MpO1xuICAgICAgICBmbi50aW1lcih0aGlzKTtcbiAgICAgICAgZm4uZml4S1IodGhpcyk7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIF8ucXVldWUgPSBbXTtcbiAgICAgICAgXy5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgIF8ubWF4UmVtYWluICAgPSAxMDAwO1xuICAgIH1cbiAgICBmbi5leHRlbmQoU2NoZWR1bGVOb2RlKTtcblxuICAgIHZhciAkID0gU2NoZWR1bGVOb2RlLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgcXVldWU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5xdWV1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtYWluOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ucXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtYXhSZW1haW46IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8ubWF4UmVtYWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5tYXhSZW1haW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzRW1wdHk6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5xdWV1ZS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbnRUaW1lOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uY3VycmVudFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQuc2NoZWQgPSBmdW5jdGlvbihkZWx0YSwgaXRlbSwgYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGRlbHRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWx0YSA9IHRpbWV2YWx1ZShkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkZWx0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5zY2hlZEFicyh0aGlzLl8uY3VycmVudFRpbWUgKyBkZWx0YSwgaXRlbSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQuc2NoZWRBYnMgPSBmdW5jdGlvbih0aW1lLCBpdGVtLCBhcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGltZSA9IHRpbWV2YWx1ZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRpbWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gXy5xdWV1ZTtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPj0gXy5tYXhSZW1haW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBxdWV1ZS5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW2ldWzBdIDwgdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIFt0aW1lLCBUKGl0ZW0pLCBhcmdzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQuYWR2YW5jZSA9IGZ1bmN0aW9uKGRlbHRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVsdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGltZXZhbHVlKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRlbHRhID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLl8uY3VycmVudFRpbWUgKz0gZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fLnF1ZXVlLnNwbGljZSgwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciBlbWl0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IF8ucXVldWU7XG5cbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWVbMF1bMF0gPCBfLmN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SXRlbSA9IF8ucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEl0ZW1bMV0uYmFuZyhuZXh0SXRlbVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIGVtaXQgPSBcInNjaGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXQgPSBcImVtcHR5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8uY3VycmVudFRpbWUgKz0gZm4uY3VycmVudFRpbWVJbmNyO1xuICAgICAgICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgICAgICAgICBfLmVtaXQoZW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwic2NoZWR1bGVcIiwgU2NoZWR1bGVOb2RlKTtcbiAgICBmbi5hbGlhcyhcInNjaGVkXCIsIFwic2NoZWR1bGVcIik7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcbiAgICB2YXIgdGltZXZhbHVlID0gVC50aW1ldmFsdWU7XG5cbiAgICBmdW5jdGlvbiBTY29wZU5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAyLCBfYXJncyk7XG4gICAgICAgIGZuLmxpc3RlbmVyKHRoaXMpO1xuICAgICAgICBmbi5maXhBUih0aGlzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5zYW1wbGVzICAgID0gMDtcbiAgICAgICAgXy53cml0ZUluZGV4ID0gMDtcbiAgICAgICAgXy5wbG90Rmx1c2ggPSB0cnVlO1xuXG4gICAgICAgIHRoaXMub25jZShcImluaXRcIiwgb25pbml0KTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKFNjb3BlTm9kZSk7XG5cbiAgICB2YXIgb25pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fLmJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5zaXplID0gMTAyNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuXy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IDEwMDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyICQgPSBTY29wZU5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgICAgICAgICAgaWYgKCFfLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9ICh2YWx1ZSA8IDY0KSA/IDY0IDogKHZhbHVlID4gMjA0OCkgPyAyMDQ4IDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmJ1ZmZlciA9IG5ldyBmbi5TaWduYWxBcnJheShuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLnJlc2VydmVkaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsID0gXy5yZXNlcnZlZGludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8ucmVzZXJ2ZWRpbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGludGVydmFsOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRpbWV2YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghXy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ucmVzZXJ2ZWRpbnRlcnZhbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5pbnRlcnZhbCAgICA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5zYW1wbGVzSW5jciA9IHZhbHVlICogMC4wMDEgKiBfLnNhbXBsZXJhdGUgLyBfLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5zYW1wbGVzSW5jciA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLnNhbXBsZXNJbmNyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uaW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJ1ZmZlcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5iYW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICB2YXIgYnVmZmVyID0gXy5idWZmZXI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBidWZmZXIubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIF8uc2FtcGxlcyAgICA9IDA7XG4gICAgICAgIF8ud3JpdGVJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuXy5lbWl0KFwiYmFuZ1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuICAgICAgICAgICAgdmFyIGksIGltYXggPSBfLmNlbGxzaXplO1xuICAgICAgICAgICAgdmFyIHNhbXBsZXMgICAgID0gXy5zYW1wbGVzO1xuICAgICAgICAgICAgdmFyIHNhbXBsZXNJbmNyID0gXy5zYW1wbGVzSW5jcjtcbiAgICAgICAgICAgIHZhciBidWZmZXIgICAgICA9IF8uYnVmZmVyO1xuICAgICAgICAgICAgdmFyIHdyaXRlSW5kZXggID0gXy53cml0ZUluZGV4O1xuICAgICAgICAgICAgdmFyIGVtaXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBidWZmZXJsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZXMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbd3JpdGVJbmRleCsrXSA9IGNlbGxbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh3cml0ZUluZGV4ID49IGJ1ZmZlcmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW1pdCA9IF8ucGxvdEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcyArPSBzYW1wbGVzSW5jcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLS1zYW1wbGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5zYW1wbGVzICAgID0gc2FtcGxlcztcbiAgICAgICAgICAgIF8ud3JpdGVJbmRleCA9IHdyaXRlSW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmVtaXQoXCJkYXRhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBzdXBlcl9wbG90ID0gVC5PYmplY3QucHJvdG90eXBlLnBsb3Q7XG5cbiAgICAkLnBsb3QgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBpZiAoXy5wbG90Rmx1c2gpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBfLmJ1ZmZlcjtcbiAgICAgICAgICAgIHZhciBtYXNrICAgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciBkYXRhICAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGogPSBfLndyaXRlSW5kZXg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBpbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhW2ldID0gYnVmZmVyWysraiAmIG1hc2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5wbG90RGF0YSAgPSBkYXRhO1xuICAgICAgICAgICAgXy5wbG90Rmx1c2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlcl9wbG90LmNhbGwodGhpcywgb3B0cyk7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwic2NvcGVcIiwgU2NvcGVOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gU2NyaXB0UHJvY2Vzc29yTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDIsIF9hcmdzKTtcbiAgICAgICAgZm4uZml4QVIodGhpcyk7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIF8ubnVtYmVyT2ZJbnB1dHMgPSAwO1xuICAgICAgICBfLm51bWJlck9mT3V0cHV0cyA9IDA7XG4gICAgICAgIF8uYnVmZmVyU2l6ZSA9IDA7XG4gICAgICAgIF8uYnVmZmVyTWFzayA9IDA7XG4gICAgICAgIF8uZHVyYXRpb24gICA9IDA7XG4gICAgICAgIF8uaW5wdXRCdWZmZXJMID0gbnVsbDtcbiAgICAgICAgXy5pbnB1dEJ1ZmZlclIgPSBudWxsO1xuICAgICAgICBfLm91dHB1dEJ1ZmZlckwgPSBudWxsO1xuICAgICAgICBfLm91dHB1dEJ1ZmZlclIgPSBudWxsO1xuICAgICAgICBfLm9uYXVkaW9wcm9jZXNzID0gbnVsbDtcbiAgICAgICAgXy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMub25jZShcImluaXRcIiwgb25pbml0KTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKFNjcmlwdFByb2Nlc3Nvck5vZGUpO1xuXG4gICAgdmFyIG9uaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgaWYgKF8ubnVtYmVyT2ZJbnB1dHMgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZJbnB1dHMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLm51bWJlck9mT3V0cHV0cyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZk91dHB1dHMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLmJ1ZmZlclNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyU2l6ZSA9IDEwMjQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyICQgPSBTY3JpcHRQcm9jZXNzb3JOb2RlLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgbnVtYmVyT2ZJbnB1dHM6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgICAgICBpZiAoXy5udW1iZXJPZklucHV0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfLm51bWJlck9mSW5wdXRzID0gKHZhbHVlID09PSAyKSA/IDIgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ubnVtYmVyT2ZJbnB1dHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlck9mT3V0cHV0czoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgICAgIGlmIChfLm51bWJlck9mT3V0cHV0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfLm51bWJlck9mT3V0cHV0cyA9ICh2YWx1ZSA9PT0gMikgPyAyIDogMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLm51bWJlck9mT3V0cHV0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYnVmZmVyU2l6ZToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgICAgIGlmIChfLmJ1ZmZlclNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFsyNTYsIDUxMiwgMTAyNCwgMjA0OCwgNDA5NiwgODE5MiwgMTYzODRdLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5idWZmZXJTaXplID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmJ1ZmZlck1hc2sgPSB2YWx1ZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmR1cmF0aW9uID0gdmFsdWUgLyBfLnNhbXBsZXJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlucHV0QnVmZmVyTCAgPSBuZXcgZm4uU2lnbmFsQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5pbnB1dEJ1ZmZlclIgID0gbmV3IGZuLlNpZ25hbEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3V0cHV0QnVmZmVyTCA9IG5ldyBmbi5TaWduYWxBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm91dHB1dEJ1ZmZlclIgPSBuZXcgZm4uU2lnbmFsQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5idWZmZXJTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbmF1ZGlvcHJvY2Vzczoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8ub25hdWRpb3Byb2Nlc3MgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLm9uYXVkaW9wcm9jZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBBdWRpb0J1ZmZlcihzZWxmLCBidWZmZXJzKSB7XG4gICAgICAgIHRoaXMuc2FtcGxlcmF0ZSA9IHNlbGYuXy5zYW1wbGVyYXRlO1xuICAgICAgICB0aGlzLmxlbmd0aCAgICAgPSBzZWxmLl8uYnVmZmVyU2l6ZTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiAgID0gc2VsZi5fLmR1cmF0aW9uO1xuICAgICAgICB0aGlzLm51bWJlck9mQ2hhbm5lbHMgPSBidWZmZXJzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5nZXRDaGFubmVsRGF0YSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJzW25dO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEF1ZGlvUHJvY2Vzc2luZ0V2ZW50KHNlbGYpIHtcbiAgICAgICAgdmFyIF8gPSBzZWxmLl87XG4gICAgICAgIHRoaXMubm9kZSA9IHNlbGY7XG4gICAgICAgIHRoaXMucGxheWJhY2tUaW1lID0gVC5jdXJyZW50VGltZTtcbiAgICAgICAgaWYgKF8ubnVtYmVyT2ZJbnB1dHMgPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgID0gbmV3IEF1ZGlvQnVmZmVyKHNlbGYsIFtfLmlucHV0QnVmZmVyTCwgXy5pbnB1dEJ1ZmZlclJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgID0gbmV3IEF1ZGlvQnVmZmVyKHNlbGYsIFtfLmlucHV0QnVmZmVyTF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLm51bWJlck9mT3V0cHV0cyA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRCdWZmZXIgPSBuZXcgQXVkaW9CdWZmZXIoc2VsZiwgW18ub3V0cHV0QnVmZmVyTCwgXy5vdXRwdXRCdWZmZXJSXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEJ1ZmZlciA9IG5ldyBBdWRpb0J1ZmZlcihzZWxmLCBbXy5vdXRwdXRCdWZmZXJMXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICB2YXIgY2VsbHNpemUgICA9IF8uY2VsbHNpemU7XG4gICAgICAgICAgICB2YXIgYnVmZmVyTWFzayA9IF8uYnVmZmVyTWFzaztcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IF8uaW5kZXg7XG4gICAgICAgICAgICB2YXIgZW5kICAgPSBiZWdpbiArIGNlbGxzaXplO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlcjtcbiAgICAgICAgICAgIHZhciBjZWxsTCAgPSB0aGlzLmNlbGxzWzFdO1xuICAgICAgICAgICAgdmFyIGNlbGxSICA9IHRoaXMuY2VsbHNbMl07XG5cbiAgICAgICAgICAgIGZuLmlucHV0U2lnbmFsQVIodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChfLm51bWJlck9mSW5wdXRzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgXy5pbnB1dEJ1ZmZlckwuc2V0KGNlbGxMLCBiZWdpbik7XG4gICAgICAgICAgICAgICAgXy5pbnB1dEJ1ZmZlclIuc2V0KGNlbGxSLCBiZWdpbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IF8uaW5wdXRCdWZmZXJMO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2VsbHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbYmVnaW4gKyBpXSA9IChjZWxsTFtpXSArIGNlbGxSW2ldKSAqIDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNlbGxMLnNldChfLm91dHB1dEJ1ZmZlckwuc3ViYXJyYXkoYmVnaW4sIGVuZCkpO1xuICAgICAgICAgICAgY2VsbFIuc2V0KF8ub3V0cHV0QnVmZmVyUi5zdWJhcnJheShiZWdpbiwgZW5kKSk7XG5cbiAgICAgICAgICAgIF8uaW5kZXggPSBlbmQgJiBidWZmZXJNYXNrO1xuXG4gICAgICAgICAgICBpZiAoXy5pbmRleCA9PT0gMCAmJiBfLm9uYXVkaW9wcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgXy5vbmF1ZGlvcHJvY2VzcyhuZXcgQXVkaW9Qcm9jZXNzaW5nRXZlbnQodGhpcykpO1xuICAgICAgICAgICAgICAgIGlmIChfLm51bWJlck9mT3V0cHV0cyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBfLm91dHB1dEJ1ZmZlclIuc2V0KF8ub3V0cHV0QnVmZmVyTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcInNjcmlwdFwiLCBTY3JpcHRQcm9jZXNzb3JOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0b3JOb2RlKF9hcmdzKSB7XG4gICAgICAgIFQuT2JqZWN0LmNhbGwodGhpcywgMiwgX2FyZ3MpO1xuXG4gICAgICAgIHRoaXMuXy5zZWxlY3RlZCAgID0gMDtcbiAgICAgICAgdGhpcy5fLmJhY2tncm91bmQgPSBmYWxzZTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKFNlbGVjdG9yTm9kZSk7XG5cbiAgICB2YXIgJCA9IFNlbGVjdG9yTm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8uc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxsc1sxXS5zZXQoZm4uZW1wdHljZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxsc1syXS5zZXQoZm4uZW1wdHljZWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fLmJhY2tncm91bmQgPSAhIXZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5iYWNrZ3JvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgICAgICAgdmFyIGksIGltYXggPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChfLmJhY2tncm91bmQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLnByb2Nlc3ModGlja0lEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0bXAgPSBub2Rlc1tfLnNlbGVjdGVkXTtcbiAgICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIV8uYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0bXAucHJvY2Vzcyh0aWNrSUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzWzFdLnNldCh0bXAuY2VsbHNbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHNbMl0uc2V0KHRtcC5jZWxsc1syXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwic2VsZWN0b3JcIiwgU2VsZWN0b3JOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuICAgIHZhciB0aW1ldmFsdWUgPSBULnRpbWV2YWx1ZTtcbiAgICB2YXIgRkZUID0gVC5tb2R1bGVzLkZGVDtcblxuICAgIHZhciBXQUlUX1NUQVRFID0gMDtcbiAgICB2YXIgRVhFQ19TVEFURSA9IDE7XG5cbiAgICBmdW5jdGlvbiBTcGVjdHJ1bU5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAyLCBfYXJncyk7XG4gICAgICAgIGZuLmxpc3RlbmVyKHRoaXMpO1xuICAgICAgICBmbi5maXhBUih0aGlzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5zdGF0dXMgID0gV0FJVF9TVEFURTtcbiAgICAgICAgXy5zYW1wbGVzID0gMDtcbiAgICAgICAgXy5zYW1wbGVzSW5jciA9IDA7XG4gICAgICAgIF8ud3JpdGVJbmRleCAgPSAwO1xuXG4gICAgICAgIF8ucGxvdEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgXy5wbG90UmFuZ2UgPSBbMCwgMzJdO1xuICAgICAgICBfLnBsb3RCYXJTdHlsZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5vbmNlKFwiaW5pdFwiLCBvbmluaXQpO1xuICAgIH1cbiAgICBmbi5leHRlbmQoU3BlY3RydW1Ob2RlKTtcblxuICAgIHZhciBvbmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIGlmICghXy5mZnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IDUxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV8uaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSA1MDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyICQgPSBTcGVjdHJ1bU5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgICAgICAgICAgaWYgKCFfLmZmdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9ICh2YWx1ZSA8IDI1NikgPyAyNTYgOiAodmFsdWUgPiAyMDQ4KSA/IDIwNDggOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZmZ0ICAgID0gbmV3IEZGVChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uYnVmZmVyID0gbmV3IGZuLlNpZ25hbEFycmF5KF8uZmZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZyZXFzICA9IG5ldyBmbi5TaWduYWxBcnJheShfLmZmdC5sZW5ndGg+PjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8ucmVzZXJ2ZWR3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmZmdC5zZXRXaW5kb3coXy5yZXNlcnZlZHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5yZXNlcnZlZHdpbmRvdyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5yZXNlcnZlZGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IF8ucmVzZXJ2ZWRpbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLnJlc2VydmVkaW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3aW5kb3c6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8uZmZ0LnNldFdpbmRvdyh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmZmdC53aW5kb3dOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnRlcnZhbDoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aW1ldmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV8uYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnJlc2VydmVkaW50ZXJ2YWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaW50ZXJ2YWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uc2FtcGxlc0luY3IgPSAodmFsdWUgKiAwLjAwMSAqIF8uc2FtcGxlcmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5zYW1wbGVzSW5jciA8IF8uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uc2FtcGxlc0luY3IgPSBfLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pbnRlcnZhbCA9IF8uc2FtcGxlc0luY3IgKiAxMDAwIC8gXy5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5pbnRlcnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3BlY3RydW06IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5mZnQuZ2V0RnJlcXVlbmN5RGF0YSh0aGlzLl8uZnJlcXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWFsOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uZmZ0LnJlYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGltYWc6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5mZnQuaW1hZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5iYW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuXy5zYW1wbGVzICAgID0gMDtcbiAgICAgICAgdGhpcy5fLndyaXRlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl8uZW1pdChcImJhbmdcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICBmbi5pbnB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1swXTtcbiAgICAgICAgICAgIHZhciBpLCBpbWF4ID0gY2VsbC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgc3RhdHVzICA9IF8uc3RhdHVzO1xuICAgICAgICAgICAgdmFyIHNhbXBsZXMgPSBfLnNhbXBsZXM7XG4gICAgICAgICAgICB2YXIgc2FtcGxlc0luY3IgPSBfLnNhbXBsZXNJbmNyO1xuICAgICAgICAgICAgdmFyIHdyaXRlSW5kZXggID0gXy53cml0ZUluZGV4O1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IF8uYnVmZmVyO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZW1pdDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVzIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gV0FJVF9TVEFURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gRVhFQ19TVEFURTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlcyArPSBzYW1wbGVzSW5jcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBFWEVDX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclt3cml0ZUluZGV4KytdID0gY2VsbFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckxlbmd0aCA8PSB3cml0ZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZmdC5mb3J3YXJkKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0ID0gXy5wbG90Rmx1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gV0FJVF9TVEFURTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAtLXNhbXBsZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgICAgICAgICBfLnN0YXR1cyAgPSBzdGF0dXM7XG4gICAgICAgICAgICBfLndyaXRlSW5kZXggPSB3cml0ZUluZGV4O1xuXG4gICAgICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuXy5lbWl0KFwiZGF0YVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIHN1cGVyX3Bsb3QgPSBULk9iamVjdC5wcm90b3R5cGUucGxvdDtcblxuICAgICQucGxvdCA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuXy5wbG90Rmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuXy5wbG90RGF0YSAgPSB0aGlzLnNwZWN0cnVtO1xuICAgICAgICAgICAgdGhpcy5fLnBsb3RGbHVzaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyX3Bsb3QuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJzcGVjdHJ1bVwiLCBTcGVjdHJ1bU5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG5cbiAgICBmdW5jdGlvbiBTdWJ0cmFjdE5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAyLCBfYXJncyk7XG4gICAgICAgIHRoaXMuXy5hciA9IGZhbHNlO1xuICAgIH1cbiAgICBmbi5leHRlbmQoU3VidHJhY3ROb2RlKTtcblxuICAgIHZhciAkID0gU3VidHJhY3ROb2RlLnByb3RvdHlwZTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgICAgICAgICB2YXIgY2VsbCAgPSB0aGlzLmNlbGxzWzBdO1xuICAgICAgICAgICAgdmFyIGNlbGxMID0gdGhpcy5jZWxsc1sxXTtcbiAgICAgICAgICAgIHZhciBjZWxsUiA9IHRoaXMuY2VsbHNbMl07XG4gICAgICAgICAgICB2YXIgaSwgaW1heCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBqLCBqbWF4ID0gY2VsbC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdG1wLCB0bXBMLCB0bXBSO1xuXG4gICAgICAgICAgICBpZiAoXy5hcikge1xuICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzWzBdLnByb2Nlc3ModGlja0lEKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wTCA9IG5vZGVzWzBdLmNlbGxzWzFdO1xuICAgICAgICAgICAgICAgICAgICB0bXBSID0gbm9kZXNbMF0uY2VsbHNbMl07XG4gICAgICAgICAgICAgICAgICAgIGNlbGxMLnNldCh0bXBMKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFIuc2V0KHRtcFIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXS5wcm9jZXNzKHRpY2tJRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBMID0gbm9kZXNbaV0uY2VsbHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBSID0gbm9kZXNbaV0uY2VsbHNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgam1heDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbExbal0gLT0gdG1wTFtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsUltqXSAtPSB0bXBSW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGptYXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbExbal0gPSBjZWxsUltpXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IG5vZGVzWzBdLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXVswXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wIC09IG5vZGVzW2ldLnByb2Nlc3ModGlja0lEKS5jZWxsc1swXVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGxbMF0gPSB0bXA7XG4gICAgICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsS1IodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCItXCIsIFN1YnRyYWN0Tm9kZSk7XG5cbn0pKHRpbWJyZSk7XG4oZnVuY3Rpb24oVCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZuID0gVC5mbjtcblxuICAgIGZ1bmN0aW9uIFN5bnRoRGVmTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDIsIF9hcmdzKTtcbiAgICAgICAgZm4uZml4QVIodGhpcyk7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIHRoaXMucGxheWJhY2tTdGF0ZSA9IGZuLkZJTklTSEVEX1NUQVRFO1xuICAgICAgICBfLnBvbHkgICAgID0gNDtcbiAgICAgICAgXy5nZW5MaXN0ICA9IFtdO1xuICAgICAgICBfLmdlbkRpY3QgID0ge307XG4gICAgICAgIF8uc3ludGhkZWYgPSBudWxsO1xuICAgICAgICBfLnJlbUdlbiA9IG1ha2VfcmVtR2VuKHRoaXMpO1xuICAgICAgICBfLm9uZW5kZWQgPSBmbi5tYWtlX29uZW5kZWQodGhpcyk7XG4gICAgfVxuICAgIGZuLmV4dGVuZChTeW50aERlZk5vZGUpO1xuXG4gICAgdmFyICQgPSBTeW50aERlZk5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICBkZWY6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnN5bnRoZGVmID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5zeW50aGRlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9seToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPCB2YWx1ZSAmJiB2YWx1ZSA8PSA2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnBvbHkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ucG9seTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG1ha2VfZG9uZUFjdGlvbiA9IGZ1bmN0aW9uKHNlbGYsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fLnJlbUdlbihvcHRzLmdlbik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBtYWtlX3JlbUdlbiA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGdlbikge1xuICAgICAgICAgICAgdmFyIF8gPSBzZWxmLl87XG4gICAgICAgICAgICB2YXIgaSA9IF8uZ2VuTGlzdC5pbmRleE9mKGdlbik7XG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBfLmdlbkxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW4ubm90ZU51bSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIF8uZ2VuRGljdFtnZW4ubm90ZU51bV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgbm90ZU9uID0gZnVuY3Rpb24obm90ZU51bSwgZnJlcSwgdmVsb2NpdHksIF9vcHRzKSB7XG4gICAgICAgIHZlbG9jaXR5IHw9IDA7XG4gICAgICAgIGlmICh2ZWxvY2l0eSA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGVPZmYodGhpcywgbm90ZU51bSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmVsb2NpdHkgPiAxMjcpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gMTI3O1xuICAgICAgICB9XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICB2YXIgbGlzdCA9IF8uZ2VuTGlzdCwgZGljdCA9IF8uZ2VuRGljdDtcbiAgICAgICAgdmFyIGdlbiA9IGRpY3Rbbm90ZU51bV07XG4gICAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgICAgIF8ucmVtR2VuKGdlbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIGZyZXEgICAgOiBmcmVxLFxuICAgICAgICAgICAgbm90ZU51bSA6IG5vdGVOdW0sXG4gICAgICAgICAgICB2ZWxvY2l0eTogdmVsb2NpdHksXG4gICAgICAgICAgICBtdWwgICAgIDogdmVsb2NpdHkgKiAwLjAwNzgxMjVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKF9vcHRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX29wdHMpIHtcbiAgICAgICAgICAgICAgICBvcHRzW2tleV0gPSBfb3B0c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdHMuZG9uZUFjdGlvbiA9IG1ha2VfZG9uZUFjdGlvbih0aGlzLCBvcHRzKTtcblxuICAgICAgICBnZW4gPSBfLnN5bnRoZGVmLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgaWYgKGdlbiBpbnN0YW5jZW9mIFQuT2JqZWN0KSB7XG4gICAgICAgICAgICBnZW4ubm90ZU51bSA9IG5vdGVOdW07XG4gICAgICAgICAgICBsaXN0LnB1c2goZ2VuKTtcbiAgICAgICAgICAgIGRpY3Rbbm90ZU51bV0gPSBvcHRzLmdlbiA9IGdlbjtcblxuICAgICAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gZm4uUExBWUlOR19TVEFURTtcblxuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gXy5wb2x5KSB7XG4gICAgICAgICAgICAgICAgXy5yZW1HZW4obGlzdFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1pZGljcHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkoMTI4KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjg7ICsraSkge1xuICAgICAgICAgICAgdGFibGVbaV0gPSA0NDAgKiBNYXRoLnBvdygyLCAoaSAtIDY5KSAqIDEgLyAxMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH0pKCk7XG5cbiAgICB2YXIgY3BzbWlkaSA9IGZ1bmN0aW9uKGNwcykge1xuICAgICAgICBpZiAoY3BzID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKGNwcyAqIDEgLyA0NDApICogTWF0aC5MT0cyRSAqIDEyICsgNjk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLm5vdGVPbiA9IGZ1bmN0aW9uKG5vdGVOdW0sIHZlbG9jaXR5LCBfb3B0cykge1xuICAgICAgICB2YXIgZnJlcSA9IG1pZGljcHNbbm90ZU51bV0gfHwgKDQ0MCAqIE1hdGgucG93KDIsIChub3RlTnVtIC0gNjkpIC8gMTIpKTtcbiAgICAgICAgbm90ZU9uLmNhbGwodGhpcywgKG5vdGVOdW0gKyAwLjUpfDAsIGZyZXEsIHZlbG9jaXR5LCBfb3B0cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLm5vdGVPZmYgPSBmdW5jdGlvbihub3RlTnVtKSB7XG4gICAgICAgIHZhciBnZW4gPSB0aGlzLl8uZ2VuRGljdFtub3RlTnVtXTtcbiAgICAgICAgaWYgKGdlbiAmJiBnZW4ucmVsZWFzZSkge1xuICAgICAgICAgICAgZ2VuLnJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5ub3RlT25XaXRoRnJlcSA9IGZ1bmN0aW9uKGZyZXEsIHZlbG9jaXR5LCBfb3B0cykge1xuICAgICAgICB2YXIgbm90ZU51bSA9IGNwc21pZGkoZnJlcSk7XG4gICAgICAgIG5vdGVPbi5jYWxsKHRoaXMsIChub3RlTnVtICsgMC41KXwwLCBmcmVxLCB2ZWxvY2l0eSwgX29wdHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5ub3RlT2ZmV2l0aEZyZXEgPSBmdW5jdGlvbihmcmVxKSB7XG4gICAgICAgIHZhciBub3RlTnVtID0gY3BzbWlkaShmcmVxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm90ZU9mZigobm90ZU51bSArIDAuNSl8MCk7XG4gICAgfTtcblxuICAgICQuYWxsTm90ZU9mZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuXy5nZW5MaXN0O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IGxpc3QubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobGlzdFtpXS5yZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgbGlzdFtpXS5yZWxlYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5hbGxTb3VuZE9mZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgdmFyIGxpc3QgPSBfLmdlbkxpc3Q7XG4gICAgICAgIHZhciBkaWN0ID0gXy5nZW5EaWN0O1xuICAgICAgICB3aGlsZSAobGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkaWN0W2xpc3Quc2hpZnQoKS5ub3RlTnVtXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLnN5bnRoID0gZnVuY3Rpb24oX29wdHMpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIHZhciBsaXN0ID0gXy5nZW5MaXN0O1xuICAgICAgICB2YXIgZ2VuLCBvcHRzID0ge307XG5cbiAgICAgICAgaWYgKF9vcHRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX29wdHMpIHtcbiAgICAgICAgICAgICAgICBvcHRzW2tleV0gPSBfb3B0c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdHMuZG9uZUFjdGlvbiA9IG1ha2VfZG9uZUFjdGlvbih0aGlzLCBvcHRzKTtcblxuICAgICAgICBnZW4gPSBfLnN5bnRoZGVmLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgaWYgKGdlbiBpbnN0YW5jZW9mIFQuT2JqZWN0KSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goZ2VuKTtcbiAgICAgICAgICAgIG9wdHMuZ2VuID0gZ2VuO1xuICAgICAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gZm4uUExBWUlOR19TVEFURTtcblxuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gXy5wb2x5KSB7XG4gICAgICAgICAgICAgICAgXy5yZW1HZW4obGlzdFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC5wcm9jZXNzID0gZnVuY3Rpb24odGlja0lEKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1swXTtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wbGF5YmFja1N0YXRlID09PSBmbi5QTEFZSU5HX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBfLmdlbkxpc3Q7XG4gICAgICAgICAgICAgICAgdmFyIGdlbjtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbEwgPSB0aGlzLmNlbGxzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsUiA9IHRoaXMuY2VsbHNbMl07XG4gICAgICAgICAgICAgICAgdmFyIGksIGltYXg7XG4gICAgICAgICAgICAgICAgdmFyIGosIGptYXggPSBjZWxsLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgdG1wTCwgdG1wUjtcblxuICAgICAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBnZW4gPSBsaXN0WzBdO1xuICAgICAgICAgICAgICAgICAgICBnZW4ucHJvY2Vzcyh0aWNrSUQpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsTC5zZXQoZ2VuLmNlbGxzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFIuc2V0KGdlbi5jZWxsc1syXSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGltYXggPSBsaXN0Lmxlbmd0aDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5wcm9jZXNzKHRpY2tJRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBMID0gZ2VuLmNlbGxzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wUiA9IGdlbi5jZWxsc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqbWF4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTFtqXSArPSB0bXBMW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxSW2pdICs9IHRtcFJbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmbi5uZXh0VGljayhfLm9uZW5kZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJTeW50aERlZlwiLCBTeW50aERlZk5vZGUpO1xuXG5cbiAgICB2YXIgZW52X2Rlc2MgPSB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChmbi5pc0RpY3Rpb25hcnkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5lbnYgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVC5PYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8uZW52ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fLmVudjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcIk9zY0dlblwiLCAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG9zY19kZXNjID0ge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFQuT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5vc2MgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLm9zYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgd2F2ZV9kZXNjID0ge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLndhdmUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLndhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN5bnRoZGVmID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgICAgICB2YXIgc3ludGgsIG9zYywgZW52LCBlbnZ0eXBlO1xuXG4gICAgICAgICAgICBvc2MgPSBfLm9zYyB8fCBudWxsO1xuICAgICAgICAgICAgZW52ID0gXy5lbnYgfHwge307XG4gICAgICAgICAgICBlbnZ0eXBlID0gZW52LnR5cGUgfHwgXCJwZXJjXCI7XG5cbiAgICAgICAgICAgIGlmIChvc2MgaW5zdGFuY2VvZiBULk9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3NjLmNsb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3NjID0gb3NjLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvc2MpIHtcbiAgICAgICAgICAgICAgICBvc2MgPSBUKFwib3NjXCIsIHt3YXZlOl8ud2F2ZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3NjLmZyZXEgPSBvcHRzLmZyZXE7XG4gICAgICAgICAgICBvc2MubXVsICA9IG9zYy5tdWwgKiBvcHRzLnZlbG9jaXR5LzEyODtcblxuICAgICAgICAgICAgc3ludGggPSBvc2M7XG4gICAgICAgICAgICBpZiAoZW52IGluc3RhbmNlb2YgVC5PYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudi5jbG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bnRoID0gZW52LmNsb25lKCkuYXBwZW5kKHN5bnRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bnRoID0gVChlbnZ0eXBlLCBlbnYsIHN5bnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN5bnRoLm9uKFwiZW5kZWRcIiwgb3B0cy5kb25lQWN0aW9uKS5iYW5nKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzeW50aDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBTeW50aERlZk5vZGUoX2FyZ3MpO1xuXG4gICAgICAgICAgICBpbnN0YW5jZS5fLndhdmUgPSBcInNpblwiO1xuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnN0YW5jZSwge1xuICAgICAgICAgICAgICAgIGVudjogZW52X2Rlc2MsIG9zYzogb3NjX2Rlc2MsIHdhdmU6IHdhdmVfZGVzY1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGluc3RhbmNlLmRlZiA9IHN5bnRoZGVmO1xuXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgfSkoKSk7XG5cbiAgICBmbi5yZWdpc3RlcihcIlBsdWNrR2VuXCIsIChmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3ludGhkZWYgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgIHZhciBzeW50aCwgZW52LCBlbnZ0eXBlO1xuXG4gICAgICAgICAgICBlbnYgPSBfLmVudiB8fCB7fTtcbiAgICAgICAgICAgIGVudnR5cGUgPSBlbnYudHlwZSB8fCBcInBlcmNcIjtcblxuICAgICAgICAgICAgc3ludGggPSBUKFwicGx1Y2tcIiwge2ZyZXE6b3B0cy5mcmVxLCBtdWw6b3B0cy52ZWxvY2l0eS8xMjh9KS5iYW5nKCk7XG4gICAgICAgICAgICBpZiAoZW52IGluc3RhbmNlb2YgVC5PYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudi5jbG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bnRoID0gZW52LmNsb25lKCkuYXBwZW5kKHN5bnRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bnRoID0gVChlbnZ0eXBlLCBlbnYsIHN5bnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN5bnRoLm9uKFwiZW5kZWRcIiwgb3B0cy5kb25lQWN0aW9uKS5iYW5nKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzeW50aDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBTeW50aERlZk5vZGUoX2FyZ3MpO1xuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnN0YW5jZSwge1xuICAgICAgICAgICAgICAgIGVudjogZW52X2Rlc2NcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnN0YW5jZS5kZWYgPSBzeW50aGRlZjtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9O1xuICAgIH0pKCkpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG4gICAgdmFyIFNjaXNzb3IgICAgPSBULm1vZHVsZXMuU2Npc3NvcjtcbiAgICB2YXIgVGFwZSAgICAgICA9IFNjaXNzb3IuVGFwZTtcbiAgICB2YXIgVGFwZVN0cmVhbSA9IFNjaXNzb3IuVGFwZVN0cmVhbTtcbiAgICB2YXIgaXNTaWduYWxBcnJheSA9IGZuLmlzU2lnbmFsQXJyYXk7XG5cbiAgICBmdW5jdGlvbiBTY2lzc29yTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDIsIF9hcmdzKTtcbiAgICAgICAgZm4uZml4QVIodGhpcyk7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIF8uaXNMb29wZWQgPSBmYWxzZTtcbiAgICAgICAgXy5vbmVuZGVkICA9IGZuLm1ha2Vfb25lbmRlZCh0aGlzLCAwKTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKFNjaXNzb3JOb2RlKTtcblxuICAgIHZhciAkID0gU2Npc3Nvck5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICB0YXBlOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRhcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFwZSBpbnN0YW5jZW9mIFRhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gZm4uUExBWUlOR19TVEFURTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnRhcGUgPSB0YXBlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8udGFwZVN0cmVhbSA9IG5ldyBUYXBlU3RyZWFtKHRhcGUsIHRoaXMuXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fLnRhcGVTdHJlYW0uaXNMb29wZWQgPSB0aGlzLl8uaXNMb29wZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcGUgaW5zdGFuY2VvZiBULk9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcGUuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFwZSA9IHRhcGUuYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFwZS5idWZmZXIpICYmIGlzU2lnbmFsQXJyYXkodGFwZS5idWZmZXJbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gZm4uUExBWUlOR19TVEFURTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8udGFwZSA9IG5ldyBTY2lzc29yKHRhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuXy50YXBlU3RyZWFtID0gbmV3IFRhcGVTdHJlYW0odGhpcy5fLnRhcGUsIHRoaXMuXy5zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8udGFwZVN0cmVhbS5pc0xvb3BlZCA9IHRoaXMuXy5pc0xvb3BlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8udGFwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNMb29wZWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5pc0xvb3BlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYnVmZmVyOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl8udGFwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLnRhcGUuZ2V0QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkLmxvb3AgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl8uaXNMb29wZWQgPSAhIXZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fLnRhcGVTdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuXy50YXBlU3RyZWFtLmlzTG9vcGVkID0gdGhpcy5fLmlzTG9vcGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLmJhbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gZm4uUExBWUlOR19TVEFURTtcbiAgICAgICAgaWYgKHRoaXMuXy50YXBlU3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLl8udGFwZVN0cmVhbS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuXy5lbWl0KFwiYmFuZ1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl8udGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy50YXBlLmdldEJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIHZhciB0YXBlU3RyZWFtID0gXy50YXBlU3RyZWFtO1xuXG4gICAgICAgICAgICBpZiAodGFwZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsTCA9IHRoaXMuY2VsbHNbMV07XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxSID0gdGhpcy5jZWxsc1syXTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wICA9IHRhcGVTdHJlYW0uZmV0Y2goY2VsbEwubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjZWxsTC5zZXQodG1wWzBdKTtcbiAgICAgICAgICAgICAgICBjZWxsUi5zZXQodG1wWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbGF5YmFja1N0YXRlID09PSBmbi5QTEFZSU5HX1NUQVRFICYmIHRhcGVTdHJlYW0uaXNFbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBmbi5uZXh0VGljayhfLm9uZW5kZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4ub3V0cHV0U2lnbmFsQVIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgZm4ucmVnaXN0ZXIoXCJ0YXBlXCIsIFNjaXNzb3JOb2RlKTtcblxufSkodGltYnJlKTtcbihmdW5jdGlvbihUKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm4gPSBULmZuO1xuICAgIHZhciB0aW1ldmFsdWUgPSBULnRpbWV2YWx1ZTtcbiAgICB2YXIgRnVuY3Rpb25XcmFwcGVyID0gVChmdW5jdGlvbigpe30pLmNvbnN0cnVjdG9yO1xuXG4gICAgZnVuY3Rpb24gVGFza05vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAxLCBfYXJncyk7XG4gICAgICAgIGZuLnRpbWVyKHRoaXMpO1xuXG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICB0aGlzLnBsYXliYWNrU3RhdGUgPSBmbi5GSU5JU0hFRF9TVEFURTtcbiAgICAgICAgXy50YXNrID0gW107XG4gICAgICAgIF8uaSAgICAgPSAwO1xuICAgICAgICBfLmogICAgID0gMDtcbiAgICAgICAgXy5pbWF4ICA9IDA7XG4gICAgICAgIF8uam1heCAgPSAwO1xuICAgICAgICBfLndhaXQgID0gMDtcbiAgICAgICAgXy5jb3VudCA9IDA7XG4gICAgICAgIF8uYXJncyAgPSB7fTtcbiAgICAgICAgXy5kb051bSA9IDE7XG4gICAgICAgIF8uaW5pdEZ1bmMgPSBmbi5ub3A7XG4gICAgICAgIF8ub25lbmRlZCA9IG1ha2Vfb25lbmRlZCh0aGlzKTtcblxuICAgICAgICB0aGlzLm9uKFwic3RhcnRcIiwgb25zdGFydCk7XG4gICAgfVxuICAgIGZuLmV4dGVuZChUYXNrTm9kZSk7XG5cbiAgICB2YXIgb25zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXywgYXJncztcbiAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gZm4uUExBWUlOR19TVEFURTtcbiAgICAgICAgXy50YXNrID0gdGhpcy5ub2Rlcy5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBGdW5jdGlvbldyYXBwZXIgPyB4LmZ1bmMgOiBmYWxzZTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXg7XG4gICAgICAgIH0pO1xuICAgICAgICBfLmkgPSBfLmogPSAwO1xuICAgICAgICBfLmltYXggPSBfLmRvTnVtO1xuICAgICAgICBfLmptYXggPSBfLnRhc2subGVuZ3RoO1xuICAgICAgICBhcmdzID0gXy5pbml0RnVuYygpO1xuICAgICAgICBpZiAoIWZuLmlzRGljdGlvbmFyeShhcmdzKSkge1xuICAgICAgICAgICAgYXJncyA9IHtwYXJhbTphcmdzfTtcbiAgICAgICAgfVxuICAgICAgICBfLmFyZ3MgPSBhcmdzO1xuICAgIH07XG5cbiAgICB2YXIgbWFrZV9vbmVuZGVkID0gZnVuY3Rpb24oc2VsZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXliYWNrU3RhdGUgPSBmbi5GSU5JU0hFRF9TVEFURTtcbiAgICAgICAgICAgIHZhciBfID0gc2VsZi5fO1xuICAgICAgICAgICAgdmFyIGNlbGwgID0gc2VsZi5jZWxsc1swXTtcbiAgICAgICAgICAgIHZhciBjZWxsTCA9IHNlbGYuY2VsbHNbMV07XG4gICAgICAgICAgICB2YXIgY2VsbFIgPSBzZWxmLmNlbGxzWzJdO1xuICAgICAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IF8uYXJncztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdFZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltYXggPSBjZWxsTC5sZW5ndGg7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFswXSA9IGNlbGxMW2ldID0gY2VsbFJbaV0gPSBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5lbWl0KFwiZW5kZWRcIiwgXy5hcmdzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyICQgPSBUYXNrTm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIFwiZG9cIjoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5kb051bSA9IHZhbHVlID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogdmFsdWV8MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmRvTnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5pbml0RnVuYyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uaW5pdEZ1bmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQuYmFuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5jb3VudCAgPSAwO1xuICAgICAgICBfLmVtaXQoXCJiYW5nXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgJC53YWl0ID0gZnVuY3Rpb24odGltZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRpbWUgPSB0aW1ldmFsdWUodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lID09PSBcIm51bWJlclwiICYmIHRpbWUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl8uY291bnQgKz0gKHRoaXMuXy5zYW1wbGVyYXRlICogdGltZSAqIDAuMDAxKXwwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgdmFyIGFyZ3MsIGZ1bmM7XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuICAgICAgICAgICAgaWYgKF8uaSA8IF8uaW1heCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChfLmNvdW50IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaiA+PSBfLmptYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrXy5pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uaSA+PSBfLmltYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5uZXh0VGljayhfLm9uZW5kZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5qID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jID0gXy50YXNrW18uaisrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMuY2FsbCh0aGlzLCBfLmksIF8uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy5jb3VudCAtPSBjZWxsLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcInRhc2tcIiwgVGFza05vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG4gICAgdmFyIHRpbWV2YWx1ZSA9IFQudGltZXZhbHVlO1xuXG4gICAgZnVuY3Rpb24gVGltZW91dE5vZGUoX2FyZ3MpIHtcbiAgICAgICAgVC5PYmplY3QuY2FsbCh0aGlzLCAwLCBfYXJncyk7XG4gICAgICAgIGZuLnRpbWVyKHRoaXMpO1xuICAgICAgICBmbi5maXhLUih0aGlzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgdGhpcy5wbGF5YmFja1N0YXRlID0gZm4uRklOSVNIRURfU1RBVEU7XG4gICAgICAgIF8uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICBfLnNhbXBsZXNNYXggPSAwO1xuICAgICAgICBfLnNhbXBsZXMgICAgPSAwO1xuICAgICAgICBfLm9uZW5kZWQgPSBmbi5tYWtlX29uZW5kZWQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5vbmNlKFwiaW5pdFwiLCBvbmluaXQpO1xuICAgICAgICB0aGlzLm9uKFwic3RhcnRcIiwgb25zdGFydCk7XG4gICAgfVxuXG4gICAgZm4uZXh0ZW5kKFRpbWVvdXROb2RlKTtcblxuICAgIHZhciBvbmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl8udGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gMTAwMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb25zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBsYXliYWNrU3RhdGUgPSBmbi5QTEFZSU5HX1NUQVRFO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9uc3RhcnQsIFwidW5yZW1vdmFibGVcIiwge1xuICAgICAgICB2YWx1ZTp0cnVlLCB3cml0YWJsZTpmYWxzZVxuICAgIH0pO1xuXG4gICAgdmFyICQgPSBUaW1lb3V0Tm9kZS5wcm90b3R5cGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcygkLCB7XG4gICAgICAgIHRpbWVvdXQ6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGltZXZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheWJhY2tTdGF0ZSA9IGZuLlBMQVlJTkdfU1RBVEU7XG4gICAgICAgICAgICAgICAgICAgIF8udGltZW91dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfLnNhbXBsZXNNYXggPSAoXy5zYW1wbGVyYXRlICogKHZhbHVlICogMC4wMDEpKXwwO1xuICAgICAgICAgICAgICAgICAgICBfLnNhbXBsZXMgPSBfLnNhbXBsZXNNYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy50aW1lb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50VGltZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkLmJhbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIHRoaXMucGxheWJhY2tTdGF0ZSA9IGZuLlBMQVlJTkdfU1RBVEU7XG4gICAgICAgIF8uc2FtcGxlcyA9IF8uc2FtcGxlc01heDtcbiAgICAgICAgXy5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgIF8uZW1pdChcImJhbmdcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcblxuICAgICAgICBpZiAodGhpcy50aWNrSUQgIT09IHRpY2tJRCkge1xuICAgICAgICAgICAgdGhpcy50aWNrSUQgPSB0aWNrSUQ7XG5cbiAgICAgICAgICAgIGlmIChfLnNhbXBsZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgXy5zYW1wbGVzIC09IGNlbGwubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5zYW1wbGVzIDw9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbWF4ID0gbm9kZXMubGVuZ3RoOyBpIDwgaW1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLmJhbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4ubmV4dFRpY2soXy5vbmVuZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8uY3VycmVudFRpbWUgKz0gZm4uY3VycmVudFRpbWVJbmNyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcInRpbWVvdXRcIiwgVGltZW91dE5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG5cbiAgICBmdW5jdGlvbiBXYXZlU2hhcGVyTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcbiAgICAgICAgZm4uZml4QVIodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fLmN1cnZlID0gbnVsbDtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKFdhdmVTaGFwZXJOb2RlKTtcblxuICAgIHZhciAkID0gV2F2ZVNoYXBlck5vZGUucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoJCwge1xuICAgICAgICBjdXJ2ZToge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChmbi5pc1NpZ25hbEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8uY3VydmUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmN1cnZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkLnByb2Nlc3MgPSBmdW5jdGlvbih0aWNrSUQpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG5cbiAgICAgICAgaWYgKHRoaXMudGlja0lEICE9PSB0aWNrSUQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0lEID0gdGlja0lEO1xuXG4gICAgICAgICAgICBmbi5pbnB1dFNpZ25hbEFSKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoXy5jdXJ2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VydmUgPSBfLmN1cnZlO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gICAgPSBjdXJ2ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHgsIGksIGltYXggPSBfLmNlbGxzaXplO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICgoKGNlbGxbaV0gKyAxKSAqIDAuNSkgKiBsZW4gKyAwLjUpfDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA+PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gbGVuIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjZWxsW2ldID0gY3VydmVbeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbi5vdXRwdXRTaWduYWxBUih0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBmbi5yZWdpc3RlcihcIndhdmVzaGFwZXJcIiwgV2F2ZVNoYXBlck5vZGUpO1xuXG59KSh0aW1icmUpO1xuKGZ1bmN0aW9uKFQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBmbiA9IFQuZm47XG5cbiAgICBmdW5jdGlvbiBaTWFwTm9kZShfYXJncykge1xuICAgICAgICBULk9iamVjdC5jYWxsKHRoaXMsIDEsIF9hcmdzKTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgXy5pbk1pbiAgPSAwO1xuICAgICAgICBfLmluTWF4ICA9IDE7XG4gICAgICAgIF8ub3V0TWluID0gMDtcbiAgICAgICAgXy5vdXRNYXggPSAxO1xuICAgICAgICBfLmFyICAgICA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMub25jZShcImluaXRcIiwgb25pbml0KTtcbiAgICB9XG4gICAgZm4uZXh0ZW5kKFpNYXBOb2RlKTtcblxuICAgIHZhciBvbmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl8ud2FycCkge1xuICAgICAgICAgICAgdGhpcy53YXJwID0gXCJsaW5saW5cIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgJCA9IFpNYXBOb2RlLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCQsIHtcbiAgICAgICAgaW5NaW46IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5pbk1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8uaW5NaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluTWF4OiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8uaW5NYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLmluTWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvdXRNaW46IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXy5vdXRNaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fLm91dE1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3V0TWF4OiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8ub3V0TWF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5vdXRNYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdhcnA6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gV2FycEZ1bmN0aW9uc1t2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8ud2FycCA9IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8ud2FycE5hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8ud2FycE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQucHJvY2VzcyA9IGZ1bmN0aW9uKHRpY2tJRCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWzBdO1xuXG4gICAgICAgIGlmICh0aGlzLnRpY2tJRCAhPT0gdGlja0lEKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tJRCA9IHRpY2tJRDtcblxuICAgICAgICAgICAgdmFyIGluTWluICA9IF8uaW5NaW4sIGluTWF4ICAgPSBfLmluTWF4O1xuICAgICAgICAgICAgdmFyIG91dE1pbiA9IF8ub3V0TWluLCBvdXRNYXggPSBfLm91dE1heDtcbiAgICAgICAgICAgIHZhciB3YXJwICAgPSBfLndhcnA7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBtdWwgPSBfLm11bCwgYWRkID0gXy5hZGQ7XG4gICAgICAgICAgICB2YXIgaSwgaW1heCA9IGNlbGwubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoXy5hciAmJiBsZW4pIHtcbiAgICAgICAgICAgICAgICBmbi5pbnB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFtpXSA9IHdhcnAoY2VsbFtpXSwgaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCkgKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZuLm91dHB1dFNpZ25hbEFSKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSAodGhpcy5ub2Rlcy5sZW5ndGgpID8gZm4uaW5wdXRTaWduYWxLUih0aGlzKSA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gd2FycChpbnB1dCwgaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCkgKiBtdWwgKyBhZGQ7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBXYXJwRnVuY3Rpb25zID0ge1xuICAgICAgICBsaW5saW46IGZ1bmN0aW9uKHgsIGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgpIHtcbiAgICAgICAgICAgIGlmICh4IDwgaW5NaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0TWluO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4ID4gaW5NYXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0TWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluTWF4ID09PSBpbk1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRNaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKHgtaW5NaW4pIC8gKGluTWF4LWluTWluKSAqIChvdXRNYXgtb3V0TWluKSArIG91dE1pbjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZXhwOiBmdW5jdGlvbih4LCBpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4KSB7XG4gICAgICAgICAgICBpZiAoeCA8IGluTWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dE1pbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA+IGluTWF4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dE1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRNaW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbk1heCA9PT0gaW5NaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0TWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KG91dE1heC9vdXRNaW4sICh4LWluTWluKS8oaW5NYXgtaW5NaW4pKSAqIG91dE1pbjtcbiAgICAgICAgfSxcbiAgICAgICAgZXhwbGluOiBmdW5jdGlvbih4LCBpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4KSB7XG4gICAgICAgICAgICBpZiAoeCA8IGluTWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dE1pbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA+IGluTWF4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dE1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbk1pbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRNYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2coeC9pbk1pbikgLyBNYXRoLmxvZyhpbk1heC9pbk1pbikgKiAob3V0TWF4LW91dE1pbikgKyBvdXRNaW47XG4gICAgICAgIH0sXG4gICAgICAgIGV4cGV4cDogZnVuY3Rpb24oeCwgaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCkge1xuICAgICAgICAgICAgaWYgKHggPCBpbk1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRNaW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHggPiBpbk1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRNYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5NaW4gPT09IDAgfHwgb3V0TWluID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3cob3V0TWF4L291dE1pbiwgTWF0aC5sb2coeC9pbk1pbikgLyBNYXRoLmxvZyhpbk1heC9pbk1pbikpICogb3V0TWluO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZuLnJlZ2lzdGVyKFwiem1hcFwiLCBaTWFwTm9kZSk7XG5cbn0pKHRpbWJyZSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiQmFja2JvbmUgXHRcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lLiQgXHRcdFx0XHRcdFx0PSAkID0gcmVxdWlyZSgnanF1ZXJ5JylcbkJhY2tib25lLk5lc3RlZE1vZGVsXHQ9IHJlcXVpcmUoJ2JhY2tib25lLW5lc3RlZCcpLk5lc3RlZE1vZGVsXG5fXHRcdFx0XHRcdFx0XHRcdFx0XHRcdD0gcmVxdWlyZSgndW5kZXJzY29yZScpXG5hc3luYyBcdFx0XHRcdFx0XHRcdFx0PSByZXF1aXJlKCdhc3luYycpXG5Sb3V0ZXIgXHRcdFx0XHRcdFx0XHRcdD0gcmVxdWlyZSgnLi4vcm91dGVzL2FwcCcpXG5QYWRzIFx0XHRcdFx0XHRcdFx0XHRcdD0gcmVxdWlyZSgnLi9wYWRzJylcbkRpc3BsYXkgXHRcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJy4vZGlzcGxheScpXG5UcmFuc3BvcnQgXHRcdFx0XHRcdFx0PSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpXG5TZXF1ZW5jZSAgXHRcdFx0XHRcdFx0PSByZXF1aXJlKCcuL3NlcXVlbmNlJylcblBhdHRlcm5VSVZpZXcgXHRcdFx0XHQ9IHJlcXVpcmUoJy4vcGF0dGVybi51aScpXG5SZWNpcGVNb2RlbCBcdFx0XHRcdFx0PSByZXF1aXJlKCcuLi9tb2RlbHMvcmVjaXBlJylcbkdyb3VwQ29sbGVjdGlvbiBcdFx0XHQ9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL2dyb3VwJylcblxuREVGQVVMVF9LRVlDT0RFUyA9IFsgXG5cdDU0LCA1NSwgNTYsICA1N1xuXHQ4OSwgODUsIDczLCAgNzlcblx0NzIsIDc0LCA3NSwgIDc2XG5cdDc4LCA3NywgMTg4LCAxOTBcbl1cblJFQ09SRF9DSEFSXHRcdFx0PSA4MlxuUExBWVBBVVNFX0NIQVIgXHQ9IDMyXG5BUFBfRUxfU0VMRUNUT1IgPSAnYm9keSdcblxuY2xhc3MgQXBwVmlldyBleHRlbmRzIEJhY2tib25lLlZpZXdcblxuXHRlbDogQVBQX0VMX1NFTEVDVE9SXG5cblx0aW5pdGlhbGl6ZTogKCkgLT5cblx0XHRCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KHB1c2hTdGF0ZTogdHJ1ZSlcblxuXHRcdCMgJChkb2N1bWVudCkuZm91bmRhdGlvbigpXG5cblx0XHRAY3VycmVudCBcdFx0XHRcdFx0PSB7fVxuXHRcdEBrZXlNYXAgXHRcdFx0XHRcdD0ge31cblx0XHRAcmVjaXBlIFx0XHRcdFx0XHQ9IG5ldyBSZWNpcGVNb2RlbCgpXG5cdFx0QHJvdXRlciBcdFx0XHRcdFx0PSBuZXcgUm91dGVyIGFwcDogQFxuXHRcdChAZGlzcGxheSBcdFx0XHRcdD0gbmV3IERpc3BsYXkgYXBwOiBAKS5sb2coJ1BsZWFzZSBXYWl0Li4uJylcblx0XHRAdHJhbnNwb3J0IFx0XHRcdFx0PSBuZXcgVHJhbnNwb3J0IGFwcDogQFxuXHRcdEBwYXR0ZXJuIFx0XHRcdFx0XHQ9IG5ldyBQYXR0ZXJuVUlWaWV3IGFwcDogQFxuXHRcdEBncm91cHMgXHRcdFx0XHRcdD0gbmV3IEdyb3VwQ29sbGVjdGlvbih7cG9zaXRpb246IDF9LCBhcHA6IEApXG5cdFx0QHBhZHMgXHRcdFx0XHRcdFx0PSBuZXcgUGFkcyBhcHA6IEBcblx0XHRAc2VxdWVuY2VcdFx0XHRcdFx0PSBuZXcgU2VxdWVuY2UgYXBwOiBAXG5cdFx0QFVJTW9kZWxcdFx0XHRcdFx0PSBuZXcgKEJhY2tib25lLk5lc3RlZE1vZGVsLmV4dGVuZCgpKVxuXG5cdFx0YXN5bmMuc2VyaWVzIFtcblx0XHRcdChjYWxsYmFjaykgPT5cblx0XHRcdFx0aWYgQHJlY2lwZS5nZXQoJ2lkJylcblx0XHRcdFx0XHRAb3BlbiBAcmVjaXBlLCAoKSA9PlxuXHRcdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJ1ZSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIGZhbHNlKVxuXHRcdF0sIChlcnIsIG9wZW5lZCkgPT5cblx0XHRcdEBfc2VsZWN0R3JvdXBBdCgwKVxuXHRcdFx0QHBhdHRlcm4uX3NlbGVjdFBhdHRlcm5BdCgwKVxuXG5cdFx0QGtleU1hcFtrZXlDb2RlXSA9IGkgZm9yIGtleUNvZGUsIGkgaW4gREVGQVVMVF9LRVlDT0RFU1xuXG5cdFx0QGRpc3BsYXkubG9nICdSZWFkeSdcblxuXHRldmVudHM6XG5cdFx0J2NsaWNrIFtkYXRhLWJlaGF2aW9yXSdcdFx0XHQ6ICdkZWxlZ2F0ZUJlaGF2aW9yJ1xuXHRcdCdrZXlwcmVzcydcdFx0XHRcdFx0XHRcdFx0XHQ6ICdrZXlQcmVzc0RlbGVnYXRlJ1xuXHRcdCdrZXlkb3duJ1x0XHRcdFx0XHRcdFx0XHRcdFx0OiAna2V5RG93bkRlbGVnYXRlJ1xuXHRcdCdrZXl1cCdcdFx0XHRcdFx0XHRcdFx0XHRcdFx0OiAna2V5VXBEZWxlZ2F0ZSdcblxuXHRkZWxlZ2F0ZUJlaGF2aW9yOiAoZSkgLT5cblx0XHRiZWhhdmlvciA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhICdiZWhhdmlvcidcblx0XHRtZXRhID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEgJ21ldGEnXG5cdFx0aWYgYmVoYXZpb3I/IGFuZCBfLmlzRnVuY3Rpb24gQFtiZWhhdmlvcl1cblx0XHRcdEBbYmVoYXZpb3JdLmNhbGwoQCwgZSwgbWV0YSlcblxuXHRzZWxlY3RHcm91cDogKGUsIG51bWJlcikgLT5cblx0XHRAX3NlbGVjdEdyb3VwKG51bWJlcilcblxuXHRfc2VsZWN0R3JvdXBBdDogKGlkeCkgLT5cblx0XHRAX3NlbGVjdEdyb3VwKEBncm91cHMuYXQoMCkuZ2V0KCdwb3NpdGlvbicpKVxuXG5cdF9zZWxlY3RHcm91cDogKGdyb3VwTnVtYmVyKSAtPlxuXHRcdEBjdXJyZW50Lmdyb3VwID0gQGdyb3Vwcy5maW5kV2hlcmUocG9zaXRpb246IGdyb3VwTnVtYmVyKVxuXHRcdEBwYWRzLnJlbmRlcihncm91cE51bWJlcilcblxuXHRvcGVuOiAocmVjaXBlLCBjYWxsYmFjaykgLT5cblx0XHRfdGhpcyA9IHRoaXNcblx0XHRAZGlzcGxheS5sb2coXCJMb2FkaW5nICN7QHJlY2lwZS5nZXQoJ25hbWUnKX0uLi5cIik7XG5cdFx0QGdyb3Vwcy5mZXRjaFJlY3Vyc2l2ZSBALCBAcmVjaXBlLCAoZXJyLCBmZXRjaGVkKSA9PlxuXHRcdFx0IyBAcGFkcy5ib290c3RyYXBHcm91cFBhZHMoQGdyb3Vwcy5hdCgwKSlcblx0XHRcdGNhbGxiYWNrLmNhbGwoQClcblx0XHRcdEBkaXNwbGF5LmxvZyBcIlJlY2lwZSBcXFwiI3tAcmVjaXBlLmdldCgnbmFtZScpfVxcXCIgTG9hZGVkXCJcblxuXHRzYXZlOiAoZSkgLT5cblx0XHRfdGhpcyA9IEBcblx0XHRhc3luYy53YXRlcmZhbGwgW1xuXHRcdFx0KHJlY2lwZVNhdmVkQ2FsbGJhY2spID0+XG5cdFx0XHRcdEByZWNpcGUuc2F2ZSh7fSwge1xuXHRcdFx0XHRcdHN1Y2Nlc3M6IChzYXZlZFJlY2lwZSkgPT5cblx0XHRcdFx0XHRcdGFzeW5jLmVhY2ggQGdyb3Vwcy5tb2RlbHMsIChncm91cCwgZWFjaEdyb3VwU2F2ZWRDYWxsYmFjaykgLT5cblx0XHRcdFx0XHRcdFx0Z3JvdXAuc2F2ZSh7cmVjaXBlX2lkOiBzYXZlZFJlY2lwZS5pZH0sIHtcblx0XHRcdFx0XHRcdFx0XHRzdWNjZXNzOiAoc2F2ZWRHcm91cCkgPT5cblx0XHRcdFx0XHRcdFx0XHRcdGFzeW5jLnBhcmFsbGVsIFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0KGNiU291bmQpIC0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXN5bmMuZWFjaCBncm91cC5zb3VuZHMubW9kZWxzLCAoc291bmQsIGVhY2hTb3VuZFNhdmVkQ2FsbGJhY2spIC0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzb3VuZC5zYXZlKHtncm91cElkOiBncm91cC5pZH0sIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3VjY2VzczogKHNhdmVkU291bmQpIC0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZWFjaFNvdW5kU2F2ZWRDYWxsYmFjayhudWxsLCBzYXZlZFNvdW5kKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogKGVycikgLT5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlYWNoU291bmRTYXZlZENhbGxiYWNrKGVycilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LCAoZXJyKSAtPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2JTb3VuZChlcnIpIGlmIGVyclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2JTb3VuZChudWxsKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQsIChjYlBhdHRlcm4pIC0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXN5bmMuZWFjaCBncm91cC5wYXR0ZXJucy5tb2RlbHMsIChwYXR0ZXJuLCBlYWNoUGF0dGVyblNhdmVkQ2FsbGJhY2spIC0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuLnNhdmUoe2dyb3VwSWQ6IGdyb3VwLmlkfSwge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdWNjZXNzOiAoc2F2ZWRQYXR0ZXJuKSAtPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVhY2hQYXR0ZXJuU2F2ZWRDYWxsYmFjayhudWxsLCBzYXZlZFBhdHRlcm4pXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiAoZXJyKSAtPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVhY2hQYXR0ZXJuU2F2ZWRDYWxsYmFjayhlcnIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCwgKGVycikgLT5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNiUGF0dGVybihlcnIpIGlmIGVyclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2JQYXR0ZXJuKG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0XHRdLCAoZXJyKSAtPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlYWNoR3JvdXBTYXZlZENhbGxiYWNrKGVycikgaWYgZXJyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVhY2hHcm91cFNhdmVkQ2FsbGJhY2sobnVsbClcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdCwgKGVycikgLT5cblx0XHRcdFx0XHRcdFx0cmVjaXBlU2F2ZWRDYWxsYmFjayhudWxsKVxuXHRcdFx0XHRcdGVycm9yOiAoZXJyKSAtPlxuXHRcdFx0XHRcdFx0cmVjaXBlU2F2ZWRDYWxsYmFjayhlcnIpXG5cdFx0XHRcdH0pXG5cdFx0XSwgKGVyciwgcmVzdWx0cykgPT5cblx0XHRcdHRocm93IG5ldyBFcnJvcihlcnIpIGlmIGVyclxuXHRcdFx0QHJvdXRlci5uYXZpZ2F0ZShcInJlY2lwZS8je0ByZWNpcGUuZ2V0KCdpZCcpfVwiLCB7c2lsZW50OiB0cnVlfSlcblx0XHRcdEBkaXNwbGF5LmxvZyBcIlJlY2lwZSBcXFwiI3tAcmVjaXBlLmdldCgnbmFtZScpfVxcXCIgU2F2ZWRcIlxuXG5cdHRvSlNPTjogKGUpIC0+XG5cdFx0cmVjaXBlID0gQHJlY2lwZS50b0pTT04oKVxuXHRcdHJlY2lwZS5ncm91cHMgPSBbXVxuXHRcdEBncm91cHMuZWFjaCAoZ3JvdXApID0+XG5cdFx0XHRncm91cEF0dHJpYnV0ZXMgPSBncm91cC50b0pTT04oKVxuXHRcdFx0Z3JvdXBBdHRyaWJ1dGVzLnNvdW5kcyA9IFtdXG5cdFx0XHRncm91cC5zb3VuZHMuZWFjaCAoc291bmQpID0+XG5cdFx0XHRcdGdyb3VwQXR0cmlidXRlcy5zb3VuZHMucHVzaChzb3VuZC50b0pTT04oKSlcblx0XHRcdGdyb3VwQXR0cmlidXRlcy5wYXR0ZXJucyA9IFtdXG5cdFx0XHRncm91cC5wYXR0ZXJucy5lYWNoIChwYXR0ZXJuKSA9PlxuXHRcdFx0XHRncm91cEF0dHJpYnV0ZXMucGF0dGVybnMucHVzaChwYXR0ZXJuLnRvSlNPTigpKVxuXHRcdFx0cmVjaXBlLmdyb3Vwcy5wdXNoKGdyb3VwQXR0cmlidXRlcylcblx0XHRjb25zb2xlLmxvZyhyZWNpcGUpXG5cblx0a2V5RG93bkRlbGVnYXRlOiAoZSkgLT5cblx0XHRjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUpXG5cblx0XHRpZiBjaGFyIGlzIFJFQ09SRF9DSEFSIGFuZCBlLmN0cmxLZXlcblx0XHRcdEB0cmFuc3BvcnQucmVjb3JkKClcblx0XHRcdHByZXZlbnQgPSB0cnVlXG5cdFx0ZWxzZSBpZiBjaGFyIGlzIFBMQVlQQVVTRV9DSEFSXG5cdFx0XHRAdHJhbnNwb3J0LnBsYXkoKVxuXHRcdFx0cHJldmVudCA9IHRydWVcblx0XHRlbHNlIGlmIF8uaW5kZXhPZihbMSwgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCddLCBjaGFyKSA+IDAgYW5kIGUuY3RybEtleVxuXHRcdFx0cHJldmVudCA9IHRydWVcblx0XHRcdEBwYWRzLnJlbmRlciBjaGFyXG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCkgaWYgcHJldmVudFxuXG5cdGtleVByZXNzRGVsZWdhdGU6IChlKSAtPlxuXHRcdGlmIEBrZXlNYXBbZS53aGljaF0/XG5cdFx0XHRAcHJlc3NpbmcgPSBlLndoaWNoXG5cdFx0XHQjICBsZWZ0IG9mZiBoZXJlIHRyeWluZyB0byBsaXN0ZW4gdG8gcHJlc3MgZXZlbnQgZnJvbSBwYXR0ZXJuIGFuZCBtYXRjaCB0byBwYWRzIHZpZXdcblx0XHRcdHBhZCA9IEBjdXJyZW50LnBhZHNbQGtleU1hcFtlLndoaWNoXV0/LnRyaWdnZXIoJ3ByZXNzJylcblxuXHRrZXlVcERlbGVnYXRlOiAoZSkgLT5cblx0XHRwYWQgPSBAY3VycmVudC5wYWRzW0BrZXlNYXBbZS53aGljaF1dPy50cmlnZ2VyKCdyZWxlYXNlJykgaWYgZS53aGljaCBpcyBAcHJlc3NpbmdcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQXBwVmlldygpXG4iLCJCYWNrYm9uZSBcdFx0XHRcdFx0PSByZXF1aXJlKCdiYWNrYm9uZScpXG5CYWNrYm9uZS4kIFx0XHRcdFx0PSByZXF1aXJlKCdqcXVlcnknKVxuTGlnYW1lbnQgXHRcdFx0XHRcdD0gcmVxdWlyZSgnYmFja2JvbmUtbGlnYW1lbnRzJylcbl9cdFx0XHRcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuRGlzcGxheU1vZGVsIFx0XHRcdD0gcmVxdWlyZSgnLi4vbW9kZWxzL2Rpc3BsYXknKVxuZGlzcGxheVRlbXBsYXRlIFx0PSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvZGlzcGxheS50cGwnKVxuXG5jbGFzcyBEaXNwbGF5VmlldyBleHRlbmRzIEJhY2tib25lLlZpZXdcblxuXHRlbDogJy5kaXNwbGF5J1xuXG5cdHRlbXBsYXRlOiBkaXNwbGF5VGVtcGxhdGVcblxuXHRpbml0aWFsaXplOiAob3B0aW9ucykgLT5cblx0XHR7IEBhcHAgfSA9IG9wdGlvbnNcblx0XHRAbW9kZWwgPSBuZXcgRGlzcGxheU1vZGVsKClcblx0XHRAcmVuZGVyKClcblx0XHRAJGNhbnZhcyA9IHRoaXMuJCgnI3dhdmVmb3JtJylcblx0XHRuZXcgTGlnYW1lbnQobW9kZWw6IEBtb2RlbCwgdmlldzogQClcblxuXHRsb2c6IChvcHRpb25zKSAtPlxuXHRcdGlmIHR5cGVvZiBvcHRpb25zIGlzICdzdHJpbmcnXG5cdFx0XHRtZXNzYWdlID0gb3B0aW9uc1xuXHRcdGVsc2Vcblx0XHRcdG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2Vcblx0XHRAbW9kZWwuc2V0KCdvbmUnLCBtZXNzYWdlKVxuXHRcdEByZW5kZXIoKVxuXG5cdHJlbmRlcjogKCkgLT5cblx0XHRAZWwuaW5uZXJIVE1MID0gQHRlbXBsYXRlKEBtb2RlbC50b0pTT04oKSlcblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwbGF5VmlldyIsIkJhY2tib25lICAgICAgICA9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lLiQgICAgICA9IHJlcXVpcmUoJy4uL3ZlbmRvci9qcXVlcnktYm9vdHN0cmFwLmpzJylcbkxpZ2FtZW50ICAgICAgICA9IHJlcXVpcmUoJ2JhY2tib25lLWxpZ2FtZW50cycpXG5cbl8gICAgICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuRGlzcGxheSAgICAgICAgID0gcmVxdWlyZSgnLi9kaXNwbGF5JylcbmVkaXRvclRlbXBsYXRlICA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9lZGl0b3IudHBsJylcblxuXG5PUkFOR0UgPSAnI2YwOGEyNCdcblxuY2xhc3MgRWRpdG9yVmlldyBleHRlbmRzIEJhY2tib25lLlZpZXdcblxuICB0ZW1wbGF0ZTogZWRpdG9yVGVtcGxhdGVcblxuICBhdHRyaWJ1dGVzOlxuICAgICdjbGFzcycgICAgICAgICA6ICdtb2RhbCBmYWRlJ1xuXG4gIGluaXRpYWxpemU6IChvcHRpb25zKSAtPlxuICAgIEB2aWV3VmFycyA9IHt9XG4gICAgeyBAbW9kZWwsIEBwYWQgfSA9IG9wdGlvbnNcblxuICAgIF8uYmluZEFsbCBALCAnZHJhd0NhbnZhcydcbiAgICBcbiAgICBAcmVuZGVyKClcblxuICAgIEBsaWdhbWVudCA9IG5ldyBMaWdhbWVudChtb2RlbDogQG1vZGVsLCB2aWV3OiBAKVxuICAgIEBsaXN0ZW5UbyBAbW9kZWwsICdjaGFuZ2UnLCBAZHJhd0NhbnZhc1xuXG4gIGV2ZW50czpcbiAgICAnY2xpY2sgW2RhdGEtYmVoYXZpb3JdJyAgICAgICA6ICdkZWxlZ2F0ZUJlaGF2aW9yJ1xuICAgICdjbGljayBjYW52YXMnICAgICAgICAgICAgICAgIDogJ3BsYXknXG4gICAgJ2NoYW5nZSBpbnB1dC5lcScgICAgICAgICAgICAgOiAnZXEnXG5cbiAgZGVsZWdhdGVCZWhhdmlvcjogKGUpIC0+XG4gICAgYmVoYXZpb3IgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSAnYmVoYXZpb3InXG4gICAgaWYgYmVoYXZpb3I/IGFuZCBfLmlzRnVuY3Rpb24gdGhpc1tiZWhhdmlvcl1cbiAgICAgIHRoaXNbYmVoYXZpb3JdLmNhbGwgdGhpcywgZVxuXG4gIHNhdmU6IChlKSAtPlxuICAgIEBwYWQubW9kZWwuc2F2ZSgpXG5cbiAgZXE6IChlKSAtPlxuICAgIHBhcmFtID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1wYXJhbScpXG4gICAgZnJlcSA9IEBtb2RlbC5nZXQoJ2Z4LmVxLnBhcmFtcy4nK3BhcmFtKVxuICAgIGZyZXFbMl0gPSBwYXJzZUludCgkKGUuY3VycmVudFRhcmdldCkudmFsKCksIDEwKVxuICAgIEBtb2RlbC5zZXQoJ2Z4LmVxLnBhcmFtcy4nK3BhcmFtLCBmcmVxKVxuICAgIGNvbnNvbGUubG9nKGZyZXEpXG5cbiAgdGFiOiAoZSkgLT5cbiAgICB0YWJDbGFzcyA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhICd0YWInXG4gICAgJChlLmN1cnJlbnRUYXJnZXQpLmFkZENsYXNzKCdhY3RpdmUnKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgIHRoaXMuJCgnLnRhYi1wYW5lJykuaGlkZSgpXG4gICAgdGhpcy4kKCcudGFiLXBhbmUnK3RhYkNsYXNzKS5zaG93KClcblxuICB0b2dnbGVFZmZlY3Q6IChlKSAtPlxuICAgIGVmZmVjdCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdlZmZlY3QnKVxuICAgIGlmIG5vdCBAbW9kZWwuZ2V0IFwiZnguI3tlZmZlY3R9XCJcbiAgICAgIEB2aWV3VmFycy5zaG93ID0gZWZmZWN0XG4gICAgICBAYWRkRWZmZWN0IGVmZmVjdFxuICAgIGVsc2VcbiAgICAgIGRlbGV0ZSBAdmlld1ZhcnMuc2hvd1xuICAgICAgQHJlbW92ZUVmZmVjdCBlZmZlY3RcblxuICBhZGRFZmZlY3Q6IChlZmZlY3QpIC0+XG4gICAgc3dpdGNoIGVmZmVjdFxuICAgICAgd2hlbiAncmV2ZXJiJ1xuICAgICAgICBmeCA9XG4gICAgICAgICAgcm9vbSAgICAgIDogMFxuICAgICAgICAgIGRhbXAgICAgICA6IDBcbiAgICAgICAgICBtaXggICAgICAgOiAwLjVcbiAgICAgIHdoZW4gJ2RlbGF5J1xuICAgICAgICBmeCA9XG4gICAgICAgICAgdGltZSAgICAgIDogMTAwXG4gICAgICAgICAgZmIgICAgICAgIDogMC4yXG4gICAgICAgICAgbWl4ICAgICAgIDogMC4zM1xuICAgICAgd2hlbiAnY2hvcnVzJ1xuICAgICAgICBmeCA9XG4gICAgICAgICAgdHlwZSAgICAgIDogJ3NpbicgICAjIG9yICd0cmknXG4gICAgICAgICAgZGVsYXkgICAgIDogMjAgICAgICAjIDAuNSAuLi4gODBcbiAgICAgICAgICByYXRlICAgICAgOiA0ICAgICAgICMgMCAuLi4gMTBcbiAgICAgICAgICBkZXB0aCAgICAgOiAyMCAgICAgICMgMCAuLi4gMTAwXG4gICAgICAgICAgZmIgICAgICAgIDogMC4yICAgICAjIC0xIC4uLiAxXG4gICAgICAgICAgd2V0ICAgICAgIDogMC4zMyAgICAjIDAgLi4uIDFcblxuICAgIEBtb2RlbC5zZXQgXCJmeC4je2VmZmVjdH1cIiwgZnhcblxuICAgIEBkcmF3Q2FudmFzKClcblxuICByZW1vdmVFZmZlY3Q6IChlZmZlY3QpIC0+XG4gICAgQG1vZGVsLnVuc2V0IFwiZnguI3tlZmZlY3R9XCJcbiAgICBAZHJhd0NhbnZhcygpXG5cbiAgcGxheTogKGUpIC0+XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgQHBhZC50cmlnZ2VyKCdwcmVzcycpXG5cbiAgc2hvdzogKCkgLT5cbiAgICBAZHJhd0NhbnZhcygpXG4gICAgQCRlbC5tb2RhbCAnc2hvdydcblxuICBoaWRlOiAoKSAtPlxuICAgIEAkZWwubW9kYWwgJ2hpZGUnXG5cbiAgcmVuZGVyOiAoKSAtPlxuICAgIEBlbC5pbm5lckhUTUwgPSBAdGVtcGxhdGUoXG4gICAgICBkYXRhOiBAbW9kZWwudG9KU09OKClcbiAgICAgIHZpZXc6IEB2aWV3VmFyc1xuICAgIClcbiAgICBAZHJhd0NhbnZhcygpXG4gICAgXG4gIGRyYXdDYW52YXM6ICgpIC0+XG4gICAgQCRjYW52YXMgPSB0aGlzLiQoJy53YXZlZm9ybScpIHVubGVzcyBAJGNhbnZhc1xuICAgIHJlbmRlck9wdGlvbnMgPSB7XG4gICAgICB3aWR0aDogNTU4XG4gICAgICBoZWlnaHQ6IDEwMFxuICAgICAgdGFyZ2V0OiBAJGNhbnZhcy5nZXQoMClcbiAgICAgIGxpbmVXaWR0aDogMC41XG4gICAgICBiYWNrZ3JvdW5kOiAnIzIyMidcbiAgICAgIGZvcmVncm91bmQ6IE9SQU5HRVxuICAgIH1cbiAgICBpZiBAcGFkLm1vZGVsPy5UPy5yZW5kZXJlZD9cbiAgICAgIEBwYWQubW9kZWwuVC5yZW5kZXJlZC5wbG90KHJlbmRlck9wdGlvbnMpXG4gICAgZWxzZSBpZiBAcGFkLm1vZGVsPy5UPy5yYXc/XG4gICAgICBAcGFkLm1vZGVsLlQucmF3LnBsb3QocmVuZGVyT3B0aW9ucylcblxubW9kdWxlLmV4cG9ydHMgPSBFZGl0b3JWaWV3IiwiQmFja2JvbmUgICAgID0gcmVxdWlyZSgnYmFja2JvbmUnKVxuQmFja2JvbmUuJCAgID0gcmVxdWlyZSgnanF1ZXJ5JylcbkxpZ2FtZW50ICAgICA9IHJlcXVpcmUoJ2JhY2tib25lLWxpZ2FtZW50cycpXG5fICAgICAgICAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJylcblNvdW5kTW9kZWwgICA9IHJlcXVpcmUoJy4uL21vZGVscy9zb3VuZCcpXG5Tb3VuZEVkaXRvciAgPSByZXF1aXJlKCcuL2VkaXRvcicpXG5wYWRUZW1wbGF0ZSAgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcGFkLnRwbCcpXG5cbmNsYXNzIFBhZFZpZXcgZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XG5cbiAgQFBBRF9DTEFTU0VTICA9ICdzbWFsbC0zIGNvbHVtbnMgcGFkLWNvbnRhaW5lcidcbiAgQFBBRF9SRUxFQVNFX1RJTUVPVVRfTVMgID0gNTBcblxuICBhdHRyaWJ1dGVzOlxuICAgIGNsYXNzOiBAUEFEX0NMQVNTRVNcblxuICB0ZW1wbGF0ZTogcGFkVGVtcGxhdGVcblxuICBpbml0aWFsaXplOiAob3B0aW9ucykgLT5cbiAgICB7IEBwYXJlbnQsIEBuYW1lLCBAbnVtYmVyIH0gPSBvcHRpb25zXG5cbiAgICBfLmJpbmRBbGwoQCwgJ2xpc3RlblRvTW9kZWxFdmVudHMnLCAncHJlc3MnKVxuXG4gICAgQG9uICdwcmVzcycsIEBwcmVzc1xuXG4gICAgQHJlbmRlcigpXG5cbiAgZXZlbnRzOlxuICAgICdjb250ZXh0bWVudSAucGFkJyAgICA6ICdlZGl0J1xuICAgICdtb3VzZWRvd24gLnBhZCcgICAgICA6ICdwcmVzcydcbiAgICAnbW91c2V1cCAucGFkJyAgICAgICAgOiAncmVsZWFzZSdcbiAgICAnZHJhZ292ZXInICAgICAgICAgICAgOiAncHJldmVudCdcbiAgICAnZHJhZ2VudGVyJyAgICAgICAgICAgOiAncHJldmVudCdcbiAgICAnZHJvcCcgICAgICAgICAgICAgICAgOiAndXBsb2FkU291bmQnXG5cbiAgbGlzdGVuVG9Nb2RlbEV2ZW50czogKCkgLT5cbiAgICBAc3RvcExpc3RlbmluZyBAbW9kZWwsICdwcmVzcydcbiAgICBAbGlzdGVuVG8gQG1vZGVsLCAncHJlc3MnLCBAcHJlc3NcblxuICAgIEBzdG9wTGlzdGVuaW5nIEBtb2RlbCwgJ2xvYWRlZCdcbiAgICBAbGlzdGVuVG8gQG1vZGVsLCAnbG9hZGVkJywgKCkgPT5cbiAgICAgIEAkKCcucGFkJykuYWRkQ2xhc3MoJ21hcHBlZCcpXG4gICAgICBAcGFyZW50LmFwcC5kaXNwbGF5LmxvZygoQG1vZGVsLmdldCgnbmFtZScpIHx8IEBuYW1lKSArICcgbG9hZGVkJylcblxuXG4gIGJvb3RzdHJhcFdpdGhNb2RlbDogKHNvdW5kTW9kZWwpIC0+XG4gICAgaWYgbm90IHNvdW5kTW9kZWwgYW5kIG5vdCBzb3VuZE1vZGVsIGluc3RhbmNlb2YgU291bmRNb2RlbFxuICAgICAgdGhyb3cgbmV3IEVycm9yICdNdXN0IHByb3ZpZGUgYSBTb3VuZE1vZGVsIGluc3RhbmNlIHdoZW4gbWFwcGluZyBhIHBhZC4nXG5cbiAgICAoQG1vZGVsID0gc291bmRNb2RlbCkucGFkID0gQFxuXG4gICAgQGxpc3RlblRvTW9kZWxFdmVudHMoKVxuXG4gICAgaWYgKGtleUNvZGUgPSBAbW9kZWwuZ2V0KCdrZXlDb2RlJykpXG4gICAgICBAbW9kZWwuc2V0ICdrZXknLCBrZXlDb2RlXG5cbiAgICBAbGlnYW1lbnQgPSBuZXcgTGlnYW1lbnQobW9kZWw6IEBtb2RlbCwgdmlldzogQClcblxuICBwcmV2ZW50OiAoZSkgLT5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgcHJlc3M6IChlID0ge30pIC0+XG4gICAgcmV0dXJuIHRydWUgaWYgZT8gYW5kIGUuYnV0dG9uIGlzIDJcbiAgICBAJCgnLnBhZCcpLmFkZENsYXNzICdhY3RpdmUnXG5cbiAgICAjIGlmIGUub3JpZ2luYWxFdmVudCBhbmQgZS5vcmlnaW5hbEV2ZW50IG5vdCBpbnN0YW5jZW9mIE1vdXNlRXZlbnRcbiAgICBzZXRUaW1lb3V0ID0+XG4gICAgICBAJCgnLnBhZCcpLnJlbW92ZUNsYXNzICdhY3RpdmUnXG4gICAgLCBAUEFEX1JFTEVBU0VfVElNRU9VVF9NU1xuXG4gICAgaWYgQG1vZGVsPy5sb2FkZWRcbiAgICAgIEBwYXJlbnQudHJpZ2dlcigncHJlc3MnLCBAKSBpZiBub3QgZS5zaWxlbnRcbiAgICAgIEBtb2RlbC5wbGF5KClcblxuICByZWxlYXNlOiAoZSkgLT5cbiAgICAjIEAkKCcucGFkJykucmVtb3ZlQ2xhc3MgJ2FjdGl2ZSdcblxuICAjIyNcbiAgICMgY3JlYXRlcyBhIG5ldyBtb2RlbCBpZiBvbmUgZG9lc24ndCBleGlzdCBmb3IgdGhpcyBwYWRcbiAgICMgQWRkcyBpdHNlbGYgdG8gdGhlIGN1cnJlbnQgZ3JvdXAncyBTb3VuZENvbGxlY3Rpb25cbiAgIyMjXG4gIGNyZWF0ZU9yRmluZE1vZGVsOiAoYXR0cnMgPSB7fSkgLT5cbiAgICB1bmxlc3MgKEBtb2RlbCA9IEBwYXJlbnQuYXBwLmdyb3Vwcy5maW5kV2hlcmUocG9zaXRpb246IEBncm91cE51bWJlcikuc291bmRzLmZpbmRXaGVyZShwYWQ6IEBudW1iZXIpKVxuICAgICAgQG1vZGVsID0gbmV3IFNvdW5kTW9kZWwgXy5leHRlbmQgcGFkOiBAJGVsLmluZGV4KCkgKyAxLCBhdHRyc1xuICAgICAgQHBhcmVudC5hcHAuY3VycmVudC5ncm91cC5zb3VuZHMuYWRkIEBtb2RlbFxuICAgICAgQGJvb3RzdHJhcFdpdGhNb2RlbChAbW9kZWwpXG4gICAgQG1vZGVsXG5cbiAgdXBsb2FkU291bmQ6IChlKSAtPlxuICAgIGUgPSBlLm9yaWdpbmFsRXZlbnRcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBAY3JlYXRlT3JGaW5kTW9kZWwoKSB1bmxlc3MgQG1vZGVsXG5cbiAgICBvYmplY3RVcmwgPSB3aW5kb3cuVVJMPy5jcmVhdGVPYmplY3RVUkw/KGUuZGF0YVRyYW5zZmVyPy5maWxlcz9bMF0pXG5cbiAgICBAc2VuZEZpbGUgZS5kYXRhVHJhbnNmZXIuZmlsZXNbMF0sIChtb2RlbCwgYXR0cnMpID0+XG4gICAgICBkZWJ1Z2dlclxuICAgICAgdW5sZXNzIG9iamVjdFVybFxuICAgICAgICBtb2RlbC5zZXQoJ3NyYycsIG1vZGVsLnVybCgpKVxuXG4gICAgaWYgb2JqZWN0VXJsXG4gICAgICBAbW9kZWwuc2V0KCdzcmMnLCBvYmplY3RVcmwpXG4gICAgICBAcGFyZW50LmFwcC5kaXNwbGF5LmxvZyhcIkZpbGU6ICN7ZS5kYXRhVHJhbnNmZXIuZmlsZXNbMF0ubmFtZX0gc2V0IG9uIHBhZCAje0BuYW1lfVwiKVxuICAgIGVsc2VcbiAgICAgIEBwYXJlbnQuYXBwLmRpc3BsYXkubG9nKFwiVXBsb2FkaW5nOiAje2UuZGF0YVRyYW5zZmVyLmZpbGVzWzBdLm5hbWV9XCIpXG5cbiAgc2VuZEZpbGU6IChmaWxlLCBjYikgLT5cbiAgICBAZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgIEB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgIEB4aHIub3BlbiAnUE9TVCcsICcvc291bmRzJywgdHJ1ZVxuICAgIEBmb3JtRGF0YS5hcHBlbmQgJ3NvdW5kJywgZmlsZVxuICAgIEB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSAoZSkgPT5cbiAgICAgIGlmIGUubGVuZ3RoQ29tcHV0YWJsZVxuICAgICAgICBjb21wbGV0ZWQgPSAoZS5sb2FkZWQgLyBlLnRvdGFsKSAqIDEwMFxuICAgICAgICBAJCgnLnByb2dyZXNzLWJhcicpLmNzcyh3aWR0aDogXCIje2NvbXBsZXRlZC50b0ZpeGVkKDApfSVcIilcbiAgICBAeGhyLm9uZXJyb3IgPSAoZSkgPT5cbiAgICAgIEBwYXJlbnQuYXBwLmRpc3BsYXkubG9nKFwiVXBsb2FkIGZhaWxlZFwiKVxuICAgIEB4aHIub25sb2FkID0gKGUpID0+XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShlLnRhcmdldC5yZXNwb25zZVRleHQpXG4gICAgICBkZWJ1Z2dlclxuICAgICAgQG1vZGVsLnNldChkYXRhKVxuICAgICAgQHBhcmVudC5hcHAuZGlzcGxheS5sb2coXCJVcGxvYWQgQ29tcGxldGVkOiAje2RhdGEuZmlsZW5hbWV9XCIpXG4gICAgICBjYiBhbmQgY2IoQG1vZGVsLCBkYXRhKVxuICAgICAgdHJ5XG4gICAgICAgIFxuICAgICAgY2F0Y2ggZVxuICAgICAgICBAcGFyZW50LmFwcC5kaXNwbGF5LmxvZyhcIlVwbG9hZCBmYWlsZWRcIilcbiAgICAgICAgYWxlcnQoXCJBbiBlcnJvciBvY2N1cnJlZCAje2UubWVzc2FnZX0gd2l0aCByZXNwb25zZSAje2UucmVzcG9uc2VUZXh0fVwiKVxuICAgIEB4aHIuc2VuZChAZm9ybURhdGEpXG4gICAgZGVsZXRlIEB4aHJcbiAgICBkZWxldGUgQGZvcm1EYXRhXG5cbiAgZWRpdDogKGUpIC0+XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgaWYgbm90IEBlZGl0b3JcbiAgICAgIEBlZGl0b3IgPSBuZXcgU291bmRFZGl0b3IoXG4gICAgICAgIG1vZGVsOiBAbW9kZWwgb3IgQGNyZWF0ZU9yRmluZE1vZGVsKClcbiAgICAgICAgcGFkOiB0aGlzXG4gICAgICApXG4gICAgQGVkaXRvci5zaG93KClcblxuICByZW5kZXI6ICgpIC0+XG4gICAgQGVsLmlubmVySFRNTCA9IEB0ZW1wbGF0ZShuYW1lOiBAbmFtZSlcblxubW9kdWxlLmV4cG9ydHMgPSBQYWRWaWV3IiwiQmFja2JvbmUgICAgICA9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lLiQgICAgPSByZXF1aXJlKCdqcXVlcnknKVxuXyAgICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuUGFkVmlldyAgICAgICA9IHJlcXVpcmUoJy4vcGFkJylcbnBhZHNUZW1wbGF0ZSAgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcGFkLnRwbCcpXG5cblBBRExBQkVMX1BSRUZJWCAgICAgPSAnYydcblxuY2xhc3MgUGFkc1ZpZXcgZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XG5cbiAgZWw6ICcucGFkcydcblxuICB0ZW1wbGF0ZTogcGFkc1RlbXBsYXRlXG5cbiAgY29sb3JNYXA6IFxuICAgICcxJzogJyNBREQ1RkYnXG4gICAgJzInOiAnI0ZGOEQ4RCdcbiAgICAnMyc6ICcjQkJCQkQ0J1xuICAgICc0JzogJyNFQkVDRjInXG4gICAgJzUnOiAnI0ZGRTk3RidcblxuICBpbml0aWFsaXplOiAob3B0aW9ucykgLT5cbiAgICB7IEBhcHAgfSA9IG9wdGlvbnNcbiAgICBAY3JlYXRlUGFkcygpXG4gICAgIyBAYm9vdHN0cmFwR3JvdXBQYWRzKEBhcHAuY3VycmVudC5ncm91cClcbiAgICBAcmVuZGVyKClcblxuICAgIEBsaXN0ZW5UbyBAYXBwLmdyb3VwcywgJ2ZldGNoJywgKGNvbGxlY3Rpb24pID0+XG4gICAgICBjb2xsZWN0aW9uLmVhY2ggKG1vZGVsKSA9PiBcbiAgICAgICAgQGJvb3RzdHJhcEdyb3VwUGFkcyhtb2RlbClcbiAgICAgIEByZW5kZXIoKVxuXG4gICAgQGxpc3RlblRvIEBhcHAuZ3JvdXBzLCAnYWRkJywgKG1vZGVsKSA9PlxuICAgICAgQGJvb3RzdHJhcEdyb3VwUGFkcyhtb2RlbClcblxuICBjcmVhdGVQYWRzOiAoKSAtPlxuICAgIEBwYWRzID0gW11cbiAgICB6ID0gMFxuICAgIGZvciBpIGluIFsxLi4xMjhdXG4gICAgICBvcHRpb25zID0gXG4gICAgICAgIG5hbWU6IFwiI3tQQURMQUJFTF9QUkVGSVggKyAoaSAtIHogKiAxNil9XCJcbiAgICAgICAgcGFyZW50OiBAXG4gICAgICAgIG51bWJlcjogKGkgLSB6ICogMTYpXG4gICAgICBAcGFkcy5wdXNoIChwYWRWaWV3ID0gbmV3IFBhZFZpZXcob3B0aW9ucykpXG4gICAgICBwYWRWaWV3Lmdyb3VwTnVtYmVyID0geiArIDFcbiAgICAgIHorKyBpZiBpICUgMTYgaXMgMFxuXG4gIGJvb3RzdHJhcEdyb3VwUGFkczogKGdyb3VwKSAtPlxuICAgIHBvcyA9IGlmIGdyb3VwLmdldCgncG9zaXRpb24nKSAtIDEgPiAtMSB0aGVuIGdyb3VwLmdldCgncG9zaXRpb24nKSAtIDEgZWxzZSAwXG4gICAgcGFkcyA9IEBwYWRzLnNsaWNlKHBvcyAqIDE2LCBwb3MgKiAxNiArIDE2KVxuXG4gICAgcGFkLmJvb3RzdHJhcFdpdGhNb2RlbCBncm91cC5zb3VuZHMuYXQoaSkgZm9yIHBhZCwgaSBpbiBwYWRzIGlmIGdyb3VwLnNvdW5kcy5hdChpKT9cblxuICB0b2dnbGVHcm91cFNlbGVjdEJ1dHRvbnM6IChncm91cCkgLT5cbiAgICBAYXBwLiQoJ1tkYXRhLWJlaGF2aW9yPVwic2VsZWN0R3JvdXBcIl0nKVxuICAgICAgLnJlbW92ZUNsYXNzICdhY3RpdmUnXG4gICAgICAuZmlsdGVyIFwiW2RhdGEtbWV0YT1cXFwiI3tncm91cH1cXFwiXVwiXG4gICAgICAuYWRkQ2xhc3MgJ2FjdGl2ZSdcblxuICByZW5kZXI6IChncm91cE51bWJlciA9IDEpIC0+XG5cbiAgICAjIHJlbW92ZSBjdXJyZW50IHBhZHMgZnJvbSBET01cbiAgICAjIFRPRE8gZG9uJ3QgY3JlYXRlIDEyOCBwYWRzLCBqdXN0IHJlLXVzZSBhbmQgcmUtbWFwIHRoZSBzYW1lIDE2XG4gICAgQCQoJy5wYWQtY29udGFpbmVyJykuZGV0YWNoKClcblxuICAgIGdyb3VwTnVtYmVyID0gZ3JvdXBOdW1iZXIgKiAxXG5cbiAgICAjIGRlc2VsZWN0IGluYWN0aXZlIGdyb3VwIGJ1dHRvbnMsIGhpZ2hsaWdodCBzZWxlY3RlZFxuICAgIEB0b2dnbGVHcm91cFNlbGVjdEJ1dHRvbnMgZ3JvdXBOdW1iZXJcblxuICAgICMgZ3JvdXBzIGhhdmUgcG9zaXRpb24gMS04LCBidXQgcGFkcyBjYWNoZSBpcyBicm9rZW4gaW50byBhIHplcm8taW5kZXhlZCBhcnJheVxuICAgIHplcm9lZEluZGV4ID0gZ3JvdXBOdW1iZXIgLSAxXG5cbiAgICAjIHNldCB0aGUgY3VycmVudEdyb3VwIHRvIHRoZSBvbmUgc2VsZWN0ZWRcbiAgICBAYXBwLmN1cnJlbnQuZ3JvdXAgPSBAYXBwLmdyb3Vwcy5maW5kV2hlcmUocG9zaXRpb246IGdyb3VwTnVtYmVyKVxuXG4gICAgIyBpZiB0aGVyZSB3YXNuJ3QgYSBncm91cCBhdCB0aGlzIHBvc2l0aW9uLCBjcmVhdGUgb25lIHJlYWwgcXVpY2suXG4gICAgaWYgbm90IEBhcHAuY3VycmVudC5ncm91cFxuICAgICAgQGFwcC5ncm91cHMuYWRkIHBvc2l0aW9uOiBncm91cE51bWJlclxuICAgICAgQGFwcC5jdXJyZW50Lmdyb3VwID0gQGFwcC5ncm91cHMuZmluZFdoZXJlKHBvc2l0aW9uOiBncm91cE51bWJlcilcblxuICAgIEBhcHAuJCgnLnBhdHRlcm5zIC5ncmlkJykuaGlkZSgpXG5cbiAgICAjIHNob3cgdGhpcyBncm91cCdzIHBhdHRlcm5cbiAgICBAYXBwLnBhdHRlcm4uX3NlbGVjdFBhdHRlcm4oQGFwcC5jdXJyZW50Lmdyb3VwLmxhc3RBY3RpdmVQYXR0ZXJuPy5nZXQoJ3Bvc2l0aW9uJykgfHwgMSlcblxuICAgICMgc2xpY2UgdGhlIHBhZHMgY2FjaGUgdG8gdGhlIDE2IHZpZXdzIHdlIHdhbnRcbiAgICBAYXBwLmN1cnJlbnQucGFkcyA9IEBwYWRzLnNsaWNlKHplcm9lZEluZGV4ICogMTYsIHplcm9lZEluZGV4ICogMTYgKyAxNilcblxuICAgICMgdXBkYXRlIGRpc3BsYXkgVUlcbiAgICBAYXBwLmRpc3BsYXkubW9kZWwuc2V0KCdyaWdodCcsIFwiR3JvdXAgI3tncm91cE51bWJlcn1cIilcblxuICAgICMgYXBwZW5kIHRoZSBET00gZWxzIGZyb20gdGhlIDE2IHBhZHMgd2Ugc2xpY2VkIGZyb20gdGhlIGNhY2hlXG4gICAgQCRlbC5hcHBlbmQoXy5wbHVjayhAYXBwLmN1cnJlbnQucGFkcywgJ2VsJykpXG5cbm1vZHVsZS5leHBvcnRzID0gUGFkc1ZpZXciLCJCYWNrYm9uZSAgICAgICAgICAgID0gcmVxdWlyZSgnYmFja2JvbmUnKVxuQmFja2JvbmUuJCAgICAgICAgICA9ICQgPSByZXF1aXJlKCdqcXVlcnknKVxuXyAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuUGF0dGVybkNvbGxlY3Rpb24gICA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL3BhdHRlcm4nKVxucGFwZXIgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXIvZGlzdC9wYXBlci1mdWxsJylcblxuSEFTX1RSSUdHRVJfQ0xBU1MgPSAnaGFzLXRyaWdnZXInXG5QQVRURVJOX0xFTkdUSCAgICA9ICc0J1xuXG5jbGFzcyBQYXR0ZXJuR3JpZFZpZXcgZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XG5cbiAgYXR0cmlidXRlczpcbiAgICBjbGFzcyAgICAgICA6ICdncmlkJ1xuICAgIHN0eWxlICAgICAgIDogJ2Rpc3BsYXk6bm9uZTsnXG5cbiAgaW5pdGlhbGl6ZTogKG9wdGlvbnMgPSB7fSkgLT5cbiAgICB7IEBtb2RlbCB9ID0gb3B0aW9uc1xuXG4gICAgXy5iaW5kQWxsIEAsICdkcmF3R3JpZCcsICdhZGRUcmlnZ2VyJywgJ3JlbW92ZVRyaWdnZXInLCAnb25UaWNrJ1xuXG4gICAgIyB0aGUgcmVmZXJlbmNlIHRvIEFwcCBzaG91bGQgYmUgdGhyb3VnaCBwYXJlbnRzIC8gaGllcmFyY2h5IG9mIHRoZSBzY2hlbWEuIEl0J3Mgb3RoZXJ3aXNlXG4gICAgIyB2ZXJ5IGRpZmZpY3VsdCB0byBpbnN0YW50aWF0ZSAvIG1hbmFnZSB0aGUgcmVmZXJlbmNlIHRvIGFwcCBhcyBtb2RlbHMgLyBjb2xsZWN0aW9ucyBhcmUgY3JlYXRlZCAvIHJlc2V0XG4gICAgIyBlbHNld2hlcmUgXG4gICAgQGFwcCA9IEBtb2RlbC5jb2xsZWN0aW9uLmdyb3VwLmFwcFxuICAgIEB1aSA9IEBhcHAucGF0dGVyblxuXG4gICAgIyBhcHBlbmQgdGhpcyBncmlkIHRvIHRoZSBwYXR0ZXJucyB2aWV3XG4gICAgQHVpLiQoJy5wYXR0ZXJucycpLmFwcGVuZCBAJGVsXG5cbiAgICBAbW9kZWwuc2V0KCdsZW4nLCBQQVRURVJOX0xFTkdUSCkgdW5sZXNzIEBtb2RlbC5nZXQoJ2xlbicpXG5cbiAgICBAcmVuZGVyKClcblxuICAgICMgcmVkcmF3R3JpZCB0aGUgZ3JpZCB3aGVuIHRoZSBwYXR0ZXJuIGNoYW5nZXNcbiAgICBAbGlzdGVuVG8gQG1vZGVsLCAnY2hhbmdlOmxlbicsIEBkcmF3R3JpZFxuICAgIEBsaXN0ZW5UbyBAbW9kZWwsICdjaGFuZ2U6em9vbScsIEBkcmF3R3JpZFxuICAgIEBsaXN0ZW5UbyBAbW9kZWwsICdjaGFuZ2U6c3RlcCcsIEBkcmF3R3JpZFxuICAgIEBsaXN0ZW5UbyBAbW9kZWwsICdyZW1vdmUnLCBAcmVtb3ZlXG5cbiAgICBAbGlzdGVuVG8gQHVpLCAndGljaycsIEBvblRpY2tcblxuICBldmVudHM6XG4gICAgJ2NvbnRleHRtZW51IC50cmlnZ2VyJyAgICAgICAgICAgICAgICA6ICdjbGlja0RlbGV0ZVRyaWdnZXInXG4gICAgJ2RibGNsaWNrJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdjbGlja0FkZFRyaWdnZXInXG5cbiAgIyMjXG4gICMgVUkgZGVsZWdhdGUuXG4gICMgYWRkcyBhIHRyaWdnZXIgd2hlcmUgdGhlIHVzZXIgZG91YmxlLWNsaWNrc1xuICAjIyNcbiAgY2xpY2tBZGRUcmlnZ2VyOiAoZSkgLT5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBAYWRkVHJpZ2dlcihAb2Zmc2V0VG9QYWROdW1iZXIoZS5vZmZzZXRZKSwgQG9mZnNldFRvVGljayhlLm9mZnNldFgpKVxuXG4gICMjI1xuICAjIFVJIGRlbGVnYXRlLlxuICAjIHJlbW92ZXMgdGhlIHJpZ2h0LWNsaWNrZWQgdHJpZ2dlciBmcm9tIHRoZSBwYXR0ZXJuXG4gICMjI1xuICBjbGlja0RlbGV0ZVRyaWdnZXI6IChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGRhdGEgPSAkKGUudGFyZ2V0KS5kYXRhKClcbiAgICBAcmVtb3ZlVHJpZ2dlcihkYXRhLnBhZE51bWJlciwgZGF0YS50aWNrKVxuICAgICQoZS50YXJnZXQpLnJlbW92ZSgpXG5cbiAgb25UaWNrOiAodGljaykgLT5cbiAgICBub3JtYWxpemVkVGljayA9IEBnZXROb3JtYWxpemVkVGljayh0aWNrKVxuICAgIGlmIEBhcHAudHJhbnNwb3J0Ll9wbGF5aW5nICYmICh0cmlnZ2VycyA9IEBtb2RlbC5nZXQoXCJ0cmlnZ2Vycy4je25vcm1hbGl6ZWRUaWNrfVwiKSlcbiAgICAgIF8uZWFjaCB0cmlnZ2VycywgKHBhZE51bWJlcikgPT5cbiAgICAgICAgY29uc29sZS5sb2coQG1vZGVsLmNvbGxlY3Rpb24uZ3JvdXAuc291bmRzLmZpbmRXaGVyZShwYWQ6IHBhZE51bWJlcikpXG4gICAgICAgIEBtb2RlbC5jb2xsZWN0aW9uLmdyb3VwLnNvdW5kcy5maW5kV2hlcmUocGFkOiBwYWROdW1iZXIpPy50cmlnZ2VyKCdwcmVzcycsIHNpbGVudDogdHJ1ZSlcblxuICBkcmF3VHJpZ2dlcnM6ICgpIC0+XG4gICAgZm9yIG93biB0aWNrLCB0cmlnZ2VycyBvZiBAbW9kZWwuZ2V0KCd0cmlnZ2VycycpXG4gICAgICBmb3IgcGFkTnVtYmVyIGluIHRyaWdnZXJzXG4gICAgICAgIEBkcmF3VHJpZ2dlciBwYWROdW1iZXIsIHRpY2tcbiAgICAgIFxuICBkcmF3VHJpZ2dlcjogKHBhZE51bWJlciwgdGljaykgLT5cbiAgICB0b3RhbFRpY2tzID0gQGdldFRvdGFsVGlja3MoKVxuICAgIGxlZnQgPSAoMTAwIC8gQGdldFRvdGFsVGlja3MoKSkgKiBAZ2V0Tm9ybWFsaXplZFRpY2sodGljaylcbiAgICAkdHJpZ2dlciA9ICQoJzxkaXYgY2xhc3M9XCJ0cmlnZ2VyXCI+JylcbiAgICAgICAgICAgICAgICAgIC5jc3NcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAocGFkTnVtYmVyIC0gMSkgKiBAdWkuJCgnLnNsb3QnKS5lcSgwKS5vdXRlckhlaWdodCgpICsgXCJweFwiXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIje0B1aS4kKCcuc2xvdCcpLmVxKDApLm91dGVySGVpZ2h0KCl9cHhcIlxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCIjeyhAdyAvIHRvdGFsVGlja3MpIC8gQHcgKiAxMDB9JVwiXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IFwiI3tsZWZ0fSVcIlxuICAgICAgICAgICAgICAgICAgLmRhdGEgJ3RpY2snLCB0aWNrXG4gICAgICAgICAgICAgICAgICAuZGF0YSAncGFkTnVtYmVyJywgcGFkTnVtYmVyXG4gICAgQCRlbC5hcHBlbmQoJHRyaWdnZXIpXG5cbiAgcmVtb3ZlVHJpZ2dlcjogKHBhZE51bWJlciwgbm9ybWFsaXplZFRpY2spIC0+XG4gICAgaWYgKHRyaWdnZXJzID0gQG1vZGVsLmdldChcInRyaWdnZXJzLiN7bm9ybWFsaXplZFRpY2t9XCIpKVxuICAgICAgQGFwcC5jdXJyZW50LnBhdHRlcm4udmlldy5kcmF3VHJpZ2dlcihub3JtYWxpemVkVGljaywgcGFkTnVtYmVyKVxuICAgICAgcmVtb3ZlZCA9IHRyaWdnZXJzLnNwbGljZShfLmluZGV4T2YodHJpZ2dlcnMsIHBhZE51bWJlciksIDEpXG4gICAgICBAbW9kZWwuc2V0KFwidHJpZ2dlcnMuI3tub3JtYWxpemVkVGlja31cIiwgdHJpZ2dlcnMpXG4gICAgICByZW1vdmVkXG4gICAgZWxzZSBcbiAgICAgIGZhbHNlXG5cbiAgYWRkVHJpZ2dlcjogKHBhZE51bWJlciwgbm9ybWFsaXplZFRpY2spIC0+XG4gICAgdHJpZ2dlcnMgPSBAbW9kZWwuZ2V0KFwidHJpZ2dlcnMuI3tub3JtYWxpemVkVGlja31cIikgfHwgW11cbiAgICB1bmxlc3MgdHJpZ2dlcnMuaW5kZXhPZihwYWROdW1iZXIpID4gLTFcbiAgICAgIHRyaWdnZXJzLnB1c2gocGFkTnVtYmVyKVxuICAgICAgQGFwcC5jdXJyZW50LnBhdHRlcm4udmlldy5kcmF3VHJpZ2dlcihwYWROdW1iZXIsIG5vcm1hbGl6ZWRUaWNrKVxuICAgICAgQG1vZGVsLnNldChcInRyaWdnZXJzLiN7bm9ybWFsaXplZFRpY2t9XCIsIHRyaWdnZXJzKVxuICAgIHBhZE51bWJlclxuXG4gIGdldFRvdGFsVGlja3M6ICgpIC0+XG4gICAgdG90YWxUaWNrcyA9IChAbW9kZWwuZ2V0KCdsZW4nKSAqIEBtb2RlbC5nZXQoJ3N0ZXAnKSlcblxuICBnZXROb3JtYWxpemVkVGljazogKHRpY2ssIGFzUGVyY2VudGFnZSA9IGZhbHNlKSAtPlxuICAgIHRpY2sgfHw9IEBhcHAudHJhbnNwb3J0LmdldFRpY2soKVxuICAgIHRvdGFsVGlja3MgPSBAZ2V0VG90YWxUaWNrcygpXG4gICAgaWYgdGljayA8PSB0b3RhbFRpY2tzXG4gICAgICBub3JtYWwgPSB0aWNrXG4gICAgZWxzZVxuICAgICAgbm9ybWFsID0gdGljayAlIEBnZXRUb3RhbFRpY2tzKClcbiAgICBpZiBhc1BlcmNlbnRhZ2VcbiAgICAgIHJldHVybiAoMTAwIC8gdG90YWxUaWNrcykgKiBub3JtYWxcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbm9ybWFsXG5cbiAgb2Zmc2V0VG9QYWROdW1iZXI6IChvZmZzZXQsIGlzUGVyY2VudGFnZSA9IGZhbHNlKSAtPlxuICAgIHVubGVzcyBpc1BlcmNlbnRhZ2VcbiAgICAgIG9mZnNldCA9IG9mZnNldCAvIEAkZWwub3V0ZXJIZWlnaHQoKVxuICAgIHBhZE51bWJlciA9IE1hdGguY2VpbChvZmZzZXQgKiAxNilcblxuICBvZmZzZXRUb1RpY2s6IChvZmZzZXQsIGlzUGVyY2VudGFnZSA9IGZhbHNlKSAtPlxuICAgIHVubGVzcyBpc1BlcmNlbnRhZ2VcbiAgICAgIG9mZnNldCA9IG9mZnNldCAvIEB3XG4gICAgdGljayA9IE1hdGguZmxvb3IoQGdldFRvdGFsVGlja3MoKSAqIG9mZnNldClcblxuICB0aWNrVG9PZmZzZXQ6ICgpIC0+XG4gICAgIyBcblxuICBkcmF3R3JpZDogKCkgLT5cbiAgICB6b29tID0gQG1vZGVsLmdldCgnem9vbScpIHx8IDJcbiAgICAkcGF0dGVybldpbmRvdyA9IEB1aS4kKCcucGF0dGVybnMnKVxuICAgIHcgPSBAdyA9ICRwYXR0ZXJuV2luZG93LndpZHRoKCkgKiBAbW9kZWwuZ2V0KCd6b29tJykgKiAwLjlcbiAgICBoID0gMzEwXG4gICAgQCRlbC53aWR0aCh3KVxuICAgIEAkZWwuaGVpZ2h0KGgpXG4gICAgbGVuID0gcGFyc2VJbnQoQG1vZGVsLmdldCgnbGVuJyksIDEwKVxuICAgIHN0ZXAgPSBwYXJzZUludChAbW9kZWwuZ2V0KCdzdGVwJyksIDEwKVxuICAgIHRvdGFsVGlja3MgPSBzdGVwICogbGVuXG4gICAgeEludGVydmFsID0gdyAvIHRvdGFsVGlja3NcbiAgICBjdXJyZW50VGljayA9IDBcbiAgICBiYXIgPSBNYXRoLmNlaWwodG90YWxUaWNrcyAvIGxlbilcbiAgICAoYmFycyB8fCBiYXJzID0gW10pLnB1c2goIGkgKiBiYXIgfHwgMCApIGZvciBpIGluIFswLi5sZW4gKyAxXVxuICAgIEBwYXBlciA9IHBhcGVyLnNldHVwIEAkY2FudmFzLmdldCgwKVxuICAgIEBwYXBlci52aWV3LnZpZXdTaXplID0gbmV3IEBwYXBlci5TaXplKHcsIGgpXG4gICAgcGF0aCA9IG5ldyBAcGFwZXIuUGF0aCgpXG4gICAgd2hpbGUgY3VycmVudFRpY2sgPD0gdG90YWxUaWNrc1xuICAgICAgeCA9IGN1cnJlbnRUaWNrICogeEludGVydmFsXG4gICAgICBwYXRoID0gbmV3IEBwYXBlci5QYXRoKClcbiAgICAgIHBhdGguc3Ryb2tlV2lkdGggPSAxXG4gICAgICBwYXRoLnN0cm9rZUNvbG9yID0gaWYgY3VycmVudFRpY2sgaW4gYmFycyB0aGVuICcjZGRkJyBlbHNlICcjNDQ0J1xuICAgICAgcGF0aC5tb3ZlVG8obmV3IEBwYXBlci5Qb2ludCh4IC0gMC41LCAwKSlcbiAgICAgIHBhdGgubGluZVRvKG5ldyBAcGFwZXIuUG9pbnQoeCAtIDAuNSwgaCkpXG4gICAgICBjdXJyZW50VGljaysrXG4gICAgc2xvdEhlaWdodCA9IEB1aS4kKCcuc2xvdCcpLmVxKDApLm91dGVySGVpZ2h0KClcbiAgICBmb3IgaSBpbiBbMC4uMTZdXG4gICAgICB4ID0gd1xuICAgICAgeSA9IGkgKiBzbG90SGVpZ2h0XG4gICAgICBwYXRoID0gbmV3IEBwYXBlci5QYXRoKClcbiAgICAgIHBhdGguc3Ryb2tlV2lkdGggPSAwLjJcbiAgICAgIHBhdGguc3Ryb2tlQ29sb3IgPSBcIiNhYWFcIlxuICAgICAgcGF0aC5tb3ZlVG8oMCwgeSlcbiAgICAgIHBhdGgubGluZVRvKHgsIHkpXG4gICAgQHBhcGVyLnZpZXcuZHJhdygpXG4gICAgQCRlbC5maW5kKCcudHJpZ2dlcicpLnJlbW92ZSgpXG4gICAgQGRyYXdUcmlnZ2VycygpXG5cbiAgcmVuZGVyOiAoKSAtPlxuICAgIEAkZWwuZW1wdHkoKVxuICAgICMgY3JlYXRlIHRoZSBjYW52YXMgdG8gZHJhdyBvblxuICAgIEAkY2FudmFzID0gJCgnPGNhbnZhcz4nKS5hcHBlbmRUbyBAJGVsXG4gICAgQCRwbGF5SGVhZCA9ICQoJzxkaXYgY2xhc3M9XCJwbGF5SGVhZFwiPicpLmFwcGVuZFRvIEAkZWxcbiAgICBAZHJhd0dyaWQoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhdHRlcm5HcmlkVmlldyIsIkJhY2tib25lICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lLiQgICAgICAgICAgICA9ICQgPSByZXF1aXJlKCdqcXVlcnknKVxuQmFja2JvbmUuTmVzdGVkTW9kZWwgID0gcmVxdWlyZSgnYmFja2JvbmUtbmVzdGVkJykuTmVzdGVkTW9kZWxcbkxpZ2FtZW50ICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2JhY2tib25lLWxpZ2FtZW50cycpXG5fICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJylcblBhdHRlcm5Db2xsZWN0aW9uICAgICA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL3BhdHRlcm4nKVxuVHJhbnNwb3J0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKVxuVFJJR0dFUl9DTEFTUyAgICAgICAgID0gJ3RyaWdnZXInXG5cbmNsYXNzIFBhdHRlcm5VSVZpZXcgZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XG5cblx0ZWw6ICcucGF0dGVybidcblxuXHRpbml0aWFsaXplOiAob3B0aW9ucyA9IHt9KSAtPlxuXHRcdHsgQGFwcCB9ID0gb3B0aW9uc1xuXG5cdFx0Xy5iaW5kQWxsIHRoaXMsICd1cGRhdGVQbGF5SGVhZCcsICdyZWNvcmRUcmlnZ2VyJ1xuXG5cdFx0QFVJTW9kZWwgPSBuZXcgKEJhY2tib25lLk5lc3RlZE1vZGVsLmV4dGVuZCh7fSkpXG5cblx0XHRAbGlnYW1lbnQgPSBuZXcgTGlnYW1lbnRcblx0XHRcdG1vZGVsOiBAVUlNb2RlbCxcblx0XHRcdHZpZXc6IEAsXG5cdFx0XHRiaW5kaW5nczpcblx0XHRcdFx0J3BhdHRlcm4uem9vbSc6IHtjYXN0OiBbcGFyc2VGbG9hdCwgMTBdfVxuXHRcdFx0XHQncGF0dGVybi5sZW4nOiB7Y2FzdDogW3BhcnNlSW50LCAxMF19XG5cdFx0XHRcdCdwYXR0ZXJuLnN0ZXAnOiB7Y2FzdDogW3BhcnNlSW50LCAxMF19XG5cblx0XHRAbGlzdGVuVG8gQFVJTW9kZWwsICdjaGFuZ2U6cGF0dGVybicsIChtb2RlbCwgY2hhbmdlZCkgPT5cblx0XHRcdEBhcHAuY3VycmVudC5wYXR0ZXJuLnNldChjaGFuZ2VkKVxuXG5cdFx0QGFwcC50cmFuc3BvcnQub24oJ3RpY2snLCBAdXBkYXRlUGxheUhlYWQpXG5cblx0XHRAd2FpdEZvclBhZHMgPSBzZXRJbnRlcnZhbCAoKSA9PlxuXHRcdFx0Y2xlYXJUaW1lb3V0IEB3YWl0Rm9yUGFkc1xuXHRcdFx0aWYgQGFwcC5wYWRzXG5cdFx0XHRcdEBhcHAucGFkcy5vbiAncHJlc3MnLCBAcmVjb3JkVHJpZ2dlclxuXHRcdCwgMTAwXG5cblx0ZXZlbnRzOlxuXHRcdCMgJ21vdXNlZG93biAucGxheUhlYWQnXHRcdFx0XHRcdFx0XHRcdFx0OiAnZW5nYWdlUGxheUhlYWRTY3J1Yidcblx0XHQjICdtb3VzZXVwIC5wbGF5SGVhZCdcdFx0XHRcdFx0XHRcdFx0XHRcdDogJ2Rpc2VuZ2FnZVBsYXlIZWFkU2NydWInXG5cdFx0J2NsaWNrIFtkYXRhLWJlaGF2aW9yXSdcdFx0XHRcdFx0XHRcdFx0XHQ6ICdkZWxlZ2F0ZUJlaGF2aW9yJ1xuXG5cdGRlbGVnYXRlQmVoYXZpb3I6IChlKSAtPlxuXHRcdGJlaGF2aW9yID0gJChlLnRhcmdldCkuZGF0YSgnYmVoYXZpb3InKVxuXHRcdGlmIGJlaGF2aW9yICYmIChkZWxlZ2F0ZSA9IEBbYmVoYXZpb3JdKVxuXHRcdFx0bWV0YSA9ICQoZS50YXJnZXQpLmRhdGEoJ21ldGEnKVxuXHRcdFx0ZGVsZWdhdGUuY2FsbChALCBlLCBtZXRhKVxuXG5cdCMjI1xuXHQjIHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZFxuXHQjIHdoZW4gdHJhbnNwb3J0IGlzIGluIHBsYXkvcmVjb3JkIFxuXHQjIyNcblx0dXBkYXRlUGxheUhlYWQ6ICh0aWNrKSAtPlxuXHRcdHRpY2sgfHw9IEBhcHAudHJhbnNwb3J0LmdldFRpY2soKVxuXHRcdCMgZ2V0IG5vcm1hbGl6ZWQgMC0xMDAlIHBvc2l0aW9uLCBsb29waW5nIGFmdGVyIDEwMCUgaXMgcmVhY2hlZC5cblx0XHRwbGF5SGVhZFBvc2l0aW9uID0gQGFwcC5jdXJyZW50LnBhdHRlcm4udmlldy5nZXROb3JtYWxpemVkVGljayh0aWNrLCB0cnVlKVxuXHRcdEBhcHAuY3VycmVudC5wYXR0ZXJuLnZpZXcuJHBsYXlIZWFkLmNzcyBsZWZ0OiBcIiN7cGxheUhlYWRQb3NpdGlvbn0lXCJcblx0XHQjIHByb3h5IHRoZSB0aWNrIGV2ZW50IHRvIHRoZSBwYXR0ZXJuLmdyaWRzXG5cdFx0QHRyaWdnZXIoJ3RpY2snLCB0aWNrKVxuXHRcdHBsYXlIZWFkUG9zaXRpb25cblxuXG5cdCMjI1xuXHQjXG5cdCNcblx0IyMjXG5cdGVuZ2FnZVBsYXlIZWFkU2NydWI6IChlKSAtPlxuXHRcdG51bGxcblxuXHQjIyNcblx0I3dlZndcblx0I1xuXHQjIyNcblx0ZGlzZW5nYWdlUGxheUhlYWRTY3J1YjogKGUpIC0+XG5cdFx0bnVsbFxuXG5cblx0IyMjXG5cdCMgY2hlY2tzIGlmIHRoZSB0cmFuc3BvcnQgaXMgcmVjb3JkaW5nLCByZWNvcmRzIGEgdHJpZ2dlciBvbiBcblx0IyBjdXJyZW50UGF0dGVybiBpbiB0aGUgY29ycmVjdCBzbG90LlxuXHQjIyNcblx0cmVjb3JkVHJpZ2dlcjogKHBhZCkgLT5cblx0XHRpZiBAYXBwLnRyYW5zcG9ydC5fcmVjb3JkaW5nXG5cdFx0XHRub3JtYWxpemVkVGljayA9IEBhcHAuY3VycmVudC5wYXR0ZXJuLnZpZXcuZ2V0Tm9ybWFsaXplZFRpY2soKVxuXHRcdFx0QGFwcC5jdXJyZW50LnBhdHRlcm4udmlldy5hZGRUcmlnZ2VyKHBhZC5udW1iZXIsIG5vcm1hbGl6ZWRUaWNrKVxuXG5cdHRvZ2dsZVBhdHRlcm5TZWxlY3RCdXR0b25zOiAocGF0dGVybk51bWJlcikgLT5cblx0XHRAJCgnW2RhdGEtYmVoYXZpb3I9XCJzZWxlY3RQYXR0ZXJuXCJdJylcblx0XHRcdC5yZW1vdmVDbGFzcyAnYWN0aXZlJ1xuXHRcdFx0LmZpbHRlciBcIltkYXRhLW1ldGE9XFxcIiN7cGF0dGVybk51bWJlcn1cXFwiXVwiXG5cdFx0XHQuYWRkQ2xhc3MgJ2FjdGl2ZSdcblxuXHRzZWxlY3RQYXR0ZXJuOiAoZSwgbnVtYmVyKSAtPlxuXHRcdEBfc2VsZWN0UGF0dGVybihudW1iZXIpXG5cblx0X3NlbGVjdFBhdHRlcm5BdDogKGlkeCkgLT5cblx0XHRAX3NlbGVjdFBhdHRlcm4oQGFwcC5jdXJyZW50Lmdyb3VwLnBhdHRlcm5zLmF0KDApLmdldCgncG9zaXRpb24nKSlcblxuXHRfc2VsZWN0UGF0dGVybjogKHBhdHRlcm5OdW1iZXIpIC0+XG5cdFx0QGFwcC5jdXJyZW50Lmdyb3VwLnBhdHRlcm5zLmZpbmRXaGVyZShwb3NpdGlvbjogcGF0dGVybk51bWJlcikgfHwgQGFwcC5jdXJyZW50Lmdyb3VwLnBhdHRlcm5zLmFkZChwb3NpdGlvbjogcGF0dGVybk51bWJlcilcblx0XHRAYXBwLmN1cnJlbnQucGF0dGVybiA9IEBhcHAuY3VycmVudC5ncm91cC5wYXR0ZXJucy5maW5kV2hlcmUocG9zaXRpb246IHBhdHRlcm5OdW1iZXIpXG5cdFx0QGFwcC5jdXJyZW50Lmdyb3VwLmxhc3RBY3RpdmVQYXR0ZXJuID0gQGFwcC5jdXJyZW50LnBhdHRlcm5cblx0XHRAdG9nZ2xlUGF0dGVyblNlbGVjdEJ1dHRvbnMgcGF0dGVybk51bWJlclxuXHRcdEAkKFwiLmdyaWRcIikuaGlkZSgpXG5cdFx0QGFwcC5jdXJyZW50LnBhdHRlcm4udmlldy4kZWwuc2hvdygpXG5cdFx0QFVJTW9kZWwuc2V0KCdwYXR0ZXJuLnpvb20nLCBAYXBwLmN1cnJlbnQucGF0dGVybi5nZXQoJ3pvb20nKSlcblx0XHQjIHVwZGF0ZSB0aGlzIGN1cnJlbnQgcGxheWhlYWQgdG8gdGhlIGNvcnJlY3QgcG9zaXRpb25cblx0XHRsZWZ0ID0gQHVwZGF0ZVBsYXlIZWFkKClcblx0XHQjIGF1dG8gc2Nyb2xsIHRvIHRoZSBwbGF5aGVhZFxuXHRcdEAkKCcucGF0dGVybnMnKS5wcm9wKCdzY3JvbGxMZWZ0JywgKGxlZnQgLyA5NSkgKiBAYXBwLmN1cnJlbnQucGF0dGVybi52aWV3LiRlbC53aWR0aCgpKVxuXHRcdEB0cmlnZ2VyKCdjaGFuZ2VQYXR0ZXJuJywgQGFwcC5jdXJyZW50LnBhdHRlcm4pXG5cbm1vZHVsZS5leHBvcnRzID0gUGF0dGVyblVJVmlldyIsIkJhY2tib25lIFx0XHRcdFx0XHQ9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lLiQgXHRcdFx0XHQ9ICQgPSByZXF1aXJlKCdqcXVlcnknKVxuX1x0XHRcdFx0XHRcdFx0XHRcdD0gcmVxdWlyZSgndW5kZXJzY29yZScpXG5zZXF1ZW5jZVRlbXBsYXRlIFx0PSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvc2VxdWVuY2UudHBsJylcblxuU0xPVF9MQUJFTF9DTEFTU0VTIFx0XHRcdFx0PSAnc2xvdCBzbG90LWxhYmVsJ1xuU0xPVF9DT0xfQ0xBU1NFU1x0XHRcdFx0XHQ9ICdjb2wgY29sLTEnXG5TTE9UX0NMQVNTRVNcdFx0XHRcdFx0XHRcdD0gJ3Nsb3QnXG5cbmNsYXNzIFNlcXVlbmNlVmlldyBleHRlbmRzIEJhY2tib25lLlZpZXdcblxuXHR0ZW1wbGF0ZTogc2VxdWVuY2VUZW1wbGF0ZVxuXG5cdGVsOiAnLnNlcXVlbmNlJ1xuXG5cdGluaXRpYWxpemU6IChvcHRpb25zKSAtPlxuXHRcdHsgQGFwcCB9ID0gb3B0aW9uc1xuXHRcdEBidWlsZFNlcXVlbmNlKClcblxuXHRidWlsZFNlcXVlbmNlOiAtPlxuXHRcdGNvbHVtbiA9IDBcblx0XHRjb2xzID0gW11cblx0XHR3aGlsZSBjb2x1bW4gPCAxM1xuXHRcdFx0cm93ID0gMFxuXHRcdFx0Y29sc1tjb2x1bW5dID0gJChcIjxkaXYgY2xhc3M9XFxcIiN7U0xPVF9DT0xfQ0xBU1NFU31cXFwiPlwiKVxuXHRcdFx0cm93cyA9IFtdXG5cdFx0XHR3aGlsZSByb3cgPCA4XG5cdFx0XHRcdGlmIGNvbHVtbiBpcyAwXG5cdFx0XHRcdFx0aHRtbCA9IFwiPGRpdiBjbGFzcz1cXFwiI3tTTE9UX0NMQVNTRVN9XFxcIj5Hcm91cCAje3JvdyArIDF9PC9kaXY+XCJcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGh0bWwgPSBcIjxkaXYgY2xhc3M9XFxcIiN7U0xPVF9DTEFTU0VTfVxcXCI+Jm5ic3A7PC9kaXY+XCJcblx0XHRcdFx0cm93cy5wdXNoKCQoaHRtbCkpXG5cdFx0XHRcdHJvdysrXG5cdFx0XHRjb2xzW2NvbHVtbl0uYXBwZW5kKHJvd3MpXG5cdFx0XHRjb2x1bW4rK1xuXHRcdEAkZWwuYXBwZW5kKGNvbHMpXG5cbm1vZHVsZS5leHBvcnRzID0gU2VxdWVuY2VWaWV3IiwiQmFja2JvbmUgICAgICAgICAgICA9IHJlcXVpcmUoJ2JhY2tib25lJylcbkJhY2tib25lLiQgICAgICAgICAgPSAkID0gcmVxdWlyZSgnanF1ZXJ5Jylcbl8gICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJylcblRyYW5zcG9ydE1vZGVsICAgICAgPSByZXF1aXJlKCcuLi9tb2RlbHMvdHJhbnNwb3J0JylcbnRyYW5zcG9ydFRlbXBsYXRlICAgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdHJhbnNwb3J0LnRwbCcpXG5cbmNsYXNzIFRyYW5zcG9ydFZpZXcgZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XG5cbiAgZWw6ICcudHJhbnNwb3J0J1xuXG4gIHRlbXBsYXRlOiB0cmFuc3BvcnRUZW1wbGF0ZVxuXG4gIGluaXRpYWxpemU6IChvcHRpb25zID0ge30pIC0+XG4gICAgeyBAYXBwIH0gPSBvcHRpb25zXG5cbiAgICBfLmJpbmRBbGwgQCwgJ19zdGFydCcsICdfc3RvcCcsICdfdGljaycsICdyZWNhbGN1bGF0ZSdcbiAgICBAbW9kZWwgPSBuZXcgVHJhbnNwb3J0TW9kZWwgYnBtOiA4MCwgc3RlcDogNjRcbiAgICBAX2N1cnJlbnRUaW1lICAgPSBAX2N1cnJlbnRUaWNrICAgPSAwXG4gICAgQF9wbGF5aW5nICAgICAgID0gQF9yZWNvcmRpbmcgICAgID0gZmFsc2VcbiAgICBAcmVuZGVyKClcblxuICBldmVudHM6XG4gICAgJ2NsaWNrIFtkYXRhLWJlaGF2aW9yXScgICAgIDogJ2RlbGVnYXRlQWN0aW9uJ1xuXG4gIHJlbmRlcjogLT5cbiAgICBAZWwuaW5uZXJIVE1MID0gQHRlbXBsYXRlKClcblxuICBkZWxlZ2F0ZUFjdGlvbjogKGUpIC0+XG4gICAgYmVoYXZpb3IgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnYmVoYXZpb3InKVxuICAgIGlmIHRoaXNbYmVoYXZpb3JdXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIHRoaXNbYmVoYXZpb3JdLmNhbGwgdGhpcywgZVxuXG4gIHN0b3A6IChlKSAtPlxuICAgIEBfc3RvcCgpXG4gICAgQCQoJ1tkYXRhLWJlaGF2aW9yPVwicmVjb3JkXCJdLCBbZGF0YS1iZWhhdmlvcj1cInBsYXlcIl0nKS5yZW1vdmVDbGFzcyAnYWN0aXZlJ1xuXG4gICMjI1xuICAjIHBhdXNlL3BsYXlcbiAgIyMjXG4gIHBsYXk6IChlKSAtPlxuICAgIGlmIEBfcGxheWluZyB0aGVuIEBfc3RvcCgpIGVsc2UgQF9zdGFydCgpXG5cbiAgIyMjXG4gICMgc2V0cyByZWNvcmRpbmcgcHJvcGVydHkgdG8gdHJ1ZSBzbyB0aGF0IHRoZSBwYWRzIFVJXG4gICMgY2FuIGRldGVjdCB0aGF0IGl0IHNob3VsZCBiZSByZWNvcmRpbmcgdHJpZ2dlcnNcbiAgIyMjXG4gIHJlY29yZDogKGUpIC0+XG4gICAgaWYgbm90IEBfcGxheWluZyB0aGVuIEBfc3RhcnQoKVxuICAgIEBfcmVjb3JkaW5nID0gIUBfcmVjb3JkaW5nXG4gICAgQCQoJ1tkYXRhLWJlaGF2aW9yPVwicmVjb3JkXCJdJykudG9nZ2xlQ2xhc3MgJ2FjdGl2ZSdcblxuICAjIyNcbiAgIyByZXN0YXJ0cyBwbGF5aGVhZCB0aWNrIHRvIDBcbiAgIyMjXG4gIHJlc3RhcnQ6IChlKSAtPlxuICAgIEBzZXRUaWNrIDBcblxuICAjIFRPRE9cbiAgZW5kOiAoZSkgLT5cbiAgICBkZWJ1Z2dlclxuXG4gICMjI1xuICAjIHByaXZhdGUgc3RhcnQgbWV0aG9kIHRvIHN0YXJ0IHRoZSBwbGF5aGVhZCBhbmQgc2VxdWVuY2UvcGF0dGVyblxuICAjIyNcbiAgX3N0YXJ0OiAtPlxuICAgIEBfcGxheWluZyA9IHRydWVcbiAgICBAY2xvY2sgPSBzZXRJbnRlcnZhbCBAX3RpY2ssIHBhcnNlSW50KEBtb2RlbC5nZXQoJ2ludGVydmFsJyksIDEwKVxuICAgIEAkKCdbZGF0YS1iZWhhdmlvcj1cInBsYXlcIl0nKS5hZGRDbGFzcyAnYWN0aXZlJ1xuXG4gICMjI1xuICAjIHByaXZhdGUgc3RvcCBtZXRob2QgdG8gc3RvcCB0aGUgcGxheWhlYWQgYW5kIHNlcXVlbmNlL3BhdHRlcm5cbiAgIyMjXG4gIF9zdG9wOiAtPlxuICAgIGNsZWFySW50ZXJ2YWwgQGNsb2NrXG4gICAgQF9yZWNvcmRpbmcgPSBmYWxzZVxuICAgIEBfcGxheWluZyA9IGZhbHNlXG4gICAgQCQoJ1tkYXRhLWJlaGF2aW9yPVwicGxheVwiXSwgW2RhdGEtYmVoYXZpb3I9XCJyZWNvcmRcIl0nKS5yZW1vdmVDbGFzcyAnYWN0aXZlJ1xuXG4gICMgcHJpdmF0ZSBtZXRob2QgY2FsbGVkIGV2ZXJ5IGNhbGN1bGF0ZWQgaW50ZXJ2YWwuXG4gICMgYWxzbyBjaGVja3MgdGhlIGN1cnJlbnQgcGF0dGVybiBhbmQgYXR0ZW1wdHMgdG8gdHJpZ2dlciBhIFwicHJlc3NcIiBldmVudCBcbiAgIyBvbiB0aGUgcGFkIGdpdmVuIGluIHRoZSBwYXR0ZXJucyB0aWNrc3RhbXAgYXJyYXkgb2YgdHJpZ2dlcnMuXG4gICMgXG4gICMgIGV4YW1wbGU6IHRoZSBwYXR0ZXJuIG1heSBsb29rIGxpa2UgdGhpc1xuICAjICB7XG4gICMgICAxNDU0MzogW3tcbiAgIyAgICAgICBwYWQgICAgICAgOiAxLFxuICAjICAgICAgIHZlbG9jaXR5ICA6IDEwMFxuICAjICAgICB9LHtcbiAgIyAgICAgICBwYWQgICAgICAgOiA0LFxuICAjICAgICAgIHZlbG9jaXR5ICA6IDEwMFxuICAjICAgfV1cbiAgIyAgfVxuICAjICBcbiAgIyAgb24gdGhlIHRpY2sgXCIxNDU0M1wiLCBwYWRzIDEsIDQsIGFuZCA1IHdvdWxkIGJlIHRyaWdnZXJlZCBpZiB0aGV5IFxuICAjICBsb2FkZWQgaW4gdGhlIGN1cnJlbnQgZ3JvdXAgKHBhZHMuY3VycmVudEdyb3VwKVxuICBfdGljazogLT5cbiAgICBAc2V0VGljayBAX2N1cnJlbnRUaWNrICsgMVxuXG4gIGdldFRpY2s6IC0+XG4gICAgQF9jdXJyZW50VGlja1xuXG4gIGdldFRpbWU6IChodW1hblJlYWRhYmxlID0gZmFsc2UpIC0+XG4gICAgaWYgbm90IGh1bWFuUmVhZGFibGUgXG4gICAgICBAX2N1cnJlbnRUaW1lXG4gICAgZWxzZVxuICAgICAgdGltZSA9ICgnJysoQF9jdXJyZW50VGltZSAvIDEwMDAgKiAxMDApKS5zcGxpdCgnLicpWzBdXG4gICAgICBmb3JtYXR0ZWQgPSAnJ1xuICAgICAgd2hpbGUgdGltZS5sZW5ndGggPCA4XG4gICAgICAgIHRpbWUgPSAnMCcrdGltZVxuICAgICAgdGltZSA9IHRpbWUuc3BsaXQoJycpXG4gICAgICB3aGlsZSB0cnVlXG4gICAgICAgIGZvcm1hdHRlZCArPSB0aW1lLnNwbGljZSgwLCAyKS5qb2luKCcnKVxuICAgICAgICBpZiB0aW1lLmxlbmd0aCA+PSAyXG4gICAgICAgICAgZm9ybWF0dGVkICs9ICc6J1xuICAgICAgICBicmVhayBpZiBub3QgdGltZS5sZW5ndGhcbiAgICAgIHJldHVybiBmb3JtYXR0ZWRcblxuICAjIyNcbiAgIyBTZXR0ZXIgZm9yIHRoZSBkZXNpcmVkIHRpY2tcbiAgIyBjYWxscyBuZWNlc3NhcnkgdXBkYXRlIG1ldGhvZHMgdG8ga2VlcCB0aGUgVUkgYW5kIHRpbWUgaW4gc3luY1xuICAjIyNcbiAgc2V0VGljazogKHZhbHVlKSAtPlxuICAgIEB0cmlnZ2VyKCd0aWNrJywgdmFsdWUpXG4gICAgQF9jdXJyZW50VGljayA9IHZhbHVlXG4gICAgQF9jdXJyZW50VGltZSA9IHZhbHVlICogcGFyc2VJbnQoQG1vZGVsLmdldCgnaW50ZXJ2YWwnKSwgMTApXG4gICAgQGFwcC5kaXNwbGF5Lm1vZGVsLnNldCAnbGVmdCcsIEBnZXRUaW1lKHRydWUpXG5cbiAgIyMjXG4gICMgc2V0dGVyIGZvciB0aGUgZGVzaXJlZCBwbGF5aGVhZCB0aW1lXG4gICMgY2FsbHMgbmVjZXNzYXJ5IHVwZGF0ZSBtZXRob2RzIHRvIGtlZXAgdGhlIFVJIGFuZCB0aWNrIGluIHN5bmNcbiAgIyMjXG4gIHNldFRpbWU6ICh2YWx1ZSkgLT5cbiAgICBAX2N1cnJlbnRUaW1lID0gdmFsdWVcbiAgICBAX2N1cnJlbnRUaWNrID0gdmFsdWUgLyBAbW9kZWwuZ2V0ICdpbnRlcnZhbCdcbiAgICBAYXBwLmRpc3BsYXkubW9kZWwuc2V0KCdsZWZ0JywgQGdldFRpbWUodHJ1ZSkpXG5cbiAgIyMjXG4gICMgcmVjYWx1bGF0ZSB0aGUgaW50ZXJ2YWwgd2hlbiB0aGUgYnBtIGNoYW5nZXNcbiAgIyMjXG4gIHJlY2FsY3VsYXRlOiAobW9kZWwsIGNoYW5nZWQpIC0+XG4gICAgaWYgY2hhbmdlZC5icG1cbiAgICAgIEBtb2RlbC5zZXQgJ2ludGVydmFsJywgQGNhbGN1bGF0ZUludGVydmFsKGNoYW5nZWQuYnBtKVxuXG4gICAgQF9zdG9wKClcbiAgICBAX3N0YXJ0KClcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRWaWV3IixudWxsLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBib290c3RyYXAtYWxlcnQuanMgdjIuMS4xXG4gKiBodHRwOi8vdHdpdHRlci5naXRodWIuY29tL2Jvb3RzdHJhcC9qYXZhc2NyaXB0Lmh0bWwjYWxlcnRzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMiBUd2l0dGVyLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7IC8vIGpzaGludCA7XztcblxuXG4gLyogQUxFUlQgQ0xBU1MgREVGSU5JVElPTlxuICAqID09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICB2YXIgZGlzbWlzcyA9ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG4gICAgLCBBbGVydCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAkKGVsKS5vbignY2xpY2snLCBkaXNtaXNzLCB0aGlzLmNsb3NlKVxuICAgICAgfVxuXG4gIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgLCBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcbiAgICAgICwgJHBhcmVudFxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgICRwYXJlbnQgPSAkKHNlbGVjdG9yKVxuXG4gICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICRwYXJlbnQubGVuZ3RoIHx8ICgkcGFyZW50ID0gJHRoaXMuaGFzQ2xhc3MoJ2FsZXJ0JykgPyAkdGhpcyA6ICR0aGlzLnBhcmVudCgpKVxuXG4gICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdjbG9zZScpKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcbiAgICAgICRwYXJlbnRcbiAgICAgICAgLnRyaWdnZXIoJ2Nsb3NlZCcpXG4gICAgICAgIC5yZW1vdmUoKVxuICAgIH1cblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmICRwYXJlbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkcGFyZW50Lm9uKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCwgcmVtb3ZlRWxlbWVudCkgOlxuICAgICAgcmVtb3ZlRWxlbWVudCgpXG4gIH1cblxuXG4gLyogQUxFUlQgUExVR0lOIERFRklOSVRJT05cbiAgKiA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICQuZm4uYWxlcnQgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICAgICwgZGF0YSA9ICR0aGlzLmRhdGEoJ2FsZXJ0JylcbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYWxlcnQnLCAoZGF0YSA9IG5ldyBBbGVydCh0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dLmNhbGwoJHRoaXMpXG4gICAgfSlcbiAgfVxuXG4gICQuZm4uYWxlcnQuQ29uc3RydWN0b3IgPSBBbGVydFxuXG5cbiAvKiBBTEVSVCBEQVRBLUFQSVxuICAqID09PT09PT09PT09PT09ICovXG5cbiAgJChmdW5jdGlvbiAoKSB7XG4gICAgJCgnYm9keScpLm9uKCdjbGljay5hbGVydC5kYXRhLWFwaScsIGRpc21pc3MsIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSlcbiAgfSlcblxufSh3aW5kb3cualF1ZXJ5KTsiLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIGJvb3RzdHJhcC1idXR0b24uanMgdjIuMS4xXG4gKiBodHRwOi8vdHdpdHRlci5naXRodWIuY29tL2Jvb3RzdHJhcC9qYXZhc2NyaXB0Lmh0bWwjYnV0dG9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMiBUd2l0dGVyLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4hZnVuY3Rpb24gKCQpIHtcblxuICBcInVzZSBzdHJpY3RcIjsgLy8ganNoaW50IDtfO1xuXG5cbiAvKiBCVVRUT04gUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICB2YXIgQnV0dG9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmJ1dHRvbi5kZWZhdWx0cywgb3B0aW9ucylcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgZCA9ICdkaXNhYmxlZCdcbiAgICAgICwgJGVsID0gdGhpcy4kZWxlbWVudFxuICAgICAgLCBkYXRhID0gJGVsLmRhdGEoKVxuICAgICAgLCB2YWwgPSAkZWwuaXMoJ2lucHV0JykgPyAndmFsJyA6ICdodG1sJ1xuXG4gICAgc3RhdGUgPSBzdGF0ZSArICdUZXh0J1xuICAgIGRhdGEucmVzZXRUZXh0IHx8ICRlbC5kYXRhKCdyZXNldFRleHQnLCAkZWxbdmFsXSgpKVxuXG4gICAgJGVsW3ZhbF0oZGF0YVtzdGF0ZV0gfHwgdGhpcy5vcHRpb25zW3N0YXRlXSlcblxuICAgIC8vIHB1c2ggdG8gZXZlbnQgbG9vcCB0byBhbGxvdyBmb3JtcyB0byBzdWJtaXRcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0YXRlID09ICdsb2FkaW5nVGV4dCcgP1xuICAgICAgICAkZWwuYWRkQ2xhc3MoZCkuYXR0cihkLCBkKSA6XG4gICAgICAgICRlbC5yZW1vdmVDbGFzcyhkKS5yZW1vdmVBdHRyKGQpXG4gICAgfSwgMClcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS10b2dnbGU9XCJidXR0b25zLXJhZGlvXCJdJylcblxuICAgICRwYXJlbnQgJiYgJHBhcmVudFxuICAgICAgLmZpbmQoJy5hY3RpdmUnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuXG4gICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcygnYWN0aXZlJylcbiAgfVxuXG5cbiAvKiBCVVRUT04gUExVR0lOIERFRklOSVRJT05cbiAgKiA9PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAkLmZuLmJ1dHRvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgICAgLCBkYXRhID0gJHRoaXMuZGF0YSgnYnV0dG9uJylcbiAgICAgICAgLCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnV0dG9uJywgKGRhdGEgPSBuZXcgQnV0dG9uKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmIChvcHRpb24gPT0gJ3RvZ2dsZScpIGRhdGEudG9nZ2xlKClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbikgZGF0YS5zZXRTdGF0ZShvcHRpb24pXG4gICAgfSlcbiAgfVxuXG4gICQuZm4uYnV0dG9uLmRlZmF1bHRzID0ge1xuICAgIGxvYWRpbmdUZXh0OiAnbG9hZGluZy4uLidcbiAgfVxuXG4gICQuZm4uYnV0dG9uLkNvbnN0cnVjdG9yID0gQnV0dG9uXG5cblxuIC8qIEJVVFRPTiBEQVRBLUFQSVxuICAqID09PT09PT09PT09PT09PSAqL1xuXG4gICQoZnVuY3Rpb24gKCkge1xuICAgICQoJ2JvZHknKS5vbignY2xpY2suYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49YnV0dG9uXScsIGZ1bmN0aW9uICggZSApIHtcbiAgICAgIHZhciAkYnRuID0gJChlLnRhcmdldClcbiAgICAgIGlmICghJGJ0bi5oYXNDbGFzcygnYnRuJykpICRidG4gPSAkYnRuLmNsb3Nlc3QoJy5idG4nKVxuICAgICAgJGJ0bi5idXR0b24oJ3RvZ2dsZScpXG4gICAgfSlcbiAgfSlcblxufSh3aW5kb3cualF1ZXJ5KTsiLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIGJvb3RzdHJhcC1kcm9wZG93bi5qcyB2Mi4xLjFcbiAqIGh0dHA6Ly90d2l0dGVyLmdpdGh1Yi5jb20vYm9vdHN0cmFwL2phdmFzY3JpcHQuaHRtbCNkcm9wZG93bnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTIgVHdpdHRlciwgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7IC8vIGpzaGludCA7XztcblxuXG4gLyogRFJPUERPV04gQ0xBU1MgREVGSU5JVElPTlxuICAqID09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICB2YXIgdG9nZ2xlID0gJ1tkYXRhLXRvZ2dsZT1kcm9wZG93bl0nXG4gICAgLCBEcm9wZG93biA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciAkZWwgPSAkKGVsZW1lbnQpLm9uKCdjbGljay5kcm9wZG93bi5kYXRhLWFwaScsIHRoaXMudG9nZ2xlKVxuICAgICAgICAkKCdodG1sJykub24oJ2NsaWNrLmRyb3Bkb3duLmRhdGEtYXBpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICRlbC5wYXJlbnQoKS5yZW1vdmVDbGFzcygnb3BlbicpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgRHJvcGRvd24ucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IERyb3Bkb3duXG5cbiAgLCB0b2dnbGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICAgICwgJHBhcmVudFxuICAgICAgICAsIGlzQWN0aXZlXG5cbiAgICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICAgICRwYXJlbnQgPSBnZXRQYXJlbnQoJHRoaXMpXG5cbiAgICAgIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICAgIGNsZWFyTWVudXMoKVxuXG4gICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgICRwYXJlbnQudG9nZ2xlQ2xhc3MoJ29wZW4nKVxuICAgICAgICAkdGhpcy5mb2N1cygpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAsIGtleWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgJHRoaXNcbiAgICAgICAgLCAkaXRlbXNcbiAgICAgICAgLCAkYWN0aXZlXG4gICAgICAgICwgJHBhcmVudFxuICAgICAgICAsIGlzQWN0aXZlXG4gICAgICAgICwgaW5kZXhcblxuICAgICAgaWYgKCEvKDM4fDQwfDI3KS8udGVzdChlLmtleUNvZGUpKSByZXR1cm5cblxuICAgICAgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgICAkcGFyZW50ID0gZ2V0UGFyZW50KCR0aGlzKVxuXG4gICAgICBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgICBpZiAoIWlzQWN0aXZlIHx8IChpc0FjdGl2ZSAmJiBlLmtleUNvZGUgPT0gMjcpKSByZXR1cm4gJHRoaXMuY2xpY2soKVxuXG4gICAgICAkaXRlbXMgPSAkKCdbcm9sZT1tZW51XSBsaTpub3QoLmRpdmlkZXIpIGEnLCAkcGFyZW50KVxuXG4gICAgICBpZiAoISRpdGVtcy5sZW5ndGgpIHJldHVyblxuXG4gICAgICBpbmRleCA9ICRpdGVtcy5pbmRleCgkaXRlbXMuZmlsdGVyKCc6Zm9jdXMnKSlcblxuICAgICAgaWYgKGUua2V5Q29kZSA9PSAzOCAmJiBpbmRleCA+IDApIGluZGV4LS0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBcbiAgICAgIGlmIChlLmtleUNvZGUgPT0gNDAgJiYgaW5kZXggPCAkaXRlbXMubGVuZ3RoIC0gMSkgaW5kZXgrKyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvd25cbiAgICAgIGlmICghfmluZGV4KSBpbmRleCA9IDBcblxuICAgICAgJGl0ZW1zXG4gICAgICAgIC5lcShpbmRleClcbiAgICAgICAgLmZvY3VzKClcbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTWVudXMoKSB7XG4gICAgZ2V0UGFyZW50KCQodG9nZ2xlKSlcbiAgICAgIC5yZW1vdmVDbGFzcygnb3BlbicpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJlbnQoJHRoaXMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG4gICAgICAsICRwYXJlbnRcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIC8jLy50ZXN0KHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy9zdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgJHBhcmVudCA9ICQoc2VsZWN0b3IpXG4gICAgJHBhcmVudC5sZW5ndGggfHwgKCRwYXJlbnQgPSAkdGhpcy5wYXJlbnQoKSlcblxuICAgIHJldHVybiAkcGFyZW50XG4gIH1cblxuXG4gIC8qIERST1BET1dOIFBMVUdJTiBERUZJTklUSU9OXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgJC5mbi5kcm9wZG93biA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgICAgLCBkYXRhID0gJHRoaXMuZGF0YSgnZHJvcGRvd24nKVxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdkcm9wZG93bicsIChkYXRhID0gbmV3IERyb3Bkb3duKHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0uY2FsbCgkdGhpcylcbiAgICB9KVxuICB9XG5cbiAgJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3RvciA9IERyb3Bkb3duXG5cblxuICAvKiBBUFBMWSBUTyBTVEFOREFSRCBEUk9QRE9XTiBFTEVNRU5UU1xuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICQoZnVuY3Rpb24gKCkge1xuICAgICQoJ2h0bWwnKVxuICAgICAgLm9uKCdjbGljay5kcm9wZG93bi5kYXRhLWFwaSB0b3VjaHN0YXJ0LmRyb3Bkb3duLmRhdGEtYXBpJywgY2xlYXJNZW51cylcbiAgICAkKCdib2R5JylcbiAgICAgIC5vbignY2xpY2suZHJvcGRvd24gdG91Y2hzdGFydC5kcm9wZG93bi5kYXRhLWFwaScsICcuZHJvcGRvd24gZm9ybScsIGZ1bmN0aW9uIChlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfSlcbiAgICAgIC5vbignY2xpY2suZHJvcGRvd24uZGF0YS1hcGkgdG91Y2hzdGFydC5kcm9wZG93bi5kYXRhLWFwaScgICwgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlKVxuICAgICAgLm9uKCdrZXlkb3duLmRyb3Bkb3duLmRhdGEtYXBpIHRvdWNoc3RhcnQuZHJvcGRvd24uZGF0YS1hcGknLCB0b2dnbGUgKyAnLCBbcm9sZT1tZW51XScgLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcbiAgfSlcblxufSh3aW5kb3cualF1ZXJ5KTsiLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIGJvb3RzdHJhcC1tb2RhbC5qcyB2Mi4xLjFcbiAqIGh0dHA6Ly90d2l0dGVyLmdpdGh1Yi5jb20vYm9vdHN0cmFwL2phdmFzY3JpcHQuaHRtbCNtb2RhbHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTIgVHdpdHRlciwgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7IC8vIGpzaGludCA7XztcblxuXG4gLyogTU9EQUwgQ0xBU1MgREVGSU5JVElPTlxuICAqID09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICB2YXIgTW9kYWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KVxuICAgICAgLmRlbGVnYXRlKCdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCAnY2xpY2suZGlzbWlzcy5tb2RhbCcsICQucHJveHkodGhpcy5oaWRlLCB0aGlzKSlcbiAgICB0aGlzLm9wdGlvbnMucmVtb3RlICYmIHRoaXMuJGVsZW1lbnQuZmluZCgnLm1vZGFsLWJvZHknKS5sb2FkKHRoaXMub3B0aW9ucy5yZW1vdGUpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgIGNvbnN0cnVjdG9yOiBNb2RhbFxuXG4gICAgLCB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbIXRoaXMuaXNTaG93biA/ICdzaG93JyA6ICdoaWRlJ10oKVxuICAgICAgfVxuXG4gICAgLCBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAgICwgZSA9ICQuRXZlbnQoJ3Nob3cnKVxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgICAgIGlmICh0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICAgJCgnYm9keScpLmFkZENsYXNzKCdtb2RhbC1vcGVuJylcblxuICAgICAgICB0aGlzLmlzU2hvd24gPSB0cnVlXG5cbiAgICAgICAgdGhpcy5lc2NhcGUoKVxuXG4gICAgICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhhdC4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpXG5cbiAgICAgICAgICBpZiAoIXRoYXQuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50LmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpIC8vZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAgICAgLnNob3coKVxuXG4gICAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAgICAgLmFkZENsYXNzKCdpbicpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSlcbiAgICAgICAgICAgIC5mb2N1cygpXG5cbiAgICAgICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXG5cbiAgICAgICAgICB0cmFuc2l0aW9uID9cbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQub25lKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCwgZnVuY3Rpb24gKCkgeyB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ3Nob3duJykgfSkgOlxuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdzaG93bicpXG5cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICwgaGlkZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXNcblxuICAgICAgICBlID0gJC5FdmVudCgnaGlkZScpXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICAgICAgaWYgKCF0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICAgdGhpcy5pc1Nob3duID0gZmFsc2VcblxuICAgICAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ21vZGFsLW9wZW4nKVxuXG4gICAgICAgIHRoaXMuZXNjYXBlKClcblxuICAgICAgICAkKGRvY3VtZW50KS5vZmYoJ2ZvY3VzaW4ubW9kYWwnKVxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2luJylcbiAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKVxuXG4gICAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgICAgdGhpcy5oaWRlV2l0aFRyYW5zaXRpb24oKSA6XG4gICAgICAgICAgdGhpcy5oaWRlTW9kYWwoKVxuICAgICAgfVxuXG4gICAgLCBlbmZvcmNlRm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdmb2N1c2luLm1vZGFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAodGhhdC4kZWxlbWVudFswXSAhPT0gZS50YXJnZXQgJiYgIXRoYXQuJGVsZW1lbnQuaGFzKGUudGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQuZm9jdXMoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICwgZXNjYXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2tleXVwLmRpc21pc3MubW9kYWwnLCBmdW5jdGlvbiAoIGUgKSB7XG4gICAgICAgICAgICBlLndoaWNoID09IDI3ICYmIHRoYXQuaGlkZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2tleXVwLmRpc21pc3MubW9kYWwnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAsIGhpZGVXaXRoVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgICAsIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhhdC4kZWxlbWVudC5vZmYoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKVxuICAgICAgICAgICAgICB0aGF0LmhpZGVNb2RhbCgpXG4gICAgICAgICAgICB9LCA1MDApXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbmUoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgICAgdGhhdC5oaWRlTW9kYWwoKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgLCBoaWRlTW9kYWw6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgICAuaGlkZSgpXG4gICAgICAgICAgLnRyaWdnZXIoJ2hpZGRlbicpXG5cbiAgICAgICAgdGhpcy5iYWNrZHJvcCgpXG4gICAgICB9XG5cbiAgICAsIHJlbW92ZUJhY2tkcm9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wLnJlbW92ZSgpXG4gICAgICAgIHRoaXMuJGJhY2tkcm9wID0gbnVsbFxuICAgICAgfVxuXG4gICAgLCBiYWNrZHJvcDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAgICwgYW5pbWF0ZSA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/ICdmYWRlJyA6ICcnXG5cbiAgICAgICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgICAgICB2YXIgZG9BbmltYXRlID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgYW5pbWF0ZVxuXG4gICAgICAgICAgdGhpcy4kYmFja2Ryb3AgPSAkKCc8ZGl2IGNsYXNzPVwibW9kYWwtYmFja2Ryb3AgJyArIGFuaW1hdGUgKyAnXCIgLz4nKVxuICAgICAgICAgICAgLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpXG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2tkcm9wICE9ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICB0aGlzLiRiYWNrZHJvcC5jbGljaygkLnByb3h5KHRoaXMuaGlkZSwgdGhpcykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRvQW5pbWF0ZSkgdGhpcy4kYmFja2Ryb3BbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG5cbiAgICAgICAgICB0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICAgICAgZG9BbmltYXRlID9cbiAgICAgICAgICAgIHRoaXMuJGJhY2tkcm9wLm9uZSgkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsIGNhbGxiYWNrKSA6XG4gICAgICAgICAgICBjYWxsYmFjaygpXG5cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duICYmIHRoaXMuJGJhY2tkcm9wKSB7XG4gICAgICAgICAgdGhpcy4kYmFja2Ryb3AucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKT9cbiAgICAgICAgICAgIHRoaXMuJGJhY2tkcm9wLm9uZSgkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsICQucHJveHkodGhpcy5yZW1vdmVCYWNrZHJvcCwgdGhpcykpIDpcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQmFja2Ryb3AoKVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG5cbiAvKiBNT0RBTCBQTFVHSU4gREVGSU5JVElPTlxuICAqID09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgJC5mbi5tb2RhbCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgICAgLCBkYXRhID0gJHRoaXMuZGF0YSgnbW9kYWwnKVxuICAgICAgICAsIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5tb2RhbC5kZWZhdWx0cywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnbW9kYWwnLCAoZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2hvdykgZGF0YS5zaG93KClcbiAgICB9KVxuICB9XG5cbiAgJC5mbi5tb2RhbC5kZWZhdWx0cyA9IHtcbiAgICAgIGJhY2tkcm9wOiB0cnVlXG4gICAgLCBrZXlib2FyZDogdHJ1ZVxuICAgICwgc2hvdzogdHJ1ZVxuICB9XG5cbiAgJC5mbi5tb2RhbC5Db25zdHJ1Y3RvciA9IE1vZGFsXG5cblxuIC8qIE1PREFMIERBVEEtQVBJXG4gICogPT09PT09PT09PT09PT0gKi9cblxuICAkKGZ1bmN0aW9uICgpIHtcbiAgICAkKCdib2R5Jykub24oJ2NsaWNrLm1vZGFsLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKCBlICkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgICAsIGhyZWYgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgICAgLCAkdGFyZ2V0ID0gJCgkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IChocmVmICYmIGhyZWYucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLywgJycpKSkgLy9zdHJpcCBmb3IgaWU3XG4gICAgICAgICwgb3B0aW9uID0gJHRhcmdldC5kYXRhKCdtb2RhbCcpID8gJ3RvZ2dsZScgOiAkLmV4dGVuZCh7IHJlbW90ZTogIS8jLy50ZXN0KGhyZWYpICYmIGhyZWYgfSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgICR0YXJnZXRcbiAgICAgICAgLm1vZGFsKG9wdGlvbilcbiAgICAgICAgLm9uZSgnaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkdGhpcy5mb2N1cygpXG4gICAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxufSh3aW5kb3cualF1ZXJ5KTsiLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogYm9vdHN0cmFwLXBvcG92ZXIuanMgdjIuMS4xXG4gKiBodHRwOi8vdHdpdHRlci5naXRodWIuY29tL2Jvb3RzdHJhcC9qYXZhc2NyaXB0Lmh0bWwjcG9wb3ZlcnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMiBUd2l0dGVyLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIFwidXNlIHN0cmljdFwiOyAvLyBqc2hpbnQgO187XG5cblxuIC8qIFBPUE9WRVIgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgdmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuaW5pdCgncG9wb3ZlcicsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuXG4gIC8qIE5PVEU6IFBPUE9WRVIgRVhURU5EUyBCT09UU1RSQVAtVE9PTFRJUC5qc1xuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICBQb3BvdmVyLnByb3RvdHlwZSA9ICQuZXh0ZW5kKHt9LCAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUG9wb3ZlclxuXG4gICwgc2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aXAgPSB0aGlzLnRpcCgpXG4gICAgICAgICwgdGl0bGUgPSB0aGlzLmdldFRpdGxlKClcbiAgICAgICAgLCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KClcblxuICAgICAgJHRpcC5maW5kKCcucG9wb3Zlci10aXRsZScpW3RoaXMub3B0aW9ucy5odG1sID8gJ2h0bWwnIDogJ3RleHQnXSh0aXRsZSlcbiAgICAgICR0aXAuZmluZCgnLnBvcG92ZXItY29udGVudCA+IConKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10oY29udGVudClcblxuICAgICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSB0b3AgYm90dG9tIGxlZnQgcmlnaHQgaW4nKVxuICAgIH1cblxuICAsIGhhc0NvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5nZXRDb250ZW50KClcbiAgICB9XG5cbiAgLCBnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udGVudFxuICAgICAgICAsICRlID0gdGhpcy4kZWxlbWVudFxuICAgICAgICAsIG8gPSB0aGlzLm9wdGlvbnNcblxuICAgICAgY29udGVudCA9ICRlLmF0dHIoJ2RhdGEtY29udGVudCcpXG4gICAgICAgIHx8ICh0eXBlb2Ygby5jb250ZW50ID09ICdmdW5jdGlvbicgPyBvLmNvbnRlbnQuY2FsbCgkZVswXSkgOiAgby5jb250ZW50KVxuXG4gICAgICByZXR1cm4gY29udGVudFxuICAgIH1cblxuICAsIHRpcDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLiR0aXApIHtcbiAgICAgICAgdGhpcy4kdGlwID0gJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kdGlwXG4gICAgfVxuXG4gICwgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oaWRlKCkuJGVsZW1lbnQub2ZmKCcuJyArIHRoaXMudHlwZSkucmVtb3ZlRGF0YSh0aGlzLnR5cGUpXG4gICAgfVxuXG4gIH0pXG5cblxuIC8qIFBPUE9WRVIgUExVR0lOIERFRklOSVRJT05cbiAgKiA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICQuZm4ucG9wb3ZlciA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgICAgLCBkYXRhID0gJHRoaXMuZGF0YSgncG9wb3ZlcicpXG4gICAgICAgICwgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ3BvcG92ZXInLCAoZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICAkLmZuLnBvcG92ZXIuQ29uc3RydWN0b3IgPSBQb3BvdmVyXG5cbiAgJC5mbi5wb3BvdmVyLmRlZmF1bHRzID0gJC5leHRlbmQoe30gLCAkLmZuLnRvb2x0aXAuZGVmYXVsdHMsIHtcbiAgICBwbGFjZW1lbnQ6ICdyaWdodCdcbiAgLCB0cmlnZ2VyOiAnY2xpY2snXG4gICwgY29udGVudDogJydcbiAgLCB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInBvcG92ZXItaW5uZXJcIj48aDMgY2xhc3M9XCJwb3BvdmVyLXRpdGxlXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PHA+PC9wPjwvZGl2PjwvZGl2PjwvZGl2PidcbiAgfSlcblxufSh3aW5kb3cualF1ZXJ5KTsiLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogYm9vdHN0cmFwLXRvb2x0aXAuanMgdjIuMS4xXG4gKiBodHRwOi8vdHdpdHRlci5naXRodWIuY29tL2Jvb3RzdHJhcC9qYXZhc2NyaXB0Lmh0bWwjdG9vbHRpcHNcbiAqIEluc3BpcmVkIGJ5IHRoZSBvcmlnaW5hbCBqUXVlcnkudGlwc3kgYnkgSmFzb24gRnJhbWVcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMiBUd2l0dGVyLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7IC8vIGpzaGludCA7XztcblxuXG4gLyogVE9PTFRJUCBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5pbml0KCd0b29sdGlwJywgZWxlbWVudCwgb3B0aW9ucylcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRvb2x0aXBcblxuICAsIGluaXQ6IGZ1bmN0aW9uICh0eXBlLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgZXZlbnRJblxuICAgICAgICAsIGV2ZW50T3V0XG5cbiAgICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMob3B0aW9ucylcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmlnZ2VyID09ICdjbGljaycpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMudG9nZ2xlLCB0aGlzKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnRyaWdnZXIgIT0gJ21hbnVhbCcpIHtcbiAgICAgICAgZXZlbnRJbiA9IHRoaXMub3B0aW9ucy50cmlnZ2VyID09ICdob3ZlcicgPyAnbW91c2VlbnRlcicgOiAnZm9jdXMnXG4gICAgICAgIGV2ZW50T3V0ID0gdGhpcy5vcHRpb25zLnRyaWdnZXIgPT0gJ2hvdmVyJyA/ICdtb3VzZWxlYXZlJyA6ICdibHVyJ1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKGV2ZW50SW4gKyAnLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLmVudGVyLCB0aGlzKSlcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbihldmVudE91dCArICcuJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMubGVhdmUsIHRoaXMpKVxuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0b3IgP1xuICAgICAgICAodGhpcy5fb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIHsgdHJpZ2dlcjogJ21hbnVhbCcsIHNlbGVjdG9yOiAnJyB9KSkgOlxuICAgICAgICB0aGlzLmZpeFRpdGxlKClcbiAgICB9XG5cbiAgLCBnZXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuW3RoaXMudHlwZV0uZGVmYXVsdHMsIG9wdGlvbnMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpKVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxheSAmJiB0eXBlb2Ygb3B0aW9ucy5kZWxheSA9PSAnbnVtYmVyJykge1xuICAgICAgICBvcHRpb25zLmRlbGF5ID0ge1xuICAgICAgICAgIHNob3c6IG9wdGlvbnMuZGVsYXlcbiAgICAgICAgLCBoaWRlOiBvcHRpb25zLmRlbGF5XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnNcbiAgICB9XG5cbiAgLCBlbnRlcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBzZWxmID0gJChlLmN1cnJlbnRUYXJnZXQpW3RoaXMudHlwZV0odGhpcy5fb3B0aW9ucykuZGF0YSh0aGlzLnR5cGUpXG5cbiAgICAgIGlmICghc2VsZi5vcHRpb25zLmRlbGF5IHx8ICFzZWxmLm9wdGlvbnMuZGVsYXkuc2hvdykgcmV0dXJuIHNlbGYuc2hvdygpXG5cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgICBzZWxmLmhvdmVyU3RhdGUgPSAnaW4nXG4gICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2VsZi5ob3ZlclN0YXRlID09ICdpbicpIHNlbGYuc2hvdygpXG4gICAgICB9LCBzZWxmLm9wdGlvbnMuZGVsYXkuc2hvdylcbiAgICB9XG5cbiAgLCBsZWF2ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBzZWxmID0gJChlLmN1cnJlbnRUYXJnZXQpW3RoaXMudHlwZV0odGhpcy5fb3B0aW9ucykuZGF0YSh0aGlzLnR5cGUpXG5cbiAgICAgIGlmICh0aGlzLnRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgICBpZiAoIXNlbGYub3B0aW9ucy5kZWxheSB8fCAhc2VsZi5vcHRpb25zLmRlbGF5LmhpZGUpIHJldHVybiBzZWxmLmhpZGUoKVxuXG4gICAgICBzZWxmLmhvdmVyU3RhdGUgPSAnb3V0J1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnb3V0Jykgc2VsZi5oaWRlKClcbiAgICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5oaWRlKVxuICAgIH1cblxuICAsIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGlwXG4gICAgICAgICwgaW5zaWRlXG4gICAgICAgICwgcG9zXG4gICAgICAgICwgYWN0dWFsV2lkdGhcbiAgICAgICAgLCBhY3R1YWxIZWlnaHRcbiAgICAgICAgLCBwbGFjZW1lbnRcbiAgICAgICAgLCB0cFxuXG4gICAgICBpZiAodGhpcy5oYXNDb250ZW50KCkgJiYgdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICR0aXAgPSB0aGlzLnRpcCgpXG4gICAgICAgIHRoaXMuc2V0Q29udGVudCgpXG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAkdGlwLmFkZENsYXNzKCdmYWRlJylcbiAgICAgICAgfVxuXG4gICAgICAgIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLCAkdGlwWzBdLCB0aGlzLiRlbGVtZW50WzBdKSA6XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudFxuXG4gICAgICAgIGluc2lkZSA9IC9pbi8udGVzdChwbGFjZW1lbnQpXG5cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5yZW1vdmUoKVxuICAgICAgICAgIC5jc3MoeyB0b3A6IDAsIGxlZnQ6IDAsIGRpc3BsYXk6ICdibG9jaycgfSlcbiAgICAgICAgICAuYXBwZW5kVG8oaW5zaWRlID8gdGhpcy4kZWxlbWVudCA6IGRvY3VtZW50LmJvZHkpXG5cbiAgICAgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbihpbnNpZGUpXG5cbiAgICAgICAgYWN0dWFsV2lkdGggPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgICAgIGFjdHVhbEhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAgICAgc3dpdGNoIChpbnNpZGUgPyBwbGFjZW1lbnQuc3BsaXQoJyAnKVsxXSA6IHBsYWNlbWVudCkge1xuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB0cCA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDJ9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB0cCA9IHt0b3A6IHBvcy50b3AgLSBhY3R1YWxIZWlnaHQsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMn1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB0cCA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0IC0gYWN0dWFsV2lkdGh9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHRwID0ge3RvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQgLyAyIC0gYWN0dWFsSGVpZ2h0IC8gMiwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGh9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5jc3ModHApXG4gICAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudClcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2luJylcbiAgICAgIH1cbiAgICB9XG5cbiAgLCBzZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRpcCA9IHRoaXMudGlwKClcbiAgICAgICAgLCB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoKVxuXG4gICAgICAkdGlwLmZpbmQoJy50b29sdGlwLWlubmVyJylbdGhpcy5vcHRpb25zLmh0bWwgPyAnaHRtbCcgOiAndGV4dCddKHRpdGxlKVxuICAgICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHQnKVxuICAgIH1cblxuICAsIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAsICR0aXAgPSB0aGlzLnRpcCgpXG5cbiAgICAgICR0aXAucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlV2l0aEFuaW1hdGlvbigpIHtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkdGlwLm9mZigkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpLnJlbW92ZSgpXG4gICAgICAgIH0sIDUwMClcblxuICAgICAgICAkdGlwLm9uZSgkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgICAgICAkdGlwLnJlbW92ZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJHRpcC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgcmVtb3ZlV2l0aEFuaW1hdGlvbigpIDpcbiAgICAgICAgJHRpcC5yZW1vdmUoKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAsIGZpeFRpdGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgICBpZiAoJGUuYXR0cigndGl0bGUnKSB8fCB0eXBlb2YoJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScpKSAhPSAnc3RyaW5nJykge1xuICAgICAgICAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJywgJGUuYXR0cigndGl0bGUnKSB8fCAnJykucmVtb3ZlQXR0cigndGl0bGUnKVxuICAgICAgfVxuICAgIH1cblxuICAsIGhhc0NvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpdGxlKClcbiAgICB9XG5cbiAgLCBnZXRQb3NpdGlvbjogZnVuY3Rpb24gKGluc2lkZSkge1xuICAgICAgcmV0dXJuICQuZXh0ZW5kKHt9LCAoaW5zaWRlID8ge3RvcDogMCwgbGVmdDogMH0gOiB0aGlzLiRlbGVtZW50Lm9mZnNldCgpKSwge1xuICAgICAgICB3aWR0aDogdGhpcy4kZWxlbWVudFswXS5vZmZzZXRXaWR0aFxuICAgICAgLCBoZWlnaHQ6IHRoaXMuJGVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0XG4gICAgICB9KVxuICAgIH1cblxuICAsIGdldFRpdGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGl0bGVcbiAgICAgICAgLCAkZSA9IHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLCBvID0gdGhpcy5vcHRpb25zXG5cbiAgICAgIHRpdGxlID0gJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScpXG4gICAgICAgIHx8ICh0eXBlb2Ygby50aXRsZSA9PSAnZnVuY3Rpb24nID8gby50aXRsZS5jYWxsKCRlWzBdKSA6ICBvLnRpdGxlKVxuXG4gICAgICByZXR1cm4gdGl0bGVcbiAgICB9XG5cbiAgLCB0aXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLiR0aXAgPSB0aGlzLiR0aXAgfHwgJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpXG4gICAgfVxuXG4gICwgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy4kZWxlbWVudFswXS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSBudWxsXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG51bGxcbiAgICAgIH1cbiAgICB9XG5cbiAgLCBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgICB9XG5cbiAgLCBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZVxuICAgIH1cblxuICAsIHRvZ2dsZUVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9ICF0aGlzLmVuYWJsZWRcbiAgICB9XG5cbiAgLCB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXNbdGhpcy50aXAoKS5oYXNDbGFzcygnaW4nKSA/ICdoaWRlJyA6ICdzaG93J10oKVxuICAgIH1cblxuICAsIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaGlkZSgpLiRlbGVtZW50Lm9mZignLicgKyB0aGlzLnR5cGUpLnJlbW92ZURhdGEodGhpcy50eXBlKVxuICAgIH1cblxuICB9XG5cblxuIC8qIFRPT0xUSVAgUExVR0lOIERFRklOSVRJT05cbiAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgJC5mbi50b29sdGlwID0gZnVuY3Rpb24gKCBvcHRpb24gKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICAgICwgZGF0YSA9ICR0aGlzLmRhdGEoJ3Rvb2x0aXAnKVxuICAgICAgICAsIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCd0b29sdGlwJywgKGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yID0gVG9vbHRpcFxuXG4gICQuZm4udG9vbHRpcC5kZWZhdWx0cyA9IHtcbiAgICBhbmltYXRpb246IHRydWVcbiAgLCBwbGFjZW1lbnQ6ICd0b3AnXG4gICwgc2VsZWN0b3I6IGZhbHNlXG4gICwgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nXG4gICwgdHJpZ2dlcjogJ2hvdmVyJ1xuICAsIHRpdGxlOiAnJ1xuICAsIGRlbGF5OiAwXG4gICwgaHRtbDogdHJ1ZVxuICB9XG5cbn0od2luZG93LmpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIGJvb3RzdHJhcC10cmFuc2l0aW9uLmpzIHYyLjEuMVxuICogaHR0cDovL3R3aXR0ZXIuZ2l0aHViLmNvbS9ib290c3RyYXAvamF2YXNjcmlwdC5odG1sI3RyYW5zaXRpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDEyIFR3aXR0ZXIsIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4hZnVuY3Rpb24gKCQpIHtcblxuICAkKGZ1bmN0aW9uICgpIHtcblxuICAgIFwidXNlIHN0cmljdFwiOyAvLyBqc2hpbnQgO187XG5cblxuICAgIC8qIENTUyBUUkFOU0lUSU9OIFNVUFBPUlQgKGh0dHA6Ly93d3cubW9kZXJuaXpyLmNvbS8pXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICB2YXIgdHJhbnNpdGlvbkVuZCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm9vdHN0cmFwJylcbiAgICAgICAgICAsIHRyYW5zRW5kRXZlbnROYW1lcyA9IHtcbiAgICAgICAgICAgICAgICdXZWJraXRUcmFuc2l0aW9uJyA6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJ1xuICAgICAgICAgICAgLCAgJ01velRyYW5zaXRpb24nICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gICAgICAgICAgICAsICAnT1RyYW5zaXRpb24nICAgICAgOiAnb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQnXG4gICAgICAgICAgICAsICAndHJhbnNpdGlvbicgICAgICAgOiAndHJhbnNpdGlvbmVuZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAsIG5hbWVcblxuICAgICAgICBmb3IgKG5hbWUgaW4gdHJhbnNFbmRFdmVudE5hbWVzKXtcbiAgICAgICAgICBpZiAoZWwuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zRW5kRXZlbnROYW1lc1tuYW1lXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9KCkpXG5cbiAgICAgIHJldHVybiB0cmFuc2l0aW9uRW5kICYmIHtcbiAgICAgICAgZW5kOiB0cmFuc2l0aW9uRW5kXG4gICAgICB9XG5cbiAgICB9KSgpXG5cbiAgfSlcblxufSh3aW5kb3cualF1ZXJ5KTsiLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBib290c3RyYXAtdHlwZWFoZWFkLmpzIHYyLjEuMVxuICogaHR0cDovL3R3aXR0ZXIuZ2l0aHViLmNvbS9ib290c3RyYXAvamF2YXNjcmlwdC5odG1sI3R5cGVhaGVhZFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTIgVHdpdHRlciwgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuIWZ1bmN0aW9uKCQpe1xuXG4gIFwidXNlIHN0cmljdFwiOyAvLyBqc2hpbnQgO187XG5cblxuIC8qIFRZUEVBSEVBRCBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIHZhciBUeXBlYWhlYWQgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sICQuZm4udHlwZWFoZWFkLmRlZmF1bHRzLCBvcHRpb25zKVxuICAgIHRoaXMubWF0Y2hlciA9IHRoaXMub3B0aW9ucy5tYXRjaGVyIHx8IHRoaXMubWF0Y2hlclxuICAgIHRoaXMuc29ydGVyID0gdGhpcy5vcHRpb25zLnNvcnRlciB8fCB0aGlzLnNvcnRlclxuICAgIHRoaXMuaGlnaGxpZ2h0ZXIgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZXIgfHwgdGhpcy5oaWdobGlnaHRlclxuICAgIHRoaXMudXBkYXRlciA9IHRoaXMub3B0aW9ucy51cGRhdGVyIHx8IHRoaXMudXBkYXRlclxuICAgIHRoaXMuJG1lbnUgPSAkKHRoaXMub3B0aW9ucy5tZW51KS5hcHBlbmRUbygnYm9keScpXG4gICAgdGhpcy5zb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlXG4gICAgdGhpcy5zaG93biA9IGZhbHNlXG4gICAgdGhpcy5saXN0ZW4oKVxuICB9XG5cbiAgVHlwZWFoZWFkLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBUeXBlYWhlYWRcblxuICAsIHNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbCA9IHRoaXMuJG1lbnUuZmluZCgnLmFjdGl2ZScpLmF0dHIoJ2RhdGEtdmFsdWUnKVxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAudmFsKHRoaXMudXBkYXRlcih2YWwpKVxuICAgICAgICAuY2hhbmdlKClcbiAgICAgIHJldHVybiB0aGlzLmhpZGUoKVxuICAgIH1cblxuICAsIHVwZGF0ZXI6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbVxuICAgIH1cblxuICAsIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb3MgPSAkLmV4dGVuZCh7fSwgdGhpcy4kZWxlbWVudC5vZmZzZXQoKSwge1xuICAgICAgICBoZWlnaHQ6IHRoaXMuJGVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0XG4gICAgICB9KVxuXG4gICAgICB0aGlzLiRtZW51LmNzcyh7XG4gICAgICAgIHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHRcbiAgICAgICwgbGVmdDogcG9zLmxlZnRcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuJG1lbnUuc2hvdygpXG4gICAgICB0aGlzLnNob3duID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgLCBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiRtZW51LmhpZGUoKVxuICAgICAgdGhpcy5zaG93biA9IGZhbHNlXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAsIGxvb2t1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgaXRlbXNcblxuICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuJGVsZW1lbnQudmFsKClcblxuICAgICAgaWYgKCF0aGlzLnF1ZXJ5IHx8IHRoaXMucXVlcnkubGVuZ3RoIDwgdGhpcy5vcHRpb25zLm1pbkxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93biA/IHRoaXMuaGlkZSgpIDogdGhpc1xuICAgICAgfVxuXG4gICAgICBpdGVtcyA9ICQuaXNGdW5jdGlvbih0aGlzLnNvdXJjZSkgPyB0aGlzLnNvdXJjZSh0aGlzLnF1ZXJ5LCAkLnByb3h5KHRoaXMucHJvY2VzcywgdGhpcykpIDogdGhpcy5zb3VyY2VcblxuICAgICAgcmV0dXJuIGl0ZW1zID8gdGhpcy5wcm9jZXNzKGl0ZW1zKSA6IHRoaXNcbiAgICB9XG5cbiAgLCBwcm9jZXNzOiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuXG4gICAgICBpdGVtcyA9ICQuZ3JlcChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoYXQubWF0Y2hlcihpdGVtKVxuICAgICAgfSlcblxuICAgICAgaXRlbXMgPSB0aGlzLnNvcnRlcihpdGVtcylcblxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKGl0ZW1zLnNsaWNlKDAsIHRoaXMub3B0aW9ucy5pdGVtcykpLnNob3coKVxuICAgIH1cblxuICAsIG1hdGNoZXI6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gfml0ZW0udG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMucXVlcnkudG9Mb3dlckNhc2UoKSlcbiAgICB9XG5cbiAgLCBzb3J0ZXI6IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgdmFyIGJlZ2luc3dpdGggPSBbXVxuICAgICAgICAsIGNhc2VTZW5zaXRpdmUgPSBbXVxuICAgICAgICAsIGNhc2VJbnNlbnNpdGl2ZSA9IFtdXG4gICAgICAgICwgaXRlbVxuXG4gICAgICB3aGlsZSAoaXRlbSA9IGl0ZW1zLnNoaWZ0KCkpIHtcbiAgICAgICAgaWYgKCFpdGVtLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLnF1ZXJ5LnRvTG93ZXJDYXNlKCkpKSBiZWdpbnN3aXRoLnB1c2goaXRlbSlcbiAgICAgICAgZWxzZSBpZiAofml0ZW0uaW5kZXhPZih0aGlzLnF1ZXJ5KSkgY2FzZVNlbnNpdGl2ZS5wdXNoKGl0ZW0pXG4gICAgICAgIGVsc2UgY2FzZUluc2Vuc2l0aXZlLnB1c2goaXRlbSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJlZ2luc3dpdGguY29uY2F0KGNhc2VTZW5zaXRpdmUsIGNhc2VJbnNlbnNpdGl2ZSlcbiAgICB9XG5cbiAgLCBoaWdobGlnaHRlcjogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKVxuICAgICAgcmV0dXJuIGl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKCcoJyArIHF1ZXJ5ICsgJyknLCAnaWcnKSwgZnVuY3Rpb24gKCQxLCBtYXRjaCkge1xuICAgICAgICByZXR1cm4gJzxzdHJvbmc+JyArIG1hdGNoICsgJzwvc3Ryb25nPidcbiAgICAgIH0pXG4gICAgfVxuXG4gICwgcmVuZGVyOiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuXG4gICAgICBpdGVtcyA9ICQoaXRlbXMpLm1hcChmdW5jdGlvbiAoaSwgaXRlbSkge1xuICAgICAgICBpID0gJCh0aGF0Lm9wdGlvbnMuaXRlbSkuYXR0cignZGF0YS12YWx1ZScsIGl0ZW0pXG4gICAgICAgIGkuZmluZCgnYScpLmh0bWwodGhhdC5oaWdobGlnaHRlcihpdGVtKSlcbiAgICAgICAgcmV0dXJuIGlbMF1cbiAgICAgIH0pXG5cbiAgICAgIGl0ZW1zLmZpcnN0KCkuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICB0aGlzLiRtZW51Lmh0bWwoaXRlbXMpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAsIG5leHQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuJG1lbnUuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAsIG5leHQgPSBhY3RpdmUubmV4dCgpXG5cbiAgICAgIGlmICghbmV4dC5sZW5ndGgpIHtcbiAgICAgICAgbmV4dCA9ICQodGhpcy4kbWVudS5maW5kKCdsaScpWzBdKVxuICAgICAgfVxuXG4gICAgICBuZXh0LmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cblxuICAsIHByZXY6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuJG1lbnUuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAsIHByZXYgPSBhY3RpdmUucHJldigpXG5cbiAgICAgIGlmICghcHJldi5sZW5ndGgpIHtcbiAgICAgICAgcHJldiA9IHRoaXMuJG1lbnUuZmluZCgnbGknKS5sYXN0KClcbiAgICAgIH1cblxuICAgICAgcHJldi5hZGRDbGFzcygnYWN0aXZlJylcbiAgICB9XG5cbiAgLCBsaXN0ZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9uKCdibHVyJywgICAgICQucHJveHkodGhpcy5ibHVyLCB0aGlzKSlcbiAgICAgICAgLm9uKCdrZXlwcmVzcycsICQucHJveHkodGhpcy5rZXlwcmVzcywgdGhpcykpXG4gICAgICAgIC5vbigna2V5dXAnLCAgICAkLnByb3h5KHRoaXMua2V5dXAsIHRoaXMpKVxuXG4gICAgICBpZiAoJC5icm93c2VyLmNocm9tZSB8fCAkLmJyb3dzZXIud2Via2l0IHx8ICQuYnJvd3Nlci5tc2llKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24nLCAkLnByb3h5KHRoaXMua2V5ZG93biwgdGhpcykpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuJG1lbnVcbiAgICAgICAgLm9uKCdjbGljaycsICQucHJveHkodGhpcy5jbGljaywgdGhpcykpXG4gICAgICAgIC5vbignbW91c2VlbnRlcicsICdsaScsICQucHJveHkodGhpcy5tb3VzZWVudGVyLCB0aGlzKSlcbiAgICB9XG5cbiAgLCBtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCF0aGlzLnNob3duKSByZXR1cm5cblxuICAgICAgc3dpdGNoKGUua2V5Q29kZSkge1xuICAgICAgICBjYXNlIDk6IC8vIHRhYlxuICAgICAgICBjYXNlIDEzOiAvLyBlbnRlclxuICAgICAgICBjYXNlIDI3OiAvLyBlc2NhcGVcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgMzg6IC8vIHVwIGFycm93XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgdGhpcy5wcmV2KClcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgNDA6IC8vIGRvd24gYXJyb3dcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICB0aGlzLm5leHQoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICB9XG5cbiAgLCBrZXlkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5zdXBwcmVzc0tleVByZXNzUmVwZWF0ID0gIX4kLmluQXJyYXkoZS5rZXlDb2RlLCBbNDAsMzgsOSwxMywyN10pXG4gICAgICB0aGlzLm1vdmUoZSlcbiAgICB9XG5cbiAgLCBrZXlwcmVzczogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzLnN1cHByZXNzS2V5UHJlc3NSZXBlYXQpIHJldHVyblxuICAgICAgdGhpcy5tb3ZlKGUpXG4gICAgfVxuXG4gICwga2V5dXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBzd2l0Y2goZS5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgNDA6IC8vIGRvd24gYXJyb3dcbiAgICAgICAgY2FzZSAzODogLy8gdXAgYXJyb3dcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgOTogLy8gdGFiXG4gICAgICAgIGNhc2UgMTM6IC8vIGVudGVyXG4gICAgICAgICAgaWYgKCF0aGlzLnNob3duKSByZXR1cm5cbiAgICAgICAgICB0aGlzLnNlbGVjdCgpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIDI3OiAvLyBlc2NhcGVcbiAgICAgICAgICBpZiAoIXRoaXMuc2hvd24pIHJldHVyblxuICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMubG9va3VwKClcbiAgICAgIH1cblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICAsIGJsdXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aGF0LmhpZGUoKSB9LCAxNTApXG4gICAgfVxuXG4gICwgY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIHRoaXMuc2VsZWN0KClcbiAgICB9XG5cbiAgLCBtb3VzZWVudGVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy4kbWVudS5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAkKGUuY3VycmVudFRhcmdldCkuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgfVxuXG4gIH1cblxuXG4gIC8qIFRZUEVBSEVBRCBQTFVHSU4gREVGSU5JVElPTlxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAkLmZuLnR5cGVhaGVhZCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgICAgLCBkYXRhID0gJHRoaXMuZGF0YSgndHlwZWFoZWFkJylcbiAgICAgICAgLCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgndHlwZWFoZWFkJywgKGRhdGEgPSBuZXcgVHlwZWFoZWFkKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICAkLmZuLnR5cGVhaGVhZC5kZWZhdWx0cyA9IHtcbiAgICBzb3VyY2U6IFtdXG4gICwgaXRlbXM6IDhcbiAgLCBtZW51OiAnPHVsIGNsYXNzPVwidHlwZWFoZWFkIGRyb3Bkb3duLW1lbnVcIj48L3VsPidcbiAgLCBpdGVtOiAnPGxpPjxhIGhyZWY9XCIjXCI+PC9hPjwvbGk+J1xuICAsIG1pbkxlbmd0aDogMVxuICB9XG5cbiAgJC5mbi50eXBlYWhlYWQuQ29uc3RydWN0b3IgPSBUeXBlYWhlYWRcblxuXG4gLyogICBUWVBFQUhFQUQgREFUQS1BUElcbiAgKiA9PT09PT09PT09PT09PT09PT0gKi9cblxuICAkKGZ1bmN0aW9uICgpIHtcbiAgICAkKCdib2R5Jykub24oJ2ZvY3VzLnR5cGVhaGVhZC5kYXRhLWFwaScsICdbZGF0YS1wcm92aWRlPVwidHlwZWFoZWFkXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIGlmICgkdGhpcy5kYXRhKCd0eXBlYWhlYWQnKSkgcmV0dXJuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICR0aGlzLnR5cGVhaGVhZCgkdGhpcy5kYXRhKCkpXG4gICAgfSlcbiAgfSlcblxufSh3aW5kb3cualF1ZXJ5KTtcbiJdfQ==
